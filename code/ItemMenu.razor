@using Sandbox;
@using Sandbox.UI;
@using TacticsRPG;
@inherits Panel
@namespace Sandbox

<root>
	@if(!IsActive) return;
	@if(!ActiveUnit.IsValid())
		<div class="item-menu" @ref="Menu">

			@foreach(CommandItem com in ActiveUnit.Turn.ItemCommands)
			{
				if(com.Active)
				{
					<div class="button" style ="@(ActiveUnit.Turn.ItemCommands.IndexOf(com) == SelectedIndex ? "background-color: green" : "background-color: blue")">
						<h1 class="button-text">@com.Text</h1>
					</div>
				}
				else if(!com.Active)
				{
					<div class="button" style ="background-color: gray">
						<h1 class="button-text">@com.Text</h1>
					</div>					
				}

			}
		</div>	
</root>

@code
{
	//CONDENSE ALL ABILITYITEM MENUS TO ONE MENU!!! (SKILL, SPELL, ITEM)
	//TODO: Use For Loop Limited By 4, Push Offset Using Selected Index INSTEAD OF FOREACH
	//This Creates Scrolling List Support, When Over 4 Items
	
	public bool IsActive = false;
	public bool IsGrey = false;
	public Unit ActiveUnit = null;
	public int MenuDepth = 3;
	public Panel Menu;
	public int SelectedIndex {get; set;} = 0;

	public void Activate()
	{
		IsActive = true;
	}

	public void Deactivate()
	{
		IsActive = false;
	}

	public void IncreaseIndex()
	{
		Log.Info(IsActive);
		if(SelectedIndex == ActiveUnit.Turn.ItemCommands.Count() - 1)
		{
			Log.Info("Out Of Range");
			return;
		}
		SelectedIndex += 1;

		StateHasChanged();
		Log.Info($"ItemMenu Index Set To {SelectedIndex}");
	}

	public void DecreaseIndex()
	{
		Log.Info(IsActive);
		if(SelectedIndex == 0)
		{
			Log.Info("Out Of Range");
			return;
		}		
		SelectedIndex -= 1;
		StateHasChanged();
		Log.Info($"ItemMenu Index Set To {SelectedIndex}");
	}
	public void SelectMenuItem()
	{

		PlayerMaster.Instance.SelectedCommand(CommandType.Item, ActiveUnit.Turn.ItemCommands[SelectedIndex]);	

		Log.Info($"{ActiveUnit.Turn.ItemCommands[SelectedIndex].Text}");
	}
	/// <summary>
	/// the hash determines if the system should be rebuilt. If it changes, it will be rebuilt
	/// </summary>
	protected override int BuildHash() => System.HashCode.Combine(RealTime.Now);
}
