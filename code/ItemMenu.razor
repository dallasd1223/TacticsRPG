@using Sandbox;
@using Sandbox.UI;
@using TacticsRPG;
@inherits Panel
@namespace Sandbox

<root>
	@if(!IsActive) return;
		<div class="item-menu" @ref="Menu">

			@foreach(CommandItem com in BattleManager.Instance.ActiveUnit.Turn.ItemCommands)
			{
				if(com.Active)
				{
					<div class="button" style ="@( BattleManager.Instance.ActiveUnit.Turn.ItemCommands.IndexOf(com) == SelectedIndex ? "background-color: green" : "background-color: blue")">
						<h1 class="button-text">@com.Text</h1>
					</div>
				}
				else if(!com.Active)
				{
					<div class="button" style ="background-color: gray">
						<h1 class="button-text">@com.Text</h1>
					</div>					
				}

			}
		</div>	
</root>

@code
{
	public bool IsActive = false;
	public bool IsGrey = false;
	public int MenuDepth = 3;
	public Panel Menu;
	[Property] public int SelectedIndex {get; set;} = 0;

	public void Activate()
	{
		IsActive = true;
	}

	public void Deactivate()
	{
		IsActive = false;
	}

	public void IncreaseIndex()
	{
		if(SelectedIndex == BattleManager.Instance.ActiveUnit.Turn.ItemCommands.Count() - 1)
		{
			Log.Info("Out Of Range");
			return;
		}
		SelectedIndex += 1;

		StateHasChanged();
		Log.Info($"ItemMenu Index Set To {SelectedIndex}");
	}

	public void DecreaseIndex()
	{
		if(SelectedIndex == 0)
		{
			Log.Info("Out Of Range");
			return;
		}		
		SelectedIndex -= 1;
		StateHasChanged();
		Log.Info($"ItemMenu Index Set To {SelectedIndex}");
	}
	public void SelectMenuItem()
	{
		var effectData = ResourceLibrary.Get<EffectData>( "Effects/PotionEffect.Effect" );
		Log.Info($"{effectData.Name} Data Loaded With Step {effectData.stepData[0].StepName}");
		EffectEvent effect = new PotionEffect(effectData);
		Log.Info($"Menu Sequence Count: {effect.Sequences.Count()}");
		EffectManager.Instance.PlayEffect(effect);

		Log.Info($"{BattleManager.Instance.ActiveUnit.Turn.ItemCommands[SelectedIndex].Text}");
	}
	/// <summary>
	/// the hash determines if the system should be rebuilt. If it changes, it will be rebuilt
	/// </summary>
	protected override int BuildHash() => System.HashCode.Combine(RealTime.Now);
}
