@using Sandbox;
@using Sandbox.UI;
@inherits Panel
@implements IFloatingElement
@namespace Sandbox
@attribute [StyleSheet]

<root>

</root>

@code
{

	public string Value;
	public string Font;
	public int Size;
	public GameObject Obj;
	public Color color; 
	public Func<ICharAnimation> animFactory;
	public FloatingTextMode Mode = FloatingTextMode.Normal;
	public TextColorMode ColorMode = TextColorMode.Normal;
	public ElementPlayType Type {get; set;} = ElementPlayType.Once;
	private List<FloatingChar> chars {get; set;} = new();

	public bool ReadyToDelete {get; set;} = false;

	private bool IsStarting = false;
	private bool DoneInitializingChars = false;
	private int TypewriterIndex;
	private TimeSince TimeSinceLetter;
	private FloatingChar pr = null;

	public FloatingText(string val, string font, int fsize, Color col, FloatingTextMode mode, TextColorMode cmode, Func<ICharAnimation> anim)
	{
		Value = val;
		Font = font;
		Size = fsize;
		color = col;
		animFactory = anim;
		Mode = mode;
		ColorMode = cmode;
	}

	public void Start()
	{
		IsStarting = true;
		TimeSinceLetter = 0f;
		if(Mode != FloatingTextMode.Normal) return;
		int i = 0;
		FloatingChar prev = null;
		foreach(Char c in Value)
		{
			var p = new FloatingChar(c, i, i, color, animFactory(), i, Size, Font);
			chars.Add(p);
			this.AddChild(p);
			p.Index = i;

			if(prev is not null)
			{
				p.prevChar = prev;
			}
			
			prev = p;

			Log.Info($"i: {i} w/ Font: {Font}");
			i++;
		}
		DoneInitializingChars = true;
	}

	public override void Tick()
	{
		if(IsStarting && Mode == FloatingTextMode.Typewriter && !DoneInitializingChars )
		{
			if(TimeSinceLetter >= 0.3f && TypewriterIndex < Value.Length)
			{
				Char c = Value[TypewriterIndex];
				var p = new FloatingChar(c, TypewriterIndex, TypewriterIndex, color, animFactory(), TypewriterIndex, Size, Font);
				chars.Add(p);
				this.AddChild(p);
				p.Index = TypewriterIndex;

				if(pr is not null)
				{
					p.prevChar = pr;
				}
				
				pr= p;

				Log.Info($"i: {TypewriterIndex} w/ Font: {Font}");
				TypewriterIndex++;
			}
			else if(TypewriterIndex >= Value.Length)
			{
				DoneInitializingChars = true;
			}
		}
		if(!chars.Any()) return;
		foreach(FloatingChar c in chars)
		{
			var point = Scene.Camera.PointToScreenPixels(Obj.WorldPosition + new Vector3(0,0,100));
			point = point + new Vector2(-((GetTotalWidth()) / 2),0);
			point = point / ScaleToScreen;
			c.Position = point;
			c.Update(Time.Delta);
		}
		if(!DoneInitializingChars) return;
		DeleteReadyChars();
		if(AllCharsDeleted())
		{
			Log.Info("All Chars Deleted, Marking Deletion");
			ReadyToDelete = true;
		}
	}

	private float GetTotalWidth()
	{
		float total = 0;
		foreach(FloatingChar c in chars)
		{
			total += c.Width;
		}
		return total;
	}
	
	private void DeleteReadyChars()
	{
		if(!chars.Any()) return;
		foreach(FloatingChar c in chars)
		{
			if(c.ReadyToDelete) c.Delete();
		}		
	}
	private bool AllCharsDeleted()
	{
		if(!chars.Any()) return true;
		foreach(FloatingChar c in chars)
		{
			if(c.IsValid()) return false;
		}
		return true;
	}

	public void Hide() {}
	
	protected override int BuildHash() => System.HashCode.Combine( RealTime.Now );
}
