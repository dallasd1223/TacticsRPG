@using Sandbox;
@using Sandbox.UI;
@attribute [StyleSheet]
@inherits Panel
@namespace Sandbox


<root>
	<label class="value" @ref ="main">@value.ToString()</label>
	<label class="outline" @ref ="shadow">@value.ToString()</label>
</root>

@code
{
	Panel main;
	Panel shadow;
	public int Index;
	public float Width;
	public float Gap;
	public float Delay;
	public float Age = 0;
	public string Font;
	public int Size;
	public Color color;
	public Char value;
	public FloatingChar prevChar;
	public Vector2 Position;
	public ICharAnimation animation;
	private bool HasStarted = false;
	private bool HasStyled = false;

	public FloatingChar(char c, float delay, float gap, Color col, ICharAnimation anim, int size = 60, string font = "Retro Pixel Thick")
	{
		value = c;
		Delay = delay;
		Gap = gap;
		Size = size;
		Font = font;
		color = col;
		animation = anim;

		Log.Info($"char: {c}, gap: {gap}");
	}
	
	public void Update(float delta)
	{
		if(!main.IsValid() || !shadow.IsValid()) return;
		if(!HasStyled)
		{
			SetStyles();
		}
		
		if(main is not null && !HasStarted)
		{
			StartAnim();
			HasStarted = true;
		}
		Age += delta;
		Width = main.Box.Rect.Width;
		Position = Position + new Vector2(GapAlignment() / ScaleToScreen, 0);
		//Position = Position + new Vector2(0, (float)Math.Sin((Time.Now - (Delay * 0.1f ))* 3f) * 10f);
		var Position1 = Position + new Vector2(8, 8);
		main.Style.Left = Position.x;
		main.Style.Top = Position.y;
		shadow.Style.Left = Position1.x;
		shadow.Style.Top = Position1.y;

		if(animation is not null)
		{
			animation.Update(main, delta, shadow);
		}

	}

	float GapAlignment()
	{
		if(prevChar is not null)
		{
			return prevChar.Width * Gap;
		}
		else
		{
			return 0;
		}
	}

	public void StartAnim()
	{
		animation.Reset(main, shadow);
		animation.IsStarted = true;
	}

	void SetStyles()
	{
		main.Style.FontFamily = Font;
		shadow.Style.FontFamily = Font;
		main.Style.FontSize = Length.Pixels(Size);
		shadow.Style.FontSize = Length.Pixels(Size);
		main.Style.FontColor = color;
	}

	public Color GetRainbow()
	{
		float hue = (((float)RealTime.Now - Delay * 0.4f)* 0.2f) % 1f;
		return HSVToRGB(hue, 1f, 1f);
	}

	public Color HSVToRGB(float h, float s, float v)
    {
        int i = (int)Math.Floor(h * 6f);
        float f = h * 6f - i;
        float p = v * (1f - s);
        float q = v * (1f - f * s);
        float t = v * (1f - (1f - f) * s);

        float r = 0, g = 0, b = 0;
        switch (i % 6)
        {
            case 0: r = v; g = t; b = p; break;
            case 1: r = q; g = v; b = p; break;
            case 2: r = p; g = v; b = t; break;
            case 3: r = p; g = q; b = v; break;
            case 4: r = t; g = p; b = v; break;
            case 5: r = v; g = p; b = q; break;
        }

        return new Color(r, g, b, 1f); // full alpha
	}

	protected override int BuildHash() => System.HashCode.Combine(RealTime.Now);
}
