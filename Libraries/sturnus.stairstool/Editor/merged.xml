<MergedRoot>
  <assembly>
    <name>Facepunch.ActionGraphs</name>
  </assembly>
  <members>
    <member name="T:Facepunch.ActionGraphs.InsertResult">
      <summary>
            Elements added by a call to <see cref="!:IActionGraph.DeserializeInsert" />.
            </summary>
      <param name="Variables">Newly added variables.</param>
      <param name="Nodes">Newly added nodes.</param>
      <param name="Links">Newly added links.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.InsertResult.#ctor(System.Collections.Generic.IReadOnlyCollection{Facepunch.ActionGraphs.Variable},System.Collections.Generic.IReadOnlyCollection{Facepunch.ActionGraphs.Node},System.Collections.Generic.IReadOnlyCollection{Facepunch.ActionGraphs.Link})">
      <summary>
            Elements added by a call to <see cref="!:IActionGraph.DeserializeInsert" />.
            </summary>
      <param name="Variables">Newly added variables.</param>
      <param name="Nodes">Newly added nodes.</param>
      <param name="Links">Newly added links.</param>
    </member>
    <member name="P:Facepunch.ActionGraphs.InsertResult.Variables">
      <summary>Newly added variables.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.InsertResult.Nodes">
      <summary>Newly added nodes.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.InsertResult.Links">
      <summary>Newly added links.</summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.ActionGraph">
      <summary>
            Represents an async method as a directed graph. Control will enter through an "event" node, which
            can route signals through a network of other nodes that perform actions.
            Use <see cref="M:Facepunch.ActionGraphs.ActionGraph.CreateEmpty(Facepunch.ActionGraphs.NodeLibrary)" /> to create a completely blank graph, or <see cref="M:Facepunch.ActionGraphs.ActionGraph.CreateDelegate``1(Facepunch.ActionGraphs.NodeLibrary)" />
            to create a graph that handles an event matching the signature of a particular delegate.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraph.TargetDefinition">
      <summary>
            The definition of the graph input that represents the target of the graph.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraph.TargetOutput">
      <summary>
            The output of the graph's entry node that represents the target of the graph.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraph.SourceLocation">
      <summary>
            Identifies where this instance was deserialized from.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraph.NodeLibrary">
      <summary>
            Library of node definitions available for use by this action graph.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraph.Nodes">
      <summary>
            Set of nodes added to this action graph.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraph.Links">
      <summary>
            Set of links added between nodes in this action graph.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraph.Variables">
      <summary>
            Set of variables added to this action graph.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraph.UserData">
      <summary>
            Arbitrary named values stored in this action graph, which will be included during serialization.
            Values must be serializable to JSON.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraph.InputNode">
      <summary>
            Entry point of the graph.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraph.PrimaryOutputNode">
      <summary>
            Primary output of the graph.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraph.OutputNodes">
      <summary>
            Nodes that emit return values or output signals from this graph to the caller.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.AddNode(Facepunch.ActionGraphs.NodeDefinition)">
      <summary>
            Add a new node to this action graph, with the given <paramref name="definition" />.
            </summary>
      <param name="definition">Definition describing the properties, inputs and outputs of a node.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.AddNode(Facepunch.ActionGraphs.NodeDefinition,Facepunch.ActionGraphs.Node)">
      <summary>
            Add a new node to this action graph, with the given <paramref name="definition" />.
            </summary>
      <param name="definition">Definition describing the properties, inputs and outputs of a node.</param>
      <param name="parent">Optional parent node to create a child for.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.RemoveNode(Facepunch.ActionGraphs.Node)">
      <summary>
            Remove a node from this action graph. Any links into or out of the node will also be removed.
            </summary>
      <param name="node">Node to remove.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.AddVariable(System.String,System.Type,System.Object)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.RemoveVariable(Facepunch.ActionGraphs.Variable)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.SetLink(Facepunch.ActionGraphs.Node.Input,Facepunch.ActionGraphs.ILinkSource)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.SetLink(Facepunch.ActionGraphs.Node.Input,Facepunch.ActionGraphs.ILinkSource,System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.InsertLink(Facepunch.ActionGraphs.Node.Input,Facepunch.ActionGraphs.ILinkSource,System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.SetLinks(Facepunch.ActionGraphs.Node.Input,System.Collections.Generic.IEnumerable{Facepunch.ActionGraphs.ILinkSource})">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.RemoveLink(Facepunch.ActionGraphs.Link)">
      <inheritdoc />
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraph.StackTraceIdentifier">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.CreateEmpty(Facepunch.ActionGraphs.NodeLibrary)">
      <summary>
            Creates a completely blank action graph. This won't be invokable until an event node is added.
            </summary>
      <param name="nodeLibrary">Source of node definitions for the new action graph.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.CreateDelegate(Facepunch.ActionGraphs.NodeLibrary,System.Type)">
      <summary>
            Creates an action graph with an event node matching the signature of <paramref name="delegateType" />.
            </summary>
      <param name="nodeLibrary">Source of node definitions for the new action graph.</param>
      <param name="delegateType">Delegate type to match the signature of.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.CreateDelegate``1(Facepunch.ActionGraphs.NodeLibrary)">
      <summary>
            Creates an action graph with an event node matching the signature of delegate type <typeparamref name="T" />.
            </summary>
      <typeparam name="T">Delegate type to base this new action graph on.</typeparam>
      <param name="nodeLibrary">Source of node definitions for the new action graph.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.Evaluate(System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
      <summary>
            For graphs composed only of expression nodes, evaluates all outputs based on the given input values.
            </summary>
      <param name="inputs">Values to use for each named input.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.InvokeAsync(System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object},System.Collections.Generic.IReadOnlyDictionary{System.String,Facepunch.ActionGraphs.Compilation.OutputDelegate})">
      <summary>
            Fires a signal from the <see cref="P:Facepunch.ActionGraphs.ActionGraph.InputNode" /> of this graph with the given named values as input.
            The returned task will complete when all resulting actions have finished executing.
            </summary>
      <param name="inputs">Values to use for each named input.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.Compile``1">
      <summary>
            Returns a delegate factory implementing the current configuration of this action graph.
            This value is cached if the graph hasn't changed since the last time this was called.
            </summary>
    </member>
    <member name="E:Facepunch.ActionGraphs.ActionGraph.LinkTriggered">
      <inheritdoc />
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraph.IsDeserializing">
      <summary>
            True during <see cref="M:Facepunch.ActionGraphs.ActionGraph.Deserialize``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Action{``0},System.Func{``1,``0},System.Func{``0,``1,``0})" />.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.Serialize(System.Collections.Generic.IEnumerable{Facepunch.ActionGraphs.Node},System.Text.Json.JsonSerializerOptions)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.SerializeToNode(System.Collections.Generic.IEnumerable{Facepunch.ActionGraphs.Node},System.Text.Json.JsonSerializerOptions)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.DeserializeInsert(System.String,System.Text.Json.JsonSerializerOptions)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.DeserializeInsert(System.Text.Json.Nodes.JsonNode,System.Text.Json.JsonSerializerOptions)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.Deserialize(System.String,System.Type,System.Text.Json.JsonSerializerOptions)">
      <summary>
            Restore a previously serialized graph from JSON in this instance.
            </summary>
      <param name="json">Serialized action graph.</param>
      <param name="delegateType">Optional delegate type, must match the one used when serializing.</param>
      <param name="options">Optional serializer options.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.CanCreateSubGraph(System.Collections.Generic.IEnumerable{Facepunch.ActionGraphs.Node})">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.CreateSubGraphAsync(System.Collections.Generic.IEnumerable{Facepunch.ActionGraphs.Node},System.Text.Json.JsonSerializerOptions,Facepunch.ActionGraphs.CreateSubGraphNodeDelegate)">
      <inheritdoc />
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraph.ChangeId">
      <summary>
            Increments each time this graph re-validates after a change.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraph.Messages">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.Validate(System.Boolean)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.ClearChanges">
      <summary>
            Don't increment <see cref="P:Facepunch.ActionGraphs.ActionGraph.ChangeId" /> during next validation.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraph.AddSortedNodes(System.Collections.Generic.List{Facepunch.ActionGraphs.Node})">
      <summary>
            Adds all nodes to <paramref name="outNodes" />, sorted topologically.
            Will add error messages if cycles are detected.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.LinkTriggeredHandler">
      <summary>
            Handler for <see cref="E:Facepunch.ActionGraphs.ActionGraph.LinkTriggered" /> events.
            </summary>
      <param name="link">The link that was triggered.</param>
      <param name="value">The value that was propagated, or null for signals.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.DelegateExtensions.GetActionGraphInstance(System.Delegate)">
      <summary>
            If the given delegate is implemented as exactly one <see cref="T:Facepunch.ActionGraphs.ActionGraph" />,
            get that graph and any input value overrides.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.DelegateExtensions.GetActionGraphInstance``1(``0)">
      <summary>
            If the given delegate is implemented as exactly one <see cref="T:Facepunch.ActionGraphs.ActionGraph" />,
            get that graph and any input value overrides.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.DelegateExtensions.GetActionGraphInstances(System.Delegate)">
      <summary>
            If the given delegate is implemented as one or more <see cref="T:Facepunch.ActionGraphs.ActionGraph" />s,
            get those graphs and their input value overrides.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.DelegateExtensions.GetActionGraphInstances``1(``0)">
      <summary>
            If the given delegate is implemented as one or more <see cref="T:Facepunch.ActionGraphs.ActionGraph" />s,
            get those graphs and their input value overrides.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.IActionGraphDelegate">
      <summary>
            Wrapper for an <see cref="T:Facepunch.ActionGraphs.ActionGraph" /> invokable as a delegate, with optional overridden input values.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.IActionGraphDelegate.Graph">
      <summary>
            Wrapped action graph.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.IActionGraphDelegate.Delegate">
      <summary>
            Delegate that is implemented by <see cref="P:Facepunch.ActionGraphs.IActionGraphDelegate.Graph" />, with default arguments supplied by <see cref="P:Facepunch.ActionGraphs.IActionGraphDelegate.Defaults" />.
            This delegate will remain up-to-date even if the wrapped graph is modified, or default argument dictionary changes.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.IActionGraphDelegate.DelegateType">
      <summary>
            The type that <see cref="P:Facepunch.ActionGraphs.IActionGraphDelegate.Delegate" /> will contain when compiled.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.IActionGraphDelegate.Defaults">
      <summary>
            Dictionary of default arguments for any graph input parameters that aren't supplied by delegate parameters.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.ActionGraphDelegate`1">
      <summary>
            Wrapper for an <see cref="T:Facepunch.ActionGraphs.ActionGraph" /> invokable as a delegate, with optional overridden input values.
            </summary>
      <typeparam name="T">Delegate type for the compiled graph.</typeparam>
    </member>
    <member name="F:Facepunch.ActionGraphs.ActionGraphDelegate`1._outerDelegate">
      <summary>
            Lazily compiled once, wraps compiling <see cref="F:Facepunch.ActionGraphs.ActionGraphDelegate`1._innerDelegate" /> (if changed) and then calling it.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.ActionGraphDelegate`1._innerDelegate">
      <summary>
            Lazily compiled each time <see cref="F:Facepunch.ActionGraphs.ActionGraphDelegate`1._outerDelegate" /> is called if <see cref="P:Facepunch.ActionGraphs.ActionGraphDelegate`1.Graph" /> has been modified.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraphDelegate`1.Delegate">
      <inheritdoc cref="P:Facepunch.ActionGraphs.IActionGraphDelegate.Delegate" />
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraphDelegate`1.DelegateType">
      <inheritdoc />
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraphDelegate`1.Graph">
      <inheritdoc />
    </member>
    <member name="P:Facepunch.ActionGraphs.ActionGraphDelegate`1.Defaults">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraphDelegate`1.BuildOuterDelegate">
      <summary>
            Builds a delegate that calls the wrapped <see cref="P:Facepunch.ActionGraphs.ActionGraphDelegate`1.Graph" />, supplying any default arguments from <see cref="P:Facepunch.ActionGraphs.ActionGraphDelegate`1.Defaults" />.
            This delegate will remain up-to-date even if the wrapped graph is modified, or default argument dictionary changes.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraphDelegate`1.GetInnerDelegate">
      <summary>
            Gets a delegate implementing the current configuration of <see cref="P:Facepunch.ActionGraphs.ActionGraphDelegate`1.Graph" /> with default arguments provided by
            <see cref="P:Facepunch.ActionGraphs.ActionGraphDelegate`1.Defaults" />, (re)compiling if needed.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.ActionGraphExtensions">
      <summary>
            Extension methods for action graphs.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraphExtensions.AddNode(Facepunch.ActionGraphs.INodeContainer,System.String)">
      <summary>
            Add a new node to this action graph with the given definition ID.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraphExtensions.AddNode``1(Facepunch.ActionGraphs.INodeContainer,``0)">
      <summary>
            Add a new node to this action graph, defined by the given method. The method must be already included in <see cref="T:Facepunch.ActionGraphs.NodeLibrary" />.
            </summary>
      <typeparam name="T">Delegate type of the method.</typeparam>
      <param name="graph">Action graph to add a node to.</param>
      <param name="func">Method defining a node.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraphExtensions.AddNode(Facepunch.ActionGraphs.INodeContainer,System.Type,System.String)">
      <summary>
            Add a new node to this action graph, defined by the given method. The method must be already included in <see cref="T:Facepunch.ActionGraphs.NodeLibrary" />.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraphExtensions.AddNode(Facepunch.ActionGraphs.INodeContainer,System.Linq.Expressions.ExpressionType)">
      <summary>
            Adds a new node to this action graph, defined by the given expression type.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraphExtensions.AddVariableNode(Facepunch.ActionGraphs.INodeContainer,Facepunch.ActionGraphs.Variable,System.Nullable{Facepunch.ActionGraphs.AssignmentKind})">
      <summary>
            Add a new variable accessor node to this action graph.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraphExtensions.AddConstantNode(Facepunch.ActionGraphs.INodeContainer,System.Object)">
      <summary>
            Add a new constant accessor node to this action graph.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ActionGraphExtensions.SetLinks(Facepunch.ActionGraphs.ActionGraph,Facepunch.ActionGraphs.Node.Input,Facepunch.ActionGraphs.ILinkSource[])">
      <inheritdoc cref="!:IActionGraph.SetLinks" />
    </member>
    <member name="T:Facepunch.ActionGraphs.ISourceLocation">
      <summary>
            Interface for types that identify the source of an <see cref="T:Facepunch.ActionGraphs.ActionGraph" />.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.SerializationOptions">
      <summary>
            Controls how <see cref="T:Facepunch.ActionGraphs.ActionGraph" />s are (de)serialized.
            </summary>
      <param name="ImpliedTarget">
            Add this input to any graphs deserialized in this scope, usually representing
            a "this" parameter holding the object this graph is embedded in.
            When serializing, omit this input from the serialized graph because we know
            it will be added automatically when deserializing.
            </param>
      <param name="Cache">
            Re-use instances from this cache when deserializing, matching by <see cref="P:Facepunch.ActionGraphs.ActionGraph.Guid" />.
            Graphs will be added to the cache when serializing or deserializing in this scope.
            When serializing, if <see cref="P:Facepunch.ActionGraphs.SerializationOptions.WriteCacheReferences" /> is true, a minimal graph reference stub
            will be written instead of full graphs.
            </param>
      <param name="SourceLocation">
            For debugging / editors, describe where graphs deserialized in this scope came from.
            </param>
      <param name="GuidMap">
            When deserializing, maps any graph <see cref="T:System.Guid" />s encountered.
            </param>
      <param name="WriteCacheReferences">
            If true, and a <see cref="P:Facepunch.ActionGraphs.SerializationOptions.Cache" /> is provided, write a reference stub when serializing
            graphs instead of the full JSON.
            </param>
      <param name="ForceUpdateCached">
            If true, replace cached instance when deserializing. Otherwise, it'll only be
            replaced if its <see cref="P:Facepunch.ActionGraphs.ActionGraph.ChangeId" /> differs.
            </param>
    </member>
    <member name="M:Facepunch.ActionGraphs.SerializationOptions.#ctor(Facepunch.ActionGraphs.InputDefinition,Facepunch.ActionGraphs.IActionGraphCache,Facepunch.ActionGraphs.ISourceLocation,System.Collections.Generic.IReadOnlyDictionary{System.Guid,System.Guid},System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Controls how <see cref="T:Facepunch.ActionGraphs.ActionGraph" />s are (de)serialized.
            </summary>
      <param name="ImpliedTarget">
            Add this input to any graphs deserialized in this scope, usually representing
            a "this" parameter holding the object this graph is embedded in.
            When serializing, omit this input from the serialized graph because we know
            it will be added automatically when deserializing.
            </param>
      <param name="Cache">
            Re-use instances from this cache when deserializing, matching by <see cref="P:Facepunch.ActionGraphs.ActionGraph.Guid" />.
            Graphs will be added to the cache when serializing or deserializing in this scope.
            When serializing, if <see cref="P:Facepunch.ActionGraphs.SerializationOptions.WriteCacheReferences" /> is true, a minimal graph reference stub
            will be written instead of full graphs.
            </param>
      <param name="SourceLocation">
            For debugging / editors, describe where graphs deserialized in this scope came from.
            </param>
      <param name="GuidMap">
            When deserializing, maps any graph <see cref="T:System.Guid" />s encountered.
            </param>
      <param name="WriteCacheReferences">
            If true, and a <see cref="P:Facepunch.ActionGraphs.SerializationOptions.Cache" /> is provided, write a reference stub when serializing
            graphs instead of the full JSON.
            </param>
      <param name="ForceUpdateCached">
            If true, replace cached instance when deserializing. Otherwise, it'll only be
            replaced if its <see cref="P:Facepunch.ActionGraphs.ActionGraph.ChangeId" /> differs.
            </param>
    </member>
    <member name="P:Facepunch.ActionGraphs.SerializationOptions.ImpliedTarget">
      <summary>
            Add this input to any graphs deserialized in this scope, usually representing
            a "this" parameter holding the object this graph is embedded in.
            When serializing, omit this input from the serialized graph because we know
            it will be added automatically when deserializing.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.SerializationOptions.Cache">
      <summary>
            Re-use instances from this cache when deserializing, matching by <see cref="P:Facepunch.ActionGraphs.ActionGraph.Guid" />.
            Graphs will be added to the cache when serializing or deserializing in this scope.
            When serializing, if <see cref="P:Facepunch.ActionGraphs.SerializationOptions.WriteCacheReferences" /> is true, a minimal graph reference stub
            will be written instead of full graphs.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.SerializationOptions.SourceLocation">
      <summary>
            For debugging / editors, describe where graphs deserialized in this scope came from.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.SerializationOptions.GuidMap">
      <summary>
            When deserializing, maps any graph <see cref="T:System.Guid" />s encountered.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.SerializationOptions.WriteCacheReferences">
      <summary>
            If true, and a <see cref="P:Facepunch.ActionGraphs.SerializationOptions.Cache" /> is provided, write a reference stub when serializing
            graphs instead of the full JSON.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.SerializationOptions.ForceUpdateCached">
      <summary>
            If true, replace cached instance when deserializing. Otherwise, it'll only be
            replaced if its <see cref="P:Facepunch.ActionGraphs.ActionGraph.ChangeId" /> differs.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.SerializationOptions.Empty">
      <summary>
            Default empty <see cref="T:Facepunch.ActionGraphs.SerializationOptions" />.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.MessageLevel">
      <summary>
            Severity level of a validation message.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.MessageLevel.Info">
      <summary>
            Purely informative, there's nothing to fix.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.MessageLevel.Warning">
      <summary>
            Suggests that something might not be intended, but isn't an error.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.MessageLevel.Error">
      <summary>
            Something is incorrect and must be fixed in order to pass validation.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.IMessageContext">
      <summary>
            Interface for action graph elements that can be the context of a <see cref="T:Facepunch.ActionGraphs.ValidationMessage" />.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.IMessageContext.ActionGraph">
      <summary>
            Action graph this element belongs to.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.IMessageContext.Parent">
      <summary>
            Parent element in the graph. Parents will list all validation messages of
            their children.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.IMessageContext.StackTraceIdentifier">
      <summary>
            Unique identifier for this graph element in a stack trace.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.ValidationExtensions">
      <summary>
            Extension methods related to validation and validation messages.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ValidationExtensions.GetMessages(Facepunch.ActionGraphs.IMessageContext)">
      <summary>
            Gets all validation messages where this, or any child element, is the context.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ValidationExtensions.HasErrors(Facepunch.ActionGraphs.IMessageContext)">
      <summary>
            Returns true if any contained validation messages are errors. An action graph can't
            be invoked if it has any errors.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.ValidationMessage">
      <summary>
            A message generated during validation with a context, level, and value.
            </summary>
      <param name="Context">Action graph element most relevant to this message.</param>
      <param name="Level">Severity of the message.</param>
      <param name="Value">Message content.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.ValidationMessage.#ctor(Facepunch.ActionGraphs.IMessageContext,Facepunch.ActionGraphs.MessageLevel,System.String,System.Object)">
      <summary>
            A message generated during validation with a context, level, and value.
            </summary>
      <param name="Context">Action graph element most relevant to this message.</param>
      <param name="Level">Severity of the message.</param>
      <param name="Value">Message content.</param>
    </member>
    <member name="P:Facepunch.ActionGraphs.ValidationMessage.Context">
      <summary>Action graph element most relevant to this message.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.ValidationMessage.Level">
      <summary>Severity of the message.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.ValidationMessage.Value">
      <summary>Message content.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.ValidationMessage.IsError">
      <summary>
            If true, this message was a cause for the action graph to fail validation.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ValidationMessage.ToString">
      <summary>
            Returns the message formatted as "[Level] Value (Context)".
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.ValidationException">
      <summary>
            Exception thrown when an invalid action graph is invoked.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ValidationException.#ctor(Facepunch.ActionGraphs.IMessageContext,System.String)">
      <summary>
            Exception thrown when an invalid action graph is invoked.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.ValidationException.Context">
      <summary>
            Action graph element most relevant to this exception.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ValidationException.ToString">
      <inheritdoc />
    </member>
    <member name="T:Facepunch.ActionGraphs.ActionGraphCache">
      <summary>
            Used to re-use <see cref="T:Facepunch.ActionGraphs.ActionGraph" /> instances when deserializing.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.INodeAttribute">
      <summary>
            Used to define ActionGraph nodes using static methods, properties, or constructors.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.INodeAttribute.Identifier">
      <summary>
            A unique name to identify this node type.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.NodeAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.INodeAttribute" />
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeAttribute.#ctor(System.String)">
      <summary>
            Used to define ActionGraph nodes using static methods, properties, or constructors.
            </summary>
      <param name="identifier">A unique name to identify this node type.</param>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeAttribute.Identifier">
      <inheritdoc />
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeAttribute.DefaultInputSignal">
      <inheritdoc />
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeAttribute.DefaultOutputSignal">
      <inheritdoc />
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeAttribute.InheritAsync">
      <inheritdoc />
    </member>
    <member name="T:Facepunch.ActionGraphs.IPureAttribute">
      <summary>
            Declares a method to not have any side effects, it only performs a calculation
            using its inputs and outputs a result.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.IImpureAttribute">
      <summary>
            Declares a method to have side effects, even if it's declared as
            readonly.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.PureAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.IPureAttribute" />
    </member>
    <member name="T:Facepunch.ActionGraphs.ImpureAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.IImpureAttribute" />
    </member>
    <member name="T:Facepunch.ActionGraphs.IPropertyAttribute">
      <summary>
            For binding in methods marked with a <see cref="T:Facepunch.ActionGraphs.NodeAttribute" />, this parameter should only
            be configurable in the inspector as a property and not have a dedicated input.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.PropertyAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.IPropertyAttribute" />
    </member>
    <member name="T:Facepunch.ActionGraphs.ITargetAttribute">
      <summary>
            For binding in methods marked with a <see cref="T:Facepunch.ActionGraphs.NodeAttribute" />, this parameter represents
            the target instance object the method is executed on.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.TargetAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.ITargetAttribute" />
    </member>
    <member name="T:Facepunch.ActionGraphs.IExposeWhenCachedAttribute">
      <summary>
            Declares that instances of the marked type can't be cached in a <see cref="T:Facepunch.ActionGraphs.ActionGraphCache" />.
            For example, if they might contain an ID that needs to get fixed up post serialization.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.ExposeWhenCachedAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.IExposeWhenCachedAttribute" />
    </member>
    <member name="T:Facepunch.ActionGraphs.IAlwaysInvokedAttribute">
      <summary>
            Marks an output signal that will always be dispatched before the default output
            signal. Used on a parameter of a method marked with <see cref="T:Facepunch.ActionGraphs.NodeAttribute" />.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.AlwaysInvokedAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.IAlwaysInvokedAttribute" />
    </member>
    <member name="T:Facepunch.ActionGraphs.INodeDefinitionAttribute">
      <summary>
            Marks a class extending <see cref="T:Facepunch.ActionGraphs.NodeDefinition" /> that should be automatically
            added to a <see cref="T:Facepunch.ActionGraphs.NodeLibrary" /> when <see cref="M:Facepunch.ActionGraphs.NodeLibrary.AddAssembly(System.Reflection.Assembly)" /> is called.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.NodeDefinitionAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.INodeDefinitionAttribute" />
    </member>
    <member name="T:Facepunch.ActionGraphs.Compilation.ValueScopes">
      <param name="FromSignalOutput">Scopes for each signal output of action nodes.</param>
      <param name="FromValueInput">Scopes for each input that needs to be evaluated each time it is accessed.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.Compilation.ValueScopes.#ctor(System.Collections.Generic.IReadOnlyDictionary{Facepunch.ActionGraphs.Node.Output,Facepunch.ActionGraphs.Compilation.ValueScope},System.Collections.Generic.IReadOnlyDictionary{Facepunch.ActionGraphs.Node.Input,Facepunch.ActionGraphs.Compilation.ValueScope})">
      <param name="FromSignalOutput">Scopes for each signal output of action nodes.</param>
      <param name="FromValueInput">Scopes for each input that needs to be evaluated each time it is accessed.</param>
    </member>
    <member name="P:Facepunch.ActionGraphs.Compilation.ValueScopes.FromSignalOutput">
      <summary>Scopes for each signal output of action nodes.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Compilation.ValueScopes.FromValueInput">
      <summary>Scopes for each input that needs to be evaluated each time it is accessed.</summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.Compilation.IOutputValue">
      <summary>
            Describes a node output in this scope. It can either have a local variable that gets
            set during the body of its node, or a constant expression that gets defined during the body.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.Compilation.ValueScope">
      <summary>
            Wraps a set of value inputs of action nodes that should be evaluated at the same time.
            Each referenced expression node in the scope will be evaluated at most once, so if the
            result of a node is used multiple times it will have the same value. This is both an
            optimization, and expected behaviour if things like random numbers are sampled.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Compilation.ValueScope.Parameter">
      <summary>
            The input or output parameter this scope was created from.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Compilation.ValueScope.Parent">
      <summary>
            The scope immediately containing this one. The graph input node has no scope.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Compilation.ValueScope.ActionValueInputs">
      <summary>
            Inputs on action nodes included in this scope. This doesn't include inputs of
            referenced expression nodes.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Compilation.ValueScope.AllowCaching">
      <summary>
            If false, we need to re-evaluate the scope each time an input is accessed.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.AssignmentKind">
      <summary>
            Operations accessor nodes can perform.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.AssignmentKind.Set">
      <summary>
            Replace the old value with the new value.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.AssignmentKind.Add">
      <summary>
            Replace the old value with old + new.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.AssignmentKind.Subtract">
      <summary>
            Replace the old value with old - new.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.AssignmentKind.Multiply">
      <summary>
            Replace the old value with old * new.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.AssignmentKind.Divide">
      <summary>
            Replace the old value with old / new.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.AssignmentKind.Increment">
      <summary>
            Replace the old value with old + 1.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.AssignmentKind.Decrement">
      <summary>
            Replace the old value with old - 1.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.AccessorNodeDefinition`1">
      <summary>
            Base class for nodes that get / set values.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.AccessorNodeDefinition`1.IsTrivial">
      <summary>
            If true, don't bother storing the result in a local variable when accessing.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.DispatchNodeDefinition">
      <summary>
            Base type for node definitions that run a bunch of output signals simultaneously,
            like <see cref="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" /> or <see cref="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.MethodBinder.Bind(System.Reflection.MethodBase)">
      <summary>
            Given a method, returns a node binding specifying
            which properties, inputs and outputs the method has.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.Input`1">
      <summary>
            Helper type for input parameters of methods marked with <see cref="T:Facepunch.ActionGraphs.NodeAttribute" />.
            The value of this input can be evaluated on demand, for cases where it may change during the
            invocation of the node.
            </summary>
      <typeparam name="T">Actual input type.</typeparam>
    </member>
    <member name="P:Facepunch.ActionGraphs.Input`1.Value">
      <summary>
            Evaluate this input.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.Input`1.op_Implicit(Facepunch.ActionGraphs.Input{`0})~`0">
      <summary>
            Evaluate this input.
            </summary>
      <param name="value" />
    </member>
    <member name="T:Facepunch.ActionGraphs.NodeKind">
      <summary>
            Nodes can be lazily evaluated expression without any signals,
            or actions that execute when receiving a signal.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.NodeKind.Expression">
      <summary>
            A lazily evaluated node without any signals.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.NodeKind.Action">
      <summary>
            A node that performs an action when receiving an input signal.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.Signal">
      <summary>
            Node inputs and outputs of this type will transmit signals rather than values.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.NodeDefinition">
      <summary>
            Describes the behaviour and bindings of a node for use in an action graph.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeDefinition.#ctor(Facepunch.ActionGraphs.NodeLibrary,System.String)">
      <summary>
            Describes the behaviour and bindings of a node for use in an action graph.
            </summary>
      <param name="nodeLibrary">Node library that will contain this node definition.</param>
      <param name="identifier">Unique identifier of this node definition.</param>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeDefinition.NodeLibrary">
      <summary>
            Node library containing this node definition.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeDefinition.Identifier">
      <summary>
            Unique identifier of this node definition.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeDefinition.DisplayInfo">
      <summary>
            Title, description, and categorizing information about the node definition.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeDefinition.Attributes">
      <summary>
            Attributes attached to this node definition.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeDefinition.IsObsolete">
      <summary>
            True if this definition has an <see cref="T:System.ObsoleteAttribute" />.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeDefinition.Bind(Facepunch.ActionGraphs.BindingSurface)">
      <summary>
            Attempts to get a binding based on property values and input types. Bindings are
            typed sets of named properties, inputs, and outputs. If a valid binding wasn't found,
            the result will contain messages explaining why.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeDefinition.OnBind(Facepunch.ActionGraphs.BindingSurface)">
      <inheritdoc cref="M:Facepunch.ActionGraphs.NodeDefinition.Bind(Facepunch.ActionGraphs.BindingSurface)" />
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeDefinition.ToString">
      <summary>
            Returns the identifier of this node definition.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.ParameterFlags.Missing">
      <summary>
            We don't have a valid definition for this parameter.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.ParameterFlags.Required">
      <summary>
            This parameter must have a value / link, and has no default value.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.ParameterFlags.Primary">
      <summary>
            This is the primary input / output signal.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.PropertyFlags.Missing">
      <inheritdoc cref="F:Facepunch.ActionGraphs.ParameterFlags.Missing" />
    </member>
    <member name="F:Facepunch.ActionGraphs.PropertyFlags.Required">
      <inheritdoc cref="F:Facepunch.ActionGraphs.ParameterFlags.Required" />
    </member>
    <member name="F:Facepunch.ActionGraphs.InputFlags.Missing">
      <inheritdoc cref="F:Facepunch.ActionGraphs.ParameterFlags.Missing" />
    </member>
    <member name="F:Facepunch.ActionGraphs.InputFlags.Required">
      <inheritdoc cref="F:Facepunch.ActionGraphs.ParameterFlags.Required" />
    </member>
    <member name="F:Facepunch.ActionGraphs.InputFlags.Primary">
      <inheritdoc cref="F:Facepunch.ActionGraphs.ParameterFlags.Primary" />
    </member>
    <member name="F:Facepunch.ActionGraphs.InputFlags.Target">
      <summary>
            This input represents the <c>this</c> parameter of a method.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.InputFlags.NotAlwaysAccessed">
      <summary>
            This input is conditionally accessed, so its source should be lazily evaluated.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.InputFlags.NoCaching">
      <summary>
            This input should be evaluated each time it is accessed, instead of being cached.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.OutputFlags.Missing">
      <inheritdoc cref="F:Facepunch.ActionGraphs.ParameterFlags.Missing" />
    </member>
    <member name="F:Facepunch.ActionGraphs.OutputFlags.Primary">
      <inheritdoc cref="!:ParameterFlags.IsPrimary" />
    </member>
    <member name="F:Facepunch.ActionGraphs.OutputFlags.AlwaysInvoked">
      <summary>
            This output signal will always be triggered.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.OutputFlags.NotAwaited">
      <summary>
            The containing node won't await this output signal's completion.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.IParameterDefinition">
      <summary>
            Base interface for <see cref="T:Facepunch.ActionGraphs.PropertyDefinition" />, <see cref="T:Facepunch.ActionGraphs.InputDefinition" /> and
            <see cref="T:Facepunch.ActionGraphs.OutputDefinition" />.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.IParameterDefinition.Name">
      <summary>
            Parameter name.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.IParameterDefinition.Display">
      <summary>
            Display info about this parameter.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.IParameterDefinition.Type">
      <summary>
            Value type stored / transmitted by this parameter.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.IParameterDefinition.IsRequired">
      <summary>
            If true, a value must be provided for this parameter otherwise a validation
            error will be generated.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.IParameterDefinition.IsMissing">
      <summary>
            If true, this parameter wasn't found on the current node binding.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.IParameterDefinition.Attributes">
      <summary>
            If this parameter was generated by reflection, contains the attributes of the source member.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.PropertyDefinition">
      <summary>
            Describes a property of a node that should be configurable in the inspector.
            </summary>
      <param name="Name">Name used to reference this property.</param>
      <param name="Type">What type is accepted for this property.</param>
      <param name="Display">Optional title and description of the property.</param>
      <param name="Default">If <see cref="P:Facepunch.ActionGraphs.PropertyDefinition.IsRequired" /> is false, this value will be used when no value is provided.</param>
      <param name="GenericParameter">If <see cref="P:Facepunch.ActionGraphs.PropertyDefinition.Type" /> is <see cref="T:System.Type" />, can hold a generic parameter constraining the type.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.PropertyDefinition.#ctor(System.String,System.Type,Facepunch.ActionGraphs.PropertyFlags,Facepunch.ActionGraphs.DisplayInfo,System.Object,System.Type,System.Collections.Generic.IReadOnlyCollection{System.Attribute})">
      <summary>
            Describes a property of a node that should be configurable in the inspector.
            </summary>
      <param name="Name">Name used to reference this property.</param>
      <param name="Type">What type is accepted for this property.</param>
      <param name="Display">Optional title and description of the property.</param>
      <param name="Default">If <see cref="P:Facepunch.ActionGraphs.PropertyDefinition.IsRequired" /> is false, this value will be used when no value is provided.</param>
      <param name="GenericParameter">If <see cref="P:Facepunch.ActionGraphs.PropertyDefinition.Type" /> is <see cref="T:System.Type" />, can hold a generic parameter constraining the type.</param>
    </member>
    <member name="P:Facepunch.ActionGraphs.PropertyDefinition.Name">
      <summary>Name used to reference this property.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.PropertyDefinition.Type">
      <summary>What type is accepted for this property.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.PropertyDefinition.Display">
      <summary>Optional title and description of the property.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.PropertyDefinition.Default">
      <summary>If <see cref="P:Facepunch.ActionGraphs.PropertyDefinition.IsRequired" /> is false, this value will be used when no value is provided.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.PropertyDefinition.GenericParameter">
      <summary>If <see cref="P:Facepunch.ActionGraphs.PropertyDefinition.Type" /> is <see cref="T:System.Type" />, can hold a generic parameter constraining the type.</summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.InputDefinition">
      <summary>
            Describes an input of a node.
            </summary>
      <param name="Name">Name used to reference this input.</param>
      <param name="Type">What type is accepted in this input. For input signals, this will be <see cref="T:Facepunch.ActionGraphs.Signal" />.</param>
      <param name="Display">Optional title and description of the input.</param>
      <param name="Default">If <see cref="P:Facepunch.ActionGraphs.InputDefinition.IsRequired" /> is false, this value will be used when no value is provided.</param>
      <param name="UsedBy">Input signals that use this input.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.InputDefinition.#ctor(System.String,System.Type,Facepunch.ActionGraphs.InputFlags,Facepunch.ActionGraphs.DisplayInfo,System.Collections.Generic.IReadOnlySet{System.String},System.Object,System.Collections.Generic.IReadOnlyCollection{System.Attribute})">
      <summary>
            Describes an input of a node.
            </summary>
      <param name="Name">Name used to reference this input.</param>
      <param name="Type">What type is accepted in this input. For input signals, this will be <see cref="T:Facepunch.ActionGraphs.Signal" />.</param>
      <param name="Display">Optional title and description of the input.</param>
      <param name="Default">If <see cref="P:Facepunch.ActionGraphs.InputDefinition.IsRequired" /> is false, this value will be used when no value is provided.</param>
      <param name="UsedBy">Input signals that use this input.</param>
    </member>
    <member name="P:Facepunch.ActionGraphs.InputDefinition.Name">
      <summary>Name used to reference this input.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.InputDefinition.Type">
      <summary>What type is accepted in this input. For input signals, this will be <see cref="T:Facepunch.ActionGraphs.Signal" />.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.InputDefinition.Display">
      <summary>Optional title and description of the input.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.InputDefinition.UsedBy">
      <summary>Input signals that use this input.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.InputDefinition.Default">
      <summary>If <see cref="P:Facepunch.ActionGraphs.InputDefinition.IsRequired" /> is false, this value will be used when no value is provided.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.InputDefinition.IsSignal">
      <summary>
            If true, this input receives a signal that will cause the parent node
            to act.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.InputDefinition.IsArray">
      <summary>
            If true, this input accepts an array of values. Each element
            can be connected to a different output.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.InputDefinition.ElementType">
      <summary>
            For array input types, the type of an element of the array.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.OutputDefinition">
      <summary>
            Describes an output of a node.
            </summary>
      <param name="Name">Name used to reference this output.</param>
      <param name="Type">What type is returned by this output. For signals, this will be <see cref="T:Facepunch.ActionGraphs.Signal" />.</param>
      <param name="Display">Optional title and description of the output.</param>
      <param name="ProvidedBy">This output is only valid when one of these output signals fires. If empty, it's always valid.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.OutputDefinition.#ctor(System.String,System.Type,Facepunch.ActionGraphs.OutputFlags,Facepunch.ActionGraphs.DisplayInfo,System.Collections.Generic.IReadOnlySet{System.String},System.Collections.Generic.IReadOnlyCollection{System.Attribute})">
      <summary>
            Describes an output of a node.
            </summary>
      <param name="Name">Name used to reference this output.</param>
      <param name="Type">What type is returned by this output. For signals, this will be <see cref="T:Facepunch.ActionGraphs.Signal" />.</param>
      <param name="Display">Optional title and description of the output.</param>
      <param name="ProvidedBy">This output is only valid when one of these output signals fires. If empty, it's always valid.</param>
    </member>
    <member name="P:Facepunch.ActionGraphs.OutputDefinition.Name">
      <summary>Name used to reference this output.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.OutputDefinition.Type">
      <summary>What type is returned by this output. For signals, this will be <see cref="T:Facepunch.ActionGraphs.Signal" />.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.OutputDefinition.Display">
      <summary>Optional title and description of the output.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.OutputDefinition.ProvidedBy">
      <summary>This output is only valid when one of these output signals fires. If empty, it's always valid.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.OutputDefinition.IsSignal">
      <summary>
            If true, this output emits signals that can trigger other nodes
            to act.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.DisplayInfo">
      <summary>
            Display information of a <see cref="T:Facepunch.ActionGraphs.NodeDefinition" />.
            </summary>
      <param name="Title">Display name of the node.</param>
      <param name="Description">Helpful text explaining the usage of the node.</param>
      <param name="Group">Category to help organize the node.</param>
      <param name="Icon">Material icon for this node.</param>
      <param name="Hidden">If true, don't show this node definition in editor UI.</param>
      <param name="Tags">Set of tags to help organize the node.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.DisplayInfo.#ctor(System.String,System.String,System.String,System.String,System.Nullable{System.Boolean},System.String[])">
      <summary>
            Display information of a <see cref="T:Facepunch.ActionGraphs.NodeDefinition" />.
            </summary>
      <param name="Title">Display name of the node.</param>
      <param name="Description">Helpful text explaining the usage of the node.</param>
      <param name="Group">Category to help organize the node.</param>
      <param name="Icon">Material icon for this node.</param>
      <param name="Hidden">If true, don't show this node definition in editor UI.</param>
      <param name="Tags">Set of tags to help organize the node.</param>
    </member>
    <member name="P:Facepunch.ActionGraphs.DisplayInfo.Title">
      <summary>Display name of the node.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.DisplayInfo.Description">
      <summary>Helpful text explaining the usage of the node.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.DisplayInfo.Group">
      <summary>Category to help organize the node.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.DisplayInfo.Icon">
      <summary>Material icon for this node.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.DisplayInfo.Hidden">
      <summary>If true, don't show this node definition in editor UI.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.DisplayInfo.Tags">
      <summary>Set of tags to help organize the node.</summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.DisplayInfo.ParameterPattern">
      <remarks>
            Pattern:<br /><code>\\{\\s*(?&lt;name&gt;[a-zA-Z_]+)\\s*(?:\\:\\s*(?&lt;format&gt;[^}|]+\\s*))?(?:\\|\\s*(?&lt;default&gt;[^}]*)\\s*)?\\}</code><br />
            Explanation:<br /><code>
            ○ Match '{'.<br />
            ○ Match a whitespace character atomically any number of times.<br />
            ○ "name" capture group.<br />
                ○ Match a character in the set [A-Z_a-z] greedily at least once.<br />
            ○ Match a whitespace character greedily any number of times.<br />
            ○ Optional (greedy).<br />
                ○ Match ':'.<br />
                ○ Match a whitespace character greedily any number of times.<br />
                ○ "format" capture group.<br />
                    ○ Match a character in the set [^|}] greedily at least once.<br />
                    ○ Match a whitespace character greedily any number of times.<br />
            ○ Optional (greedy).<br />
                ○ Match '|'.<br />
                ○ Match a whitespace character greedily any number of times.<br />
                ○ "default" capture group.<br />
                    ○ Match a character other than '}' greedily any number of times.<br />
                ○ Match a whitespace character atomically any number of times.<br />
            ○ Match '}'.<br /></code></remarks>
    </member>
    <member name="T:Facepunch.ActionGraphs.TitleAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.ITitleAttribute" />
    </member>
    <member name="T:Facepunch.ActionGraphs.DescriptionAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.IDescriptionAttribute" />
    </member>
    <member name="T:Facepunch.ActionGraphs.GroupAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.IGroupAttribute" />
    </member>
    <member name="T:Facepunch.ActionGraphs.IconAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.IIconAttribute" />
    </member>
    <member name="T:Facepunch.ActionGraphs.HiddenAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.IHiddenAttribute" />
    </member>
    <member name="T:Facepunch.ActionGraphs.TagsAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.ITagsAttribute" />
    </member>
    <member name="M:Facepunch.ActionGraphs.StringExtensions.ToTitleCase(System.String)">
      <summary>
            Convert a variable name to something more user friendly.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.IGraphLoader.LoadGraph(System.String)">
      <summary>
            Attempts to read a serialized <see cref="T:Facepunch.ActionGraphs.ActionGraph" /> from a path.
            </summary>
      <param name="path">Path describing the location of a serialized graph.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.DefaultGraphLoader.LoadGraph(System.String)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.FileSystemGraphLoader.LoadGraph(System.String)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.ReflectionExtensions.GetGenericInstanceType(System.Type,System.Type)">
      <summary>
            Given a <paramref name="type" /> that possibly extends a <paramref name="genericType" /> definition,
            get the generic instance type so we know what the type parameters are. Returns null if the given type
            doesn't actually extend the generic type.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ExpressionExtensions.Coerce(System.Linq.Expressions.Expression,System.Type)">
      <summary>
            Generates an expression that coerces a value to the given type.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ExpressionExtensions.ContinueWith(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.String)">
      <summary>
            Concatenate two expressions, each of which may return a <see cref="T:System.Threading.Tasks.Task" />, with the
            final value being the result of the latter expression.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ExpressionExtensions.ReadFromDictionaryExpression(System.Linq.Expressions.Expression,System.String,System.Type,System.Linq.Expressions.Expression)">
      <summary>
            Generates an expression that reads a named value from a <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2" />.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.Link">
      <summary>
            A link connects one <see cref="T:Facepunch.ActionGraphs.Node.Input" /> to a <see cref="T:Facepunch.ActionGraphs.Node.Output" />.
            They can either transmit values or signals. A signal will trigger the receiving
            node to act when the sending node fires its output.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Link.Target">
      <summary>
            The receiving node's input.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Link.Source">
      <summary>
            Where this link retrieves its value from.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Link.ActionGraph">
      <summary>
            The action graph containing this link.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Link.IsSignal">
      <summary>
            If true, this link will transmit a signal from an action
            node to another.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Link.Type">
      <summary>
            The value type being transmitted by the link.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Link.TargetType">
      <summary>
            The value type the target requires from this link.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Link.IsArrayElement">
      <summary>
            If true, this link is supplying one element of an input that
            accepts an array.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Link.ArrayIndex">
      <summary>
            If <see cref="P:Facepunch.ActionGraphs.Link.IsArrayElement" /> is true, this is the index
            of the element in the receiving array.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Link.UserData">
      <summary>
            Arbitrary named values stored in this link, which will be included during
            serialization. Values must be serializable to JSON.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Link.IsValid">
      <summary>
            Becomes false when this link is removed.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Link.StackTraceIdentifier">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.Link.Collapse">
      <summary>
            Collapses any no-op nodes to find the root source of this link.
            </summary>
      <returns />
    </member>
    <member name="M:Facepunch.ActionGraphs.Link.Remove">
      <summary>
            Remove this link from the action graph, disconnecting it from
            the source and target.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.Link.TryGetConstant(System.Object@)">
      <summary>
            If this link is from a <see cref="T:Facepunch.ActionGraphs.Constant" /> source, return true
            and output the constant value.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.Link.TryGetVariable(Facepunch.ActionGraphs.Variable@)">
      <summary>
            If this link is from a <see cref="T:Facepunch.ActionGraphs.Variable" /> source, return true
            and output the referenced variable.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.Link.ToString">
      <summary>
            Returns a string with the format "Link({Source}, {Target})".
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.Node">
      <summary>
            The main building block of an action graph. Represents either an action or expression.
            An action node has input and output signals, and will act only when receiving a signal.
            Expression nodes have only input and output values, and will be evaluated lazily when
            one of its outputs is requested.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.Node._sourceModel">
      <summary>
            Keep hold of the model this node was deserialized from if there were any exceptions,
            so we can safely round-trip serialize even in the worst case. This will get cleared
            if any changes are made to the node.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.SortedIndex">
      <summary>
            Order of this node, such that any nodes linked to its inputs have a smaller index. Used during validation.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.ForceAsync">
      <summary>
            True if executing this node is async because one of its outputs involves running another async node. Used during validation.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.IsAsync">
      <summary>
            Does the execution of this node produce an async task. Used during validation.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Id">
      <summary>
            Unique id of this node in the containing <see cref="P:Facepunch.ActionGraphs.Node.ActionGraph" />.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Parent">
      <summary>
            Parent of a nested node.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Children">
      <summary>
            Nodes that were created as children of this node.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Definition">
      <summary>
            Definition describing the behaviour and property / input / output bindings of this node.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.DisplayInfo">
      <summary>
            Display information for this node.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Attributes">
      <summary>
            Attributes provided by this node's current binding.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.UserData">
      <summary>
            Arbitrary named values stored in this node, which will be included during serialization.
            Values must be serializable to JSON.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Properties">
      <summary>
            Constant named values stored in this node.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Inputs">
      <summary>
            Named inputs of this node, that may either link to the outputs of other nodes,
            or be assigned a constant value.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Outputs">
      <summary>
            Named outputs of this node, that may link to the inputs of other nodes.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.VariableReferences">
      <summary>
            All properties or links that reference a variable.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Links">
      <summary>
            All current input and output links attached to this node.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.CanSkipSerialization">
      <summary>
            Nested constant / variable nodes are serialized as links.
            We can also skip serializing nested nodes with no references.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.ActionGraph">
      <summary>
            Parent <see cref="P:Facepunch.ActionGraphs.Node.ActionGraph" /> of this node.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.StackTraceIdentifier">
      <inheritdoc />
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.IsValid">
      <summary>
            Will become false if this node was removed from its action graph.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.Node.MarkDirty">
      <summary>
            Notify the containing graph that this node needs updating.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.Node.Remove">
      <summary>
            Remove this node from the containing graph. Any links into or out of the
            node will also be removed.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.Node.ToString">
      <summary>
            Returns a string with the format "Node{ID}".
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Kind">
      <summary>
            Is this node an action or an expression?
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.Node.SetParameters(System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
      <summary>
            Sets the named properties and inputs to the given values.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.Node.UpdateParameters">
      <summary>
            Immediately update this node's binding based on its input types and property values.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.IParameter.Node">
      <summary>
            The parent node of this parameter.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.IParameter.Name">
      <summary>
            The name of this parameter.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.IParameter.Definition">
      <summary>
            Current definition of this parameter, including type and
            display information.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.IParameter.Type">
      <summary>
            Value type of this parameter.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.IParameter.Display">
      <summary>
            Display info for this parameter.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.IParameter.Attributes">
      <summary>
            If this parameter was generated using reflection, contains the attributes
            attached to the reflected member.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.Node.Parameter`1">
      <summary>
            Base class for properties, inputs, and outputs of nodes.
            </summary>
      <typeparam name="T">Definition type for this parameter.</typeparam>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Parameter`1.Definition">
      <inheritdoc cref="P:Facepunch.ActionGraphs.Node.IParameter.Definition" />
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Parameter`1.IsMissing">
      <inheritdoc cref="P:Facepunch.ActionGraphs.IParameterDefinition.IsMissing" />
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Parameter`1.Node">
      <inheritdoc />
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Parameter`1.Name">
      <inheritdoc />
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Parameter`1.StackTraceIdentifier">
      <inheritdoc />
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Parameter`1.Type">
      <inheritdoc />
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Parameter`1.Display">
      <inheritdoc />
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Parameter`1.Attributes">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.Node.Parameter`1.ToString">
      <summary>
            Returns A string with the format "{Node}.{Name}".
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.Node.Property">
      <summary>
            A named constant value stored inside a node.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Property.IsVariable">
      <summary>
            If true, this property references a <see cref="T:Facepunch.ActionGraphs.Variable" />.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Property.Value">
      <summary>
            Constant value assigned to this parameter.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.Node.Property.TryGetValue(System.Object@)">
      <summary>
            Attempts to get either the current assigned value, or default value
            for optional properties. Returns false if this property is required
            and has no assigned value.
            </summary>
      <param name="value">Current assigned or default value.</param>
      <returns>True if this node has an assigned or default value.</returns>
    </member>
    <member name="M:Facepunch.ActionGraphs.Node.Property.GetValueOrDefault">
      <summary>
            Attempts to get either the current assigned value, or default value
            for optional properties. Throws an exception if this property is
            required and has no assigned value.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.Node.Property.GetValueOrDefault``1">
      <summary>
            Attempts to get either the current assigned value, or default value
            for optional properties. Throws an exception if this property is
            required and has no assigned value, or the assigned value is the
            wrong type.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.Node.Input">
      <summary>
            A named input of a node. Inputs can connect to outputs of other nodes,
            or have a constant value. Use <see cref="!:SetLink(LinkSource)" /> to set which output
            this input links to, or <see cref="!:SetLinks(LinkSource[])" /> if this input
            can accept an array of values.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Input.IsArray">
      <summary>
            If true, this input accepts an array of values. Each element
            can be connected to a different output with <see cref="M:Facepunch.ActionGraphs.Node.Input.InsertLink(Facepunch.ActionGraphs.ILinkSource,System.Int32)" />
            or <see cref="!:SetLinks(Output[])" />.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Input.IsSignal">
      <summary>
            If true, this input receives a signal that will cause the parent node
            to act.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Input.IsLinked">
      <summary>
            If true, this input is linked to an output.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Input.SourceType">
      <summary>
            Gets the type arriving in this input. Returns null if unlinked.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Input.Link">
      <summary>
            If this is linked to a single output, gets that link.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Input.LinkArray">
      <summary>
            If this is linked to an array of outputs, gets the connecting links.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Input.Links">
      <summary>
            Gets any links connected to this input.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Input.ElementType">
      <summary>
            For array input types, the type of an element of the array.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Input.Value">
      <summary>
            Constant source value for this input.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.Node.Input.IndexOfLink(Facepunch.ActionGraphs.Link)">
      <summary>
            If this input is connected to an array of outputs, gets the index
            of the given link in that array. Returns -1 if not found.
            </summary>
      <param name="link">Link to get the index of.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.Node.Input.ClearLinks">
      <summary>
            Removes all links from this input.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.Node.Input.SetLink(Facepunch.ActionGraphs.ILinkSource)">
      <summary>
            Clears any existing links or constant value, and sets this input to be linked to the given output.
            </summary>
      <param name="source">Output to link to.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.Node.Input.SetLink(Facepunch.ActionGraphs.ILinkSource,System.Int32)">
      <summary>
            If this input accepts an array of links, replaces a link in that array to the given output.
            </summary>
      <param name="source">Output to link to.</param>
      <param name="index">Index into the link array to set the link.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.Node.Input.InsertLink(Facepunch.ActionGraphs.ILinkSource,System.Int32)">
      <summary>
            If this input accepts an array of links, inserts a link in that array to the given output.
            </summary>
      <param name="source">Output to link to.</param>
      <param name="index">Index into the link array to insert the link.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.Node.Input.SetLinks(Facepunch.ActionGraphs.ILinkSource[])">
      <summary>
            If this input accepts an array of links, clears any existing links or constant value and sets
            this input to be linked to the given array of outputs.
            </summary>
      <param name="sources">Array of outputs to link to.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.Node.Input.SetLinks(System.Collections.Generic.IReadOnlyList{Facepunch.ActionGraphs.ILinkSource})">
      <summary>
            If this input accepts an array of links, clears any existing links or constant value and sets
            this input to be linked to the given array of outputs.
            </summary>
      <param name="sources">Array of outputs to link to.</param>
    </member>
    <member name="T:Facepunch.ActionGraphs.Node.Output">
      <summary>
            A named output of a node. Use <see cref="!:Input.SetLink(LinkSource)" />,
            or <see cref="!:Input.SetLinks(LinkSource[])" /> to connect this
            output to an input.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Output.IsSignal">
      <summary>
            If true, this output emits signals that can trigger other nodes
            to act.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Output.InvokesAsync">
      <summary>
            Are any nodes invoked by this output async? Used during validation.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Output.Links">
      <summary>
            All links currently connected to this output.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Node.Output.IsLinked">
      <summary>
            If true, this output has at least one connected input.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.ParameterNames">
      <summary>
            Special names for parameters of built-in node types.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.NodeProperties">
      <summary>
            Constant named values stored in a node.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeProperties.Variable">
      <summary>
            Used by:
            <list type="bullet"><item><description><see cref="!:NodeLibrary.GetVar" /></description></item><item><description><see cref="!:NodeLibrary.SetVar" /></description></item></list></summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeProperties.Type">
      <summary>
            Used by:
            <list type="bullet"><item><description><see cref="P:Facepunch.ActionGraphs.NodeLibrary.Property" /></description></item><item><description><see cref="P:Facepunch.ActionGraphs.NodeLibrary.CallMethod" /></description></item></list></summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeProperties.Name">
      <summary>
            Used by:
            <list type="bullet"><item><description><see cref="P:Facepunch.ActionGraphs.NodeLibrary.Property" /></description></item><item><description><see cref="P:Facepunch.ActionGraphs.NodeLibrary.CallMethod" /></description></item></list></summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeProperties.IsStatic">
      <summary>
            Used by:
            <list type="bullet"><item><description><see cref="P:Facepunch.ActionGraphs.NodeLibrary.Property" /></description></item><item><description><see cref="P:Facepunch.ActionGraphs.NodeLibrary.CallMethod" /></description></item><item><description><see cref="P:Facepunch.ActionGraphs.NodeLibrary.Output" /></description></item></list></summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeProperties.Kind">
      <summary>
            Used by:
            <list type="bullet"><item><description><see cref="P:Facepunch.ActionGraphs.NodeLibrary.Property" /></description></item></list></summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeProperties.Value">
      <summary>
            Used by:
            <list type="bullet"><item><description><see cref="P:Facepunch.ActionGraphs.NodeLibrary.Constant" /></description></item></list></summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.NodeInputs">
      <summary>
            Named inputs of a node, that may either link to the outputs of other nodes,
            or be assigned a constant value.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeInputs.Signal">
      <summary>
            Used by <see cref="F:Facepunch.ActionGraphs.NodeKind.Action" /> nodes.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeInputs.Target">
      <summary>
            Used by:
            <list type="bullet"><item><description><see cref="P:Facepunch.ActionGraphs.NodeLibrary.Property" /></description></item><item><description><see cref="P:Facepunch.ActionGraphs.NodeLibrary.CallMethod" /></description></item></list></summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeInputs.Result">
      <summary>
            Used by:
            <list type="bullet"><item><description><see cref="P:Facepunch.ActionGraphs.NodeLibrary.Output" /></description></item></list></summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeInputs.Value">
      <summary>
            Used by:
            <list type="bullet"><item><description><see cref="P:Facepunch.ActionGraphs.NodeLibrary.Property" /></description></item><item><description><see cref="!:NodeLibrary.SetVar" /></description></item></list></summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeInputs.Links">
      <summary>
            All current links into inputs of this node.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.NodeOutputs">
      <summary>
            Named outputs of a node, that may link to the inputs of other nodes.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeOutputs.Signal">
      <summary>
            Used by <see cref="F:Facepunch.ActionGraphs.NodeKind.Action" /> nodes.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeOutputs.Result">
      <summary>
            Default output of most nodes that produce a single value.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeOutputs.Links">
      <summary>
            All current links from outputs of this node.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.NodeBinding">
      <summary>
            A collection of named node properties, inputs, and outputs with specific types, as
            provided by a <see cref="T:Facepunch.ActionGraphs.NodeDefinition" />. Bindings may depend on the property values
            or currently linked input types of a node.
            </summary>
      <param name="DisplayInfo">Display information for the bound node.</param>
      <param name="Properties">Named constant values stored in a node.</param>
      <param name="Inputs">Named inputs that can be provided either from the outputs of other nodes, or with constant values.</param>
      <param name="Outputs">Named outputs that can be connected to the inputs of other nodes.</param>
      <param name="Messages">Can contain warnings or errors if this binding isn't fully valid.</param>
      <param name="Target">Optional binding target data used by <see cref="M:Facepunch.ActionGraphs.NodeDefinition.BuildExpression(Facepunch.ActionGraphs.Compilation.INodeExpressionBuilder)" />.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeBinding.#ctor(Facepunch.ActionGraphs.DisplayInfo,System.Collections.Generic.IReadOnlyCollection{Facepunch.ActionGraphs.PropertyDefinition},System.Collections.Generic.IReadOnlyCollection{Facepunch.ActionGraphs.InputDefinition},System.Collections.Generic.IReadOnlyCollection{Facepunch.ActionGraphs.OutputDefinition},System.Collections.Generic.IReadOnlyCollection{Facepunch.ActionGraphs.NodeBinding.ValidationMessage},System.Collections.Generic.IReadOnlyCollection{System.Attribute},System.Boolean,System.Object)">
      <summary>
            A collection of named node properties, inputs, and outputs with specific types, as
            provided by a <see cref="T:Facepunch.ActionGraphs.NodeDefinition" />. Bindings may depend on the property values
            or currently linked input types of a node.
            </summary>
      <param name="DisplayInfo">Display information for the bound node.</param>
      <param name="Properties">Named constant values stored in a node.</param>
      <param name="Inputs">Named inputs that can be provided either from the outputs of other nodes, or with constant values.</param>
      <param name="Outputs">Named outputs that can be connected to the inputs of other nodes.</param>
      <param name="Messages">Can contain warnings or errors if this binding isn't fully valid.</param>
      <param name="Target">Optional binding target data used by <see cref="M:Facepunch.ActionGraphs.NodeDefinition.BuildExpression(Facepunch.ActionGraphs.Compilation.INodeExpressionBuilder)" />.</param>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeBinding.DisplayInfo">
      <summary>Display information for the bound node.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeBinding.Properties">
      <summary>Named constant values stored in a node.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeBinding.Inputs">
      <summary>Named inputs that can be provided either from the outputs of other nodes, or with constant values.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeBinding.Outputs">
      <summary>Named outputs that can be connected to the inputs of other nodes.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeBinding.Messages">
      <summary>Can contain warnings or errors if this binding isn't fully valid.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeBinding.Target">
      <summary>Optional binding target data used by <see cref="M:Facepunch.ActionGraphs.NodeDefinition.BuildExpression(Facepunch.ActionGraphs.Compilation.INodeExpressionBuilder)" />.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeBinding.Kind">
      <summary>
            Is this node an action or an expression?
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.NodeBinding.ValidationMessage">
      <summary>
            A message generated when attempting to bind a set of named property values and input types.
            Becomes a <see cref="T:Facepunch.ActionGraphs.ValidationMessage" /> during action graph validation.
            </summary>
      <param name="Context">Which property, input or output this message is relevant to.</param>
      <param name="Level">Message severity.</param>
      <param name="Value">Message content.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeBinding.ValidationMessage.#ctor(Facepunch.ActionGraphs.IParameterDefinition,Facepunch.ActionGraphs.MessageLevel,System.String,System.Object)">
      <summary>
            A message generated when attempting to bind a set of named property values and input types.
            Becomes a <see cref="T:Facepunch.ActionGraphs.ValidationMessage" /> during action graph validation.
            </summary>
      <param name="Context">Which property, input or output this message is relevant to.</param>
      <param name="Level">Message severity.</param>
      <param name="Value">Message content.</param>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeBinding.ValidationMessage.Context">
      <summary>Which property, input or output this message is relevant to.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeBinding.ValidationMessage.Level">
      <summary>Message severity.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeBinding.ValidationMessage.Value">
      <summary>Message content.</summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.AddAssemblyResult">
      <summary>
            Returned by <see cref="M:Facepunch.ActionGraphs.NodeLibrary.AddAssembly(System.Reflection.Assembly)" />.
            </summary>
      <param name="AlreadyAdded">If true, this assembly was previously added so it was skipped.</param>
      <param name="Errors">Any exceptions thrown when attempting to add methods can be found here.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.AddAssemblyResult.#ctor(System.Boolean,System.Collections.Generic.IReadOnlyDictionary{System.Reflection.MemberInfo,System.Exception})">
      <summary>
            Returned by <see cref="M:Facepunch.ActionGraphs.NodeLibrary.AddAssembly(System.Reflection.Assembly)" />.
            </summary>
      <param name="AlreadyAdded">If true, this assembly was previously added so it was skipped.</param>
      <param name="Errors">Any exceptions thrown when attempting to add methods can be found here.</param>
    </member>
    <member name="P:Facepunch.ActionGraphs.AddAssemblyResult.AlreadyAdded">
      <summary>If true, this assembly was previously added so it was skipped.</summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.AddAssemblyResult.Errors">
      <summary>Any exceptions thrown when attempting to add methods can be found here.</summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.NodeLibrary">
      <summary>
            Contains a library of <see cref="T:Facepunch.ActionGraphs.NodeDefinition" />s, each with a unique identifier.
            Custom node definitions can be added with <see cref="M:Facepunch.ActionGraphs.NodeLibrary.Add(Facepunch.ActionGraphs.NodeDefinition)" />, or from methods marked with
            either <see cref="!:ActionNodeAttribute" /> or <see cref="!:ExpressionNodeAttribute" /> when
            using <see cref="M:Facepunch.ActionGraphs.NodeLibrary.AddAssembly(System.Reflection.Assembly)" />.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeLibrary.#ctor(Facepunch.ActionGraphs.ITypeLoader,Facepunch.ActionGraphs.IGraphLoader)">
      <summary>
            Contains a library of <see cref="T:Facepunch.ActionGraphs.NodeDefinition" />s, each with a unique identifier.
            An <see cref="T:Facepunch.ActionGraphs.ITypeLoader" /> is required to wrap reflection methods. Use an <see cref="T:Facepunch.ActionGraphs.DefaultTypeLoader" />
            if no access control is needed.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeLibrary.All">
      <summary>
            Dictionary of all added definitions, indexed by their <see cref="P:Facepunch.ActionGraphs.NodeDefinition.Identifier" />s.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeLibrary.Input">
      <summary>
            Node definition for the entry point of the graph. Each graph can only have one such entry point.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeLibrary.InputValue">
      <summary>
            Helper node for accessing a graph input parameter.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeLibrary.Output">
      <summary>
            Node definition for output signals of the graph. Each graph can have at most one primary output.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeLibrary.Graph">
      <summary>
            A node implemented by an action graph.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeLibrary.Variable">
      <summary>
            Node definition for getting or setting <see cref="P:Facepunch.ActionGraphs.NodeLibrary.Variable" /> values.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeLibrary.Constant">
      <summary>
            Node definition for providing constant values.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeLibrary.Property">
      <summary>
            Node definition for getting or setting static or instance properties.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeLibrary.CallMethod">
      <summary>
            Node definition for calling a named method.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeLibrary.NewInstance">
      <summary>
            Node definition for calling a constructor to create an instance.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeLibrary.NoOperation">
      <summary>
            A node that does nothing, just forwards an input to its output.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.NodeLibrary.Comment">
      <summary>
            A node with no inputs or outputs, only metadata. Useful for holding documentation.
            </summary>
    </member>
    <member name="E:Facepunch.ActionGraphs.NodeLibrary.VoidTaskFaulted">
      <summary>
            Invoked when an async graph, invoked as a delegate returning <see cref="T:System.Void" />,
            throws an exception.
            </summary>
    </member>
    <member name="E:Facepunch.ActionGraphs.NodeLibrary.ActionGraphCreated">
      <summary>
            Event dispatched whenever an <see cref="T:Facepunch.ActionGraphs.ActionGraph" /> belonging to this node library is created.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeLibrary.Add(Facepunch.ActionGraphs.NodeDefinition)">
      <summary>
            Add a custom node definition. The <see cref="P:Facepunch.ActionGraphs.NodeDefinition.Identifier" /> must be unique
            in this library. See also <see cref="M:Facepunch.ActionGraphs.NodeLibrary.AddAssembly(System.Reflection.Assembly)" /> for an easier way to implement custom nodes.
            </summary>
      <param name="definition">Custom node definition to add.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeLibrary.AddAssembly(System.Reflection.Assembly)">
      <summary>
            Adds a node definition for each method annotated with either <see cref="!:ActionNodeAttribute" /> or
            <see cref="T:Facepunch.ActionGraphs.ExpressionNodeDefinition" /> in the given assembly.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeLibrary.Get(System.String)">
      <summary>
            Gets a node definition by identifier. Returns null if not found.
            </summary>
      <param name="identifier">Unique identifier of the node definition to find.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeLibrary.Get``1(``0)">
      <summary>
            Gets a node definition by the method that implements it. Method must already
            be added with <see cref="M:Facepunch.ActionGraphs.NodeLibrary.AddAssembly(System.Reflection.Assembly)" />.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeLibrary.Get(System.Type,System.String)">
      <inheritdoc cref="M:Facepunch.ActionGraphs.NodeLibrary.Get``1(``0)" />
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeLibrary.Get(System.Reflection.MethodInfo)">
      <inheritdoc cref="M:Facepunch.ActionGraphs.NodeLibrary.Get``1(``0)" />
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeLibrary.Get(System.Linq.Expressions.ExpressionType)">
      <summary>
            Gets a node definition by the operator it implements.
            </summary>
      <param name="expressionType">Operator of the node definition to find.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeLibrary.Reset">
      <summary>
            Removes all custom node definitions from this library.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeLibrary.IsPure(System.Reflection.MethodBase)">
      <summary>
            Returns true if the given method has been marked as pure. Pure methods
            have no (visible) side effects, and so can be turned into expression nodes.
            </summary>
      <param name="method">Method to test.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.NodeLibrary.IsProperty(System.Reflection.ParameterInfo)">
      <summary>
            Returns true if the given parameter should be a property on a node, rather than
            an input or output.
            </summary>
      <param name="parameter">Parameter to test.</param>
    </member>
    <member name="T:Facepunch.ActionGraphs.Nodes.ControlFlow">
      <summary>
            Nodes providing basic control flow structures like branches and loops.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.Nodes.ControlFlow.Body">
      <summary>
            An action to perform in a branch or loop.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.Nodes.ControlFlow.ForEachBody`1">
      <summary>
            Output signal for a <see cref="M:Facepunch.ActionGraphs.Nodes.ControlFlow.ForEach``1(System.Collections.Generic.IEnumerable{``0},Facepunch.ActionGraphs.Nodes.ControlFlow.ForEachBody{``0})" /> node, fired for each element of an enumerable.
            </summary>
      <typeparam name="T">Element type.</typeparam>
    </member>
    <member name="T:Facepunch.ActionGraphs.Nodes.ControlFlow.ForRangeBody">
      <summary>
            Output signal for a <see cref="M:Facepunch.ActionGraphs.Nodes.ControlFlow.ForRange(Facepunch.ActionGraphs.Nodes.ControlFlow.ForRangeBody,System.Int32,System.Int32,System.Int32)" /> node, fired for each value in the range.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.Nodes.Math">
      <summary>
            Nodes relating to numbers and geometry.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.Null">
      <summary>
            Represents a null reference.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.JsonExtensions">
      <summary>
            Extension methods for <see cref="N:System.Text.Json" /> types.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.JsonExtensions.AddActionGraphConverters(System.Text.Json.JsonSerializerOptions,Facepunch.ActionGraphs.NodeLibrary)">
      <summary>
            Adds the ability for this <see cref="T:System.Text.Json.JsonSerializerOptions" /> to convert <see cref="T:Facepunch.ActionGraphs.ActionGraph" />,
            <see cref="!:ActionGraph&lt;T&gt;" />, and <see cref="T:System.Delegate" /> instances implemented with action graphs.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.JsonExtensions.AddActionGraphConverters(System.Text.Json.JsonSerializerOptions,Facepunch.ActionGraphs.GetNodeLibraryDelegate)">
      <summary>
            Adds the ability for this <see cref="T:System.Text.Json.JsonSerializerOptions" /> to convert <see cref="T:Facepunch.ActionGraphs.ActionGraph" />,
            <see cref="!:ActionGraph&lt;T&gt;" />, and <see cref="T:System.Delegate" /> instances implemented with action graphs.
            </summary>
    </member>
    <member name="T:Facepunch.ActionGraphs.ITypeLoader">
      <summary>
            An implementation of this interface will wrap reflection calls, allowing
            custom access control. See <see cref="T:Facepunch.ActionGraphs.DefaultTypeLoader" /> for a default implementation
            with no access control.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ITypeLoader.TypeToIdentifier(System.Type)">
      <summary>
            Gets an identifier string that can later be used by <see cref="M:Facepunch.ActionGraphs.ITypeLoader.TypeFromIdentifier(System.String)" /> to
            deserialize a type instance.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ITypeLoader.TypeFromIdentifier(System.String)">
      <summary>
            Load a type from an identifier, as produced by <see cref="M:Facepunch.ActionGraphs.ITypeLoader.TypeToIdentifier(System.Type)" />.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ITypeLoader.GetProperty(System.Type,System.String)">
      <summary>
            Gets a named property declared on the given type. Should
            return null if the property isn't found, or if it isn't allowed to be accessed.
            </summary>
      <param name="declaringType">Declaring type that contains the property.</param>
      <param name="name">Property name.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.ITypeLoader.GetField(System.Type,System.String)">
      <summary>
            Gets a named field declared on the given type. Should
            return null if the field isn't found, or if it isn't allowed to be accessed.
            </summary>
      <param name="declaringType">Declaring type that contains the field.</param>
      <param name="name">Field name.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.ITypeLoader.CanRead(System.Reflection.PropertyInfo)">
      <summary>
            Returns true if <see cref="T:Facepunch.ActionGraphs.ActionGraph" /> is allowed to read from this property.
            Basic checks, like if a get method exists, will have already been performed.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ITypeLoader.CanWrite(System.Reflection.PropertyInfo)">
      <summary>
            Returns true if <see cref="T:Facepunch.ActionGraphs.ActionGraph" /> is allowed to write to this property.
            Basic checks, like if a set method exists, will have already been performed.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ITypeLoader.CanRead(System.Reflection.FieldInfo)">
      <summary>
            Returns true if <see cref="T:Facepunch.ActionGraphs.ActionGraph" /> is allowed to read from this field.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ITypeLoader.CanWrite(System.Reflection.FieldInfo)">
      <summary>
            Returns true if <see cref="T:Facepunch.ActionGraphs.ActionGraph" /> is allowed to read from this field.
            Basic checks, like if it is marked <see cref="P:System.Reflection.FieldInfo.IsInitOnly" />, will
            have already been performed.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.ITypeLoader.GetConstructors(System.Type)">
      <summary>
            Gets all constructors declared on the given type.
            </summary>
      <param name="declaringType">Declaring type that contains the constructors.</param>
      <returns />
    </member>
    <member name="M:Facepunch.ActionGraphs.ITypeLoader.GetMethods(System.Type,System.String)">
      <summary>
            Gets all methods with the given name declared on the given type.
            </summary>
      <param name="declaringType">Declaring type that contains the methods.</param>
      <param name="name">Method name.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.ITypeLoader.GetNestedType(System.Type,System.String)">
      <summary>
            Gets a nested type from its name and the containing type. Should
            return null if the type isn't found, or if it isn't allowed to be accessed.
            </summary>
      <param name="declaringType">Declaring type that contains the nested type.</param>
      <param name="name">Short name of the nested type, not the fully qualified name.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.ITypeLoader.MakeArrayType(System.Type,System.Nullable{System.Int32})">
      <summary>
            Makes an array type from the given element type and optional rank. Should
            throw an exception if creating such an array is forbidden.
            </summary>
      <param name="elementType">Type of each element in the array.</param>
      <param name="rank">Optional number of dimensions of the array.</param>
    </member>
    <member name="M:Facepunch.ActionGraphs.ITypeLoader.MakeGenericType(System.Type,System.Type[])">
      <summary>
            Makes a generic instance type from the given generic type definition and type
            arguments. Should throw an exception if the arguments aren't valid for the generic
            type definition, or if creating such a type is forbidden.
            </summary>
      <param name="genericTypeDefinition">Generic type definition with one or more open type parameters.</param>
      <param name="genericArguments">Type arguments to use when creating the generic instance type.</param>
      <returns />
    </member>
    <member name="T:Facepunch.ActionGraphs.DefaultTypeLoader">
      <summary>
            A default implementation of <see cref="T:Facepunch.ActionGraphs.ITypeLoader" /> with no access control.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.DefaultTypeLoader.TypeToIdentifier(System.Type)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.DefaultTypeLoader.TypeFromIdentifier(System.String)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.DefaultTypeLoader.GetProperty(System.Type,System.String)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.DefaultTypeLoader.GetField(System.Type,System.String)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.DefaultTypeLoader.CanRead(System.Reflection.PropertyInfo)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.DefaultTypeLoader.CanWrite(System.Reflection.PropertyInfo)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.DefaultTypeLoader.CanRead(System.Reflection.FieldInfo)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.DefaultTypeLoader.CanWrite(System.Reflection.FieldInfo)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.DefaultTypeLoader.GetConstructors(System.Type)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.DefaultTypeLoader.GetMethods(System.Type,System.String)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.DefaultTypeLoader.GetNestedType(System.Type,System.String)">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.DefaultTypeLoader.MakeArrayType(System.Type,System.Nullable{System.Int32})">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.DefaultTypeLoader.MakeGenericType(System.Type,System.Type[])">
      <inheritdoc />
    </member>
    <member name="M:Facepunch.ActionGraphs.DefaultTypeLoader.CanCache(System.Type)">
      <inheritdoc />
    </member>
    <member name="T:Facepunch.ActionGraphs.Variable">
      <summary>
            Variables have a name and type, and are local to each invocation of an <see cref="P:Facepunch.ActionGraphs.Variable.ActionGraph" />.
            They are assigned with a <see cref="!:NodeLibrary.SetVar" /> node, and read with <see cref="!:NodeLibrary.GetVar" />.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Variable.Name">
      <summary>
            The name of this variable, unique in its action graph.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Variable.Type">
      <summary>
            Value type stored in this variable.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Variable.DefaultValue">
      <summary>
            Initial value of the variable before being assigned.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Variable.UserData">
      <summary>
            Arbitrary named values stored in this variable, which will be included during
            serialization. Values must be serializable to JSON.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Variable.References">
      <summary>
            All node properties that currently reference this variable.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Variable.ActionGraph">
      <summary>
            The action graph this variable belongs to.
            </summary>
    </member>
    <member name="P:Facepunch.ActionGraphs.Variable.StackTraceIdentifier">
      <inheritdoc />
    </member>
    <member name="P:Facepunch.ActionGraphs.Variable.IsValid">
      <summary>
            Becomes false when this variable is removed.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.Variable.Remove">
      <summary>
            Remove this variable from its action graph.
            This will clear any references to it.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.Variable.ToString">
      <summary>
            Returns the name of the variable.
            </summary>
    </member>
    <member name="F:Facepunch.ActionGraphs.Variable._sourceType">
      <summary>
            Keep hold of the node the variable type was deserialized from if there were any exceptions,
            so we can safely round-trip serialize even in the worst case. This will get cleared
            if any changes are made to the variable.
            </summary>
    </member>
    <member name="M:Facepunch.ActionGraphs.Versions.Version3.ReplaceExpandedOutputsWithChildNodes(System.Text.Json.Nodes.JsonObject,Facepunch.ActionGraphs.NodeLibrary,System.Text.Json.JsonSerializerOptions)">
      <summary>
            Replace legacy expanded output system with parented nodes.
            Expanded outputs generated outputs with names like "output.X" to get the "X" property of "output".
            </summary>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.ParameterPattern_0">
      <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex" />-derived type for the ParameterPattern method.</summary>
    </member>
    <member name="F:System.Text.RegularExpressions.Generated.ParameterPattern_0.Instance">
      <summary>Cached, thread-safe singleton instance.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.ParameterPattern_0.#ctor">
      <summary>Initializes the instance.</summary>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.ParameterPattern_0.RunnerFactory">
      <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner" /> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.ParameterPattern_0.RunnerFactory.CreateInstance">
      <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner" /> used by methods on <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.ParameterPattern_0.RunnerFactory.Runner">
      <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.ParameterPattern_0.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
      <summary>Scan the <paramref name="inputSpan" /> starting from base.runtextstart for the next match.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.ParameterPattern_0.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
      <summary>Search <paramref name="inputSpan" /> starting from base.runtextpos for the next location a match could possibly start.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
      <returns>true if a possible match was found; false if no more matches are possible.</returns>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.ParameterPattern_0.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
      <summary>Determine whether <paramref name="inputSpan" /> at base.runtextpos is a match for the regular expression.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
      <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.Utilities">
      <summary>Helper methods used by generated <see cref="T:System.Text.RegularExpressions.Regex" />-derived implementations.</summary>
    </member>
    <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout">
      <summary>Default timeout value set in <see cref="T:System.AppContext" />, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> if none was set.</summary>
    </member>
    <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_hasTimeout">
      <summary>Whether <see cref="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout" /> is non-infinite.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPop(System.Int32[],System.Int32@,System.Int32@,System.Int32@)">
      <summary>Pops 2 values from the backtracking stack.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32)">
      <summary>Pushes 1 value onto the backtracking stack.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32,System.Int32)">
      <summary>Pushes 2 values onto the backtracking stack.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32,System.Int32,System.Int32)">
      <summary>Pushes 3 values onto the backtracking stack.</summary>
    </member>
    <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FEFFFF87FEFFFF07">
      <summary>Supports searching for characters in or not in "ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".</summary>
    </member>
  </members>
  <assembly>
    <name>Sandbox.Access</name>
  </assembly>
  <members>
    <member name="M:Sandbox.AccessControl.TrustUnsafe(System.Byte[])">
      <summary>
            Dangerous! Create a <see cref="T:Sandbox.TrustedBinaryStream" /> of the given stream
            without actually passing it through access control.
            </summary>
    </member>
    <member name="M:Sandbox.AccessControl.VerifyAssembly(System.IO.Stream,Sandbox.TrustedBinaryStream@,System.Boolean)">
      <summary>
            Returns true if assembly is fine. Previous errors are cleared at the start of this method
            so only new Errors are set if returning false.
            </summary>
      <param name="dll" />
      <param name="outStream">
        <see cref="T:Sandbox.TrustedBinaryStream" /> wrapper around <paramref name="dll" />.
            Will close if <paramref name="dll" /> gets closed.</param>
      <param name="addToWhitelist" />
    </member>
    <member name="M:Sandbox.AccessControl.InitTouches(System.Byte[])">
      <summary>
            Clear the touches and fill them with everything this dll touches
            </summary>
    </member>
    <member name="M:Sandbox.AccessControl.ForgetAssembly(System.String)">
      <summary>
            If we're definitely never going to see this assembly again (because it's being unloaded for instance)
            We can totally get rid of it and free all that lovely memory.
            </summary>
    </member>
    <member name="M:Sandbox.AccessControl.ForgetOlderAssemblyDefinitions(System.Reflection.AssemblyName)">
      <summary>
            Forget all versions of the named assembly strictly older than this one.
            </summary>
    </member>
    <member name="M:Sandbox.AccessControl.ForgetOlderAssemblyDefinitions(Mono.Cecil.AssemblyNameReference)">
      <summary>
            Forget all versions of the named assembly strictly older than this one.
            </summary>
    </member>
    <member name="M:Sandbox.AccessControl.RemoveLocalTouches">
      <summary>
            Remove touches that are inside addon depends or this dll.
            </summary>
    </member>
    <member name="F:Sandbox.AccessControl.skipMethods">
      <summary>
            These methods show up a lot and unexplitable, easy to skip
            </summary>
    </member>
    <member name="M:Sandbox.AccessRules.IsInWhitelist(System.String)">
      <summary>
            Returns true if call is in the whitelist
            </summary>
    </member>
    <member name="T:Sandbox.TrustedBinaryStream">
      <summary>
            Wraps a stream containing a binary that has passed access control.
            </summary>
    </member>
    <member name="M:Sandbox.TrustedBinaryStream.CreateInternal(System.Byte[])">
      <summary>
            This should only be used by access control!
            </summary>
    </member>
  </members>
  <assembly>
    <name>Sandbox.AppSystem</name>
  </assembly>
  <members>
    <member name="M:Sandbox.AppSystem.CreateMenu">
      <summary>
            Create the Menu instance. This is created in a sandboxed context, which means it gets its
            own sandbox.game.dll, to avoid interfering with anything in the game. There's a good argument
            to say that this is no longer necessary, with a bit of work routing input and ui management.
            </summary>
    </member>
    <member name="M:Sandbox.AppSystem.CreateGame">
      <summary>
            Create the Game (Sandbox.GameInstance)
            </summary>
    </member>
    <member name="M:Sandbox.AppSystem.CreateEditor">
      <summary>
            Create the editor (Sandbox.Tools)
            </summary>
    </member>
    <member name="M:Sandbox.AppSystem.LoadSteamDll">
      <summary>
            Explicitly load the Steam Api dll from our bin folder, so that it doesn't accidentally
            load one from c:\system32\ or something. This is a problem when people have installed
            pirate versions of Steam in the past and have the assembly hanging around still. By loading
            it here we're saying use this version, and it won't try to load another one.
            </summary>
    </member>
    <member name="T:Sandbox.EditorAppSystem">
      <summary>
            Used for sbox-dev editor
            </summary>
    </member>
    <member name="M:Sandbox.EditorAppSystem.CheckProject">
      <summary>
            Checks if a valid -project parameter was passed
            </summary>
    </member>
    <member name="T:Sandbox.MissingDependancyDiagnosis">
      <summary>
            Poke a bunch of native dlls that are required and try to work out if they exist, and can load.
            </summary>
    </member>
    <member name="M:Sandbox.QtAppSystem.LoadSteamDll">
      <summary>
            Explicitly load the Steam Api dll from our bin folder, so that it doesn't accidentally
            load one from c:\system32\ or something. This is a problem when people have installed
            pirate versions of Steam in the past and have the assembly hanging around still. By loading
            it here we're saying use this version, and it won't try to load another one.
            </summary>
    </member>
    <member name="T:Sandbox.ToolAppSystem">
      <summary>
            Used to create standalone tools that can still interop to the engine
            </summary>
    </member>
    <member name="M:Sandbox.ToolAppSystem.InitEnginePaths">
      <summary>
            We want to set current dir to /game/ 
            and add the native dll paths to the path
            </summary>
    </member>
  </members>
  <assembly>
    <name>Sandbox.Bind</name>
  </assembly>
  <members>
    <member name="T:Sandbox.Bind.BindSystem">
      <summary>
            Data bind system, bind properties to each other.
            </summary>
    </member>
    <member name="P:Sandbox.Bind.BindSystem.Name">
      <summary>
            The debug name given to this system (ie Tools, Client, Server)
            </summary>
    </member>
    <member name="P:Sandbox.Bind.BindSystem.ThrottleUpdates">
      <summary>
            If true we'll throttle time between link change checks. This should
            always be enabled in game, for performance reasons.
            </summary>
    </member>
    <member name="P:Sandbox.Bind.BindSystem.CatchExceptions">
      <summary>
            If true we'll catch and remove exceptions when testing links instead of
            propagating them to the Tick call.
            </summary>
    </member>
    <member name="P:Sandbox.Bind.BindSystem.LinkCount">
      <summary>
            The current amount of active links
            </summary>
    </member>
    <member name="M:Sandbox.Bind.BindSystem.Tick">
      <summary>
            Should be called every frame. Will run through the links and check
            for changes, then action those changes. Will also remove dead links.
            </summary>
    </member>
    <member name="M:Sandbox.Bind.BindSystem.Flush">
      <summary>
            Call a tick with no timer limits, forcing all pending actions to be actioned
            </summary>
    </member>
    <member name="P:Sandbox.Bind.BindSystem.Build">
      <summary>
            A helper to create binds between two properties (or whatever you want)
            </summary>
    </member>
    <member name="M:Sandbox.Bind.BindSystem.FindAttributes``1(``0,System.String)">
      <summary>
            For this object, with this property, find the property
            that supplies it and return any attributes set on it.
            This is useful for editors to allow them to supply the correct
            editor, without having access to the property.
            </summary>
    </member>
    <member name="T:Sandbox.Bind.Builder">
      <summary>
            A helper to create binds between two properties (or whatever you want)
            <para>
            Example usage: set "BoolValue" from value of "StringValue"
            <code>BindSystem.Build.Set( this, "BoolValue" ).From( this, "StringValue" );</code></para></summary>
    </member>
    <member name="M:Sandbox.Bind.Builder.ReadOnly(System.Boolean)">
      <summary>
            Makes the bind link one way. The system will not try to write to the target/right hand property. (The one you set via "From" methods)
            </summary>
    </member>
    <member name="M:Sandbox.Bind.Builder.Set``2(``0,System.Func{``1},System.Action{``1})">
      <summary>
            Call this function when the Right hand changes. Stop updating when the object dies.
            </summary>
    </member>
    <member name="M:Sandbox.Bind.Builder.From``1(System.Func{``0},System.Action{``0})">
      <summary>
            Read and write the Right hand side via custom callbacks, rather than a specific property.
            </summary>
      <param name="read">Called to update the Left hand side. Return the target value.</param>
      <param name="write">Called to update the Right hand side. Do whatever you need with the provided value.</param>
    </member>
    <member name="T:Sandbox.Bind.Link">
      <summary>
            Joins two proxies together, so one can be updated from the other (or both from each other)
            </summary>
    </member>
    <member name="P:Sandbox.Bind.Link.IsValid">
      <summary>
            This is updated in tick. Will return false if either binding is invalid. Bindings become
            invalid if the object is garbage collected or is an IValid and made invalid.
            </summary>
    </member>
    <member name="P:Sandbox.Bind.Link.OneWay">
      <summary>
            True if this should only update from left to right.
            </summary>
    </member>
    <member name="P:Sandbox.Bind.Link.Left">
      <summary>
            The primary binding. Changes to this value always take priority over the other.
            </summary>
    </member>
    <member name="P:Sandbox.Bind.Link.Right">
      <summary>
            The secondary binding, if we're OneWay then this will only ever be written to.
            </summary>
    </member>
    <member name="F:Sandbox.Bind.Link.nextCall">
      <summary>
            The next time this link is allowed to check
            </summary>
    </member>
    <member name="M:Sandbox.Bind.Link.Tick(System.Double,Sandbox.Bind.BindSystem)">
      <summary>
            Called from manager for each link.
            It's this function's job to avoid calling Tick to save performance.
            </summary>
    </member>
    <member name="M:Sandbox.Bind.Link.OnDownstreamChanged(System.Object)">
      <summary>
            A value on our value has changed, which has changed our value. Replace both bindings
            with our value.
            </summary>
    </member>
    <member name="T:Sandbox.Bind.DeepPropertyProxy">
      <summary>
            A proxy that can access properties using a deep path, ie "School.Teacher.Name".
            Slower than the regular proxy because we don't do any caching.
            </summary>
    </member>
    <member name="T:Sandbox.Bind.MethodProxy`1">
      <summary>
            A proxy where set and get are done via functions
            </summary>
    </member>
    <member name="T:Sandbox.Bind.PropertyProxy">
      <summary>
            A proxy wrapped around a PropertyInfo
            </summary>
    </member>
    <member name="T:Sandbox.Bind.Proxy">
      <summary>
            Gets and Sets a value from somewhere.
            </summary>
    </member>
    <member name="P:Sandbox.Bind.Proxy.Target">
      <summary>
            The object to read data from and write data to.
            </summary>
    </member>
    <member name="P:Sandbox.Bind.Proxy.Name">
      <summary>
            Debug name for this property
            </summary>
    </member>
    <member name="P:Sandbox.Bind.Proxy.Value">
      <summary>
            Get or set the value.
            </summary>
    </member>
    <member name="P:Sandbox.Bind.Proxy.CanRead">
      <summary>
            True if we can get the value.
            </summary>
    </member>
    <member name="P:Sandbox.Bind.Proxy.CanWrite">
      <summary>
            True if we can set the value
            </summary>
    </member>
    <member name="P:Sandbox.Bind.Proxy.IsValid">
      <summary>
            Should return <see langword="false" /> if the proxy is now invalid, like if the source object was destroyed.
            </summary>
    </member>
  </members>
  <assembly>
    <name>Sandbox.Compiling</name>
  </assembly>
  <members>
    <member name="P:Sandbox.CodeArchive.CompilerName">
      <summary>
            The name of the compiler
            </summary>
    </member>
    <member name="P:Sandbox.CodeArchive.Configuration">
      <summary>
            The compiler's configuration settings
            </summary>
    </member>
    <member name="P:Sandbox.CodeArchive.SyntaxTrees">
      <summary>
            The syntax trees that should be compiled
            </summary>
    </member>
    <member name="T:Sandbox.CodeArchive.AdditionalFile">
      <summary>
            Represents a file to send to the compiler along with all the code. This is usually
            something that the generator turns into code, such as a Razor file.
            </summary>
    </member>
    <member name="M:Sandbox.CodeArchive.AdditionalFile.#ctor(System.String,System.String)">
      <summary>
            Represents a file to send to the compiler along with all the code. This is usually
            something that the generator turns into code, such as a Razor file.
            </summary>
    </member>
    <member name="P:Sandbox.CodeArchive.AdditionalFiles">
      <summary>
            Additional files that the compiler/generator needs. This is going to be .razor files.
            </summary>
    </member>
    <member name="P:Sandbox.CodeArchive.FileMap">
      <summary>
            Converts the syntax tree paths from physical paths to project local paths
            </summary>
    </member>
    <member name="P:Sandbox.CodeArchive.References">
      <summary>
            References that this compiler/generator needs to compile the code
            </summary>
    </member>
    <member name="P:Sandbox.CodeArchive.Version">
      <summary>
            The version of the code archive
            1005 - Inital version
            1006 - Razor updates. Add razor namespaces on older versions.
            </summary>
    </member>
    <member name="M:Sandbox.CodeArchive.Serialize">
      <summary>
            Serialize to a byte array
            </summary>
    </member>
    <member name="M:Sandbox.CodeArchive.Deserialize(System.Byte[])">
      <summary>
            Deserialize from a byte array
            </summary>
    </member>
    <member name="P:Sandbox.CompileGroup.SuppressBuildNotifications">
      <summary>
            Build notifications start of suppressed until after startup proper. That way
            we don't get 4 build notification windows popping up on startup.
            </summary>
    </member>
    <member name="P:Sandbox.CompileGroup.Compilers">
      <summary>
            The compilers within the group
            </summary>
    </member>
    <member name="P:Sandbox.CompileGroup.Name">
      <summary>
            The name of this compile group, for debugging/display purposes
            </summary>
    </member>
    <member name="F:Sandbox.CompileGroup.packageAssemblies">
      <summary>
            Dlls downloaded from the package system can be stored in the group so they're available to compiles.
            </summary>
    </member>
    <member name="P:Sandbox.CompileGroup.NeedsBuild">
      <summary>
            Returns true if we have compiles pending
            </summary>
    </member>
    <member name="P:Sandbox.CompileGroup.IsBuilding">
      <summary>
            Returns true if we are currently in the process of building
            </summary>
    </member>
    <member name="P:Sandbox.CompileGroup.PrintErrorsInConsole">
      <summary>
            True if we want to print errors in the console when compiling
            </summary>
    </member>
    <member name="P:Sandbox.CompileGroup.AllowFastHotload">
      <summary>
            True if we want to use fast hotloading with this compile group
            </summary>
    </member>
    <member name="P:Sandbox.CompileGroup.BuildResult">
      <summary>
            Returns true if build was successful
            </summary>
    </member>
    <member name="P:Sandbox.CompileGroup.OnCompileStarted">
      <summary>
            Called when a compiling starts
            </summary>
    </member>
    <member name="P:Sandbox.CompileGroup.OnCompileFinished">
      <summary>
            Called when a compiling ends
            </summary>
    </member>
    <member name="P:Sandbox.CompileGroup.OnCompileSuccess">
      <summary>
            Called when a compile completes successfully. Can access the result from BuildResult. 
            </summary>
    </member>
    <member name="F:Sandbox.CompileGroup._compilers">
      <summary>
            All created compilers.
            </summary>
    </member>
    <member name="F:Sandbox.CompileGroup._recompileList">
      <summary>
            Compilers waiting for recompile
            </summary>
    </member>
    <member name="M:Sandbox.CompileGroup.Dispose">
      <summary>
            Shut everything down
            </summary>
    </member>
    <member name="M:Sandbox.CompileGroup.CreateCompiler(System.String,System.String,Sandbox.Compiler.Configuration)">
      <summary>
            Create a new compiler in this group.
            </summary>
    </member>
    <member name="M:Sandbox.CompileGroup.MarkForRecompile(Sandbox.Compiler)">
      <summary>
            Mark this assembly as changed.
            </summary>
    </member>
    <member name="M:Sandbox.CompileGroup.MarkDependantsForRecompile(Sandbox.Compiler,System.Collections.Generic.HashSet{Sandbox.Compiler})">
      <summary>
            Recompile anything that depends on us too
            </summary>
    </member>
    <member name="M:Sandbox.CompileGroup.BuildAsync">
      <summary>
            Build the compilers
            </summary>
    </member>
    <member name="M:Sandbox.CompileGroup.AddAssembly(System.String,System.Span{System.Byte},System.Boolean)">
      <summary>
            Add an assembly to the group, which compilers can freely reference
            </summary>
    </member>
    <member name="M:Sandbox.CompileGroup.RemoveAssembly(System.String)">
      <summary>
            Remove an assembly from the group
            </summary>
    </member>
    <member name="M:Sandbox.CompileGroup.TryFindReference(System.String,Sandbox.Compiler,Microsoft.CodeAnalysis.PortableExecutableReference@)">
      <summary>
            Find a reference for this dll
            </summary>
    </member>
    <member name="M:Sandbox.CompileGroup.Reset">
      <summary>
            Reset the compile group. Clear errors and outputs.
            </summary>
    </member>
    <member name="T:Sandbox.Compiler">
      <summary>
            Given a folder of .cs files, this will produce (and load) an assembly
            </summary>
    </member>
    <member name="P:Sandbox.Compiler.Configuration.Whitelist">
      <summary>
            If true, we will be using the whitelist system. If false then this package won't
            be "sandboxed", so won't be able to be published on the platform.
            </summary>
    </member>
    <member name="P:Sandbox.Compiler.Configuration.Unsafe">
      <summary>
            If true, we'll compile with /unsafe. This means that the package won't be able to
            be published on the platform.
            </summary>
    </member>
    <member name="P:Sandbox.Compiler.Configuration.AssemblyReferences">
      <summary>
            References to non-package assemblies, by assembly name.
            </summary>
    </member>
    <member name="P:Sandbox.Compiler.Configuration.IgnoreFolders">
      <summary>
            Folders to ignore when walking the tree
            </summary>
    </member>
    <member name="P:Sandbox.Compiler.Configuration.DistinctAssemblyReferences">
      <summary>
            Each unique element of <see cref="P:Sandbox.Compiler.Configuration.AssemblyReferences" /></summary>
    </member>
    <member name="M:Sandbox.Compiler.UpdateFromArchive(Sandbox.CodeArchive)">
      <summary>
            Fill this compiler from a code archive
            </summary>
    </member>
    <member name="M:Sandbox.Compiler.Build">
      <summary>
            Build and load the assembly.
            </summary>
    </member>
    <member name="P:Sandbox.Compiler.Group">
      <summary>
            Each compiler must belong to a compile group
            </summary>
    </member>
    <member name="P:Sandbox.Compiler.Output">
      <summary>
            The output from the previous build
            </summary>
    </member>
    <member name="P:Sandbox.Compiler.Building">
      <summary>
            Is this addon is still building?
            </summary>
    </member>
    <member name="P:Sandbox.Compiler.Name">
      <summary>
            Name of the project this compiler was created for. This could be something like "base" or "org.ident".
            </summary>
    </member>
    <member name="P:Sandbox.Compiler.UseAbsoluteSourcePaths">
      <summary>
            During development we use absolute source paths so that debugging works better. In a packed/release build it's
            good to use relative paths instead, just to avoid exposing the builder's file system.
            </summary>
    </member>
    <member name="P:Sandbox.Compiler.Diagnostics">
      <summary>
            A list of warnings and errors created by the last build
            </summary>
    </member>
    <member name="P:Sandbox.Compiler.AssemblyName">
      <summary>
            Generated assembly name, without an extension. This will be "package.{Name}".
            </summary>
    </member>
    <member name="P:Sandbox.Compiler.GeneratedCode">
      <summary>
            Global namespaces
            </summary>
    </member>
    <member name="P:Sandbox.Compiler.SourceLocations">
      <summary>
            Directories to search for code
            </summary>
    </member>
    <member name="P:Sandbox.Compiler.FileSystem">
      <summary>
            An aggregate of all the filesystem this compiler has
            </summary>
    </member>
    <member name="F:Sandbox.Compiler.MetadataReference">
      <summary>
            After compile is completed successfully this will be non null.
            </summary>
    </member>
    <member name="F:Sandbox.Compiler._recentMetadataReferences">
      <summary>
            Keeps track of the most recent <see cref="F:Sandbox.Compiler.MetadataReference" /> values,
            in case the current one is revoked because it was fast-hotloaded.
            This dictionary is cleared when a version is built that doesn't support
            fast hotload at all.
            </summary>
    </member>
    <member name="F:Sandbox.Compiler.config">
      <summary>
            The compiler's settings. 
            </summary>
    </member>
    <member name="M:Sandbox.Compiler.#ctor(Sandbox.CompileGroup,System.String,System.String,Sandbox.Compiler.Configuration)">
      <summary>
            Should only ever get called from CompileGroup.
            </summary>
    </member>
    <member name="M:Sandbox.Compiler.#ctor(Sandbox.CompileGroup,System.String)">
      <summary>
            Should only ever get called from CompileGroup.
            </summary>
    </member>
    <member name="M:Sandbox.Compiler.AddSourcePath(System.String)">
      <summary>
            Add an extra source path. Useful for situations where you want to combine multiple addons into one.
            </summary>
    </member>
    <member name="P:Sandbox.Compiler.BuildResult">
      <summary>
            Results for the assembly build. This can contain warnings or errors.
            </summary>
    </member>
    <member name="P:Sandbox.Compiler.BuildSuccess">
      <summary>
            Accesses Output.Successful
            </summary>
    </member>
    <member name="F:Sandbox.Compiler.compileCounter">
      <summary>
            Keep tabs of how many times we've compiled
            </summary>
    </member>
    <member name="M:Sandbox.Compiler.ReadTextForgiving(System.String,System.Int32,System.Int32)">
      <summary>
            Read text from a file while dealing with the fact that it might be being saved right 
            when we're loading it so it's likely to throw IOExceptions.
            </summary>
    </member>
    <member name="M:Sandbox.Compiler.GetReferencedCompilers">
      <summary>
            Return this compiler and all child compilers
            </summary>
    </member>
    <member name="M:Sandbox.Compiler.MarkForRecompile">
      <summary>
            Recompile this as soon as is appropriate
            </summary>
    </member>
    <member name="P:Sandbox.Compiler._references">
      <summary>
            References needed for compile
            </summary>
    </member>
    <member name="M:Sandbox.Compiler.AddReference(System.String)">
      <summary>
            Add a reference to this compiler. This might be a system dll, or an assembly name from a fellow compiler.
            </summary>
    </member>
    <member name="M:Sandbox.Compiler.HasReference(System.String,System.Boolean)">
      <summary>
            Returns true if <see cref="P:Sandbox.Compiler._references" /> contains the given reference assembly name.
            If <paramref name="deep" /> is true, referenced compilers are searched too.
            </summary>
    </member>
    <member name="F:Sandbox.Compiler.CompilerExtraPath">
      <summary>
            Generated file that will get stuff like global usings and assembly attributes.
            </summary>
    </member>
    <member name="M:Sandbox.Compiler.GetSyntaxTree(Sandbox.CodeArchive,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions)">
      <summary>
            Collect all of the code that should compiled into this assembly
            </summary>
    </member>
    <member name="M:Sandbox.Compiler.WatchForChanges">
      <summary>
            Watch the filesystem for changes to our c# files, and trigger a recompile if they change.
            </summary>
    </member>
    <member name="P:Sandbox.CompilerOutput.Successful">
      <summary>
            True if the build succeeded
            </summary>
    </member>
    <member name="P:Sandbox.CompilerOutput.Compiler">
      <summary>
            The compiler that has produced this build
            </summary>
    </member>
    <member name="P:Sandbox.CompilerOutput.Version">
      <summary>
            The version of the assembly
            </summary>
    </member>
    <member name="P:Sandbox.CompilerOutput.AssemblyData">
      <summary>
            The [assembly].dll contents for this build
            </summary>
    </member>
    <member name="P:Sandbox.CompilerOutput.Archive">
      <summary>
            A code archive created during the compile
            </summary>
    </member>
    <member name="P:Sandbox.CompilerOutput.XmlDocumentation">
      <summary>
            The [assembly].xml contents for this build
            </summary>
    </member>
    <member name="P:Sandbox.CompilerOutput.Diagnostics">
      <summary>
            A list of diagnostics caused by the previous build
            </summary>
    </member>
    <member name="P:Sandbox.CompilerOutput.Exception">
      <summary>
            If an exception happened during the build, it'll be available here
            </summary>
    </member>
    <member name="T:Sandbox.IncrementalCompileState">
      <summary>
            Holds state for incremental compilation. Ask Matt or James to add comments, I don't know.
            </summary>
    </member>
    <member name="T:Sandbox.FrameworkReferences">
      <summary>
            Loads the framework assemblies from the bin/ref folder and makes 
            them available globally to every compiler.
            </summary>
    </member>
    <member name="M:Sandbox.FrameworkReferences.FindByName(System.String)">
      <summary>
            Find a framework reference by its assembly name
            </summary>
    </member>
  </members>
  <assembly>
    <name>Sandbox.Engine</name>
  </assembly>
  <members>
    <member name="M:Sandbox.ActionGraphs.RandomNodes.Color(System.Single,System.Single)">
      <summary>
            Returns a color with a random hue.
            </summary>
      <param name="saturation">Saturation of the generated color, from 0 to 1.</param>
      <param name="lightness">Lightness of the generated color, from 0 to 1.</param>
      <returns />
    </member>
    <member name="T:Sandbox.ActionGraphs.ISerializationOptionProvider">
      <summary>
            A <see cref="T:Facepunch.ActionGraphs.ISourceLocation" /> that provides <see cref="T:Facepunch.ActionGraphs.SerializationOptions" />.
            </summary>
    </member>
    <member name="T:Sandbox.ActionGraphs.MapSourceLocation">
      <summary>
            Source location for action graphs that belong to a Hammer map. This is used for stack
            traces, and for knowing which map to save when editing a graph.
            </summary>
    </member>
    <member name="M:Sandbox.ActionGraphs.MapSourceLocation.Get(System.String)">
      <summary>
            Gets a <see cref="T:Sandbox.ActionGraphs.MapSourceLocation" /> from a path name.
            </summary>
      <param name="mapPathName">Project-relative map path ending with ".vmap" or ".vpk".</param>
    </member>
    <member name="T:Sandbox.ActionGraphs.GameResourceSourceLocation">
      <summary>
            Source location for action graphs that belong to a <see cref="T:Sandbox.GameResource" />.
            These can include scenes and prefabs, or custom resources. This is used for stack
            traces, and for knowing which asset to save when editing a graph.
            </summary>
      <param name="Resource">Resource that contains action graphs.</param>
    </member>
    <member name="M:Sandbox.ActionGraphs.GameResourceSourceLocation.#ctor(Sandbox.GameResource)">
      <summary>
            Source location for action graphs that belong to a <see cref="T:Sandbox.GameResource" />.
            These can include scenes and prefabs, or custom resources. This is used for stack
            traces, and for knowing which asset to save when editing a graph.
            </summary>
      <param name="Resource">Resource that contains action graphs.</param>
    </member>
    <member name="P:Sandbox.ActionGraphs.GameResourceSourceLocation.Resource">
      <summary>Resource that contains action graphs.</summary>
    </member>
    <member name="M:Sandbox.ActionGraphs.UtilityNodes.As``2(``0)">
      <summary>
            Tests if the given input is of the given type, otherwise returns null.
            </summary>
      <typeparam name="TIn">Input type.</typeparam>
      <typeparam name="TValue">Type to test for.</typeparam>
      <param name="input">Input value to test the type of.</param>
    </member>
    <member name="M:Sandbox.ActionGraphs.UtilityNodes.IsNull(System.Object)">
      <summary>
            Tests if the given input is null or invalid.
            </summary>
      <param name="input">Input value to test for null.</param>
    </member>
    <member name="M:Sandbox.ActionGraphs.UtilityNodes.IsNotNull(System.Object)">
      <summary>
            Tests if the given input is not null and not invalid.
            </summary>
      <param name="input">Input value to test for null.</param>
    </member>
    <member name="M:Sandbox.ActionGraphs.UtilityNodes.SystemToString``1(``0)">
      <inheritdoc cref="M:System.Object.ToString" />
    </member>
    <member name="M:Sandbox.ActionGraphs.UtilityNodes.SystemToString``1(``0,System.String)">
      <inheritdoc cref="M:System.Object.ToString" />
    </member>
    <member name="M:Sandbox.ActionGraphs.UtilityNodes.SystemGetHashCode``1(``0)">
      <inheritdoc cref="M:System.Object.GetHashCode" />
    </member>
    <member name="P:Sandbox.AccountInformation.Links">
      <summary>
            A list of services that we have linked
            </summary>
    </member>
    <member name="P:Sandbox.AccountInformation.Memberships">
      <summary>
            A list of organizations of which we're a member
            </summary>
    </member>
    <member name="P:Sandbox.AccountInformation.Favourites">
      <summary>
            A list of our favourited games
            </summary>
    </member>
    <member name="P:Sandbox.AccountInformation.Session">
      <summary>
            Current client hash (the login session cookie)
            </summary>
    </member>
    <member name="P:Sandbox.AccountInformation.SteamId">
      <summary>
            The current logged in user's steamid
            </summary>
    </member>
    <member name="P:Sandbox.AccountInformation.Score">
      <summary>
            The current logged in user's gamercore
            </summary>
    </member>
    <member name="P:Sandbox.AccountInformation.AvatarJson">
      <summary>
            The current logged in user's avatar, from the backend
            </summary>
    </member>
    <member name="M:Sandbox.AccountInformation.Update">
      <summary>
            Update Current
            </summary>
    </member>
    <member name="M:Sandbox.AccountInformation.IsFavourite(System.String)">
      <summary>
            Helper - return true if Current.Favourites contains us
            </summary>
    </member>
    <member name="M:Sandbox.AccountInformation.HasOrganization(System.String)">
      <summary>
            Returns true if a user is a member of this organization
            </summary>
    </member>
    <member name="M:Sandbox.AccountInformation.GetUploadEndPointAsync(System.String)">
      <summary>
            Returns a URL in which users have the ability to upload files (but not the ability to list or download files).
            This is used so users can upload files to our blob storage, and give us the filename - rather than uploading big
            ass files to our api.
            </summary>
    </member>
    <member name="M:Sandbox.Api.GetAccountInformation">
      <summary>
            Get linked service credentials, ie "twitch". Under the hood, on our server, we will
            probably be renewing the token with the service (assume the token is only good for 2-3 hours).
            </summary>
    </member>
    <member name="M:Sandbox.Api.Benchmarks.Post(Sandbox.Services.BenchmarkRecord[],System.Threading.CancellationToken)">
      <summary>
            Post a batch of analytic events. Analytic events are things like compile or load times to 
            help us find, fix and track performance issues.
            </summary>
    </member>
    <member name="M:Sandbox.Api.Events.Add(Sandbox.Api.Events.EventRecord)">
      <summary>
            Add an event to the queue. You should not use this event again.
            </summary>
    </member>
    <member name="M:Sandbox.Api.Events.Flush">
      <summary>
            Force an immediate flush of all events
            </summary>
    </member>
    <member name="M:Sandbox.Api.Events.TickEvents">
      <summary>
            Post a batch of analytic events. Analytic events are things like compile or load times to 
            help us find, fix and track performance issues.
            </summary>
    </member>
    <member name="M:Sandbox.Api.Events.PostEventsAsync(Sandbox.Api.Events.EventRecord[])">
      <summary>
            Post a batch of analytic events. Analytic events are things like compile or load times to 
            help us find, fix and track performance issues.
            </summary>
    </member>
    <member name="M:Sandbox.Api.Performance.CollectStat(System.String,System.Double)">
      <summary>
            Collect a statistic. This should usually be called ONCE per frame, per stat.
            </summary>
    </member>
    <member name="M:Sandbox.Api.Performance.BuildStats">
      <summary>
            Convert statDict into an object that we can send to the backend.
            </summary>
    </member>
    <member name="M:Sandbox.Api.Performance.ArrayToMetric(System.Collections.Generic.List{System.Double})">
      <summary>
             Here we take the array of values and convert them into an object with a bunch of statistics about them.
             Basically trying to cover our bases as much as possible, in case we need to show this data later on.
            </summary>
    </member>
    <member name="F:Sandbox.Api.LaunchGuid">
      <summary>
            This attempts to be a unique identifier for the launch of a game.
            </summary>
    </member>
    <member name="M:Sandbox.Api.Stats.FlushWithBookmarkAsync(System.String,System.Boolean,System.Threading.CancellationToken)">
      <summary>
            Flush the stats and wait until they have been ingested by the backend, 
            at which point they should be available in stats and leaderboard queries.
            </summary>
    </member>
    <member name="M:Sandbox.Api.Stats.ForceFlush">
      <summary>
            Force an immediate flush of all events
            </summary>
    </member>
    <member name="M:Sandbox.Api.Stats.ForceFlushAsync">
      <summary>
            Force an immediate flush of the stats and wait until it's done
            </summary>
    </member>
    <member name="M:Sandbox.Api.Stats.TickStats">
      <summary>
            Post a batch of analytic events. Analytic events are things like compile or load times to 
            help us find, fix and track performance issues.
            </summary>
    </member>
    <member name="M:Sandbox.Api.Stats.PostStatsAsync(Sandbox.Api.Stats.StatRecord[])">
      <summary>
            Post a batch of analytic events. Analytic events are things like compile or load times to 
            help us find, fix and track performance issues.
            </summary>
    </member>
    <member name="P:Sandbox.Api.Stats.StatRecord.Package">
      <summary>
            The package ident (lowercase [org.package])
            </summary>
    </member>
    <member name="P:Sandbox.Api.Stats.StatRecord.Name">
      <summary>
            The name of the stat (lowercase, no spaces)
            </summary>
    </member>
    <member name="P:Sandbox.Api.Stats.StatRecord.Created">
      <summary>
            When this stat was created
            </summary>
    </member>
    <member name="P:Sandbox.Api.Stats.StatRecord.Updated">
      <summary>
            When this stat was updated
            </summary>
    </member>
    <member name="P:Sandbox.Api.Stats.StatRecord.IsIncrement">
      <summary>
            If this is an increment
            </summary>
    </member>
    <member name="P:Sandbox.Api.Stats.StatRecord.Compounds">
      <summary>
            If this represents multiple calls, this is the number of calls
            </summary>
    </member>
    <member name="P:Sandbox.Api.Stats.StatRecord.MinValue">
      <summary>
            If this represents multiple calls, this is the smallest
            </summary>
    </member>
    <member name="P:Sandbox.Api.Stats.StatRecord.MaxValue">
      <summary>
            If this represents multiple calls, this is the largest
            </summary>
    </member>
    <member name="P:Sandbox.Api.Stats.StatRecord.Value">
      <summary>
            The actual value
            </summary>
    </member>
    <member name="P:Sandbox.Api.Stats.StatRecord.Context">
      <summary>
            Additional context. Map etc..
            </summary>
    </member>
    <member name="P:Sandbox.Api.Stats.StatRecord.Session">
      <summary>
            The current session (or null if #local)
            </summary>
    </member>
    <member name="P:Sandbox.Api.Stats.StatRecord.SessionSeconds">
      <summary>
            The current time in session
            </summary>
    </member>
    <member name="P:Sandbox.Api.Stats.StatRecord.Data">
      <summary>
            Should be a dynamic object
            </summary>
    </member>
    <member name="P:Sandbox.Application.IsInitialized">
      <summary>
            Prevent double initialization
            </summary>
    </member>
    <member name="P:Sandbox.Application.AppId">
      <summary>
            Steam AppId of S&amp;box.
            </summary>
    </member>
    <member name="P:Sandbox.Application.IsUnitTest">
      <summary>
            True if we're running the engine as part of a unit test
            </summary>
    </member>
    <member name="P:Sandbox.Application.IsLiveUnitTest">
      <summary>
            True if we're running a live unit test.
            </summary>
    </member>
    <member name="P:Sandbox.Application.IsHeadless">
      <summary>
            True if running as a background task, or terminal, like a dedicated server.
            </summary>
    </member>
    <member name="P:Sandbox.Application.IsConsoleApp">
      <summary>
            True if running in a terminal like console, instead of a game window or editor.
            </summary>
    </member>
    <member name="P:Sandbox.Application.IsDedicatedServer">
      <summary>
            True if this is a dedicated server
            </summary>
    </member>
    <member name="P:Sandbox.Application.IsBenchmark">
      <summary>
            True if running a benchmark
            </summary>
    </member>
    <member name="P:Sandbox.Application.IsEditor">
      <summary>
            True if running with the tools or editor attached
            </summary>
    </member>
    <member name="P:Sandbox.Application.IsJoinLocal">
      <summary>
            True if running with -joinlocal. This is an instance that launches and joins
            an in process editor session.
            </summary>
    </member>
    <member name="P:Sandbox.Application.Version">
      <summary>
            The engine's version string
            </summary>
    </member>
    <member name="P:Sandbox.Application.IsRetail">
      <summary>
            True if this is compiled and published on steam
            </summary>
    </member>
    <member name="P:Sandbox.Application.VersionDate">
      <summary>
            The date of this version, as a UTC datetime.
            </summary>
    </member>
    <member name="P:Sandbox.Application.ExceptionCount">
      <summary>
            Number of exceptions we've had. Resets on game exit.
            </summary>
    </member>
    <member name="P:Sandbox.Application.IsStandalone">
      <summary>
            True if the game is running in standalone mode
            </summary>
    </member>
    <member name="P:Sandbox.Application.LanguageCode">
      <summary>
            The language code for the current language
            </summary>
    </member>
    <member name="P:Sandbox.Application.IsVR">
      <summary>
            True if the game is running in VR mode
            </summary>
    </member>
    <member name="M:Sandbox.Application.InitUnitTest(System.Boolean,System.Boolean)">
      <summary>
            Called from unit test projects to initialize the engine
            </summary>
    </member>
    <member name="M:Sandbox.Application.ShutdownUnitTest">
      <summary>
            Called from unit test projects to politely shut down the engine
            </summary>
    </member>
    <member name="P:Sandbox.Application.GamePackage">
      <summary>
            The currently loaded game package. May be null if no game loaded. 
            Controlled by GameMenuDll.
            </summary>
    </member>
    <member name="P:Sandbox.Application.MapPackage">
      <summary>
            The currently loaded map package
            </summary>
    </member>
    <member name="P:Sandbox.Application.GameIdent">
      <summary>
            The currently loaded game package's ident - if applicable.
            </summary>
    </member>
    <member name="P:Sandbox.Application.IsMicrophoneListening">
      <summary>
            Returns true if the microphone is currently listening
            </summary>
    </member>
    <member name="P:Sandbox.Application.IsMicrophoneRecording">
      <summary>
            Returns true if the microphone is currently listening and actually hearing/capturing sounds
            </summary>
    </member>
    <member name="P:Sandbox.Application.IsFocused">
      <summary>
            Is the game window in focus?
            </summary>
    </member>
    <member name="M:Sandbox.Application.Exit">
      <summary>
            Exits the application if we're running in standalone mode or we are a Dedicated Server.
            </summary>
    </member>
    <member name="P:Sandbox.Achievement.IsVisible">
      <summary>
            Returns whether this achievement should be visible to the player
            </summary>
    </member>
    <member name="P:Sandbox.Achievement.ProgressionFraction">
      <summary>
            A float, representing the progression of this stat. 0 is 0%, 1 is 100%. Not clamped.
            </summary>
    </member>
    <member name="M:Sandbox.Achievement.GetFractionFromStat(Sandbox.Services.Stats.PlayerStat)">
      <summary>
            Given a stat return the fraction completed this achievement is. The assumption
            is that the stat you pass in matches the stat this achievement is looking for.
            The number returned is unclamped.
            </summary>
    </member>
    <member name="T:Sandbox.AchievementCollection">
      <summary>
            Holds achievements for a package
            </summary>
    </member>
    <member name="M:Sandbox.AchievementCollection.Get(System.String)">
      <summary>
            Get achievement by name, or null of it doesn't exist
            </summary>
    </member>
    <member name="M:Sandbox.AchievementCollection.RecountProgression">
      <summary>
            Use the current stats to recount the progression on stats with progression. This is purely for UI,
            you can't force an achivement to unlock early by calling this.
            </summary>
    </member>
    <member name="M:Sandbox.AchievementCollection.ManualUnlock(System.String)">
      <summary>
            Unlock this achievement. It must be a manual achievement.
            </summary>
    </member>
    <member name="M:Sandbox.AchievementCollection.Unlock(System.String)">
      <summary>
            Unlock this achievement. It can be anything.
            </summary>
    </member>
    <member name="M:Sandbox.AchievementCollection.TestAchivementsForUnlock">
      <summary>
            Check each achievement to see if it can be unlocked.
            </summary>
    </member>
    <member name="T:Sandbox.Cloud">
      <summary>
            For accessing assets from the cloud - from code
            </summary>
    </member>
    <member name="M:Sandbox.Cloud.Asset(System.String)">
      <summary>
            Returns the path of the asset referenced by this package
            </summary>
    </member>
    <member name="T:Sandbox.Cloud.AssetAttribute">
      <summary>
            Automatically addeded to a type as a result of using Cloud.Model etc inside.
            </summary>
    </member>
    <member name="T:Sandbox.Cloud.CloudAssetProviderAttribute">
      <summary>
            Tells codegen to generate a [assembly: Cloud.Asset] for this method
            </summary>
    </member>
    <member name="T:Sandbox.LocalPackage">
      <summary>
            A mock package, this is a package wrapped around a <see cref="P:Sandbox.LocalPackage.Project" /></summary>
    </member>
    <member name="P:Sandbox.LocalPackage.ContentPath">
      <summary>
            The path to this project's assets
            </summary>
    </member>
    <member name="P:Sandbox.LocalPackage.CodePath">
      <summary>
            The path to this project's code
            </summary>
    </member>
    <member name="P:Sandbox.LocalPackage.LocalizationPath">
      <summary>
            The path to this project's localization files
            </summary>
    </member>
    <member name="P:Sandbox.LocalPackage.IsBuiltIn">
      <summary>
            True if this package is shipped with the game - so everyone should have it
            </summary>
    </member>
    <member name="P:Sandbox.LocalPackage.AssemblyFileSystem">
      <summary>
            A filesystem into which compiled assemblies are written
            </summary>
    </member>
    <member name="M:Sandbox.LocalPackage.GetMeta``1(System.String,``0)">
      <summary>
            Retrieve meta directly from the project instead of the package
            </summary>
    </member>
    <member name="M:Sandbox.LocalPackage.NeedsLocalBasePackage">
      <summary>
            Return true if we need the "base" package including. There are a few situations:
            
            1. We're the root gamemode
            
            </summary>
    </member>
    <member name="T:Sandbox.ManifestSchema">
      <summary>
            An addon's manifest, describing what files are available
            </summary>
    </member>
    <member name="P:Sandbox.ManifestSchema.Schema">
      <summary>
            For internal use
            </summary>
    </member>
    <member name="P:Sandbox.ManifestSchema.Files">
      <summary>
            A list of files that should be mounted to use this asset
            </summary>
    </member>
    <member name="T:Sandbox.Package">
      <summary>
            Represents an asset on <a href="https://asset.party/">Asset Party</a>.
            </summary>
    </member>
    <member name="M:Sandbox.Package.GetAchievements">
      <summary>
            Get a list of achievements
            </summary>
    </member>
    <member name="P:Sandbox.Package.IsRemote">
      <summary>
            Whether this is a remote or a locally installed package.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Org">
      <summary>
            The owner of this package.
            </summary>
    </member>
    <member name="P:Sandbox.Package.FullIdent">
      <summary>
            Full unique identity of this package.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Ident">
      <summary>
            Unique identity of this package within its <see cref="P:Sandbox.Package.Org">organization.</see>.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Title">
      <summary>
            A "nice" name of this package, which will be shown to players in UI.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Summary">
      <summary>
            A short summary of the package.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Description">
      <summary>
            Full description of the package.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Thumb">
      <summary>
            Link to the thumbnail image of this package.
            </summary>
    </member>
    <member name="P:Sandbox.Package.ThumbWide">
      <summary>
            Link to the thumbnail image of this package.
            </summary>
    </member>
    <member name="P:Sandbox.Package.ThumbTall">
      <summary>
            Link to the thumbnail image of this package.
            </summary>
    </member>
    <member name="P:Sandbox.Package.VideoThumb">
      <summary>
            Link to the thumbnail video of this package.
            </summary>
    </member>
    <member name="P:Sandbox.Package.EngineVersion">
      <summary>
            Engine version this package was uploaded with.
            This is useful for when the base game undergoes large API changes.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Tags">
      <summary>
            List of tags for this package.
            </summary>
    </member>
    <member name="P:Sandbox.Package.PackageReferences">
      <summary>
            List of packages that this package depends on. These will be downloaded and installed when
            installing this package.
            </summary>
    </member>
    <member name="P:Sandbox.Package.EditorReferences">
      <summary>
            List of packages that this package depended on during editing.
            </summary>
    </member>
    <member name="P:Sandbox.Package.PackageType">
      <summary>
            What kind of package it is.
            </summary>
    </member>
    <member name="P:Sandbox.Package.TypeName">
      <summary>
            What kind of package it is.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Public">
      <summary>
            Whether this package is public or hidden.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Archived">
      <summary>
            Whether this package is archived or not.
            </summary>
    </member>
    <member name="P:Sandbox.Package.FileSize">
      <summary>
            The total size of this package in MB. This only applies to packages from Asset Party, the total file size
            of local packages are not calculated.
            </summary>
    </member>
    <member name="T:Sandbox.Package.PackageUsageStats">
      <summary>
            Statistics for user interactions with this package
            </summary>
    </member>
    <member name="P:Sandbox.Package.PackageUsageStats.Group.Users">
      <summary>
            Unique Users
            </summary>
    </member>
    <member name="P:Sandbox.Package.PackageUsageStats.Group.Seconds">
      <summary>
            Total combined user-seconds
            </summary>
    </member>
    <member name="P:Sandbox.Package.PackageUsageStats.Group.Sessions">
      <summary>
            Total combined user-seconds
            </summary>
    </member>
    <member name="P:Sandbox.Package.PackageUsageStats.Total">
      <summary>
            Total lifetime usage stats
            </summary>
    </member>
    <member name="P:Sandbox.Package.PackageUsageStats.Month">
      <summary>
            Usage for the last 3 days
            </summary>
    </member>
    <member name="P:Sandbox.Package.PackageUsageStats.Week">
      <summary>
            Usage for the last week
            </summary>
    </member>
    <member name="P:Sandbox.Package.PackageUsageStats.Day">
      <summary>
            Usage for the last 24 hours
            </summary>
    </member>
    <member name="P:Sandbox.Package.PackageUsageStats.UsersNow">
      <summary>
            How many users are using it right now
            </summary>
    </member>
    <member name="P:Sandbox.Package.PackageUsageStats.Trend">
      <summary>
            The trend is a number that represents whether it's been popular recently. Higher means more popular.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Usage">
      <summary>
            Statistics for user interactions with this package
            </summary>
    </member>
    <member name="P:Sandbox.Package.Favourited">
      <summary>
            Number of players who added this package to their favourites.
            </summary>
    </member>
    <member name="P:Sandbox.Package.VotesUp">
      <summary>
            Number of players who voted this package up.
            </summary>
    </member>
    <member name="P:Sandbox.Package.VotesDown">
      <summary>
            Number of players who voted this package down.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Source">
      <summary>
            Link to this package's sources, if set.
            </summary>
    </member>
    <member name="P:Sandbox.Package.ApiVersion">
      <summary>
            For game extension compatibility. Game targeting extensions are only compatible with that game
            if the API Versions match.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Screenshots">
      <summary>
            A list of screenshots
            </summary>
    </member>
    <member name="P:Sandbox.Package.Screenshot.IsVideo">
      <summary>
            True if this is a loading screen rather than a regular screenshot
            </summary>
    </member>
    <member name="M:Sandbox.Package.Screenshot.GetThumbUrl(System.Int32,System.Int32)">
      <summary>
            Return the URL of a thumbnail matching this exact size. For caching reasons it's going to be best if
            we can keep this to round number sizes (256, 512 etc) rather than trying to exact fit.
            </summary>
    </member>
    <member name="P:Sandbox.Package.IsFavourite">
      <summary>
            True if this asset is in our favourite list.
            </summary>
    </member>
    <member name="P:Sandbox.Package.CanEdit">
      <summary>
            True if we're a member of this package's organization.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Url">
      <summary>
            A link to this asset on our backend
            </summary>
    </member>
    <member name="P:Sandbox.Package.Updated">
      <summary>
            When the entry was last updated. If these are different between packages
            then something updated on the backend.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Created">
      <summary>
            When the package was originally created.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Collections">
      <summary>
            How many collections we're in (roughly)
            </summary>
    </member>
    <member name="P:Sandbox.Package.Referencing">
      <summary>
            How many packages we're referencing (roughly)
            </summary>
    </member>
    <member name="P:Sandbox.Package.Referenced">
      <summary>
            How many packages we're referenced by (roughly)
            </summary>
    </member>
    <member name="P:Sandbox.Package.Reviews">
      <summary>
            Stats for the reviews. Gives the number of reviews, and the fraction of the total score.
            </summary>
    </member>
    <member name="P:Sandbox.Package.ErrorRate">
      <summary>
            What fraction of users got errors from this package in the last day
            </summary>
    </member>
    <member name="P:Sandbox.Package.LatestNewsPost">
      <summary>
            The latest news post created by this package
            </summary>
    </member>
    <member name="T:Sandbox.Package.Organization">
      <summary>
            Represents an organization on Asset Party. Organization owns packages.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Organization.Ident">
      <summary>
            Unique string that identifies this organization.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Organization.Title">
      <summary>
            Full or "nice" name of this organization.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Organization.SocialTwitter">
      <summary>
            Link to Twitter of this organization, if set.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Organization.SocialWeb">
      <summary>
            Link to the website of this organization, if set.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Organization.Description">
      <summary>
            Description of this organization.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Organization.Thumb">
      <summary>
            Link to the thumbnail image of this organization.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Organization.Created">
      <summary>
            When the organization was created.
            </summary>
    </member>
    <member name="P:Sandbox.Package.IRevision.VersionId">
      <summary>
            Unique index of this revision.
            </summary>
    </member>
    <member name="P:Sandbox.Package.IRevision.FileCount">
      <summary>
            Number of files in this revision.
            </summary>
    </member>
    <member name="P:Sandbox.Package.IRevision.TotalSize">
      <summary>
            Total size of all the files in this revision, in bytes.
            </summary>
    </member>
    <member name="P:Sandbox.Package.IRevision.Created">
      <summary>
            When this revision was created.
            </summary>
    </member>
    <member name="P:Sandbox.Package.IRevision.EngineVersion">
      <summary>
            Engine version of this revision.
            TODO: How exactly is this different from <see cref="P:Sandbox.Package.EngineVersion" />?
            </summary>
    </member>
    <member name="P:Sandbox.Package.IRevision.Manifest">
      <summary>
            Manifest of the revision, describing what files are available. For this to be available
            you should call DownloadManifestAsync first.
            </summary>
    </member>
    <member name="M:Sandbox.Package.IRevision.DownloadManifestAsync(System.Threading.CancellationToken)">
      <summary>
            The manifest will not be immediately available until you've downloaded it.
            </summary>
    </member>
    <member name="P:Sandbox.Package.Revision">
      <summary>
            Information about the current package revision/version.
            </summary>
    </member>
    <member name="M:Sandbox.Package.IsNamed(System.String)">
      <summary>
            Returns true if the org and ident of the passed in ident matches this package
            </summary>
    </member>
    <member name="P:Sandbox.Package.Interaction">
      <summary>
            Describes the authenticated user's interactions with this package. This is only available
            clientside for specific users in order to show things like play history state, favourite
            status and whether they have rated the item or not.
            </summary>
    </member>
    <member name="P:Sandbox.Package.LoadingScreen">
      <summary>
            If this package is a game, it can provide media to show on the loading screen
            </summary>
    </member>
    <member name="P:Sandbox.Package.LoadingScreenSetup.MediaUrl">
      <summary>
            The URL to an image or video to use as a loading screen. The extension should reveal its type.
            </summary>
    </member>
    <member name="M:Sandbox.Package.GetValue``1(System.String,``0)">
      <summary>
            Get a data value. These are usually set on the backend, and are package type specific. These are
            generally values that are used to configure behaviour in the menu system.
            </summary>
    </member>
    <member name="M:Sandbox.Package.FilterFileDownloads(Sandbox.ManifestSchema.File)">
      <summary>
            Don't blindly download every file in the manifest. We can filter them here.
            </summary>
    </member>
    <member name="M:Sandbox.Package.Download(Sandbox.Internal.ILoadingInterface,System.Threading.CancellationToken)">
      <summary>
            Download a package to a temporary location and return a filesystem with its contents
            </summary>
    </member>
    <member name="M:Sandbox.Package.CheckFileCrc(System.String,Sandbox.ManifestSchema.File,System.Threading.CancellationToken)">
      <summary>
            Make sure this manifest file entry is what it says it is
            </summary>
    </member>
    <member name="M:Sandbox.Package.DownloadFileAsync(Sandbox.Package.FileDownloadEntry,Sandbox.PackageFileSystem,Sandbox.Utility.DataProgress.Callback,System.Threading.CancellationToken)">
      <summary>
            Download an individual file
            </summary>
    </member>
    <member name="T:Sandbox.Package.Facet">
      <summary>
            Describes a facet of a group of items, with a limited
            number of each facet with their total item counts
            </summary>
    </member>
    <member name="M:Sandbox.Package.Facet.#ctor(System.String,System.String,Sandbox.Package.Facet.Entry[])">
      <summary>
            Describes a facet of a group of items, with a limited
            number of each facet with their total item counts
            </summary>
    </member>
    <member name="T:Sandbox.Package.Facet.Entry">
      <summary>
            A facet entry consists of a name, display information and the number of items inside
            </summary>
    </member>
    <member name="M:Sandbox.Package.Facet.Entry.#ctor(System.String,System.String,System.String,System.Int32,System.Collections.Generic.List{Sandbox.Package.Facet.Entry})">
      <summary>
            A facet entry consists of a name, display information and the number of items inside
            </summary>
    </member>
    <member name="T:Sandbox.Package.FindResult">
      <summary>
            A result from the call to FindAsync
            </summary>
    </member>
    <member name="P:Sandbox.Package.FindResult.Milliseconds">
      <summary>
            The amount of time the query took
            </summary>
    </member>
    <member name="P:Sandbox.Package.FindResult.Packages">
      <summary>
            A list of packages retrieved
            </summary>
    </member>
    <member name="P:Sandbox.Package.FindResult.TotalCount">
      <summary>
            The total amount of packages
            </summary>
    </member>
    <member name="P:Sandbox.Package.FindResult.Facets">
      <summary>
            Facets particular to this search
            </summary>
    </member>
    <member name="P:Sandbox.Package.FindResult.Tags">
      <summary>
            A list of tags relevant to this search
            </summary>
    </member>
    <member name="P:Sandbox.Package.FindResult.Orders">
      <summary>
            A list of sort orders. There may be other sort orders, but we provide a list here that can
            be easily used to save rewriting the same code over and over.
            </summary>
    </member>
    <member name="P:Sandbox.Package.FindResult.Properties">
      <summary>
            Binary options
            </summary>
    </member>
    <member name="T:Sandbox.Package.TagEntry">
      <summary>
            Represents a tag along with the count of items it contains
            </summary>
    </member>
    <member name="M:Sandbox.Package.TagEntry.#ctor(System.String,System.Int32)">
      <summary>
            Represents a tag along with the count of items it contains
            </summary>
    </member>
    <member name="T:Sandbox.Package.SortOrder">
      <summary>
            Describes a sort order which can be used with the package/find api
            </summary>
    </member>
    <member name="M:Sandbox.Package.SortOrder.#ctor(System.String,System.String,System.String)">
      <summary>
            Describes a sort order which can be used with the package/find api
            </summary>
    </member>
    <member name="T:Sandbox.Package.PackageProperty">
      <summary>
            A binary category used to divide into two categories. For example, Work In Progress.
            </summary>
    </member>
    <member name="M:Sandbox.Package.PackageProperty.#ctor(System.String,System.String,System.String,System.String,System.Int32,System.Boolean)">
      <summary>
            A binary category used to divide into two categories. For example, Work In Progress.
            </summary>
    </member>
    <member name="T:Sandbox.Package.ListResult">
      <summary>
            Represents the actual response from the api
            </summary>
    </member>
    <member name="P:Sandbox.Package.ListResult.Groupings">
      <summary>
            The groups of packages
            </summary>
    </member>
    <member name="P:Sandbox.Package.ListResult.Grouping.Title">
      <summary>
            The title of this group
            </summary>
    </member>
    <member name="P:Sandbox.Package.ListResult.Grouping.QueryString">
      <summary>
            Link to get a full list of this category
            </summary>
    </member>
    <member name="P:Sandbox.Package.ListResult.Grouping.Packages">
      <summary>
            The packages in this group
            </summary>
    </member>
    <member name="M:Sandbox.Package.GetMeta``1(System.String,``0)">
      <summary>
            Get metadata value from this package for given key. This will be specific to each <see cref="T:Sandbox.Package.Type" />.
            </summary>
      <typeparam name="T">Type of the metadata value. This should be something that can be serialized by JSON.</typeparam>
      <param name="keyName">The name of the key to look up.</param>
      <param name="defaultValue">Default value to return when requested key was not present in the package's metadata.</param>
    </member>
    <member name="M:Sandbox.Package.GetCachedMeta``1(System.String,``0)">
      <summary>
        <see cref="M:Sandbox.Package.GetMeta``1(System.String,``0)" /> but with cache.
            </summary>
    </member>
    <member name="M:Sandbox.Package.GetCachedMeta``1(System.String,System.Func{``0})">
      <summary>
        <see cref="M:Sandbox.Package.GetMeta``1(System.String,``0)" /> but with cache.
            </summary>
    </member>
    <member name="M:Sandbox.Package.GetIdent(System.Boolean,System.Boolean)">
      <summary>
            Get the full ident with your choice of fidelity
            </summary>
    </member>
    <member name="M:Sandbox.Package.ClearCache(System.String)">
      <summary>
            Remove a specific package from the cache
            </summary>
    </member>
    <member name="M:Sandbox.Package.TryParseIdent(System.String,System.ValueTuple{System.String,System.String,System.Nullable{System.Int32},System.Boolean}@)">
      <summary>
            Parse a package ident into parts. There are a few different formats you can pass to this.
            
             - org/package
             - org.package
             - org.package#version
             - https://sbox.game/org/package
             - https://sbox.game/org/package#version
             
             If package version isn't specified version will be null
            
            </summary>
    </member>
    <member name="M:Sandbox.Package.FormatIdent(System.String,System.String,System.Nullable{System.Int32},System.Boolean)">
      <summary>
            Produces a package ident of the form <c><paramref name="org" />.<paramref name="package" />[#<paramref name="local" />|#<paramref name="version" />]</c>.
            </summary>
    </member>
    <member name="M:Sandbox.Package.FetchAsync(System.String,System.Boolean)">
      <summary>
            Find package information
            </summary>
    </member>
    <member name="M:Sandbox.Package.FetchAsync(System.String,System.Boolean,System.Boolean)">
      <summary>
            Find package information
            </summary>
    </member>
    <member name="M:Sandbox.Package.TryGetCached(System.String,Sandbox.Package@,System.Boolean)">
      <summary>
            Find package information
            </summary>
    </member>
    <member name="M:Sandbox.Package.Fetch(System.String,System.Boolean)">
      <summary>
            Find package information
            </summary>
    </member>
    <member name="M:Sandbox.Package.GetCachedTitle(System.String)">
      <summary>
            If we have this package information, try to get its name
            </summary>
    </member>
    <member name="M:Sandbox.Package.GetMockPackages(System.String)">
      <summary>
            These packages are created from local addons, and should be the only way 99% of systems interact with local addons.
            </summary>
    </member>
    <member name="M:Sandbox.Package.FindAsync(System.String,System.Int32,System.Int32,System.Threading.CancellationToken)">
      <summary>
            Retrieve a list of packages
            </summary>
    </member>
    <member name="M:Sandbox.Package.ListAsync(System.Int32,System.Threading.CancellationToken)">
      <summary>
            Retrieve a list of packages, organised into groups, for discovery
            </summary>
    </member>
    <member name="M:Sandbox.Package.SortByReferences(System.Collections.Generic.IEnumerable{Sandbox.Package})">
      <summary>
            Sort the given list of packages so that referenced packages are ordered before the packages that reference them.
            </summary>
      <param name="unordered">Unordered list of packages.</param>
      <returns>A new enumerable, ordered to maintain references.</returns>
    </member>
    <member name="M:Sandbox.Package.SortByReferences``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Sandbox.Package})">
      <summary>
            Sort the given list of items so that referenced packages are ordered before the packages that reference them.
            </summary>
      <param name="unordered">Unordered list of items with a corresponding package.</param>
      <param name="getPackageFunc">Delegate that maps each item to its corresponding package.</param>
      <returns>A new enumerable, ordered to maintain references.</returns>
    </member>
    <member name="M:Sandbox.Package.FetchVersions(System.String,System.Threading.CancellationToken)">
      <summary>
            Get package version list
            </summary>
    </member>
    <member name="T:Sandbox.LoadedAssembly">
      <summary>
            An assembly that has been loaded into a PackageLoader.
            </summary>
    </member>
    <member name="P:Sandbox.LoadedAssembly.ModifiedAssembly">
      <summary>
            If not null, this is an assembly that was created by Fast Hotload
            </summary>
    </member>
    <member name="T:Sandbox.PackageOptions">
      <summary>
            Options when downloading a package
            </summary>
    </member>
    <member name="F:Sandbox.PackageOptions.Loading">
      <summary>
            Loading progress callbacks
            </summary>
    </member>
    <member name="F:Sandbox.PackageOptions.AllowLocalPackages">
      <summary>
            If true then allow finding local packages
            </summary>
    </member>
    <member name="T:Sandbox.PackageLoader">
      <summary>
            Handles the loading of package assemblies into a loadcontext.
            </summary>
    </member>
    <member name="P:Sandbox.PackageLoader.AccessControl">
      <summary>
            The library used to load assemblies
            </summary>
    </member>
    <member name="P:Sandbox.PackageLoader.ToolsMode">
      <summary>
            In tools mode we don't register events unless they're from a tools project
            </summary>
    </member>
    <member name="P:Sandbox.PackageLoader.DisableAccessControl">
      <summary>
            Disables access control on all loaded local packages, but not remote packages.
            </summary>
    </member>
    <member name="M:Sandbox.PackageLoader.#ctor(System.String,System.Reflection.Assembly,System.Boolean)">
      <summary>
            Called on Game Loop Init
            </summary>
    </member>
    <member name="M:Sandbox.PackageLoader.TestAccessControl(System.IO.Stream,Sandbox.TrustedBinaryStream@)">
      <summary>
            Make sure we should be able to load this dll
            </summary>
    </member>
    <member name="M:Sandbox.PackageLoader.TryFastHotload(Sandbox.LoadedAssembly,Sandbox.LoadedAssembly)">
      <summary>
            If successful, will change outgoing in place and return true
            </summary>
    </member>
    <member name="M:Sandbox.PackageLoader.HasOldReferencedAssemblyUnloaded(System.Reflection.Assembly,System.Reflection.Assembly)">
      <summary>
            Return true if, between <paramref name="incoming" /> and <paramref name="outgoing" />,
            package references are added or removed, or a package reference changes version and wasn't fast-hotloaded itself.
            If either is the case, the incoming assembly can't be fast-hotloaded because the types it references have changed.
            </summary>
    </member>
    <member name="M:Sandbox.PackageLoader.EmitFastHotloadEvent(Sandbox.LoadedAssembly)">
      <summary>
            Trigger a switch event
            </summary>
    </member>
    <member name="M:Sandbox.PackageLoader.TriggerRegisterEvent(Sandbox.LoadedAssembly)">
      <summary>
            Trigger a switch event
            </summary>
    </member>
    <member name="M:Sandbox.PackageLoader.TriggerUnregisterEvent(Sandbox.LoadedAssembly)">
      <summary>
            Trigger a switch event
            </summary>
    </member>
    <member name="M:Sandbox.PackageLoader.GetLoadedAssemblies(System.String,System.Boolean,System.Boolean)">
      <summary>
            Called by Enroller to get the assemblies associated with a package. If deep is true then
            this should return all assemblies needed by this package and its dependencies.
            </summary>
    </member>
    <member name="T:Sandbox.PackageLoader.Enroller">
      <summary>
            Holds a list of assemblies with the intention of enrolling them into
            services like TypeLibrary, Event. Handles deduplication and switching due to 
            hotloading etc..
            </summary>
    </member>
    <member name="F:Sandbox.PackageLoader.Enroller.loaded">
      <summary>
            All of the assembles loaded into this enroller
            </summary>
    </member>
    <member name="M:Sandbox.PackageLoader.Enroller.GetLoadedAssemblies">
      <summary>
            Get all of the loaded assemblies. This is only to be used when sending 
            assemblies to children.
            </summary>
    </member>
    <member name="M:Sandbox.PackageLoader.Enroller.OnHotloadEvent(Sandbox.LoadedAssembly)">
      <summary>
            Called by PackageLoader when the assembly has undergone a fast hotload
            </summary>
    </member>
    <member name="M:Sandbox.PackageLoader.Enroller.OnRegisterEvent(Sandbox.LoadedAssembly)">
      <summary>
            Called after hotload, to register a swapped assembly
            </summary>
    </member>
    <member name="M:Sandbox.PackageLoader.Enroller.OnUnregisterEvent(Sandbox.LoadedAssembly)">
      <summary>
            Called after hotload, to register a swapped assembly
            </summary>
    </member>
    <member name="M:Sandbox.PackageLoader.Enroller.Add(Sandbox.LoadedAssembly)">
      <summary>
            Called internally on all the assemblies when a package is loaded.
            This then calls down to all of the listeners, to let them know.
            </summary>
    </member>
    <member name="T:Sandbox.PackageManager.ActivePackage">
      <summary>
            Describes a package that is currently mounted. Mounted packages are shared between client, server and editor.
            We keep track of which host is using which package using Tags.
            </summary>
    </member>
    <member name="P:Sandbox.PackageManager.ActivePackage.ProjectSettings">
      <summary>
            The project settings folder
            </summary>
    </member>
    <member name="P:Sandbox.PackageManager.ActivePackage.Localization">
      <summary>
            The project's localization folder
            </summary>
    </member>
    <member name="F:Sandbox.PackageManager.ActivePackage.memoryFileSystem">
      <summary>
            Mounted on FileSystem, this is where the codearchive is mounted to
            </summary>
    </member>
    <member name="M:Sandbox.PackageManager.ActivePackage.DownloadAsync(Sandbox.Internal.ILoadingInterface,System.Threading.CancellationToken)">
      <summary>
            Set the filesystem up from this downloaded asset
            </summary>
    </member>
    <member name="M:Sandbox.PackageManager.ActivePackage.Delete">
      <summary>
            Called to unmount and remove this package from being active
            </summary>
    </member>
    <member name="M:Sandbox.PackageManager.CmdList">
      <summary>
            List all currently active packages
            </summary>
    </member>
    <member name="M:Sandbox.PackageManager.CmdAdd(System.String,System.String)">
      <summary>
            Install a package in the specific context
            </summary>
      <param name="package">The package ident</param>
      <param name="context">The context (ie, client, server)</param>
    </member>
    <member name="M:Sandbox.PackageManager.CmdWipe(System.String)">
      <summary>
            Unmount all packages that use a specific tag. This is usually done on leaving a game for client and server
            </summary>
    </member>
    <member name="E:Sandbox.PackageManager.OnPackageInstalledToContext">
      <summary>
            Called when a new package is installed
            </summary>
    </member>
    <member name="M:Sandbox.PackageManager.InstallAsync(System.String,System.String,System.Threading.CancellationToken,System.Nullable{Sandbox.PackageOptions})">
      <summary>
            Install a package
            </summary>
    </member>
    <member name="M:Sandbox.PackageManager.InstallProjects(Sandbox.Project[],System.Threading.CancellationToken)">
      <summary>
            Install all of the projects as packages
            </summary>
    </member>
    <member name="M:Sandbox.PackageManager.Find(System.String)">
      <summary>
            Retrieve a package by ident.
            </summary>
    </member>
    <member name="M:Sandbox.PackageManager.Find(System.String,System.Boolean,System.Boolean)">
      <summary>
            Retrieve a package by ident and minimum download mode.
            </summary>
    </member>
    <member name="M:Sandbox.PackageRevision.DownloadManifestAsync(System.Threading.CancellationToken)">
      <summary>
            The manifest might not be immediately available until you've downloaded it
            </summary>
    </member>
    <member name="M:Sandbox.RemotePackage.GetValue``1(System.String,``0)">
      <summary>
            Get a data value. These are usually set on the backend, and are package type specific. These are
            generally values that are used to configure behaviour in the menu system.
            </summary>
    </member>
    <member name="T:Sandbox.Audio.AudioEngine">
      <summary>
            A mix frame size is 512 samples
            A second is made up of 44100 samples
            This means one frame is about 11.6ms
            So as long as mixing takes less than 10ms we're okay
            </summary>
    </member>
    <member name="P:Sandbox.Audio.AudioEngine.ChannelCount">
      <summary>
            How many output channels do we have? Generally 2, but if they have a 7.1 setup it can be more.
            </summary>
    </member>
    <member name="P:Sandbox.Audio.AudioEngine.QueuedBuffers">
      <summary>
            By getting the amount of buffers queued, we can determine how many seconds there are of audio in the buffer
            </summary>
    </member>
    <member name="P:Sandbox.Audio.AudioEngine.SecondsPerSample">
      <summary>
            How many seconds one sample lasts
            </summary>
    </member>
    <member name="P:Sandbox.Audio.AudioEngine.EmptyBuffers">
      <summary>
            How many empty buffers are there on the device? We want to keep them all as full as possible, so this
            should generally be 0.
            </summary>
    </member>
    <member name="P:Sandbox.Audio.AudioEngine.SamplingRate">
      <summary>
            The engine's output sampling rate. This doesn't change.
            </summary>
    </member>
    <member name="P:Sandbox.Audio.AudioEngine.MixBufferSize">
      <summary>
            The size of one 
            </summary>
    </member>
    <member name="T:Sandbox.Audio.AudioMeter">
      <summary>
            Allows the capture and monitor of an audio source
            </summary>
    </member>
    <member name="P:Sandbox.Audio.AudioMeter.Frame.VoiceCount">
      <summary>
            The amount of individual voices playing
            </summary>
    </member>
    <member name="T:Sandbox.Audio.AudioSampler">
      <summary>
            A wrapper around CAudioMixer, which is used in c++ to read from a wav etc.
            This has two parts. 
            
             o Sample - reads the samples, advances the index
             o GetSamples - returns the samples.
             
            The reason it's coded like this is because each mix frame we read all samples, then
            the mixers can do whatever they want with them. So rather than have the mixers fight
            over reading and advancing, they can all get the samples if they want to.
            </summary>
    </member>
    <member name="M:Sandbox.Audio.AudioSampler.Sample(System.Single)">
      <summary>
            Read samples to our internal buffer and advance the index. 
            Pitch should be default 1.
            </summary>
    </member>
    <member name="M:Sandbox.Audio.AudioSampler.GetLastReadSamples">
      <summary>
            Get the last read samples. This is called by the mixers.
            </summary>
    </member>
    <member name="T:Sandbox.Audio.MixBuffer">
      <summary>
            Contains 512 samples of audio data, this is used when mixing a single channel
            </summary>
    </member>
    <member name="F:Sandbox.Audio.MixBuffer._external">
      <summary>
            If true, this buffer pointer is managed by something else
            </summary>
    </member>
    <member name="F:Sandbox.Audio.MixBuffer._locked">
      <summary>
            This is locked from being disposed
            </summary>
    </member>
    <member name="M:Sandbox.Audio.MixBuffer.Silence">
      <summary>
            Silence this buffer
            </summary>
    </member>
    <member name="P:Sandbox.Audio.MixBuffer.Buffer">
      <summary>
            Get direct access to the memory
            </summary>
    </member>
    <member name="M:Sandbox.Audio.MixBuffer.CopyFrom(Sandbox.Audio.MixBuffer)">
      <summary>
            Set this buffer to this value 
            </summary>
    </member>
    <member name="M:Sandbox.Audio.MixBuffer.MixFrom(Sandbox.Audio.MixBuffer,System.Single)">
      <summary>
            Mix this buffer with another
            </summary>
    </member>
    <member name="M:Sandbox.Audio.MixBuffer.MixFrom(Sandbox.Audio.MultiChannelBuffer,System.Single)">
      <summary>
            Mix this buffer with another
            </summary>
    </member>
    <member name="M:Sandbox.Audio.MixBuffer.Scale(System.Single)">
      <summary>
            Scale the buffer by volume
            </summary>
    </member>
    <member name="T:Sandbox.Audio.MultiChannelBuffer">
      <summary>
            Holds up to 8 mix buffers, which usually represent output speakers.
            </summary>
    </member>
    <member name="P:Sandbox.Audio.MultiChannelBuffer.ChannelCount">
      <summary>
            How many channels do we have
            </summary>
    </member>
    <member name="M:Sandbox.Audio.MultiChannelBuffer.Dispose">
      <summary>
            Delete and release all resources. Cannot be used again.
            </summary>
    </member>
    <member name="M:Sandbox.Audio.MultiChannelBuffer.Get(Sandbox.Audio.AudioChannel)">
      <summary>
            Get MixBuffer number i
            </summary>
    </member>
    <member name="M:Sandbox.Audio.MultiChannelBuffer.Get(System.Int32)">
      <summary>
            Get MixBuffer number i
            </summary>
    </member>
    <member name="M:Sandbox.Audio.MultiChannelBuffer.Silence">
      <summary>
            Silence all buffers
            </summary>
    </member>
    <member name="M:Sandbox.Audio.MultiChannelBuffer.CopyFrom(Sandbox.Audio.MultiChannelBuffer)">
      <summary>
            Set this buffer to this value 
            </summary>
    </member>
    <member name="M:Sandbox.Audio.MultiChannelBuffer.CopyFromUpmix(Sandbox.Audio.MultiChannelBuffer)">
      <summary>
            Copies from one buffer to the other. If the other has less channels, we'll upmix
            </summary>
    </member>
    <member name="M:Sandbox.Audio.MultiChannelBuffer.MixFrom(Sandbox.Audio.MultiChannelBuffer,System.Single)">
      <summary>
            Mix the target buffer into this buffer
            </summary>
    </member>
    <member name="M:Sandbox.Audio.MultiChannelBuffer.Scale(System.Single)">
      <summary>
            Scale volume of this buffer
            </summary>
    </member>
    <member name="M:Sandbox.Audio.MultiChannelBuffer.SendToOutput">
      <summary>
            Send to device output
            </summary>
    </member>
    <member name="M:Sandbox.Audio.MultiChannelBuffer.ToMono(Sandbox.Audio.MixBuffer,System.Single)">
      <summary>
            Mix each channel into the single buffer, using passed in volume
            </summary>
    </member>
    <member name="T:Sandbox.Audio.DspInstance">
      <summary>
            An instance of a DspPreset. The actual processor creates one of these from
            a DspPreset, and then uses it to process the audio buffers.
            </summary>
    </member>
    <member name="T:Sandbox.Audio.DspPreset">
      <summary>
            Defines a DSP preset. This is a collection of DSP processors that can be applied to a sound.
            These originate from Half-Life 1's DSP system, and give that iconic Source Engine Sound.
            </summary>
    </member>
    <member name="T:Sandbox.Audio.DspPresetHandle">
      <summary>
            A handle to a DspPreset
            </summary>
    </member>
    <member name="T:Sandbox.Audio.Mixer">
      <summary>
            Takes a bunch of sound, changes its volumes, mixes it together, outputs it
            </summary>
    </member>
    <member name="P:Sandbox.Audio.Mixer.Meter">
      <summary>
            Allows monitoring of the output of the mixer
            </summary>
    </member>
    <member name="P:Sandbox.Audio.Mixer.Id">
      <summary>
            Unique identifier for this object, for lookup, deserialization etc
            </summary>
    </member>
    <member name="F:Sandbox.Audio.Mixer._listener">
      <summary>
            We don't want to access Sound.Listener directly, because it might keep changing
            in the other thread. This is a local copy for us to use.
            </summary>
    </member>
    <member name="F:Sandbox.Audio.Mixer._voiceCount">
      <summary>
            The current voices playing on this mixer
            </summary>
    </member>
    <member name="P:Sandbox.Audio.Mixer.Name">
      <summary>
            The display name for this mixer
            </summary>
    </member>
    <member name="P:Sandbox.Audio.Mixer.Volume">
      <summary>
            Scale the volume of our output by this amount
            </summary>
    </member>
    <member name="P:Sandbox.Audio.Mixer.MaxVoices">
      <summary>
            The maximum amount of voices to play at one time on this mixer
            </summary>
    </member>
    <member name="P:Sandbox.Audio.Mixer.OverrideOcclusion">
      <summary>
            If true then this mixer will use custom occlusion tags. If false we'll use what our parent uses.
            </summary>
    </member>
    <member name="P:Sandbox.Audio.Mixer.OcclusionTags">
      <summary>
            The tags which occlude our physics
            </summary>
    </member>
    <member name="M:Sandbox.Audio.Mixer.GetOcclusionTags">
      <summary>
            Get an array of occlusion tags our sounds want to hit. May return null if there are none defined!
            </summary>
    </member>
    <member name="P:Sandbox.Audio.Mixer.Spacializing">
      <summary>
            When 0 the sound will come out of all speakers, when 1 it will be fully spacialized
            </summary>
    </member>
    <member name="P:Sandbox.Audio.Mixer.DistanceAttenuation">
      <summary>
            Sounds get quieter as they go further away
            </summary>
    </member>
    <member name="P:Sandbox.Audio.Mixer.Occlusion">
      <summary>
            How much these sounds can get occluded
            </summary>
    </member>
    <member name="P:Sandbox.Audio.Mixer.AirAbsorption">
      <summary>
            How much the air absorbs energy from the sound
            </summary>
    </member>
    <member name="P:Sandbox.Audio.Mixer.Solo">
      <summary>
            Should this be the only mixer that is heard?
            </summary>
    </member>
    <member name="P:Sandbox.Audio.Mixer.Mute">
      <summary>
            Is this mixer muted?
            </summary>
    </member>
    <member name="P:Sandbox.Audio.Mixer.IsMaster">
      <summary>
            The default mixer gets all sounds that don't have a mixer specifically assigned
            </summary>
    </member>
    <member name="M:Sandbox.Audio.Mixer.StartMixing(Transform)">
      <summary>
            Called at the start of the mixing frame
            </summary>
    </member>
    <member name="M:Sandbox.Audio.Mixer.MixChildren(System.Collections.Generic.List{Sandbox.SoundHandle})">
      <summary>
            Mix the child mixes
            </summary>
    </member>
    <member name="M:Sandbox.Audio.Mixer.MixVoices(System.Collections.Generic.List{Sandbox.SoundHandle})">
      <summary>
            Mix the incoming voices into the mix
            </summary>
    </member>
    <member name="M:Sandbox.Audio.Mixer.FinishMixing">
      <summary>
            Mixing is finished. Clean up and finalize
            </summary>
    </member>
    <member name="M:Sandbox.Audio.Mixer.MixVoice(Sandbox.SoundHandle)">
      <summary>
            Mix a single voice
            </summary>
    </member>
    <member name="M:Sandbox.Audio.Mixer.ConvertToBinaural(Sandbox.SoundHandle,Sandbox.Audio.MultiChannelBuffer)">
      <summary>
            This will spatialize the voice based on its location
            </summary>
    </member>
    <member name="M:Sandbox.Audio.Mixer.StopAll(System.Single)">
      <summary>
            Stop all sound handles using this mixer
            </summary>
    </member>
    <member name="M:Sandbox.Audio.Mixer.FindMixerByName(Sandbox.Audio.Mixer,System.String)">
      <summary>
            We might want to do a fast lookup at some point
            </summary>
    </member>
    <member name="M:Sandbox.Audio.Mixer.FindMixerByGuid(Sandbox.Audio.Mixer,System.Guid)">
      <summary>
            We might want to do a fast lookup at some point
            </summary>
    </member>
    <member name="F:Sandbox.Audio.Mixer._processorList">
      <summary>
            Private, because we want to make this as thread safe as possible
            </summary>
    </member>
    <member name="M:Sandbox.Audio.Mixer.AddProcessor(Sandbox.Audio.AudioProcessor)">
      <summary>
            Add a processor to the list
            </summary>
    </member>
    <member name="M:Sandbox.Audio.Mixer.ClearProcessors">
      <summary>
            Add a processor to the list
            </summary>
    </member>
    <member name="M:Sandbox.Audio.Mixer.RemoveProcessor(Sandbox.Audio.AudioProcessor)">
      <summary>
            Add a processor to the list
            </summary>
    </member>
    <member name="P:Sandbox.Audio.Mixer.ProcessorCount">
      <summary>
            The amount of processors
            </summary>
    </member>
    <member name="M:Sandbox.Audio.Mixer.GetProcessors">
      <summary>
            Get the current processor list
            </summary>
    </member>
    <member name="M:Sandbox.Audio.Mixer.ApplyProcessors">
      <summary>
            Actually apply the processors to the output buffer
            </summary>
    </member>
    <member name="T:Sandbox.Audio.MixerHandle">
      <summary>
            A handle to a Mixer
            </summary>
    </member>
    <member name="T:Sandbox.Audio.MixingThread">
      <summary>
            This is a real thread! We need to be very careful about what this accesses, and how.
            </summary>
    </member>
    <member name="M:Sandbox.Audio.MixingThread.SampleVoices(System.Collections.Generic.List{Sandbox.SoundHandle})">
      <summary>
            Read one sample from each voice
            </summary>
    </member>
    <member name="M:Sandbox.Audio.MixingThread.FinishVoices(System.Collections.Generic.List{Sandbox.SoundHandle})">
      <summary>
            Mark any finished voices as finished
            </summary>
    </member>
    <member name="T:Sandbox.Audio.AudioProcessor">
      <summary>
            Takes a bunch of samples and processes them. It's common for these to be chained together.
            It's also common for the processor to store state between calls.
            </summary>
    </member>
    <member name="P:Sandbox.Audio.AudioProcessor.Enabled">
      <summary>
            Is this processor active?
            </summary>
    </member>
    <member name="P:Sandbox.Audio.AudioProcessor.Mix">
      <summary>
            Should we fade the influence of this processor in?
            </summary>
    </member>
    <member name="P:Sandbox.Audio.AudioProcessor.Listener">
      <summary>
            The listener's position in this frame (don't use Sound.Listener!)
            </summary>
    </member>
    <member name="M:Sandbox.Audio.AudioProcessor.Process(Sandbox.Audio.MultiChannelBuffer,Sandbox.Audio.MultiChannelBuffer)">
      <summary>
            Should process input into output
            </summary>
    </member>
    <member name="M:Sandbox.Audio.AudioProcessor.ProcessInPlace(Sandbox.Audio.MultiChannelBuffer)">
      <summary>
            Will process the buffer, and copy it back to output
            </summary>
    </member>
    <member name="M:Sandbox.Audio.AudioProcessor.ProcessEachChannel(Sandbox.Audio.MultiChannelBuffer)">
      <summary>
            Called internally to process each channel in a buffer
            </summary>
    </member>
    <member name="M:Sandbox.Audio.AudioProcessor.ProcessSingleChannel(Sandbox.Audio.AudioChannel,System.Span{System.Single})">
      <summary>
            For implementations that process each channel individually
            </summary>
    </member>
    <member name="T:Sandbox.Audio.AudioChannel">
      <summary>
            Represents an audio channel, between 0 and 7. This is used to index into buffers.
            This is used rather than an int to avoid unfortuate bugs.
            </summary>
    </member>
    <member name="T:Sandbox.Audio.PerChannel`1">
      <summary>
            Stores a variable per channel
            </summary>
    </member>
    <member name="M:Sandbox.Audio.PerChannel`1.Get(Sandbox.Audio.AudioChannel)">
      <summary>
            Get the value in a channel
            </summary>
    </member>
    <member name="M:Sandbox.Audio.PerChannel`1.Set(Sandbox.Audio.AudioChannel,`0)">
      <summary>
            Set the value in a channel
            </summary>
    </member>
    <member name="T:Sandbox.Audio.HighPassProcessor">
      <summary>
            Just a test - don't count on this sticking around
            </summary>
    </member>
    <member name="P:Sandbox.Audio.HighPassProcessor.Cutoff">
      <summary>
            Cutoff frequency of the high-pass filter (0 to 1, where 1 is Nyquist frequency).
            </summary>
    </member>
    <member name="M:Sandbox.Audio.HighPassProcessor.ProcessSingleChannel(Sandbox.Audio.AudioChannel,System.Span{System.Single})">
      <summary>
            Processes each channel individually using a simple one-pole high-pass filter.
            </summary>
    </member>
    <member name="T:Sandbox.Audio.LowPassProcessor">
      <summary>
            Just a test - don't count on this sticking around
            </summary>
    </member>
    <member name="P:Sandbox.Audio.LowPassProcessor.Cutoff">
      <summary>
            Cutoff frequency for the low-pass filter (normalized 0 to 1).
            </summary>
    </member>
    <member name="M:Sandbox.Audio.LowPassProcessor.ProcessSingleChannel(Sandbox.Audio.AudioChannel,System.Span{System.Single})">
      <summary>
            Processes a single audio channel with a low-pass filter.
            </summary>
    </member>
    <member name="M:Sandbox.Audio.DirectSource.Snap">
      <summary>
            Stop any lerping and jump straight to the target occlusion
            </summary>
    </member>
    <member name="M:Sandbox.Audio.DirectSource.ComputeOcclusion(Vector3,Vector3,System.Single,Sandbox.Audio.Mixer)">
      <summary>
            Compute how occluded a sound is. Returns 0 if fully occluded, 1 if not occluded
            </summary>
    </member>
    <member name="T:Sandbox.Audio.SteamAudio">
      <summary>
            Static global SteamAudio manager
            </summary>
    </member>
    <member name="T:Sandbox.Audio.SteamAudioSource">
      <summary>
            A source for the "direct" group of effects. This gets added to the SteamAudio scene and
            is simulated for things like occlusion.
            </summary>
    </member>
    <member name="M:Sandbox.Audio.SteamAudioSource.ApplyDirectMix(Transform@,Sandbox.Audio.MultiChannelBuffer,Sandbox.Audio.MultiChannelBuffer,System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Buffers should be mono in, mono out
            </summary>
    </member>
    <member name="M:Sandbox.Audio.SteamAudioSource.ApplyBinauralMix(Vector3,System.Single,Sandbox.Audio.MultiChannelBuffer,Sandbox.Audio.MultiChannelBuffer)">
      <summary>
            Buffers should be mono in, stereo out
            </summary>
    </member>
    <member name="M:Sandbox.Audio.SteamAudioSource.UpdateFrom(Sandbox.SoundHandle)">
      <summary>
            Called by the sound handle at the appropriate times to update the native source
            </summary>
    </member>
    <member name="T:Sandbox.Sound">
      <summary>
            Single source for creating sounds
            </summary>
    </member>
    <member name="P:Sandbox.Sound.MasterVolume">
      <summary>
            The user's preference for their field of view
            </summary>
    </member>
    <member name="M:Sandbox.Sound.Preload(System.String)">
      <summary>
            Precaches sound files associated with given sound event by name.
            This helps avoid stutters on first load of each sound file.
            </summary>
    </member>
    <member name="P:Sandbox.Sound.DspNames">
      <summary>
            Get a list of available DSP names
            </summary>
    </member>
    <member name="M:Sandbox.Sound.UncompressVoiceData(System.Byte[],System.Action{System.Memory{System.Int16}})">
      <summary>
            Uncompress the voice data
            </summary>
    </member>
    <member name="P:Sandbox.Sound.VoiceSampleRate">
      <summary>
            The sample rate for voice data
            </summary>
    </member>
    <member name="M:Sandbox.Sound.Play(Sandbox.SoundEvent,Vector3)">
      <summary>
            Play a sound and set its position
            </summary>
    </member>
    <member name="M:Sandbox.Sound.Play(System.String,Vector3)">
      <summary>
            Play a sound and set its position
            </summary>
    </member>
    <member name="M:Sandbox.Sound.Play(System.String,Sandbox.Audio.Mixer)">
      <summary>
            Play a sound and set its mixer
            </summary>
    </member>
    <member name="T:Sandbox.SoundHandle">
      <summary>
            A handle to a sound that is currently playing. You can use this to control the sound's position, volume, pitch etc.
            </summary>
    </member>
    <member name="F:Sandbox.SoundHandle._CreatedTime">
      <summary>
            RealTime that this sound was created
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.Empty">
      <summary>
            An empty, do nothing sound, that we can return to avoid NREs
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.Position">
      <summary>
            Position of the sound.
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.Rotation">
      <summary>
            The direction the sound is facing
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.Transform">
      <summary>
            This sound's transform
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.Volume">
      <summary>
            Volume of the sound.
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.Name">
      <summary>
            A debug name to help identify the sound
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.SpacialBlend">
      <summary>
            How 3d the sound should be. 0 means no 3d, 1 means fully
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.Distance">
      <summary>
            How many units the sound can be heard from.
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.Falloff">
      <summary>
            The falloff curve for the sound.
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.Fadeout">
      <summary>
            The fadeout curve for when the sound stops.
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.Pitch">
      <summary>
            Pitch of the sound.
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.IsPlaying">
      <summary>
            Whether the sound is currently playing or not.
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.Paused">
      <summary>
            Whether the sound is currently paused or not.
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.Finished">
      <summary>
            Sound is done
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.Reflections">
      <summary>
            Enable the sound reflecting off surfaces
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.Occlusion">
      <summary>
            Allow this sound to be occluded by geometry etc
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.OcclusionRadius">
      <summary>
            The radius of this sound's occlusion, allow for partial occlusion
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.DistanceAttenuation">
      <summary>
            Should the sound fade out over distance
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.AirAbsorption">
      <summary>
            Should the sound get absorbed by air, so it sounds different at distance
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.Transmission">
      <summary>
            Should the sound transmit through walls, doors etc
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.TargetMixer">
      <summary>
            Which mixer do we want to write to
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.SampleRate">
      <summary>
            How many samples per second?
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.TimeUntilFinished">
      <summary>
            Keep playing silently for a second or two, to finish reverb effect
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.TimeUntilFaded">
      <summary>
            Keep playing until faded out
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.IsFading">
      <summary>
            Have we started fading out?
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.IsStopped">
      <summary>
            True if the sound has been stopped
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.ListenLocal">
      <summary>
            Place the listener at 0,0,0 facing 1,0,0.
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.Loopback">
      <summary>
            If true, then this sound won't be played unless voice_loopback is 1. The assumption is that it's the 
            local user's voice. Amplitude and visme data will still be available!
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.Amplitude">
      <summary>
            Measure of audio loudness.
            </summary>
    </member>
    <member name="M:Sandbox.SoundHandle.WantsDefaultMixer">
      <summary>
            Return true if this has no mixer specified, so will use the default mixer
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.SoundHandle.IsTargettingMixer(Sandbox.Audio.Mixer)">
      <summary>
            Return true if we want to play on this mixer. Will return true if we have no
            mixer specified, and the provided mixer is the default.
            </summary>
    </member>
    <member name="M:Sandbox.SoundHandle.TickInternal">
      <summary>
            This is called on the main thread for all active voices
            </summary>
    </member>
    <member name="M:Sandbox.SoundHandle.Update">
      <summary>
            Called to push changes to a sound immediately, rather than waiting for the next tick.
            You should call this if you make changes to a sound.
            </summary>
    </member>
    <member name="M:Sandbox.SoundHandle.OnActive">
      <summary>
            Before we're added to the active list, we need to get some stuff straight
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.FollowParent">
      <summary>
            Update our position every frame relative to our parent
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.LocalTransform">
      <summary>
            If we're following a parent, our position will be this relative to them.
            </summary>
    </member>
    <member name="M:Sandbox.SoundHandle.SetParent(Sandbox.ISoundParent)">
      <summary>
            Called in extension method to allow following of GameObject
            </summary>
    </member>
    <member name="M:Sandbox.SoundHandle.ClearParent">
      <summary>
            Clear our parent - stop following
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.LipSync">
      <summary>
            Access lipsync processing.
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.LipSyncAccessor.Visemes">
      <summary>
            A list of 15 lipsync viseme weights. Requires <see cref="P:Sandbox.SoundHandle.LipSyncAccessor.Enabled" /> to be true.
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.LipSyncAccessor.FrameNumber">
      <summary>
            Count from start of recognition.
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.LipSyncAccessor.FrameDelay">
      <summary>
            Frame delay in milliseconds.
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.LipSyncAccessor.LaughterScore">
      <summary>
            Laughter score for the current audio frame.
            </summary>
    </member>
    <member name="P:Sandbox.SoundHandle.LipSyncAccessor.Enabled">
      <summary>
            Enables lipsync processing.
            </summary>
    </member>
    <member name="P:Sandbox.SoundStream.SampleRate">
      <summary>
            Number of samples per second, as set during its creation.
            </summary>
    </member>
    <member name="P:Sandbox.SoundStream.Channels">
      <summary>
            Number of audio channels, as set during its creation.
            </summary>
    </member>
    <member name="M:Sandbox.SoundStream.Play(System.Single,System.Single)">
      <summary>
            Play sound of the stream.
            </summary>
    </member>
    <member name="M:Sandbox.SoundStream.Play(System.Single,System.Single,System.Single)">
      <summary>
            Play sound of the stream.
            </summary>
    </member>
    <member name="T:Sandbox.Speech.SpeechRecognitionResult">
      <summary>
            A result from speech recognition.
            </summary>
    </member>
    <member name="P:Sandbox.Speech.SpeechRecognitionResult.Confidence">
      <summary>
            From 0-1 how confident are we that this is the correct result?
            </summary>
    </member>
    <member name="P:Sandbox.Speech.SpeechRecognitionResult.Text">
      <summary>
            The text result from speech recognition.
            </summary>
    </member>
    <member name="P:Sandbox.Speech.SpeechRecognitionResult.Success">
      <summary>
            Did we successfully find a match?
            </summary>
    </member>
    <member name="T:Sandbox.Speech.Recognition.OnSpeechResult">
      <summary>
            Called when we have a result from speech recognition.
            </summary>
      <param name="result" />
    </member>
    <member name="P:Sandbox.Speech.Recognition.IsListening">
      <summary>
            Whether or not we are currently listening for speech.
            </summary>
    </member>
    <member name="P:Sandbox.Speech.Recognition.IsSupported">
      <summary>
            Whether or not speech recognition is supported and a language is available.
            </summary>
    </member>
    <member name="M:Sandbox.Speech.Recognition.Start(Sandbox.Speech.Recognition.OnSpeechResult,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Start listening for speech to recognize as text. When speech has been recognized the callback
            will be invoked, the callback will also be invoked if recognition fails.
            </summary>
      <param name="callback">
            A callback that will be invoked when recognition has finished.
            </param>
      <param name="choices">
            An array of possible choices. If specified, the closest match will be chosen and passed to
            the callback.
            </param>
    </member>
    <member name="M:Sandbox.Speech.Recognition.Stop">
      <summary>
            Stop any active listening for speech.
            </summary>
    </member>
    <member name="T:Sandbox.Speech.Synthesizer">
      <summary>
            A speech synthesis stream. Lets you write text into speech and output it to a <see cref="T:Sandbox.SoundHandle" />.
            </summary>
    </member>
    <member name="P:Sandbox.Speech.Synthesizer.OnVisemeReachedEvent">
      <summary>
            Called by SpeechSynthesizer to populate viseme data.
            </summary>
    </member>
    <member name="P:Sandbox.Speech.Synthesizer.InstalledVoices">
      <summary>
            Gets a list of currently installed voices on the user's system.
            </summary>
    </member>
    <member name="P:Sandbox.Speech.Synthesizer.CurrentVoice">
      <summary>
            Gets the current voice being used by <see cref="F:Sandbox.Speech.Synthesizer.SpeechSynthesizer" />.
            </summary>
    </member>
    <member name="M:Sandbox.Speech.Synthesizer.TrySetVoice(System.String)">
      <summary>
            Tries to set the voice to a matching voice name installed on the user's system.
            </summary>
      <param name="voiceName" />
      <returns />
    </member>
    <member name="M:Sandbox.Speech.Synthesizer.TrySetVoice(System.String,System.String)">
      <summary>
            Tries to set the voice matching gender and age criteria.
            </summary>
      <param name="gender" />
      <param name="age" />
      <returns />
    </member>
    <member name="M:Sandbox.Speech.Synthesizer.WithText(System.String)">
      <summary>
            Adds some text to the speech.
            </summary>
      <param name="input" />
      <returns />
    </member>
    <member name="M:Sandbox.Speech.Synthesizer.OnVisemeReached(System.Action{System.Int32,System.TimeSpan})">
      <summary>
            Registers an action to fetch all viseme data.
            </summary>
      <param name="action" />
      <returns />
    </member>
    <member name="M:Sandbox.Speech.Synthesizer.WithRate(System.Int32)">
      <summary>
            Sets the playback rate of the synthesizer.
            </summary>
      <param name="rate" />
      <returns />
    </member>
    <member name="M:Sandbox.Speech.Synthesizer.WithBreak">
      <summary>
            Adds a break to the speech.
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.Speech.Synthesizer.Play">
      <summary>
            Takes info from <see cref="F:Sandbox.Speech.Synthesizer.Builder" /> and creates a <see cref="T:System.Speech.Synthesis.SpeechSynthesizer" />, outputting to a stream object.
            Using <see cref="T:Sandbox.Speech.Synthesizer.AudioStreamHelpers" /> we then read all the PCM samples, and write it to a SoundStream.
            This means it'll work like any other sound.
            </summary>
      <returns />
    </member>
    <member name="T:Sandbox.Speech.Synthesizer.AudioStreamHelpers">
      <summary>
            A collection of helper methods to help read PCM samples. Taken mostly from https://github.com/Facepunch/sbox-arcade/
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Bootstrap.VersionSha">
      <summary>
            The github SHA of the current build
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Bootstrap.PreInit(CMaterialSystem2AppSystemDict)">
      <summary>
            Called before anything else. This should set up any low level stuff that
            might be relied on if static functions are called.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Bootstrap.EnvironmentExit(System.Int32)">
      <summary>
            Let's native exit the C# app so AppDomain.ProcessExit gets called
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Bootstrap.TaskScheduler_UnobservedTaskException(System.Object,System.Threading.Tasks.UnobservedTaskExceptionEventArgs)">
      <summary>
            Called on exceptions from a task (delayed, because it'll only get called when the exception gets collected)
            TODO: Move this somewhere else
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Bootstrap.Init">
      <summary>
            Called to initialize the engine.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Bootstrap.LoadingFinished">
      <summary>
            Should be called when startup has finished.
            If we have a client, this is when the menu is first entered.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.IBaseDll.OwnsAssembly(System.Reflection.Assembly)">
      <summary>
            Return true if this assembly is a part of this context
            </summary>
    </member>
    <member name="M:Sandbox.Engine.IGameInstanceDll.Disconnect">
      <summary>
            Called when the "disconnect" command is ran.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.IGameInstanceDll.CloseGame">
      <summary>
            Closes the current GameInstance immediately
            </summary>
    </member>
    <member name="M:Sandbox.Engine.IGameInstanceDll.TryGetReplicatedVarValue(System.String,System.String@)">
      <summary>
            Get the replicated var value from the host
            </summary>
    </member>
    <member name="F:Sandbox.Engine.GameLoadingFlags.Remote">
      <summary>
            Set if we're loading a game as a result of joining a server
            </summary>
    </member>
    <member name="F:Sandbox.Engine.GameLoadingFlags.Host">
      <summary>
            Set if we're the hosting as the result of starting our own server
            </summary>
    </member>
    <member name="F:Sandbox.Engine.GameLoadingFlags.Reload">
      <summary>
            Set if we want to reload the game, even if it's already loaded
            </summary>
    </member>
    <member name="F:Sandbox.Engine.GameLoadingFlags.Developer">
      <summary>
            Set if this is a developer session. It started from an editor session and as such we shouldn't load
            assemblies from the package, they should be loaded from the Network Tables instead.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputContext.Name">
      <summary>
            The name of this context, for debugging purposes
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputContext.MouseCursor">
      <summary>
            What mouse cursor does this context want to show?
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputContext.MouseState">
      <summary>
            What kind of mouse interaction is this context interested in right now
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputContext.MouseCapture">
      <summary>
            Mouse is UI mode but wants to use the mouse capture/delta mode
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputContext.KeyboardState">
      <summary>
            What kind of keyboard interaction is this context interested in right now
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputContext.OnMouseMotion">
      <summary>
            Mouse moved in game mode
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputContext.OnMouseMoved">
      <summary>
            Mouse moved in UI mode
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputContext.OnGameButton">
      <summary>
            A button event to be sent to the game
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputContext.OnEscapeButton">
      <summary>
            The escape button has been pressed
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputContext.TrappingKeys">
      <summary>
            When true we've called StartTrapping and are waiting for the user to release keys
            </summary>
    </member>
    <member name="M:Sandbox.Engine.InputContext.StartTrapping(System.Action{System.String[]})">
      <summary>
            Start trapping keys. When the user releases all keys the callback will be called
            with a list of buttons that were pressed during the trap.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.InputContext.EndTrapping">
      <summary>
            Called when a key is released if we're trapping keys.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.InputContext.In_Escape">
      <summary>
            Special handling for the escape button. Return false if we didn't use it.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.InputContext.IN_ButtonReleased(NativeEngine.ButtonCode,Sandbox.KeyboardModifiers)">
      <summary>
            This is called even if the context doesn't have focus.
            It's just a place to unpress buttons, if they're down.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.InputContext.IsReservedButton(NativeEngine.ButtonCode)">
      <summary>
            Is this a reserved button? This means developers can not detect these keys as up or down.
            </summary>
      <param name="button" />
      <returns />
    </member>
    <member name="F:Sandbox.Engine.InputContext.InputState.Ignore">
      <summary>
            Doesn't want it, pass down to next context
            </summary>
    </member>
    <member name="F:Sandbox.Engine.InputContext.InputState.UI">
      <summary>
            Interacting with UI
            </summary>
    </member>
    <member name="F:Sandbox.Engine.InputContext.InputState.Game">
      <summary>
            Interacting with the game
            </summary>
    </member>
    <member name="M:Sandbox.Engine.IToolsDll.RegisterHandle(System.IntPtr,System.UInt32)">
      <summary>
            Registers exclusive Sandbox.Tools <see cref="T:Sandbox.IHandle" /> types
            </summary>
    </member>
    <member name="M:Sandbox.Engine.IToolsDll.LoadProject">
      <summary>
            Load the startup project for the first time
            </summary>
    </member>
    <member name="P:Sandbox.Engine.IToolsDll.IsGameViewVisible">
      <summary>
            Is the game view visible, or is it in a tab in the background?
            </summary>
    </member>
    <member name="M:Sandbox.Engine.IToolsDll.OnInitializeHost">
      <summary>
            Called after the host network system is initialised, used to add additional package references etc. to dev servers 
            </summary>
    </member>
    <member name="T:Sandbox.Engine.SandboxedLoadContext">
      <summary>
            A LoadContext holds a bunch of instanced assemblies. These assemblies and the types within
            are separate from each other. This means we can load two Sandbox.Event dlls and the globals
            will be different in both. This is good for different realms of addons where we want them to
            all be separate.
            </summary>
    </member>
    <member name="T:Sandbox.Engine.Input">
      <summary>
            Temporary housing for common inputs
            Games that don't define any input actions will get a bunch of default actions given to them
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Input.GetKeyWithBinding(System.String)">
      <summary>
            Returns the name of a key that is bound to this value
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Input.GetBindingForButton(System.String)">
      <summary>
            Returns the binding for this key
            </summary>
    </member>
    <member name="T:Sandbox.Engine.BindCollection">
      <summary>
            
            A collection of action binds. 
            
             BindCollection
               - Action: attack1
                 - Slot0: mouse1
               - Action: selectall
                 - Slot0: ctrl + a
                 
            The bind collection can be saved and loaded from disk via the BindSaveConfig class.
            
            The bind collection can have a base collection which it will fall back to if it contains
            the same binds. This allows us to have a "common" collection which can be shared between
            all games, but can also let the games + users to override those binds if they choose.
            
            </summary>
    </member>
    <member name="P:Sandbox.Engine.BindCollection.Base">
      <summary>
            The base collection. Game binds have this set to the common binds.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.BindCollection.CollectionName">
      <summary>
            Will be either "common" or the ident of the current game.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.BindCollection.ConfigPath">
      <summary>
            The location of the config file to load from in EngineFileSystem.Config
            </summary>
    </member>
    <member name="F:Sandbox.Engine.BindCollection.Actions">
      <summary>
            The actual collection of binds.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.BindCollection.#ctor(System.String)">
      <summary>
            Creates a collection and tries to load it from disk.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.BindCollection.FillDefaultCommonInputs">
      <summary>
            If we're the common collection and have no binds (because we haven't
            been able to load a customized config from disk) then we'll fill in
            the defaults based on Input.CommonInputs.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.BindCollection.GetBind(System.String,System.Boolean)">
      <summary>
            Get the bind, create if it doesn't exist
            </summary>
    </member>
    <member name="M:Sandbox.Engine.BindCollection.Set(System.String,System.Int32,System.String)">
      <summary>
            Set the bind value for this action. This will overwrite what's in this slot.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.BindCollection.Get(System.String,System.Int32)">
      <summary>
            Get the bind value at this slot
            </summary>
    </member>
    <member name="M:Sandbox.Engine.BindCollection.SaveToDisk">
      <summary>
            Save the collection to disk
            </summary>
    </member>
    <member name="M:Sandbox.Engine.BindCollection.ResetToDefaults">
      <summary>
            Reset the collection to the default values.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.BindCollection.EnumerateWithButton(System.String)">
      <summary>
            Enumerate all actions that contain this button
            </summary>
    </member>
    <member name="M:Sandbox.Engine.BindCollection.UpdateActions(System.Collections.Generic.List{Sandbox.InputAction})">
      <summary>
            The action list has changed, we just got the config from the server.
            Here we'll clear the actions, add all of the defaults from the new config
            and then load the user config if it exists.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.BindCollection.ActionBind.IsCommon">
      <summary>
            If this is set then we want to read the value from the base collection
            </summary>
    </member>
    <member name="T:Sandbox.Engine.BindSaveConfig">
      <summary>
            A struct which is serialized/deserialized to save binds to a file (in a more readable format)
            </summary>
    </member>
    <member name="P:Sandbox.Engine.BindSaveConfig.Schema">
      <summary>
            To allow us to cater for changes in schema
            </summary>
    </member>
    <member name="P:Sandbox.Engine.BindSaveConfig.Binds">
      <summary>
            A list of strings that describe the binds
                "jump": "space;m",
            	"run": "shift",
            	"walk": "alt",
            </summary>
    </member>
    <member name="M:Sandbox.Engine.BindSaveConfig.Load(System.String,Sandbox.Engine.BindCollection)">
      <summary>
            Load a serialized collection from disk
            </summary>
    </member>
    <member name="M:Sandbox.Engine.BindSaveConfig.Save(System.String,Sandbox.Engine.BindCollection)">
      <summary>
            Save a serialized collection to disk
            </summary>
    </member>
    <member name="M:Sandbox.Engine.InputBinds.FindCollection(System.String)">
      <summary>
            Find a bind collection by name. The name is generally the ident of the current game.
            We'll try to load the binds from /config/input/*.json - if we fail then we'll serve
            the default.
            </summary>
    </member>
    <member name="T:Sandbox.Engine.InputRouter">
      <summary>
            This is where input is sent to from the engine. This is the first place input is routed to.
            From here it tries to route it to the menu, game menu and client - in that order. That should
            really be abstracted out though, so we can use this properly in Standalone.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputRouter.MouseCursorVisible">
      <summary>
            True if the cursor is visible
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputRouter.MouseCursorPosition">
      <summary>
            The mouse cursor position. Or the last position if it's now invisible.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputRouter.MouseCursorDelta">
      <summary>
            The mouse cursor delta
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputRouter.KeyboardFocusPanel">
      <summary>
            The panel we're keyboard focusing on
            </summary>
    </member>
    <member name="F:Sandbox.Engine.InputRouter.mouseCapturePosition">
      <summary>
            The position in which we entered capture/relative mode
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputRouter.EscapeIsDown">
      <summary>
            True if an "exit game" button is pressed, escape on keyboard
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputRouter.EscapeWasPressed">
      <summary>
            The escape button was pressed this frame. 
            The game is allowed to consume this. Then it will go to the menu.
            This is distinct from EscapeIsDown, because that is used to close the game when held down.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputRouter.TimeSinceEscapePressed">
      <summary>
            Time since escape was pressed
            </summary>
    </member>
    <member name="F:Sandbox.Engine.InputRouter.PressedButtons">
      <summary>
            Buttons that are currently pressed
            </summary>
    </member>
    <member name="F:Sandbox.Engine.InputRouter.PressedControllerButtons">
      <summary>
            Controller buttons that are currently pressed
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputRouter.EscapeTime">
      <summary>
            Returns the number of seconds escape has been held down
            </summary>
    </member>
    <member name="P:Sandbox.Engine.InputRouter.Contexts">
      <summary>
            Return the input contexts of each context, in order of priority
            </summary>
    </member>
    <member name="M:Sandbox.Engine.InputRouter.SetCursorPosition(Sandbox.Engine.InputContext,Vector2)">
      <summary>
            An input context wants to set the cursor position
            </summary>
    </member>
    <member name="M:Sandbox.Engine.InputRouter.IsButtonDown(NativeEngine.ButtonCode)">
      <summary>
            Return true if button is pressed
            </summary>
    </member>
    <member name="M:Sandbox.Engine.InputRouter.SetButtonState(NativeEngine.ButtonCode,System.Boolean)">
      <summary>
            Return true if button is pressed
            </summary>
    </member>
    <member name="M:Sandbox.Engine.InputRouter.IsButtonDown(Sandbox.GamepadCode)">
      <summary>
            Return true if button is pressed
            </summary>
    </member>
    <member name="M:Sandbox.Engine.InputRouter.SetButtonState(Sandbox.GamepadCode,System.Boolean)">
      <summary>
            Return true if button is pressed
            </summary>
    </member>
    <member name="M:Sandbox.Engine.InputRouter.OnConsoleCommand(System.String)">
      <summary>
            A console command from the engine.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.InputRouter.OnMouseMotion(System.Int32,System.Int32)">
      <summary>
            Cursor is hidden and restricted to window (game mode) but the mouse has been moved
            </summary>
    </member>
    <member name="M:Sandbox.Engine.InputRouter.OnMousePositionChange(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Cursor is visible and mouse is being moved
            </summary>
    </member>
    <member name="M:Sandbox.Engine.InputRouter.OnEscapePressed(System.Boolean)">
      <summary>
            The escape, or start button has been pressed
            </summary>
    </member>
    <member name="M:Sandbox.Engine.InputRouter.EngineToModifier(System.Int32)">
      <summary>
            Convert engine (IE_ShiftPressed etc) to our KeyboardModifiers enum
            </summary>
    </member>
    <member name="T:Sandbox.Engine.WebSocket">
      <summary>
            A WebSocket client for connecting to external services.
            </summary>
      <remarks>
            Events handlers will be called on the synchronization context that <see cref="M:Sandbox.Engine.WebSocket.Connect(System.String,System.Threading.CancellationToken)" /> was called on.
            </remarks>
    </member>
    <member name="T:Sandbox.Engine.WebSocket.MessageReceivedHandler">
      <summary>
            Event handler which processes text messages from the WebSocket service.
            </summary>
      <param name="message">The message text that was received.</param>
    </member>
    <member name="T:Sandbox.Engine.WebSocket.DataReceivedHandler">
      <summary>
            Event handler which processes binary messages from the WebSocket service.
            </summary>
      <param name="data">The binary message data that was received.</param>
    </member>
    <member name="T:Sandbox.Engine.WebSocket.DisconnectedHandler">
      <summary>
            Event handler which fires when the WebSocket disconnects from the server.
            </summary>
      <param name="status">The close status code from the server, or 0 if there was none. See known values here: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent</param>
      <param name="reason">The reason string for closing the connection. This may not be populated, may be from the server, or may be a client exception message.</param>
    </member>
    <member name="P:Sandbox.Engine.WebSocket.IsConnected">
      <summary>
            Returns true as long as a WebSocket connection is established.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.WebSocket.SubProtocol">
      <summary>
            Get the sub-protocol that was negotiated during the opening handshake.
            </summary>
    </member>
    <member name="E:Sandbox.Engine.WebSocket.OnMessageReceived">
      <summary>
            Event which fires when a text message is received from the server.
            </summary>
    </member>
    <member name="E:Sandbox.Engine.WebSocket.OnDataReceived">
      <summary>
            Event which fires when a binary message is received from the server.
            </summary>
    </member>
    <member name="E:Sandbox.Engine.WebSocket.OnDisconnected">
      <summary>
            Event which fires when the connection to the WebSocket service is lost, for any reason.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.WebSocket.#ctor(System.Int32)">
      <summary>
            Initialized a new WebSocket client.
            </summary>
      <param name="maxMessageSize">The maximum message size to allow from the server, in bytes. Default 64 KiB.</param>
    </member>
    <member name="M:Sandbox.Engine.WebSocket.Dispose">
      <summary>
            Cleans up resources used by the WebSocket client. This will also immediately close the connection if it is currently open.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.WebSocket.AddSubProtocol(System.String)">
      <summary>
            Add a sub-protocol to be negotiated during the WebSocket connection handshake.
            </summary>
      <param name="protocol" />
    </member>
    <member name="M:Sandbox.Engine.WebSocket.Connect(System.String,System.Threading.CancellationToken)">
      <summary>
            Establishes a connection to an external WebSocket service.
            </summary>
      <param name="websocketUri">The WebSocket URI to connect to. For example, "ws://hostname.local:1280/" for unencrypted WebSocket or "wss://hostname.local:1281/" for encrypted.</param>
      <param name="ct">A <see cref="T:System.Threading.CancellationToken" /> which allows the connection attempt to be aborted if necessary.</param>
      <returns>A <see cref="T:System.Threading.Tasks.Task" /> which completes when the connection is established, or throws if it failed to connect.</returns>
    </member>
    <member name="M:Sandbox.Engine.WebSocket.Send(System.String)">
      <summary>
            Sends a text message to the WebSocket server.
            </summary>
      <param name="message">The message text to send. Must not be null.</param>
      <returns>A <see cref="T:System.Threading.Tasks.ValueTask" /> which completes when the message was queued to be sent.</returns>
    </member>
    <member name="M:Sandbox.Engine.WebSocket.Send(System.Byte[])">
      <summary>
            Sends a binary message to the WebSocket server.
            </summary>
      <remarks>
            The <see cref="M:Sandbox.Engine.WebSocket.Send(System.ArraySegment{System.Byte})" /> and <see cref="M:Sandbox.Engine.WebSocket.Send(System.Span{System.Byte})" /> overloads allow sending subsections of byte arrays.
            </remarks>
      <param name="data">The message data to send. Must not be null.</param>
      <returns>A <see cref="T:System.Threading.Tasks.ValueTask" /> which completes when the message was queued to be sent.</returns>
    </member>
    <member name="M:Sandbox.Engine.WebSocket.Send(System.ArraySegment{System.Byte})">
      <summary>
            Sends a binary message to the WebSocket server.
            </summary>
      <param name="data">The message data to send. Must not be null.</param>
      <returns>A <see cref="T:System.Threading.Tasks.ValueTask" /> which completes when the message was queued to be sent.</returns>
    </member>
    <member name="M:Sandbox.Engine.WebSocket.Send(System.Span{System.Byte})">
      <summary>
            Sends a binary message to the WebSocket server.
            </summary>
      <param name="data">The message data to send.</param>
      <returns>A <see cref="T:System.Threading.Tasks.ValueTask" /> which completes when the message was queued to be sent.</returns>
    </member>
    <member name="T:Sandbox.Engine.Protocol">
      <summary>
            A centralized place to access the protocols
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Protocol.Api">
      <summary>
            We cannot play packages with an Api version higher than this.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Protocol.Network">
      <summary>
            We cannot talk to servers or clients with a network protocol different to this.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Settings.RenderSettings.ApplySettingsForBenchmarks">
      <summary>
            We want benchmarks to have all similar settings. Set them here.
            The only fluctuations we should see are resolution and hardware.
            </summary>
    </member>
    <member name="T:Sandbox.Engine.Shaders.CompiledCombo">
      <summary>
            The results of compiling a single combo
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Shaders.ProgramSource.Compile(Sandbox.Engine.Shaders.ShaderCompileOptions,Sandbox.Shader,System.String,Sandbox.Engine.Shaders.ShaderCompile.Results,System.Threading.CancellationToken)">
      <summary>
            Compile a single program on this shader
            </summary>
    </member>
    <member name="T:Sandbox.Engine.Shaders.ShaderCompile.Results">
      <summary>
            The results of a shader compile
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Shaders.ShaderCompile.Results.Success">
      <summary>
            True if the shader was compiled successfully. False indicates an error
            occurred. You can dig deeper into why in Programs.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Shaders.ShaderCompile.Results.Skipped">
      <summary>
            If true then this compile was skipped because nothing changed
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Shaders.ShaderCompile.Results.CompiledShader">
      <summary>
            If successful, this contains the actual resource-encoded bytes of the
            shader compile.
            </summary>
    </member>
    <member name="T:Sandbox.Engine.Shaders.ShaderCompile.Results.Program">
      <summary>
            The results of an individual shader program compile (PS, VS etc)
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Shaders.ShaderCompile.Results.Program.Name">
      <summary>
            The identifier for this program
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Shaders.ShaderCompile.Results.Program.ComboCount">
      <summary>
            How many combos had to be compiled for this program. This is Static * Dynamic.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Shaders.ShaderCompile.Results.Program.Source">
      <summary>
            The full pre-processed source for this shader
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Shaders.ShaderCompile.Results.Program.Success">
      <summary>
            True if this was compiled successfully
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Shaders.ShaderCompile.Results.Program.Output">
      <summary>
            Shader compile output, warnings and errors
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Shaders.ShaderCompile.Compile(System.String,Sandbox.Engine.Shaders.ShaderCompileOptions,System.Threading.CancellationToken)">
      <summary>
            Compile a shader from a filename ("/folder/file.shader")
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Shaders.ShaderCompile.CompileResourceFile(System.String,System.Byte[])">
      <summary>
            Convert a shader to a resource file
            </summary>
    </member>
    <member name="T:Sandbox.Engine.Shaders.ShaderCompileContext">
      <summary>
            Passed to shader compiles to provide a shared context between the compiles.
            This provides the source code to the compile, but it also gives an opportunity
            for the threaded, individual compiles, to share and cache information between them.
            </summary>
    </member>
    <member name="T:Sandbox.Engine.Shaders.ShaderCompileOptions">
      <summary>
            Options used when compiling a shader
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Shaders.ShaderCompileOptions.ConsoleOutput">
      <summary>
            Write to console. Used when running from the command line.
            </summary>
    </member>
    <member name="T:Sandbox.Engine.Shaders.ShaderSource">
      <summary>
            A source version of the shader. 
            In the future we'll use this to pre-process the shader, work out what programs it contains, and pull out all of the meta data that we need. 
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Shaders.ShaderSource.CheckOutOfDate">
      <summary>
            Updates IsOutOfDate
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Shaders.ShaderSource.ReadPrograms(System.String[])">
      <summary>
            Go through each line and find the programs that we have
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Shaders.ShaderSource.AddProgram(Sandbox.ShaderProgramType)">
      <summary>
            Add a program to compile
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Shaders.ShaderSource.Serialize(Sandbox.Shader)">
      <summary>
            Serialize to the correct format
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Streamer.Username">
      <summary>
            Your own username
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Streamer.UserId">
      <summary>
            Your own user id
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Streamer.ServiceType">
      <summary>
            The service type (ie "Twitch")
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Streamer.IsActive">
      <summary>
            Are we connected to a service
            </summary>
    </member>
    <member name="P:Sandbox.Engine.SystemInfo.ProcessorName">
      <summary>
            Human-readable product name of this system's processor.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.SystemInfo.ProcessorFrequency">
      <summary>
            The frequency of this system's processor in GHz.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.SystemInfo.ProcessorCount">
      <summary>
            The number of logical processors in this system.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.SystemInfo.TotalMemory">
      <summary>
            Total physical memory available on this machine, in bytes.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.SystemInfo.Gpu">
      <summary>
            Human-readable product name of the graphics card in this system.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.SystemInfo.GpuVersion">
      <summary>
            The version number of the graphics card driver.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.SystemInfo.GpuMemory">
      <summary>
            Total VRAM on this system's graphics card.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.SystemInfo.StorageSizeAvailable">
      <summary>
            Indicates the amount of available free space on game drive in bytes
            </summary>
    </member>
    <member name="P:Sandbox.Engine.SystemInfo.StorageSizeTotal">
      <summary>
            Gets the total size of storage space on game drive in bytes
            </summary>
    </member>
    <member name="M:Sandbox.Engine.SystemInfo.AsObject">
      <summary>
            Return as an object, for sending to backends
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Run">
      <summary>
            Run the trace and return the result. The result will return the first hit.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Ray(Vector3@,Vector3@)">
      <summary>
            Casts a ray from point A to point B.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Ray(Ray@,System.Single@)">
      <summary>
            Casts a ray from a given position and direction, up to a given distance.
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.WithTag(System.String)">
      <summary>
            Only return scene objects with this tag. Subsequent calls to this will add multiple requirements
            and they'll all have to be met (ie, the scene object will need all tags).
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.WithAllTags(System.String[])">
      <summary>
            Only return scene objects with all of these tags
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.WithAnyTags(System.String[])">
      <summary>
            Only return scene objects with any of these tags
            </summary>
    </member>
    <member name="M:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.WithoutTags(System.String[])">
      <summary>
            Only return scene objects without any of these tags
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.Distance">
      <summary>
            The distance between start and end positions.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.StartPosition">
      <summary>
            The start position of the trace
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.EndPosition">
      <summary>
            The end or hit position of the trace
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.HitPosition">
      <summary>
            The hit position of the trace
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.Fraction">
      <summary>
            A fraction [0..1] of where the trace hit between the start and the original end positions
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.Normal">
      <summary>
            The hit surface normal (direction vector)
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.Transform">
      <summary>
            The transform of the hit object (if it has one)
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.SceneObject">
      <summary>
            If we hit something associated with a sceneobject, this will be that object.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.HitTriangleUv">
      <summary>
            This is the Uv coordinate on the triangle hit. 'x' represents the distance between Vertex 0-1, 'y' represents the distance between Vertex 0-2.
            </summary>
    </member>
    <member name="P:Sandbox.Engine.Utility.RayTrace.MeshTraceRequest.Result.VertexInfluence">
      <summary>
            Given the position on the triangle hit, this vector gives the influence of each vertex on that position.
            So for example, if the Vector is [1,0,0] that means that the hit point is right on vertex 0. If it's [0.33, 0.33, 0.33] then it's 
            right in the middle of each vertex.
            </summary>
    </member>
    <member name="P:Sandbox.Command.IsSaved">
      <summary>
            Saved into config file
            </summary>
    </member>
    <member name="P:Sandbox.Command.IsProtected">
      <summary>
            If true then this cannot be interacted with via game code
            </summary>
    </member>
    <member name="P:Sandbox.Command.IsServer">
      <summary>
            If true then this command can only be run on the server
            </summary>
    </member>
    <member name="P:Sandbox.Command.IsAdmin">
      <summary>
            If true then this command can only be run by a server administrator
            </summary>
    </member>
    <member name="P:Sandbox.Command.IsReplicated">
      <summary>
            Server value is replicated to clients
            </summary>
    </member>
    <member name="P:Sandbox.Command.IsHidden">
      <summary>
            Not visible in auto complete and find
            </summary>
    </member>
    <member name="P:Sandbox.Command.IsUserInfo">
      <summary>
            Client values are sent to the server, accessible via Connection userinfo
            </summary>
    </member>
    <member name="P:Sandbox.Command.IsCheat">
      <summary>
            Can't access unless sv_cheats is 1
            </summary>
    </member>
    <member name="M:Sandbox.Command.SetVariableFromCommandLine">
      <summary>
            If we have a command line version of the command then set it and return true
            </summary>
    </member>
    <member name="M:Sandbox.ManagedCommand.GetAutoComplete(System.String)">
      <summary>
            Todo: Add support for managed commands to return shit here
            Todo: We could maybe do this in a cool way, using parameters?
                  So that for example, we could list players if it's a player etc
            </summary>
    </member>
    <member name="P:Sandbox.ConVarSystem.ConVarChanged">
      <summary>
            Called when the ConVar is changed.
            </summary>
    </member>
    <member name="M:Sandbox.ConVarSystem.AddAssembly(System.Reflection.Assembly,System.String,System.String)">
      <summary>
            Add this assembly to the console library, which will scan it for console commands and make them available.
            </summary>
    </member>
    <member name="M:Sandbox.ConVarSystem.RemoveAssembly(System.Reflection.Assembly)">
      <summary>
            Remove this assembly and its console commands.
            </summary>
    </member>
    <member name="M:Sandbox.ConVarSystem.AddCommand(Sandbox.Command)">
      <summary>
            Add this command to the library. Any existing commands named the same will be over-written.
            </summary>
    </member>
    <member name="M:Sandbox.ConVarSystem.AddConVar(Sandbox.Command)">
      <summary>
            Add this ConVar to the library. Any existing commands named the same will be over-written.
            </summary>
    </member>
    <member name="M:Sandbox.ConVarSystem.GetValue(System.String,System.String,System.Boolean)">
      <summary>
            Get a ConVar value as a string.
            </summary>
    </member>
    <member name="M:Sandbox.ConVarSystem.GetInt(System.String,System.Int32,System.Boolean)">
      <summary>
            Get a ConVar value as an integer. If the ConVar value is a boolean, this will return
            the value in its integer form.
            </summary>
    </member>
    <member name="M:Sandbox.ConVarSystem.GetFloat(System.String,System.Single,System.Boolean)">
      <summary>
            Get a ConVar value as a float.
            </summary>
    </member>
    <member name="M:Sandbox.ConVarSystem.SetValue(System.String,System.String,System.Boolean)">
      <summary>
            Try to set a ConVar. You will only be able to set variables that you have permission to set.
            </summary>
    </member>
    <member name="M:Sandbox.ConVarSystem.SetInt(System.String,System.Int32,System.Boolean)">
      <summary>
            Try to set a ConVar. You will only be able to set variables that you have permission to set.
            </summary>
    </member>
    <member name="M:Sandbox.ConVarSystem.SetFloat(System.String,System.Single,System.Boolean)">
      <summary>
            Try to set a ConVar. You will only be able to set variables that you have permission to set.
            </summary>
    </member>
    <member name="M:Sandbox.ConVarSystem.SaveAll">
      <summary>
            Save all the convars.
            </summary>
    </member>
    <member name="M:Sandbox.ConVarSystem.RunSingle(System.String)">
      <summary>
            Run a single command. [command] [args]
            </summary>
    </member>
    <member name="M:Sandbox.ConVarSystem.Run(System.String)">
      <summary>
            Run a potential string of commands, seperated by newlines or ;
            </summary>
    </member>
    <member name="M:Sandbox.ConVarSystem.OnConVarChanged``1(System.String,``0,``0)">
      <summary>
            Should be called any time a ConVar is changed. This should be called from two places, the managed side and the native side.
            Managed side comes from when the property value actually changes. The native side comes from a on change callback.
            CAVEAT: This will only get called for ConVars that use CODEGEN!
            </summary>
    </member>
    <member name="M:Sandbox.ConVarSystem.RegisterNativeVar(NativeEngine.ConVar)">
      <summary>
            Called from native as a result of calling RefreshNativeVariables
            </summary>
    </member>
    <member name="M:Sandbox.ConVarSystem.RegisterNativeCommand(NativeEngine.ConCommand)">
      <summary>
            Called from native as a result of calling RefreshNativeVariables
            </summary>
    </member>
    <member name="P:Sandbox.CookieItem.DeleteAt">
      <summary>
             If set to non 0, this key will be deleted at/after given time.
             This is useful in case you didn't open your game for more than 30 days (which is the default expiry time),
             and then you lose all your cookies because they all are expired and get deleted on launch.
            
             This way you have a 24 hour grace period.
             </summary>
    </member>
    <member name="M:Sandbox.CookieContainer.Dispose">
      <summary>
            Not public, not IDisposable. Don't want people to be able to do this from game.
            </summary>
    </member>
    <member name="M:Sandbox.CookieContainer.SetString(System.String,System.String)">
      <summary>
            Set a cookie to be stored between sessions. The cookie will expire one month
            from when it was set.
            </summary>
    </member>
    <member name="M:Sandbox.CookieContainer.GetString(System.String,System.String)">
      <summary>
            Get a stored session cookie.
            </summary>
    </member>
    <member name="M:Sandbox.CookieContainer.TryGetString(System.String,System.String@)">
      <summary>
            Get a stored session cookie.
            </summary>
    </member>
    <member name="M:Sandbox.CookieContainer.Get``1(System.String,``0)">
      <summary>
            Load JSON encodable data from cookies
            </summary>
    </member>
    <member name="M:Sandbox.CookieContainer.Set``1(System.String,``0)">
      <summary>
            Set JSON encodable object to data
            </summary>
    </member>
    <member name="M:Sandbox.CookieContainer.Remove(System.String)">
      <summary>
            Removes a cookie from the cache entirely
            </summary>
      <param name="key" />
    </member>
    <member name="T:Sandbox.Diagnostics.Allocations">
      <summary>
            Tools for diagnosing heap allocations
            </summary>
    </member>
    <member name="T:Sandbox.Diagnostics.CodeIterate">
      <summary>
            A shared private class with the explicit purpose of recording how long it takes
            between a developer saving a .cs file, and the changes being available on the client.
            This is used to diagnose and monitor the code iteration time.
            </summary>
    </member>
    <member name="T:Sandbox.Diagnostics.FrameStats">
      <summary>
            Stats returned from the engine each frame describing what was rendered, and how much of it.
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.FrameStats.ObjectsRendered">
      <summary>
            Number of objects rendered that passed the cull checks.
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.FrameStats.TrianglesRendered">
      <summary>
            Total number of triangles rendered
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.FrameStats.DrawCalls">
      <summary>
            Number of draw calls
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.FrameStats.MaterialChanges">
      <summary>
            Number of scenesystem material changes
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.FrameStats.DisplayLists">
      <summary>
            Number of display lists submitted to the GPU
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.FrameStats.SceneViewsRendered">
      <summary>
            Number of scene system views rendered
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.FrameStats.RenderTargetResolves">
      <summary>
            Number of render target resolves
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.FrameStats.ObjectsCulledByVis">
      <summary>
            Number of objects culled by static visibility (vis)
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.FrameStats.ObjectsCulledByScreenSize">
      <summary>
            Number of objects culled by screen size
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.FrameStats.ObjectsCulledByFade">
      <summary>
            Number of objects culled by distance fading
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.FrameStats.ObjectsFading">
      <summary>
            Number of objects currently being distance-faded
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.FrameStats.ShadowedLightsInView">
      <summary>
            Number of lights in view that cast shadows
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.FrameStats.UnshadowedLightsInView">
      <summary>
            Number of lights in view that don't cast shadows
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.FrameStats.ShadowMaps">
      <summary>
            Number of shadow maps rendered this frame
            </summary>
    </member>
    <member name="M:Sandbox.Diagnostics.Performance.Scope(System.String)">
      <summary>
            Record a frame state section in PerformanceStats
            </summary>
    </member>
    <member name="T:Sandbox.Diagnostics.Performance.ScopeSection">
      <summary>
            This exists to allow the creation of performance scopes without
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.PerformanceStats.FrameTime">
      <summary>
            Get the time taken, in seconds, that were required to process the previous frame.
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.PerformanceStats.GpuFrametime">
      <summary>
            Latest available GPU frametime, in ms.
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.PerformanceStats.GpuFrameNumber">
      <summary>
            Frame number of the last reported <see cref="P:Sandbox.Diagnostics.PerformanceStats.GpuFrametime" />.
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.PerformanceStats.BytesAllocated">
      <summary>
            The number of bytes that were allocated on the managed heap in the last frame.
            <remarks>This may not include allocations from threads other than the game thread.</remarks></summary>
    </member>
    <member name="P:Sandbox.Diagnostics.PerformanceStats.Gen0Collections">
      <summary>
            Number of generation 0 (fastest) garbage collections were done in the last frame.
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.PerformanceStats.Gen1Collections">
      <summary>
            Number of generation 1 (fast) garbage collections were done in the last frame.
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.PerformanceStats.Gen2Collections">
      <summary>
            Number of generation 2 (slow) garbage collections were done in the last frame.
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.PerformanceStats.GcPause">
      <summary>
            How many ticks we paused in the last frame
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.PerformanceStats.Exceptions">
      <summary>
            Number of exceptions in the last frame.
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.PerformanceStats.ApproximateProcessMemoryUsage">
      <summary>
            Approximate working set of this process.
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.PerformanceStats.LastSecond">
      <summary>
            Performance statistics over the last period, which is dictated by "perf_time" console command.
            </summary>
    </member>
    <member name="M:Sandbox.Diagnostics.PerformanceStats.Timings.GetMain">
      <summary>
            Return a list of the main top tier timings we're interested in
            </summary>
    </member>
    <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.NumFrames">
      <summary>
            How many frames have we rendered so far?
            </summary>
    </member>
    <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.NumDroppedFrames">
      <summary>
            How many frames have we missed so far?
            </summary>
    </member>
    <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.ReprojectionRatio">
      <summary>
            Number of frames that were reprojected as a fraction
            </summary>
    </member>
    <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.TotalRenderGpu">
      <summary>
            Total GPU time in milliseconds
            </summary>
    </member>
    <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.CompositorRenderGpu">
      <summary>
            Total time the compositor took on the GPU, in milliseconds
            </summary>
    </member>
    <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.CompositorRenderCpu">
      <summary>
            Total time the compositor took on the CPU, in milliseconds
            </summary>
    </member>
    <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.ResolutionScale">
      <summary>
            SteamVR supersampling scale as a fraction
            </summary>
    </member>
    <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.Resolution">
      <summary>
            Effective render resolution (base resolution multiplied by <see cref="F:Sandbox.Diagnostics.PerformanceStats.VRStats.ResolutionScale" />), per-eye
            </summary>
    </member>
    <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.InterpupillaryDistance">
      <summary>
            IPD in millimetres
            </summary>
    </member>
    <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.LeftControllerBatteryPercentage">
      <summary>
            Total left controller battery percentage (0 to 100)
            </summary>
    </member>
    <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.RightControllerBatteryPercentage">
      <summary>
            Total right controller battery percentage (0 to 100)
            </summary>
    </member>
    <member name="F:Sandbox.Diagnostics.PerformanceStats.VRStats.HeadsetBatteryPercentage">
      <summary>
            Total headset battery percentage (0 to 100)
            </summary>
    </member>
    <member name="P:Sandbox.Diagnostics.PerformanceStats.VR">
      <summary>
            Stats retrieved from the SteamVR compositor
            </summary>
    </member>
    <member name="M:Sandbox.EngineLoop.UpdateInput">
      <summary>
            Pumps the input system
            </summary>
    </member>
    <member name="M:Sandbox.EngineLoop.Exiting">
      <summary>
            Called when the application is shutting down
            </summary>
    </member>
    <member name="M:Sandbox.EngineLoop.DispatchConsoleCommand(System.String,System.String,System.Int64)">
      <summary>
            A console command has arrived, or a convar has changed
            </summary>
    </member>
    <member name="M:Sandbox.EngineLoop.DisposeAtFrameEnd(System.IDisposable)">
      <summary>
            Queue something to be disposed of after the frame has ended and everything has finished rendering.
            </summary>
    </member>
    <member name="T:Sandbox.BlendMode">
      <summary>
            Blend modes used by the UI system
            </summary>
    </member>
    <member name="F:Sandbox.SceneLayerType.Translucent">
      <summary>
            Translucent pass. We're rendering translucent objects in depth sorted order, from back to front.
            </summary>
    </member>
    <member name="F:Sandbox.SceneLayerType.Shadow">
      <summary>
            Rendering dynamic shadows
            </summary>
    </member>
    <member name="F:Sandbox.SceneLayerType.EffectsTranslucent">
      <summary>
            Translucent effects on the 1/4 texture
            </summary>
    </member>
    <member name="F:Sandbox.SceneLayerType.EffectsOpaque">
      <summary>
            Opaque effects on the 1/4 texture
            </summary>
    </member>
    <member name="F:Sandbox.SceneLayerType.DepthPrepass">
      <summary>
            Depth prepass to reduce overdraw
            </summary>
    </member>
    <member name="T:Sandbox.AssetDownloadCache">
      <summary>
            Downloadeded assets go in the ".source2/assets" folder, where they are symlinked on demand
            for use by the engine.
            </summary>
    </member>
    <member name="M:Sandbox.AssetDownloadCache.Reset">
      <summary>
            Remove all symlinks, clear the filesystem
            </summary>
    </member>
    <member name="M:Sandbox.AssetDownloadCache.StoreFile(System.String,System.UInt64,System.Byte[])">
      <summary>
            We have downloaded an asset file. Store it for reuse in the future
            </summary>
    </member>
    <member name="M:Sandbox.AssetDownloadCache.TryMountFile(System.String,System.UInt64,System.Boolean@)">
      <summary>
            Try to mount the downloaded file with this path and crc. If it doesn't exist, return false
            </summary>
    </member>
    <member name="M:Sandbox.AssetDownloadCache.CreateCacheFilename(System.String,System.UInt64)">
      <summary>
            Makes sure the directory exists, and returns the relative path to this file
            </summary>
    </member>
    <member name="M:Sandbox.AssetDownloadCache.GetAbsolutePath(System.String,System.UInt64)">
      <summary>
            Generate the absolute path for this, whether it exists or not
            </summary>
    </member>
    <member name="P:Sandbox.EngineFileSystem.LibraryContent">
      <summary>
            Content from libraries. This only exists in editor.
            </summary>
    </member>
    <member name="P:Sandbox.EngineFileSystem.Assets">
      <summary>
            For tools, maintain a list of mounted addon content paths
            </summary>
    </member>
    <member name="P:Sandbox.EngineFileSystem.Temporary">
      <summary>
            A place to write files temporarily. This is stored in memory so 
            cleaning up after yourself is a good idea (!)
            </summary>
    </member>
    <member name="P:Sandbox.EngineFileSystem.ProjectSettings">
      <summary>
            The folder holding the project's settings files
            </summary>
    </member>
    <member name="M:Sandbox.EngineFileSystem.Initialize(System.String)">
      <summary>
            Don't try to use the filesystem until you've called this!
            </summary>
    </member>
    <member name="M:Sandbox.EngineFileSystem.InitializeConfigFolder(System.String)">
      <summary>
            Setup Config parameter
            </summary>
    </member>
    <member name="M:Sandbox.EngineFileSystem.InitializeAddonsFolder(System.String)">
      <summary>
            Setup Addons parameter (there's no reason for this to exist now?)
            </summary>
    </member>
    <member name="M:Sandbox.EngineFileSystem.InitializeDownloadsFolder(System.String)">
      <summary>
            Setup Download folder
            </summary>
    </member>
    <member name="M:Sandbox.EngineFileSystem.InitializeDataFolder(System.String)">
      <summary>
            Setup Addons parameter (there's no reason for this to exist now?)
            </summary>
    </member>
    <member name="M:Sandbox.EngineFileSystem.Shutdown">
      <summary>
            Should only be called at the very death
            </summary>
    </member>
    <member name="T:Sandbox.PackageFileSystem">
      <summary>
            A filesystem that redirects a package's local paths to the actual files in a download cache
            </summary>
    </member>
    <member name="M:Sandbox.PackageFileSystem.AddFile(System.String,System.UInt64)">
      <summary>
            Add a file to this redirect system
            </summary>
    </member>
    <member name="T:Sandbox.Clothing">
      <summary>
            A piece of player model customization.
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.HumanSkinModel">
      <summary>
            Model to replace the human skin with
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.HumanSkinBodyGroups">
      <summary>
            Bodygroup on the model to choose
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.HumanSkinMaterialGroup">
      <summary>
            Bodygroup on the model to choose
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.HumanSkinTags">
      <summary>
            Allows adding tags for this skin, ie "female". This affects which alternative clothing models are used with it.
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.Title">
      <summary>
            Name of the clothing to show in UI.
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.Subtitle">
      <summary>
            A subtitle for this clothing piece.
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.Category">
      <summary>
            What kind of clothing this is?
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.ConditionalModels">
      <summary>
            A list of conditional models.
            (key) = tag(s), (value) = model
            </summary>
    </member>
    <member name="M:Sandbox.Clothing.GetModel(System.Collections.Generic.IEnumerable{Sandbox.Clothing},Sandbox.TagSet)">
      <summary>
             Tries to get the model for this current clothing. Takes into account any conditional model for other clothing.
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.SubCategory">
      <summary>
            This should be a single word to describe the subcategory, and should match any other items you want to categorize in the same bunch. The work will be tokenized so it can become localized.
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.Parent">
      <summary>
            The clothing to parent this too.  It will be displayed as a variation of its parent
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.Model">
      <summary>
            The model to bonemerge to the player when this clothing is equipped.
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.HumanAltModel">
      <summary>
            The model to bonemerge to the human player when this clothing is equipped.
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.HumanAltFemaleModel">
      <summary>
            The model to bonemerge to the human player when this clothing is equipped.
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.SkinMaterial">
      <summary>
            Replace the skin with this material
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.EyesMaterial">
      <summary>
            Replace the eyes with this material
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.MaterialGroup">
      <summary>
            Which material group of the model to use.
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.SlotsUnder">
      <summary>
            Which slots this clothing takes on "inner" layer.
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.SlotsOver">
      <summary>
            Which slots this clothing takes on "outer" layer.
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.HideBody">
      <summary>
            Which body parts of the player model should not show when this clothing is equipped.
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.SteamItemDefinitionId">
      <summary>
            The Steam Item Definition ID for this clothing item, if it's an inventory item
            </summary>
    </member>
    <member name="M:Sandbox.Clothing.HasPermissions">
      <summary>
            Can we wear this item?
            </summary>
    </member>
    <member name="M:Sandbox.Clothing.CanBeWornWith(Sandbox.Clothing)">
      <summary>
            Return true if this item of clothing can be worn with the target item, at the same time.
            </summary>
    </member>
    <member name="P:Sandbox.Clothing.Icon">
      <summary>
            Icon for this clothing piece.
            </summary>
    </member>
    <member name="M:Sandbox.Clothing.DressSceneObject(Sandbox.SceneModel,System.Collections.Generic.IEnumerable{Sandbox.Clothing})">
      <summary>
            Dress this sceneobject with the passed clothes. Return the created clothing.
            </summary>
    </member>
    <member name="M:Sandbox.Clothing.GetBodyGroups(System.Collections.Generic.IEnumerable{Sandbox.Clothing})">
      <summary>
            Return a list of bodygroups and what their value should be
            </summary>
    </member>
    <member name="T:Sandbox.ClothingContainer">
      <summary>
            Holds a collection of clothing items. Won't let you add items that aren't compatible.
            </summary>
    </member>
    <member name="P:Sandbox.ClothingContainer.ClothingEntry.Tint">
      <summary>
            Used to select a tint
            </summary>
    </member>
    <member name="P:Sandbox.ClothingContainer.Height">
      <summary>
            The avatar's height. Default is 1.
            </summary>
    </member>
    <member name="P:Sandbox.ClothingContainer.PrefersHuman">
      <summary>
            If true, this avatar prefers to use a human model when possible
            </summary>
    </member>
    <member name="F:Sandbox.ClothingContainer.Clothing">
      <summary>
            A list of clothing items the avatar is wearing
            </summary>
    </member>
    <member name="M:Sandbox.ClothingContainer.Normalize">
      <summary>
            Restrict things like Height to their sensible limits
            </summary>
    </member>
    <member name="M:Sandbox.ClothingContainer.Toggle(Sandbox.Clothing)">
      <summary>
            Add a clothing item if we don't already contain it, else remove it
            </summary>
    </member>
    <member name="M:Sandbox.ClothingContainer.Add(Sandbox.Clothing)">
      <summary>
            Add clothing item
            </summary>
    </member>
    <member name="M:Sandbox.ClothingContainer.Add(Sandbox.ClothingContainer.ClothingEntry)">
      <summary>
            Add clothing item
            </summary>
    </member>
    <member name="M:Sandbox.ClothingContainer.AddRange(System.Collections.Generic.IEnumerable{Sandbox.ClothingContainer.ClothingEntry})">
      <summary>
            Add clothing items
            </summary>
    </member>
    <member name="M:Sandbox.ClothingContainer.FindEntry(Sandbox.Clothing)">
      <summary>
            Find a clothing entry matching this clothing item
            </summary>
    </member>
    <member name="M:Sandbox.ClothingContainer.Remove(Sandbox.Clothing)">
      <summary>
            Remove clothing item
            </summary>
    </member>
    <member name="M:Sandbox.ClothingContainer.Has(Sandbox.Clothing)">
      <summary>
            Returns true if we have this clothing item
            </summary>
    </member>
    <member name="M:Sandbox.ClothingContainer.GetBodyGroups">
      <summary>
            Return a list of bodygroups and what their value should be
            </summary>
    </member>
    <member name="M:Sandbox.ClothingContainer.GetBodyGroups(System.Collections.Generic.IEnumerable{Sandbox.Clothing})">
      <summary>
            Return a list of bodygroups and what their value should be
            </summary>
    </member>
    <member name="M:Sandbox.ClothingContainer.Serialize">
      <summary>
            Serialize to Json
            </summary>
    </member>
    <member name="M:Sandbox.ClothingContainer.Deserialize(System.String)">
      <summary>
            Deserialize from Json
            </summary>
    </member>
    <member name="T:Sandbox.ClothingContainer.Entry">
      <summary>
            Used for serialization
            </summary>
    </member>
    <member name="P:Sandbox.ClothingContainer.Entry.Tint">
      <summary>
            Tint variable used to evaluate the model tint color gradient
            </summary>
    </member>
    <member name="M:Sandbox.ClothingContainer.CreateFromJson(System.String)">
      <summary>
            Create the container from json definitions
            </summary>
    </member>
    <member name="M:Sandbox.ClothingContainer.CreateFromLocalUser">
      <summary>
            Create the container from the local user's setup
            </summary>
    </member>
    <member name="T:Sandbox.WorkshopItemMetaData">
      <summary>
            Some metadata we'll pack into a workshop submission when publishing.
            </summary>
    </member>
    <member name="P:Sandbox.Friend.IsMe">
      <summary>
            Returns true if this friend is the local user
            </summary>
    </member>
    <member name="P:Sandbox.Friend.Id">
      <summary>
            The friend's Steam Id
            </summary>
    </member>
    <member name="P:Sandbox.Friend.Name">
      <summary>
            The friend's name
            </summary>
    </member>
    <member name="P:Sandbox.Friend.IsOnline">
      <summary>
            Returns true if your friend is online
            </summary>
    </member>
    <member name="P:Sandbox.Friend.IsFriend">
      <summary>
            Returns true if this user is your friend
            </summary>
    </member>
    <member name="P:Sandbox.Friend.IsAway">
      <summary>
            Returns true if your friend is away
            </summary>
    </member>
    <member name="P:Sandbox.Friend.IsBusy">
      <summary>
            Returns true if this friend is marked as busy
            </summary>
    </member>
    <member name="P:Sandbox.Friend.IsSnoozing">
      <summary>
            Returns true if this friend is marked as snoozing
            </summary>
    </member>
    <member name="M:Sandbox.Friend.GetRichPresence(System.String)">
      <summary>
            Returns a string that was possibly set by rich presence
            </summary>
    </member>
    <member name="P:Sandbox.Friend.IsPlayingThisGame">
      <summary>
            Returns true if they're playing this game
            </summary>
    </member>
    <member name="P:Sandbox.Friend.IsPlayingAGame">
      <summary>
            Returns true if they're playing any game
            </summary>
    </member>
    <member name="M:Sandbox.Friend.OpenInOverlay">
      <summary>
            Opens the Steam overlay web browser to their user profile.
            </summary>
    </member>
    <member name="M:Sandbox.Friend.OpenAddFriendOverlay">
      <summary>
            Opens the Steam overlay with a popup that allows the local Steam user to confirm whether to add this user to their Steam friends list.
            </summary>
    </member>
    <member name="P:Sandbox.Menu.LoadingProgress.Fraction">
      <summary>
            A value between 0 and 1, to show a progress bar
            </summary>
    </member>
    <member name="P:Sandbox.Menu.LoadingProgress.Mbps">
      <summary>
            The current transfer rate in Megabits per second. 0 is none.
            </summary>
    </member>
    <member name="P:Sandbox.Menu.LoadingProgress.Percent">
      <summary>
            Delta multipled by 100
            </summary>
    </member>
    <member name="P:Sandbox.Menu.LoadingProgress.TotalSize">
      <summary>
            The total size of what we're trying to download
            </summary>
    </member>
    <member name="T:Sandbox.DataModel.GameSetting">
      <summary>
            A <see cref="T:Sandbox.ConVarAttribute" /> that has been marked with <see cref="F:Sandbox.ConVarFlags.GameSetting" />
            This is stored as project metadata so we can set up a game without loading it.
            </summary>
    </member>
    <member name="M:Sandbox.DataModel.GameSetting.#ctor(System.String,System.String,System.String,System.String)">
      <summary>
            A <see cref="T:Sandbox.ConVarAttribute" /> that has been marked with <see cref="F:Sandbox.ConVarFlags.GameSetting" />
            This is stored as project metadata so we can set up a game without loading it.
            </summary>
    </member>
    <member name="T:Sandbox.DataModel.ProjectConfig">
      <summary>
            Configuration of a <see cref="T:Sandbox.Project" />.
            </summary>
    </member>
    <member name="P:Sandbox.DataModel.ProjectConfig.Directory">
      <summary>
            The directory housing this addon (TODO)
            </summary>
    </member>
    <member name="P:Sandbox.DataModel.ProjectConfig.AssetsDirectory">
      <summary>
            The directory housing this addon (TODO)
            </summary>
    </member>
    <member name="P:Sandbox.DataModel.ProjectConfig.Title">
      <summary>
            The human readable title, for example "Sandbox", "Counter-Strike"
            </summary>
    </member>
    <member name="P:Sandbox.DataModel.ProjectConfig.Type">
      <summary>
            The type of addon. Current valid values are "game"
            </summary>
    </member>
    <member name="P:Sandbox.DataModel.ProjectConfig.Org">
      <summary>
            The ident of the org that owns this addon. For example "facepunch", "valve".
            </summary>
    </member>
    <member name="P:Sandbox.DataModel.ProjectConfig.Ident">
      <summary>
            The ident of this addon. For example "sandbox", "cs" or "dm98"
            </summary>
    </member>
    <member name="P:Sandbox.DataModel.ProjectConfig.PackageType">
      <summary>
            Type of the package.
            </summary>
    </member>
    <member name="P:Sandbox.DataModel.ProjectConfig.FullIdent">
      <summary>
            Returns a combination of Org and Ident - for example "facepunch.sandbox" or "valve.cs".
            </summary>
    </member>
    <member name="P:Sandbox.DataModel.ProjectConfig.Schema">
      <summary>
            The version of the addon file. Allows us to upgrade internally.
            </summary>
    </member>
    <member name="P:Sandbox.DataModel.ProjectConfig.IncludeSourceFiles">
      <summary>
            If true then we'll include all the source files
            </summary>
    </member>
    <member name="P:Sandbox.DataModel.ProjectConfig.Resources">
      <summary>
            A list of paths in which to look for extra assets to upload with the addon. Note that compiled asset files are automatically included.
            </summary>
    </member>
    <member name="P:Sandbox.DataModel.ProjectConfig.PackageReferences">
      <summary>
            A list of packages that this package depends on. These should be installed alongside this package.
            </summary>
    </member>
    <member name="P:Sandbox.DataModel.ProjectConfig.EditorReferences">
      <summary>
            A list of packages that this package uses but there is no need to install. For example, a map package might use
            a model package - but there is no need to download that model package because any usage will organically be included
            in the manifest. However, when loading this item in the editor, it'd make sense to install these 'cloud' packages.
            </summary>
    </member>
    <member name="P:Sandbox.DataModel.ProjectConfig.Mounts">
      <summary>
            A list of mounts that are required
            </summary>
    </member>
    <member name="P:Sandbox.DataModel.ProjectConfig.DistinctPackageReferences">
      <summary>
            Contains unique elements from <see cref="P:Sandbox.DataModel.ProjectConfig.PackageReferences" />, along with any implicit package references.
            An example implicit reference is the parent package of an addon.
            </summary>
    </member>
    <member name="P:Sandbox.DataModel.ProjectConfig.IsStandaloneOnly">
      <summary>
            Whether or not this project is standalone-only, and supports disabling the whitelist, compiling with /unsafe, etc.
            </summary>
    </member>
    <member name="P:Sandbox.DataModel.ProjectConfig.Metadata">
      <summary>
            Custom key-value storage for this project.
            </summary>
    </member>
    <member name="M:Sandbox.DataModel.ProjectConfig.ToJson">
      <summary>
            Serialize the entire config to a JSON string.
            </summary>
    </member>
    <member name="M:Sandbox.DataModel.ProjectConfig.TryGetMeta``1(System.String,``0@)">
      <summary>
            Try to get a value at given key in <see cref="P:Sandbox.DataModel.ProjectConfig.Metadata" />.
            </summary>
      <typeparam name="T">Type of the value.</typeparam>
      <param name="keyname">The key to retrieve the value of.</param>
      <param name="outvalue">The value, if it was present in the metadata storage.</param>
      <returns>Whether the value was successfully retrieved.</returns>
    </member>
    <member name="M:Sandbox.DataModel.ProjectConfig.GetMetaOrDefault``1(System.String,``0)">
      <summary>
            Get the package's meta value. If it's missing or the wrong type then use the default value.
            </summary>
    </member>
    <member name="M:Sandbox.DataModel.ProjectConfig.SetMeta(System.String,System.Object)">
      <summary>
            Store custom data at given key in the <see cref="P:Sandbox.DataModel.ProjectConfig.Metadata" />.
            </summary>
      <param name="keyname">The key for the data.</param>
      <param name="outvalue">The data itself to store.</param>
      <returns>Always true.</returns>
    </member>
    <member name="T:Sandbox.IGameInstance">
      <summary>
            Todo: make internal - the only thing using ir right now is the binds system
            </summary>
    </member>
    <member name="M:Sandbox.IGameInstance.OnLoadingFinished">
      <summary>
            Called after all loading is done, right before we enter the game
            </summary>
    </member>
    <member name="P:Sandbox.IGameInstance.IsLoading">
      <summary>
            True after the game is fully loaded
            </summary>
    </member>
    <member name="P:Sandbox.Internal.IPanel.Id">
      <summary>
            The Id of the element ( id="foo" )
            </summary>
    </member>
    <member name="P:Sandbox.Internal.IPanel.SourceFile">
      <summary>
            If the panel created by razor, this is the file in which it was defined
            </summary>
    </member>
    <member name="P:Sandbox.Internal.IPanel.SourceLine">
      <summary>
            If the panel was created by razor, this is the line in which it was defined
            </summary>
    </member>
    <member name="P:Sandbox.Internal.IPanel.WantsPointerEvents">
      <summary>
            If true then this panel (or its ancestor) has pointer-events: all
            </summary>
    </member>
    <member name="M:Sandbox.Internal.IPanel.SetAbsolutePosition(Sandbox.TextFlag,Vector2,System.Single)">
      <summary>
            Set the panel's absolute position. This wouldn't be needed if we could expose the styles. Which we should
            do.
            </summary>
    </member>
    <member name="P:Sandbox.Internal.IPanel.PseudoClass">
      <summary>
            Procedural classes such as :hover and :active
            </summary>
    </member>
    <member name="P:Sandbox.Internal.IPanel.ActiveStyleBlocks">
      <summary>
            Get all style blocks active on this panel
            </summary>
    </member>
    <member name="T:Sandbox.Internal.BlockingLoopPumper">
      <summary>
            Sometimes stuff is blocking that doesn't need to be. We want to keep running the main loop
            while the function is blocking. This usually happens with Qt stuff like the drag and drop.
            This should allow the main loop to still be pumped while waiting for that blocking function.
            
            - main game loop
            while ( true )
            {
            	mainloop();
            	
            	BlockingLoopPumper.Run()
            	{
            		runBlockingFunction();
            	}
            }
            
            - somewhere else - usually Qt Timer
            BlockingLoopPumper.Pump();
            {
            	mainloop();
            }
            
            </summary>
    </member>
    <member name="P:Sandbox.Internal.BlockingLoopPumper.PendingFunction">
      <summary>
            Used to call things outside of the main frame
            </summary>
    </member>
    <member name="M:Sandbox.Internal.BlockingLoopPumper.Run(System.Action)">
      <summary>
            Called outside the main game loop.
            </summary>
      <param name="pumper">An action to call the main game loop</param>
    </member>
    <member name="M:Sandbox.Internal.BlockingLoopPumper.Pump">
      <summary>
            Should be called regularly, on the main thread. Generally this is called
            automatically by Qt in the timer (search OnQtHeartbeat).
            This should do total nothing if we're not actually in a blocking loop -  
            because loopPump will be null.
            </summary>
    </member>
    <member name="T:Sandbox.Internal.IMenuSystem">
      <summary>
            This is how the engine communicates with the menu system
            </summary>
    </member>
    <member name="M:Sandbox.Internal.IMenuSystem.Init">
      <summary>
            Called to initialize the menu system
            </summary>
    </member>
    <member name="M:Sandbox.Internal.IMenuSystem.Shutdown">
      <summary>
            Close down the menu, delete everything
            </summary>
    </member>
    <member name="M:Sandbox.Internal.IMenuSystem.Tick">
      <summary>
            Called every frame, to let the menu think
            </summary>
    </member>
    <member name="M:Sandbox.Internal.IMenuSystem.Popup(System.String,System.String,System.String)">
      <summary>
            Show a popup
            </summary>
    </member>
    <member name="M:Sandbox.Internal.IMenuSystem.Question(System.String,System.String,System.Action,System.Action)">
      <summary>
            Show a question
            </summary>
    </member>
    <member name="M:Sandbox.Internal.IMenuSystem.OnPackageClosed(Sandbox.Package)">
      <summary>
            Package closed. Add a toast asking if it was cool or not
            </summary>
    </member>
    <member name="P:Sandbox.Internal.IMenuSystem.ForceCursorVisible">
      <summary>
            True if we want to force the cursor to be visible and swallow input.
            This is used for the developer console and loading screens.
            </summary>
    </member>
    <member name="T:Sandbox.Internal.ILoadingInterface">
      <summary>
            Used to talk to the menu's loading screen.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.SceneObjectTags.GetTokens">
      <summary>
            Try to get all tags in the set.
            </summary>
    </member>
    <member name="T:Sandbox.LaunchArguments">
      <summary>
            These are arguments that were set when launching the current game.
            This is used to pre-configure the game from the menu
            </summary>
    </member>
    <member name="P:Sandbox.LaunchArguments.Map">
      <summary>
            The map to start with. It's really up to the game to use this
            </summary>
    </member>
    <member name="P:Sandbox.LaunchArguments.MaxPlayers">
      <summary>
            Preferred max players for multiplayer games. Used by games, but not enforced.
            </summary>
    </member>
    <member name="P:Sandbox.LaunchArguments.GameSettings">
      <summary>
            The game settings to apply on join. These are a list of convars.
            </summary>
    </member>
    <member name="M:Sandbox.LaunchArguments.Reset">
      <summary>
            Should be called when leaving a game to set the properties back to default. We need to be
            aware and prevent these leaking between games.
            </summary>
    </member>
    <member name="T:Sandbox.LoadingScreen">
      <summary>
            Holds metadata and raw data relating to a Saved Game.
            </summary>
    </member>
    <member name="P:Sandbox.LoadingScreen.Title">
      <summary>
            A title to show
            </summary>
    </member>
    <member name="P:Sandbox.LoadingScreen.Subtitle">
      <summary>
            A subtitle to show
            </summary>
    </member>
    <member name="P:Sandbox.LoadingScreen.Media">
      <summary>
            A URL or filepath to show as the background image.
            </summary>
    </member>
    <member name="T:Sandbox.LobbyManager">
      <summary>
            A class to orchestrate lobbies, globally.
            </summary>
    </member>
    <member name="P:Sandbox.LobbyManager.ActiveLobbies">
      <summary>
            A low level list of lobbies we're in
            </summary>
    </member>
    <member name="M:Sandbox.LobbyManager.OnLeave(System.UInt64)">
      <summary>
            Note there's not a callback for this afaik, so we call this manually
            </summary>
    </member>
    <member name="P:Sandbox.Map.PhysicsGroup">
      <summary>
            The world physics objects
            </summary>
    </member>
    <member name="P:Sandbox.Map.SceneMap">
      <summary>
            The world geometry;
            </summary>
    </member>
    <member name="T:Sandbox.MapLoader.ObjectEntry">
      <summary>
            Holds key values for the map object
            </summary>
    </member>
    <member name="M:Sandbox.MapLoader.CreateObject(Sandbox.MapLoader.ObjectEntry)">
      <summary>
            Create an object from a serialized object entry
            </summary>
    </member>
    <member name="M:Sandbox.Mounting.Directory.LoadAssemblies">
      <summary>
            Load the assemblies and collect sources. That's all.
            </summary>
    </member>
    <member name="M:Sandbox.Mounting.Directory.GetAll">
      <summary>
            Get information about all the current mounts
            </summary>
    </member>
    <member name="M:Sandbox.Mounting.Directory.Get(System.String)">
      <summary>
            Get information about all the current mounts
            </summary>
    </member>
    <member name="M:Sandbox.Mounting.Directory.SetMountState(System.String,System.Boolean)">
      <summary>
            Set mounted or not mounted. Called by user via editor.
            </summary>
    </member>
    <member name="M:Sandbox.Mounting.Directory.TryMountFilesystem(System.String)">
      <summary>
            If /mount/{x}/assets exists, add it to our filesystem
            </summary>
    </member>
    <member name="T:Sandbox.Mounting.MountInfo">
      <summary>
            Information about a single mount
            </summary>
    </member>
    <member name="P:Sandbox.Mounting.MountInfo.Ident">
      <summary>
            A short, lowercase string that will be used to uniquely identify this asset source
            </summary>
    </member>
    <member name="P:Sandbox.Mounting.MountInfo.Title">
      <summary>
            The display name of this
            </summary>
    </member>
    <member name="P:Sandbox.Mounting.MountInfo.Available">
      <summary>
            Is this source available, is this game installed? Can we mount it?
            </summary>
    </member>
    <member name="P:Sandbox.Mounting.MountInfo.Mounted">
      <summary>
            Is this active and mounted?
            </summary>
    </member>
    <member name="F:Sandbox.Navigation.NavMeshBoxAreaData.Box">
      <summary>
            Forms an OBB together with the transform
            </summary>
    </member>
    <member name="T:Sandbox.Navigation.NavMesh">
      <summary>
            Navigation Mesh - allowing AI to navigate a world
            </summary>
      <summary>
            Navigation Mesh - allowing AI to navigate a world
            </summary>
      <summary>
            Navigation Mesh - allowing AI to navigate a world
            </summary>
    </member>
    <member name="P:Sandbox.Navigation.NavMesh.IsEnabled">
      <summary>
            Determines wether the navigation mesh is enabled and should be generated
            </summary>
    </member>
    <member name="P:Sandbox.Navigation.NavMesh.IsGenerating">
      <summary>
            The navigation mesh is generating
            </summary>
    </member>
    <member name="P:Sandbox.Navigation.NavMesh.IsDirty">
      <summary>
            The navigation mesh is dirty and needs a complete rebuild
            </summary>
    </member>
    <member name="P:Sandbox.Navigation.NavMesh.IncludeStaticBodies">
      <summary>
            Should the generator include static bodies
            </summary>
    </member>
    <member name="P:Sandbox.Navigation.NavMesh.IncludeKeyframedBodies">
      <summary>
            Should the generator include keyframed bodies
            </summary>
    </member>
    <member name="P:Sandbox.Navigation.NavMesh.ExcludedBodies">
      <summary>
            Don't include these bodies in the generation
            </summary>
    </member>
    <member name="P:Sandbox.Navigation.NavMesh.IncludedBodies">
      <summary>
            If any, we'll only include bodies with this tag
            </summary>
    </member>
    <member name="P:Sandbox.Navigation.NavMesh.EditorAutoUpdate">
      <summary>
            Constantly update the navigation mesh in the editor
            </summary>
    </member>
    <member name="P:Sandbox.Navigation.NavMesh.DrawMesh">
      <summary>
            Draw the navigation mesh in the editor
            </summary>
    </member>
    <member name="P:Sandbox.Navigation.NavMesh.AgentHeight">
      <summary>
            Height of the agent
            </summary>
    </member>
    <member name="P:Sandbox.Navigation.NavMesh.AgentRadius">
      <summary>
            The radius of the agent. This will change how much gap is left on the edges of surfaces, so they don't clip into walls.
            </summary>
    </member>
    <member name="P:Sandbox.Navigation.NavMesh.AgentStepSize">
      <summary>
            The maximum height an agent can climb (step)
            </summary>
    </member>
    <member name="P:Sandbox.Navigation.NavMesh.AgentMaxSlope">
      <summary>
            The maximum slope an agent can walk up (in degrees)
            </summary>
    </member>
    <member name="F:Sandbox.Navigation.NavMesh.CellSize">
      <summary>
            The xz-plane cell size to use for fields. [Limit: &gt; 0] [Units: wu] 
            </summary>
    </member>
    <member name="F:Sandbox.Navigation.NavMesh.CellHeight">
      <summary>
            The y-axis cell size to use for fields. [Limit: &gt; 0] [Units: wu]
            </summary>
    </member>
    <member name="P:Sandbox.Navigation.NavMesh.TileSizeXYVoxels">
      <summary>
            The width/height size of tile's on the xy-plane. [Limit: &gt;= 0] [Units: vx]
            </summary>
    </member>
    <member name="M:Sandbox.Navigation.NavMesh.SetDirty">
      <summary>
            Set the navgiation a dirty, so it will rebuild next update
            </summary>
    </member>
    <member name="M:Sandbox.Navigation.NavMesh.GetRandomPoint(BBox)">
      <summary>
            Get a random point on the navmesh, within the bounding box. 
            This will return null if it can't find a point on the navmesh in a few tries. Returning false doesn't mean it's impossible, our algorithm here isn't the best.
            </summary>
    </member>
    <member name="M:Sandbox.Navigation.NavMesh.GetRandomPoint(Vector3,System.Single)">
      <summary>
            Get a random point on the navmesh, within the sphere.
            This will return null if it can't find a point on the navmesh in a few tries. Returning false doesn't mean it's impossible, our algorithm here isn't the best.
            </summary>
    </member>
    <member name="M:Sandbox.Navigation.NavMesh.Serialize">
      <summary>
            Data saved in a Scene file
            </summary>
    </member>
    <member name="M:Sandbox.Navigation.NavMesh.Deserialize(System.Text.Json.Nodes.JsonObject)">
      <summary>
            Data loaded from a Scene file
            </summary>
    </member>
    <member name="M:Sandbox.Navigation.NavMesh.GenerateTile(Sandbox.PhysicsWorld,Vector3)">
      <summary>
            Generates or regenerates the navmesh tile at the given world position.
            This function is thread safe but can only be called from the main thread.
            </summary>
      <remarks>
            While most of the generation happens in parallel, this function also requires some time on the main thread.
            If you need to update many tiles, consider spreading the updates accross multiple frames.
            </remarks>
    </member>
    <member name="M:Sandbox.Navigation.NavMesh.GenerateTiles(Sandbox.PhysicsWorld,BBox)">
      <summary>
            Generates or regenerates the navmesh tiles overlapping with the given bounds.
            This function is thread safe but can only be called from the main thread.
            </summary>
      <remarks>
            While most of the generation happens in parallel, this function also requires some time on the main thread.
            If you need to update many tiles, consider spreading the updates accross multiple frames.
            </remarks>
    </member>
    <member name="T:Sandbox.PartyRoom">
      <summary>
            A Party. A Party with your friends.
            </summary>
    </member>
    <member name="P:Sandbox.PartyRoom.Id">
      <summary>
            The unique identifier of this lobby
            </summary>
    </member>
    <member name="M:Sandbox.PartyRoom.SetOwner(Sandbox.SteamId)">
      <summary>
            Set the owner to someone else. You need to be the owner
            </summary>
    </member>
    <member name="P:Sandbox.PartyRoom.VoiceCommunicationAllowed">
      <summary>
            Allow communication via voice when in the main menu.
            </summary>
    </member>
    <member name="M:Sandbox.PartyRoom.OnVoiceRecorded(System.Memory{System.Byte})">
      <summary>
            Voice data has been recieved. Send it to everyone.
            </summary>
    </member>
    <member name="P:Sandbox.PartyRoom.Members">
      <summary>
            A list of members in this room
            </summary>
    </member>
    <member name="M:Sandbox.PartyRoom.SetBroadcastVoice">
      <summary>
            Called each frame that a client wants to broadcast their voice
            </summary>
    </member>
    <member name="T:Sandbox.Preferences">
      <summary>
            Holds information about the current user's preferences.
            </summary>
    </member>
    <member name="P:Sandbox.Preferences.FieldOfView">
      <summary>
            The user's preference for their field of view
            </summary>
    </member>
    <member name="P:Sandbox.Preferences.MusicVolume">
      <summary>
            The user's preferred Music volume, as set in the options, clamped between 0 and 1
            </summary>
    </member>
    <member name="P:Sandbox.Preferences.VoipVolume">
      <summary>
            The user's preferred VOIP volume, as set in the options, clamped between 0 and 1
            </summary>
    </member>
    <member name="P:Sandbox.Preferences.Sensitivity">
      <summary>
            The mouse sensitivity
            </summary>
    </member>
    <member name="T:Sandbox.Services.AchievementOverview">
      <summary>
            Activity Feed
            </summary>
    </member>
    <member name="T:Sandbox.Services.Achievements">
      <summary>
            Allows access to stats for the current game. Stats are defined by the game's author
            and can be used to track anything from player actions to performance metrics. They are
            how you submit data to leaderboards.
            </summary>
    </member>
    <member name="M:Sandbox.Services.Achievements.DelayAchievementUnlocks(System.Single)">
      <summary>
            Delay automatic achievement unlocks for this many seconds. Useful when loading etc.
            </summary>
    </member>
    <member name="T:Sandbox.Services.Achievements.Map">
      <summary>
            Stats for the current map
            </summary>
    </member>
    <member name="M:Sandbox.Services.Auth.GetToken(System.String,System.Threading.CancellationToken)">
      <summary>
            Get an auth token, which can be passed to the backend
            </summary>
    </member>
    <member name="M:Sandbox.Services.Auth.GetAuthTicket(System.UInt64,System.Byte[]@)">
      <summary>
            Get a Steam authentication ticket intended for a target with a particular Steam Id.
            </summary>
      <param name="targetSteamId" />
      <param name="ticket" />
      <returns />
    </member>
    <member name="M:Sandbox.Services.Auth.EndAuthSession(System.UInt64)">
      <summary>
            End an authentication session with a particular user.
            </summary>
      <param name="steamId" />
    </member>
    <member name="M:Sandbox.Services.Auth.BeginAuthSession(System.UInt64,System.Byte[])">
      <summary>
            Begin an authentication session with a particular user, using the ticket they provided you.
            </summary>
      <param name="senderSteamId" />
      <param name="ticket" />
    </member>
    <member name="M:Sandbox.Services.Auth.CancelAuthTicket(Steamworks.Data.HAuthTicket)">
      <summary>
            Cancel an authentication ticket from a handle obtained by <see cref="M:Sandbox.Services.Auth.GetAuthTicket(System.UInt64,System.Byte[]@)" />.
            </summary>
      <param name="handle" />
    </member>
    <member name="T:Sandbox.Services.BenchmarkSystem">
      <summary>
            Allows access to stats for the current game. Stats are defined by the game's author
            and can be used to track anything from player actions to performance metrics. They are
            how you submit data to leaderboards.
            </summary>
    </member>
    <member name="M:Sandbox.Services.BenchmarkSystem.Start(System.String)">
      <summary>
            Called to start a benchmark
            </summary>
    </member>
    <member name="M:Sandbox.Services.BenchmarkSystem.SetMetric(System.String,System.Double)">
      <summary>
            Set a custom metric, like load time, shutdown time etc
            </summary>
      <param name="name" />
      <param name="metric" />
    </member>
    <member name="M:Sandbox.Services.BenchmarkSystem.Finish">
      <summary>
            Called to close a benchmark off
            </summary>
    </member>
    <member name="M:Sandbox.Services.BenchmarkSystem.Sample">
      <summary>
            Should be called in update every frame
            </summary>
    </member>
    <member name="M:Sandbox.Services.BenchmarkSystem.SendAsync(System.Threading.CancellationToken)">
      <summary>
            Finish this benchmark session and send it off to the backend
            </summary>
    </member>
    <member name="P:Sandbox.Services.BenchmarkSystem.Sampler.Result.P5">
      <summary>
            The value below which 5% of the samples fall (the 5th percentile).
            </summary>
    </member>
    <member name="P:Sandbox.Services.BenchmarkSystem.Sampler.Result.P95">
      <summary>
            The value below which 95% of the samples fall (the 95th percentile).
            </summary>
    </member>
    <member name="P:Sandbox.Services.BenchmarkSystem.Sampler.Result.P99">
      <summary>
            The value below which 99% of the samples fall (the 99th percentile).
            </summary>
    </member>
    <member name="P:Sandbox.Services.BenchmarkSystem.Sampler.Result.P99_9">
      <summary>
            The value below which 99.9% of the samples fall (the 99.9th percentile).
            </summary>
    </member>
    <member name="P:Sandbox.Services.BenchmarkSystem.Sampler.Result.Stuttering">
      <summary>
            This is the sum of all samples that exceeded the stuttering threshold.
            May not be very useful for non time based samples.
            </summary>
    </member>
    <member name="M:Sandbox.Services.BenchmarkSystem.Sampler.Percentile(System.Double)">
      <summary>
            Calculates the specified percentile value from the collected samples.
            </summary>
      <param name="percentile">
            The percentile to compute (a value between 0 and 100).
            For example, passing 95 computes the 95th percentile.
            </param>
      <returns>
            The value below which the given percentage of samples fall.
            </returns>
    </member>
    <member name="M:Sandbox.Services.BenchmarkSystem.Sampler.Stuttering(System.Double)">
      <summary>
            Calculates the sum of all samples that exceeded the stuttering threshold.
            A sample is considered stuttering if it exceeds the moving average multiplied by the stuttering factor.
            </summary>
      <param name="stutteringFactor">
            The multiplier used to determine the stuttering threshold.
            A higher factor makes it less sensitive to spikes (default is typically 2.5).
            </param>
    </member>
    <member name="T:Sandbox.Services.Feed">
      <summary>
            Activity Feed
            </summary>
    </member>
    <member name="T:Sandbox.Services.Inventory">
      <summary>
            Allows access to the Steam Inventory system
            </summary>
      <summary>
            Allows access to the Steam Inventory system
            </summary>
    </member>
    <member name="P:Sandbox.Services.Inventory.Items">
      <summary>
            All of the items the user has in their inventory
            </summary>
    </member>
    <member name="M:Sandbox.Services.Inventory.Refresh(System.Threading.CancellationToken)">
      <summary>
            Get the user's inventory. This is called on startup - and shouldn't really need to be
            called again unless the user buys something. Returns a list of items added since the last refresh.
            </summary>
    </member>
    <member name="M:Sandbox.Services.Inventory.HasItem(System.Int32)">
      <summary>
            Returns true if we have this item
            </summary>
    </member>
    <member name="P:Sandbox.Services.Inventory.Definitions">
      <summary>
            All item definitions
            </summary>
    </member>
    <member name="M:Sandbox.Services.Inventory.FindDefinition(System.Int32)">
      <summary>
            Find a definition by id
            </summary>
    </member>
    <member name="M:Sandbox.Services.Inventory.RefreshDefinitions">
      <summary>
            Ask steam to start getting the item definitions. If there's anything new
            it'll come via OnDefinitionUpdate(). This is called during startup, in menudll
            and we shouldn't ever really have to call it again.
            </summary>
    </member>
    <member name="T:Sandbox.Services.Inventory.Item">
      <summary>
            Describes a type of item that can be in the inventory
            </summary>
    </member>
    <member name="T:Sandbox.Services.Inventory.ItemDefinition">
      <summary>
            Describes a type of item that can be in the inventory
            </summary>
    </member>
    <member name="P:Sandbox.Services.Inventory.ItemDefinition.Price">
      <summary>
            If we're for sale, this is our price
            </summary>
    </member>
    <member name="P:Sandbox.Services.Inventory.ItemDefinition.BasePrice">
      <summary>
            If we're for sale but on sale, this is our regular price
            </summary>
    </member>
    <member name="P:Sandbox.Services.Leaderboards.Board.TargetSteamId">
      <summary>
            The steamid to get information about. If unset then this defaults to the current player.
            </summary>
    </member>
    <member name="P:Sandbox.Services.Leaderboards.Board.MaxEntries">
      <summary>
            The maximum entries to respond with.
            </summary>
    </member>
    <member name="P:Sandbox.Services.Leaderboards.Board.Group">
      <summary>
            global, country, friends
            </summary>
    </member>
    <member name="P:Sandbox.Services.Leaderboards.Board.Title">
      <summary>
            The group name of this board. For example, "Global" for global, "Friends" for friends.
            </summary>
    </member>
    <member name="P:Sandbox.Services.Leaderboards.Board.DisplayName">
      <summary>
            The display name of this board, which was set in the backend.
            </summary>
    </member>
    <member name="P:Sandbox.Services.Leaderboards.Board.Description">
      <summary>
            The description of this board, which was set in the backend.
            </summary>
    </member>
    <member name="P:Sandbox.Services.Leaderboards.Board.TotalEntries">
      <summary>
            The total number of chart entries for this board.
            </summary>
    </member>
    <member name="P:Sandbox.Services.Leaderboards.Board.Unit">
      <summary>
            The unit type chosen for this board
            </summary>
    </member>
    <member name="P:Sandbox.Services.Leaderboards.Board.Entries">
      <summary>
            The group of entries for this board. This is usually the entries that surround
            the TargetSteamId.
            </summary>
    </member>
    <member name="F:Sandbox.Services.Leaderboards.Entry.Me">
      <summary>
            True if this entry is for the current player.
            </summary>
    </member>
    <member name="F:Sandbox.Services.Leaderboards.Entry.Rank">
      <summary>
            The rank in the board
            </summary>
    </member>
    <member name="F:Sandbox.Services.Leaderboards.Entry.Value">
      <summary>
            The value in the board
            </summary>
    </member>
    <member name="F:Sandbox.Services.Leaderboards.Entry.FormattedValue">
      <summary>
            The value, but formatted according to Unit
            </summary>
    </member>
    <member name="F:Sandbox.Services.Leaderboards.Entry.SteamId">
      <summary>
            The steamid of the entry
            </summary>
    </member>
    <member name="F:Sandbox.Services.Leaderboards.Entry.DisplayName">
      <summary>
            The player's display name
            </summary>
    </member>
    <member name="M:Sandbox.Services.Leaderboards.Board2.CenterOnSteamId(System.Int64)">
      <summary>
            Center the results on this steamid, show the surrounding results with this in the middle.
            </summary>
    </member>
    <member name="M:Sandbox.Services.Leaderboards.Board2.CenterOnMe">
      <summary>
            Center the results on you, show the surrounding results with you in the middle.
            </summary>
    </member>
    <member name="M:Sandbox.Services.Leaderboards.Board2.IncludeSteamIds(System.Int64[])">
      <summary>
            If they have any results, include these steamids in the results - regardless of their position.
            </summary>
    </member>
    <member name="P:Sandbox.Services.Leaderboards.Board2.TargetSteamId">
      <summary>
            The steamid to get information about. If unset then this defaults to the current player.
            </summary>
    </member>
    <member name="P:Sandbox.Services.Leaderboards.Board2.MaxEntries">
      <summary>
            The maximum entries to respond with.
            </summary>
    </member>
    <member name="P:Sandbox.Services.Leaderboards.Board2.Offset">
      <summary>
            The offset to start at. If less than 0, we will start from the bottom.
            </summary>
    </member>
    <member name="P:Sandbox.Services.Leaderboards.Board2.TotalEntries">
      <summary>
            The total number of chart entries for this board.
            </summary>
    </member>
    <member name="P:Sandbox.Services.Leaderboards.Board2.TimePeriodDescription">
      <summary>
            If you are restructing by time period, this is the name of the period
            </summary>
    </member>
    <member name="P:Sandbox.Services.Leaderboards.Board2.Entries">
      <summary>
            The group of entries for this board. This is usually the entries that surround
            the TargetSteamId.
            </summary>
    </member>
    <member name="F:Sandbox.Services.Leaderboards.Board2.Entry.Rank">
      <summary>
            The rank in the board
            </summary>
    </member>
    <member name="F:Sandbox.Services.Leaderboards.Board2.Entry.Value">
      <summary>
            The value in the board
            </summary>
    </member>
    <member name="F:Sandbox.Services.Leaderboards.Board2.Entry.SteamId">
      <summary>
            The steamid of the entry
            </summary>
    </member>
    <member name="F:Sandbox.Services.Leaderboards.Board2.Entry.CountryCode">
      <summary>
            The country which this entry is from
            </summary>
    </member>
    <member name="F:Sandbox.Services.Leaderboards.Board2.Entry.DisplayName">
      <summary>
            The player's display name
            </summary>
    </member>
    <member name="F:Sandbox.Services.Leaderboards.Board2.Entry.Timestamp">
      <summary>
            The time this entry was created.
            </summary>
    </member>
    <member name="F:Sandbox.Services.Leaderboards.Board2.Entry.Data">
      <summary>
            Data associated with this entry
            </summary>
    </member>
    <member name="F:Sandbox.Services.Messaging.incoming">
      <summary>
            Store the messages from the other thread so we can process them 
            on the main thread, at an appropriate time in the loop
            </summary>
    </member>
    <member name="T:Sandbox.Services.News">
      <summary>
            News Posts
            </summary>
    </member>
    <member name="T:Sandbox.Services.Notification">
      <summary>
            Player notification
            </summary>
    </member>
    <member name="T:Sandbox.Services.Players.Overview">
      <summary>
            An overview of a player. Only available if their profile isn't set to private.
            </summary>
    </member>
    <member name="P:Sandbox.Services.Players.Overview.AvatarJson">
      <summary>
            A json string representing how their avatar is dressed
            </summary>
    </member>
    <member name="T:Sandbox.Services.Players.Profile">
      <summary>
            Player profile
            </summary>
    </member>
    <member name="T:Sandbox.Services.Review">
      <summary>
            Package Reviews
            </summary>
    </member>
    <member name="P:Sandbox.Services.Review.Player">
      <summary>
            The player who made the review
            </summary>
    </member>
    <member name="P:Sandbox.Services.Review.Content">
      <summary>
            The actual content (text only right now)
            </summary>
    </member>
    <member name="P:Sandbox.Services.Review.Score">
      <summary>
            The score of the review
            </summary>
    </member>
    <member name="P:Sandbox.Services.Review.PlayTime">
      <summary>
            How many seconds this user played
            </summary>
    </member>
    <member name="P:Sandbox.Services.Review.Updated">
      <summary>
            Date this review was updated
            </summary>
    </member>
    <member name="T:Sandbox.Services.ServerList.Entry">
      <summary>
            This is a cleaned up version of gameserveritem_t.
            </summary>
    </member>
    <member name="T:Sandbox.Services.gameserveritem_t">
      <summary>
            Data from c++
            We skip the steamid because there's some class padding fuckery going on.
            We pass that in manually to make life easier.
            </summary>
    </member>
    <member name="T:Sandbox.Services.Stats">
      <summary>
            Allows access to stats for the current game. Stats are defined by the game's author
            and can be used to track anything from player actions to performance metrics. They are
            how you submit data to leaderboards.
            </summary>
      <summary>
            Allows access to stats for the current game. Stats are defined by the game's author
            and can be used to track anything from player actions to performance metrics. They are
            how you submit data to leaderboards.
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.FlushAsync(System.Threading.CancellationToken)">
      <summary>
            Send any pending stats to the backend. Don't wait for confirmation of ingestiom, fire and forget.
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.Flush">
      <summary>
            Send any pending stats to the backend. Don't wait for confirmation of ingestiom, fire and forget.
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.FlushAndWaitAsync(System.Threading.CancellationToken)">
      <summary>
            Send any pending stats to the backend, will wait until they're available for query before finishing.
            </summary>
    </member>
    <member name="F:Sandbox.Services.Stats._globalStats">
      <summary>
            Static cache of all the global stats
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.Global">
      <summary>
            Get the global stats for the calling package
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.GetGlobalStats(System.String)">
      <summary>
            Get the global stats for this package
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.GlobalStats.IsRefreshing">
      <summary>
            True if we're currently fetching new stats
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.GlobalStats.LastRefresh">
      <summary>
            The UTC datetime when we last fetched new stats
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.GlobalStats.Copy">
      <summary>
            Make a copy of this class. Allows you to store the stats from a point in time.
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.GlobalStats.Get(System.String)">
      <summary>
            Get a stat by name. Will return an empty stat if not found
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.GlobalStats.TryGet(System.String,Sandbox.Services.Stats.GlobalStat@)">
      <summary>
            Get a stat by name, returns true if found
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.GlobalStats.Refresh">
      <summary>
            Refresh these global stats - grab the latest values
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.GlobalStat.Name">
      <summary>
            The programatic name for this stat. This should probably be called Ident
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.GlobalStat.Title">
      <summary>
            The title of this stat, as defined on the backend
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.GlobalStat.Description">
      <summary>
            The description of this stat, as defined on the backend
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.GlobalStat.Unit">
      <summary>
            The unit of this stat as defined on the backend
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.GlobalStat.Velocity">
      <summary>
            The change in this stat in units per hour
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.GlobalStat.Value">
      <summary>
            The current stat value
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.GlobalStat.ValueString">
      <summary>
            The current value formatted using Unit
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.GlobalStat.Players">
      <summary>
            The amount of players that have this stat
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.GlobalStat.Max">
      <summary>
            The maximum value
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.GlobalStat.Min">
      <summary>
            The minimum value
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.GlobalStat.Avg">
      <summary>
            The average value
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.GlobalStat.Sum">
      <summary>
            The sum of all values
            </summary>
    </member>
    <member name="T:Sandbox.Services.Stats.Map">
      <summary>
            Stats for the current map
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.Map.Local">
      <summary>
            Get the stats for the local player
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.Map.Global">
      <summary>
            Get the global stats
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.Map.SetValue(System.String,System.Double,System.Collections.Generic.Dictionary{System.String,System.Object})">
      <summary>
            Add a stat value for this package
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.Map.GetLocal(System.String)">
      <summary>
            Get a stat for the local player
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.Map.GetGlobal(System.String)">
      <summary>
            Get a stat for the local player
            </summary>
    </member>
    <member name="F:Sandbox.Services.Stats._playerStats">
      <summary>
            Static cache of all the global stats
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.LocalPlayer">
      <summary>
            Get the global stats for the calling package
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.GetLocalPlayerStats(System.String)">
      <summary>
            Get the global stats for this package
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.GetPlayerStats(System.String,System.Int64)">
      <summary>
            Get the stats for this package
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.PlayerStats.IsRefreshing">
      <summary>
            True if we're currently fetching new stats
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.PlayerStats.LastRefresh">
      <summary>
            The UTC datetime when we last fetched new stats
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.PlayerStats.Copy">
      <summary>
            Make a copy of this class. Allows you to store the stats from a point in time.
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.PlayerStats.Get(System.String)">
      <summary>
            Get a stat by name. Will return an empty stat if not found
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.PlayerStats.TryGet(System.String,Sandbox.Services.Stats.PlayerStat@)">
      <summary>
            Get a stat by name, returns true if found
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.PlayerStats.Refresh">
      <summary>
            Refresh these global stats - grab the latest values
            </summary>
    </member>
    <member name="M:Sandbox.Services.Stats.PlayerStats.Predict(System.String,System.Double)">
      <summary>
            When the stat is queued for change on the backend, we can predict its change on the front
            end, for achievements etc.
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.PlayerStat.Name">
      <summary>
            The programatic name for this stat. This should probably be called Ident
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.PlayerStat.Title">
      <summary>
            The title of this stat, as defined on the backend
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.PlayerStat.Description">
      <summary>
            The description of this stat, as defined on the backend
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.PlayerStat.Unit">
      <summary>
            The unit of this stat as defined on the backend
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.PlayerStat.Value">
      <summary>
            The current stat value
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.PlayerStat.ValueString">
      <summary>
            The current value formatted using Unit
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.PlayerStat.Max">
      <summary>
            The maximum value
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.PlayerStat.Min">
      <summary>
            The minimum value
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.PlayerStat.Avg">
      <summary>
            The average value
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.PlayerStat.Sum">
      <summary>
            The sum of all values
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.PlayerStat.Last">
      <summary>
            The time of the last value
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.PlayerStat.LastValue">
      <summary>
            The last value
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.PlayerStat.First">
      <summary>
            The time of the first value
            </summary>
    </member>
    <member name="P:Sandbox.Services.Stats.PlayerStat.FirstValue">
      <summary>
            The last value
            </summary>
    </member>
    <member name="T:Sandbox.Services.Ugc">
      <summary>
            Implements SteamUgc, lets us edit/create workshop items
            </summary>
    </member>
    <member name="P:Sandbox.Services.Ugc.NeedsLegalAgreement">
      <summary>
            Does this user need to sign the license agreement for their published items?
            You need to call this after submitting an item
            </summary>
    </member>
    <member name="M:Sandbox.Services.Ugc.CreateItem">
      <summary>
            Creates a Ugc item
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.Services.Ugc.SetItemId(System.UInt64)">
      <summary>
            Sets the current item id, so any updates are scoped to this item
            </summary>
      <param name="id" />
    </member>
    <member name="M:Sandbox.Services.Ugc.GetItemId">
      <summary>
            Gets the current item id
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.Services.Ugc.StartUpdating">
      <summary>
            Start updating an item
            </summary>
    </member>
    <member name="M:Sandbox.Services.Ugc.SetTitle(System.String)">
      <summary>
            Sets the title of the item
            </summary>
      <param name="title" />
    </member>
    <member name="M:Sandbox.Services.Ugc.SetContent(System.String)">
      <summary>
            Sets the content of the item
            </summary>
      <param name="path" />
    </member>
    <member name="M:Sandbox.Services.Ugc.Submit">
      <summary>
            Submits an item's changes to the steam workshop
            </summary>
      <returns />
    </member>
    <member name="T:Sandbox.CurrencyValue">
      <summary>
            Describes money, in a certain currency
            </summary>
    </member>
    <member name="F:Sandbox.CurrencyValue.Currency">
      <summary>
            The name of the currency
            </summary>
    </member>
    <member name="F:Sandbox.CurrencyValue.Value">
      <summary>
            The value without decimals. This is in the smallest denomination of the currency.
            </summary>
    </member>
    <member name="T:Sandbox.Gizmo.GizmoControls">
      <summary>
            Extendable helper to create common gizmos
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoControls.Position(System.String,Vector3,Vector3@,System.Nullable{Rotation},System.Single)">
      <summary>
            A front left up position movement widget. If widget was moved then will return true and out will return the new position.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoControls.Arrow(System.String,Vector3,System.Single@,System.Single,System.Single,System.Single,System.Single,System.Single,System.String)">
      <summary>
            Draw an arrow - return move delta if interacted with
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoControls.DragSquare(System.String,Vector2,Rotation,Vector3@,System.Action)">
      <summary>
            Manipulate a 2d value by moving on 2 axis
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoControls.PushFixedScale(System.Nullable{System.Single})">
      <summary>
            Scope this before drawing a control to obey Settings.GizmoScale
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoControls.Rotate(System.String,Angles@)">
      <summary>
            A full 3d rotation gizmo. If rotated will return true and newValue will be the new value
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoControls.RotateSingle(System.String,Color,System.Single@,System.Single)">
      <summary>
            A single rotation axis
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoControls.Scale(System.String,System.Single,System.Single@)">
      <summary>
            A front left up position movement widget. If widget was moved then will return true and out will return the new position.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoControls.Scale(System.String,Vector3,Vector3@,System.Nullable{Rotation},System.Single)">
      <summary>
            A front left up position movement widget. If widget was moved then will return true and out will return the new position.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoControls.Sphere(System.String,System.Single,System.Single@,Color)">
      <summary>
            A scalable sphere gizmo. Returns true if the gizmo was interacted with and outValue will return the new radius.
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Control">
      <summary>
            Holds fully realized controls to manipulate some value
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Draw">
      <summary>
            Draw a shape using the gizmo library
            </summary>
    </member>
    <member name="T:Sandbox.Gizmo.GizmoDraw">
      <summary>
            Contains functions to add objects to the Gizmo Scene. This
            is an instantiable class so it's possible to add extensions.
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.GizmoDraw.Color">
      <summary>
            The color to render the next object
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.GizmoDraw.IgnoreDepth">
      <summary>
            Ignore depth when drawing, draw on top of everything
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.GizmoDraw.LineThickness">
      <summary>
            The thickness of line drawings
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.Model(System.String,Transform)">
      <summary>
            Draw a model
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.Model(System.String)">
      <summary>
            Draw a model
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.Model(Sandbox.Model,Transform)">
      <summary>
            Draw a model
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.Model(Sandbox.Model)">
      <summary>
            Draw a model
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.Particles(System.String,Transform,System.Nullable{System.Single})">
      <summary>
            Draw particles. Control points will be set to the transform position.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.Particles(System.String,System.Nullable{System.Single})">
      <summary>
            Draw particles. Control point 0 will be set to the transform position.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.Text(System.String,Transform,System.String,System.Single,Sandbox.TextFlag)">
      <summary>
            Draw text
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.ScreenText(System.String,Vector2,System.String,System.Single,Sandbox.TextFlag)">
      <summary>
            Draw text
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.ScreenText(System.String,Vector3,Vector2,System.String,System.Single,Sandbox.TextFlag)">
      <summary>
            Draw text on screen at a 3d position
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.ScreenRect(Sandbox.Rect,Color,Vector4,Color,Vector4,Sandbox.BlendMode)">
      <summary>
            Draw a rect, on the screen
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.ScreenText(System.String,Vector2,Vector2,System.Single,System.String,System.Single,Sandbox.TextFlag)">
      <summary>
            Draw text at an angle
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.Plane(Vector3,Vector3)">
      <summary>
            Draw a plane
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.Arrow(Vector3,Vector3,System.Single,System.Single)">
      <summary>
            Draw a line with an arrow on the end
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.Grid(Sandbox.Gizmo.GridAxis,System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Draws a grid
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.Grid(Sandbox.Gizmo.GridAxis,Vector2,System.Single,System.Single,System.Single)">
      <summary>
            Draws a grid
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.Grid(Vector3,Sandbox.Gizmo.GridAxis,Vector2,System.Single,System.Single,System.Single)">
      <summary>
            Draws a grid centered at a position
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.AddLineInternal(Sandbox.VertexSceneObject,Vector3@,Vector3@)">
      <summary>
            Adds a line to the current object, but also adds it as a potential hitbox
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.Line(Vector3@,Vector3@)">
      <summary>
            Draw a line from a to b
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.Line(Line@)">
      <summary>
            Draw a line from a to b
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.Lines(System.Collections.Generic.IEnumerable{Line}@)">
      <summary>
            Draw a lines
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.LineBBox(BBox@)">
      <summary>
            Draw a bounding box
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.LineFrustum(Sandbox.Frustum@)">
      <summary>
            Draws a frustum.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.LineSphere(Vector3@,System.Single@,System.Int32@)">
      <summary>
            Draw a sphere made out of lines
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.LineSphere(Sandbox.Sphere@,System.Int32)">
      <summary>
            Draw a sphere made out of lines
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.LineCircle(Vector3@,System.Single,System.Single,System.Single,System.Int32)">
      <summary>
            Draw a sphere made out of lines
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.LineCylinder(Vector3,Vector3,System.Single,System.Single,System.Int32)">
      <summary>
            A cylinder
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.LineTriangle(Sandbox.Triangle@)">
      <summary>
            A triangle
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.LineTriangles(System.Collections.Generic.IEnumerable{Sandbox.Triangle}@)">
      <summary>
            Multiple triangles
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.SolidCone(Vector3,Vector3,System.Single,System.Nullable{System.Int32})">
      <summary>
            Draw a solid cone shape
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.SolidBox(BBox)">
      <summary>
            Draw a solid box shape
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.SolidTriangle(Sandbox.Triangle@)">
      <summary>
            Draw a solid triangle shape
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.SolidTriangle(Vector3@,Vector3@,Vector3@)">
      <summary>
            Draw a solid triangle shape
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.SolidTriangles(System.Collections.Generic.IEnumerable{Sandbox.Triangle}@)">
      <summary>
            Multiple solid triangles
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.SolidCircle(Vector3,System.Single,System.Single,System.Single,System.Int32)">
      <summary>
            Draw a filled circle
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.SolidRing(Vector3,System.Single,System.Single,System.Single,System.Single,System.Int32)">
      <summary>
            Draw a filled ring
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.SolidSphere(Vector3,System.Single,System.Int32,System.Int32)">
      <summary>
            Draw a solid sphere shape
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.SolidCylinder(Vector3,Vector3,System.Single,System.Int32)">
      <summary>
            Draw a solid cylinder shape
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.SolidCapsule(Vector3,Vector3,System.Single,System.Int32,System.Int32)">
      <summary>
            Draw a solid capsule shape
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.ScreenBiasedHalfCircle(Vector3,System.Single)">
      <summary>
            Draws a half circle that tries its best to point towards the camera. This is used by
            the rotation widgets that bias towards the camera.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.Sprite(Vector3,System.Single,Sandbox.Texture)">
      <summary>
            Draw a sprite. This is horrible right now because it doesn't seem like we can load png textures from disk!?!?
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoDraw.Sprite(Vector3,Vector2,Sandbox.Texture,System.Boolean)">
      <summary>
            Draw a sprite. This is horrible right now because it doesn't seem like we can load png textures from disk!?!?
            </summary>
    </member>
    <member name="T:Sandbox.Gizmo.Colors">
      <summary>
            Using pure primary colors is horrible. Lets make it easier to avoid.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.Scope(System.String,Transform)">
      <summary>
            Create a new scope - any changes to colors and transforms will be stored
            and reverted when exiting the scope.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.Scope(System.String,Vector3)">
      <summary>
            Create a new scope - any changes to colors and transforms will be stored
            and reverted when exiting the scope.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.Scope(System.String,Vector3,Rotation,System.Single)">
      <summary>
            Create a new scope - any changes to colors and transforms will be stored
            and reverted when exiting the scope.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.Scope(System.String)">
      <summary>
            Create a new scope - any changes to colors and transforms will be stored
            and reverted when exiting the scope.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.ObjectScope``1(``0,Transform)">
      <summary>
            Create a new scope - any changes to colors and transforms will be stored
            and reverted when exiting the scope.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GetPositionOnPlane(Vector3,Vector3,Ray)">
      <summary>
            Get the distance from a point on a plane
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GetMouseDelta(Vector3,Vector3)">
      <summary>
            Get the mouse delta at this current position
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GetMouseDrag(Vector3,Vector3)">
      <summary>
            Get the mouse drag distance at this current position, assuming we are pressed
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GetMouseDistance(Vector3,Vector3)">
      <summary>
            Get the distance from a point on a plane
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GetMouseDistanceDelta(Vector3,Vector3)">
      <summary>
            Get the distance moved from (or towards) a position on a plane
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.CursorPosition">
      <summary>
            The current cursor position, in screen space
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.CursorMoveDelta">
      <summary>
            The delta of cursor movement between this frame and last, in screen space
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.CursorDragDelta">
      <summary>
            The delta of cursor movement between last press and now, in screen space.
            If left mouse isn't down, will return CursorMoveDelta
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.KeyboardModifiers">
      <summary>
            The current keyboard modifiers
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.Snap(Vector3,Vector3)">
      <summary>
            Will snap this position, depending on the current snap settings and keys that are pressed.
            Will snap along if movement is detected along that axis. For example, if movement is 1,0,0 then we'll
            only snap on the x axis.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.Snap(Angles,Angles)">
      <summary>
            Will snap this position, depending on the current snap settings and keys that are pressed.
            Will snap along if movement is detected along that axis. For example, if movement is 1,0,0 then we'll
            only snap on the x axis.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.Nudge(Rotation,Vector2)">
      <summary>
            Will give you a nudge vector along the most aligned left and up axis of the rotation
            based on left/right/up/down direction and camera angle
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.CameraTransform">
      <summary>
            The cameras transform - in world space
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.LocalCameraTransform">
      <summary>
            The cameras transform - in local space
            </summary>
    </member>
    <member name="T:Sandbox.Gizmo.Inputs">
      <summary>
            The input state, allows interaction with Gizmos
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Inputs.IsHovered">
      <summary>
            True if the scene is being hovered by the mouse. False if the cursor is being used somewhere else
            </summary>
    </member>
    <member name="T:Sandbox.Gizmo.Instance">
      <summary>
            Holds the backend state for a Gizmo scope. This allows us to have multiple different gizmo
            states (for multiple views, multiple windows, game and editor) and push them as the current
            active state whenever needed.
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Instance.Debug">
      <summary>
            If true, we'll draw some debug information
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Instance.DebugHitboxes">
      <summary>
            If true we'll enable hitbox debugging
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Instance.World">
      <summary>
            The SceneWorld this instance is writing to. This world exists only for this instance.
            You need to add this world to your camera for it to render (!)
            </summary>
    </member>
    <member name="F:Sandbox.Gizmo.Instance.Input">
      <summary>
            Input state. Should be setup before push.
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Instance.PreviousInput">
      <summary>
            The previous input state
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Instance.Pool">
      <summary>
            Last frame's objects that are available for reuse
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Instance.Entries">
      <summary>
            This frame's created (or re-used) objects
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Instance.Selection">
      <summary>
            This frame's created (or re-used) objects
            </summary>
    </member>
    <member name="F:Sandbox.Gizmo.Instance.scope">
      <summary>
            When a new scope is pushed, we store the old one and copy it to this.
            When it's disposed we restore this to the old one. This is the currently
            active scope.
            </summary>
    </member>
    <member name="F:Sandbox.Gizmo.Instance.lineScope">
      <summary>
            Holds the current hitbox line scope status
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Instance.ControlMode">
      <summary>
            The current control mode. This is generally implementation specific. 
            We tend to use "mouse" and "firstperson".
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Instance.Settings">
      <summary>
            Some global settings accessible to the gizmos. Your implementation
            generally lets your users set up  these things to their preference, 
            and the gizmos should try to obey them.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.Instance.GetValue``1(System.String)">
      <summary>
            Generic storage for whatever you want to do. 
            You're responsible for not spamming into this and cleaning up after yourself.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.Instance.SetValue``1(System.String,``0)">
      <summary>
            Generic storage for whatever you want to do. 
            You're responsible for not spamming into this and cleaning up after yourself.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.Instance.Clear">
      <summary>
            Called when the scene changes and we don't want to inherit a bunch of values.
            We might want to just target some specific values here instead of clearing the log.
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Instance.LoopMilliseconds">
      <summary>
            how long the previous loop took, in milliseconds
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.Instance.Dispose">
      <summary>
            Destroy this instance, clean up any created resources/scene objects, destroy the world.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.Instance.Push">
      <summary>
            Push this instance as the global Gizmo state. All Gizmo calls during this scope
            will use this instance.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.Instance.Start">
      <summary>
            Called at the start of a 'frame'
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.Instance.End">
      <summary>
            Called at the end of a 'frame'
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.Instance.FindOrCreate``1(System.String,System.Func{``0})">
      <summary>
            Find a cached version of this sceneobject - if not found, create one
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.Instance.StompCursorPosition(Vector2)">
      <summary>
            Set all of the state's cursor positions to this value. This stomps previous values
            which will effectively clear any deltas. This should be used prior to starting a loop.
            </summary>
    </member>
    <member name="T:Sandbox.Gizmo.Pressed">
      <summary>
            Access to the currently pressed path information
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Pressed.Ray">
      <summary>
            The ray representing the cursor direction
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Pressed.This">
      <summary>
            True if the current gizmo scope is pressed
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Pressed.Any">
      <summary>
            True if any object is currently pressed
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Pressed.CursorDelta">
      <summary>
            The distance the cursor has travelled since press started
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Pressed.CursorPosition">
      <summary>
            The cursor position at the start of the press
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Pressed.IsActive">
      <summary>
            True if press is active. This generally means that the left mouse button is down
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.SceneSettings.EditMode">
      <summary>
            How do we want to edit this? Usually something like "position", "rotation", "scale" etc
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.SceneSettings.Selection">
      <summary>
            Do we want to let the user select things in the current mode?
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.SceneSettings.ViewMode">
      <summary>
            What is the current view mode? 3d, 2d, ui?
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.SceneSettings.GizmosEnabled">
      <summary>
            Are gizmos enabled?
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.SceneSettings.GizmoScale">
      <summary>
            How big to show the gizmos
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.SceneSettings.GridSpacing">
      <summary>
            Grid spacing
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.SceneSettings.SnapToGrid">
      <summary>
            Snap positions to the grid
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.SceneSettings.SnapToAngles">
      <summary>
            Snap angles
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.SceneSettings.AngleSpacing">
      <summary>
            Grid spacing
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.SceneSettings.GlobalSpace">
      <summary>
            Editing in local space
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.SceneSettings.DebugActionGraphs">
      <summary>
            Should we show lines representing GameObject references in action graphs?
            </summary>
    </member>
    <member name="T:Sandbox.Gizmo.ScopeState">
      <summary>
            Whenever Gizmo.State is called, this is copied, stored and restored. This
            should hold whatever data is important to reset at the end of a scope. We
            should be really careful not to fill this with too much shit.
            </summary>
    </member>
    <member name="P:Sandbox.Gizmo.Hitbox">
      <summary>
            Allows creating a gizmo hitbox which will be interactable using the mouse (or vr deck2 super controller)
            </summary>
    </member>
    <member name="T:Sandbox.Gizmo.GizmoHitbox">
      <summary>
            Contains functions to add objects to the immediate mode Scene. This
            is an instantiable class so it's possible to add extensions.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoHitbox.TrySetHovered(System.Single)">
      <summary>
            If this distance is closer than our previous best, this path will become the hovered path
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoHitbox.TrySetHovered(Vector3)">
      <summary>
            If this distance is closer than our previous best, this path will become the hovered path
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoHitbox.Sphere(Sandbox.Sphere)">
      <summary>
            A sphere hitbox
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoHitbox.BBox(BBox)">
      <summary>
            A bounding box hitbox
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoHitbox.Circle(Vector3,Vector3,System.Single,System.Single)">
      <summary>
            A 2d circle hitbox, on a plane
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoHitbox.Model(Sandbox.Model)">
      <summary>
            A model hitbox
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoHitbox.Sprite(Vector3,System.Single,System.Boolean)">
      <summary>
            A 2d sprite hitbox
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoHitbox.LineScope">
      <summary>
            Start a line scope. Any drawn lines should become a hitbox during this scope.
            </summary>
    </member>
    <member name="M:Sandbox.Gizmo.GizmoHitbox.AddPotentialLine(Vector3@,Vector3@,System.Single)">
      <summary>
            If we're in a hitbox linescope we'll distance this test vs the current ray. If
            not, we'll return immediately.
            This is automatically called when rendering lines
            </summary>
    </member>
    <member name="T:Sandbox.GizmoInlineSceneObject">
      <summary>
            Draws anything
            </summary>
    </member>
    <member name="T:Sandbox.TextSceneObject">
      <summary>
            Draws text in screenspace
            </summary>
    </member>
    <member name="P:Sandbox.TextSceneObject.AngleDegrees">
      <summary>
            this argument is short sighted and stupid, don't keep using it
            </summary>
    </member>
    <member name="T:Sandbox.VertexSceneObject">
      <summary>
            Draws a vertex object. Lines or solids usually.
            </summary>
    </member>
    <member name="T:Sandbox.ModelArchetype">
      <summary>
            Default model archetypes.
            These types are defined in "tools/model_archetypes.txt".
            </summary>
    </member>
    <member name="F:Sandbox.ModelArchetype.static_prop_model">
      <summary>
            A static model. It can still have collisions, but they do not have physics.
            </summary>
    </member>
    <member name="F:Sandbox.ModelArchetype.animated_model">
      <summary>
            Animated model. Typically no physics.
            </summary>
    </member>
    <member name="F:Sandbox.ModelArchetype.physics_prop_model">
      <summary>
            A generic physics enabled model.
            </summary>
    </member>
    <member name="F:Sandbox.ModelArchetype.jointed_physics_model">
      <summary>
            A ragdoll type model.
            </summary>
    </member>
    <member name="F:Sandbox.ModelArchetype.breakable_prop_model">
      <summary>
            A physics model that can be broken into other physics models.
            </summary>
    </member>
    <member name="F:Sandbox.ModelArchetype.generic_actor_model">
      <summary>
            A generic actor/NPC model.
            </summary>
    </member>
    <member name="M:Sandbox.ModelEditor.Internal.BaseModelDocAttribute.AddTransform(System.Text.StringBuilder)">
      <summary>
            Internal, used to add multi level key-values.
            </summary>
    </member>
    <member name="M:Sandbox.ModelEditor.Internal.BaseModelDocAttribute.AddKeys(System.Collections.Generic.Dictionary{System.String,System.Object})">
      <summary>
            Add generic key-values to the helper.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.Internal.BaseTransformAttribute.Bone">
      <summary>
            Internal name of the key that dictates which bone to use as parent for position/angles.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.Internal.BaseTransformAttribute.Attachment">
      <summary>
            Internal name of the key that dictates which attachment to use as parent for position/angles.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.Internal.BaseTransformAttribute.Origin">
      <summary>
            Internal name of the key to store position in, if set, allows the helper to be moved.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.Internal.BaseTransformAttribute.Angles">
      <summary>
            Internal name of the key to store angles in, allows the helper to be rotated.
            </summary>
    </member>
    <member name="T:Sandbox.ModelEditor.GameDataAttribute">
      <summary>
            Indicates that this class/struct should be available as GenericGameData node in ModelDoc
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.GameDataAttribute.AllowMultiple">
      <summary>
            Indicates that this type compiles as list, rather than a single entry in the model.
            This will also affect how you retrieve this data via Model.GetData().
            </summary>
    </member>
    <member name="T:Sandbox.ModelEditor.AxisAttribute">
      <summary>
            Draws 3 line axis visualization, which can set up to be manipulated via gizmos. You can have multiple of these.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.AxisAttribute.Enabled">
      <summary>
            Internal name of a boolean key that dictates whether this helper should draw or not. If unset, will draw always.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.AxisAttribute.ParentLine">
      <summary>
            If set to true, when the node is selected a line will be drawn from the helper to the parent attachment/bone.
            </summary>
    </member>
    <member name="T:Sandbox.ModelEditor.BoxAttribute">
      <summary>
            Draws a box, which can be manipulated via gizmos. You can have multiple of these.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.BoxAttribute.HideSurface">
      <summary>
            If set, the semi-transparent box "walls" will not be drawn.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.BoxAttribute.ShowGizmos">
      <summary>
            If set, gizmos will be shown in transform mode to quickly move/scale the box.
            For "dimensions" box Origin/Angles must be set.
            </summary>
    </member>
    <member name="M:Sandbox.ModelEditor.BoxAttribute.#ctor(System.String)">
      <summary>
            Store the box's dimensions in a single key, acting as (maxs-mins) which assumes the box's center is at the models origin.
            The box's center can be set up to be movable via "Origin" property and rotatable via "Angles" property.
            </summary>
      <param name="dimensionsKey">Internal name of a key on the node that will store the dimensions of the box.</param>
    </member>
    <member name="M:Sandbox.ModelEditor.BoxAttribute.#ctor(System.String,System.String)">
      <summary>
            Store the box's dimensions in 2 keys as Mins and Maxs. This type cannot be rotated.
            </summary>
      <param name="minsKey">Internal name of a key on the node that will store the mins of the box.</param>
      <param name="maxsKey">Internal name of a key on the node that will store the maxs of the box.</param>
    </member>
    <member name="T:Sandbox.ModelEditor.SphereAttribute">
      <summary>
            Draws a sphere, which can be manipulated via gizmos. You can have multiple of these.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.SphereAttribute.HideSurface">
      <summary>
            If set, the semi-transparent sphere "wall"/surface will not be drawn.
            </summary>
    </member>
    <member name="T:Sandbox.ModelEditor.CapsuleAttribute">
      <summary>
            Draws a capsule, which can be manipulated via gizmos. You can have multiple of these.
            </summary>
    </member>
    <member name="M:Sandbox.ModelEditor.CapsuleAttribute.#ctor(System.String,System.String,System.String)">
      <summary>
            This variation has 1 radius for both points.
            </summary>
    </member>
    <member name="M:Sandbox.ModelEditor.CapsuleAttribute.#ctor(System.String,System.String,System.String,System.String)">
      <summary>
            This variation has independent radius for each point.
            </summary>
    </member>
    <member name="T:Sandbox.ModelEditor.CylinderAttribute">
      <summary>
            Draws a cylinder, which can be manipulated via gizmos. You can have multiple of these.
            </summary>
    </member>
    <member name="M:Sandbox.ModelEditor.CylinderAttribute.#ctor(System.String,System.String,System.String)">
      <summary>
            This variation has 1 radius for both points.
            </summary>
    </member>
    <member name="M:Sandbox.ModelEditor.CylinderAttribute.#ctor(System.String,System.String,System.String,System.String)">
      <summary>
            This variation has independent radius for each point.
            </summary>
    </member>
    <member name="T:Sandbox.ModelEditor.HingeJointAttribute">
      <summary>
            A helper that draws axis of rotation and angle limit of a hinge joint.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.HingeJointAttribute.EnableLimit">
      <summary>
            Key name that dictates whether the hinge limit is enabled or not.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.HingeJointAttribute.MinAngle">
      <summary>
            Key name that stores the minimum angle value for the revolute joint.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.HingeJointAttribute.MaxAngle">
      <summary>
            Key name that stores the maximum angle value for the revolute joint.
            </summary>
    </member>
    <member name="T:Sandbox.ModelEditor.EditorWidgetAttribute">
      <summary>
            Adds a custom editor widget to the game data node.
            Currently only 1 option is available - "HandPosePairEditor"
            </summary>
    </member>
    <member name="T:Sandbox.ModelEditor.HandPoseAttribute">
      <summary>
            A helper used for VR hand purposes.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.HandPoseAttribute.Origin">
      <summary>
            Internal name of the key to store position in.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.HandPoseAttribute.Angles">
      <summary>
            Internal name of the key to store angles in.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.HandPoseAttribute.Model">
      <summary>
            Path to a model to use.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.HandPoseAttribute.IsRightHand">
      <summary>
            Whether this helper represents the right hand or not.
            This decides the names of the bones the helper will try to use.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.HandPoseAttribute.Label">
      <summary>
            Text label this helper will have when hovered/selected.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.HandPoseAttribute.Enabled">
      <summary>
            Internal name of the key that controls whether this helper is visible or not.
            </summary>
    </member>
    <member name="M:Sandbox.ModelEditor.HandPoseAttribute.#ctor(System.String,System.String,System.String,System.Boolean)">
      <param name="originKey">Internal name of the key to store position in.</param>
      <param name="anglesKey">Internal name of the key to store angles in.</param>
      <param name="model">Path to a model to use.</param>
      <param name="isRightHand">Whether this helper represents the right hand or not. This decides the names of the bones the helper will try to use.</param>
    </member>
    <member name="P:Sandbox.ModelEditor.LineAttribute.BoneFrom">
      <summary>
            Internal name of the key that dictates which bone to use as parent for start position.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.LineAttribute.AttachmentFrom">
      <summary>
            Internal name of the key that dictates which attachment to use as parent for start position.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.LineAttribute.OriginFrom">
      <summary>
            Internal name of the key to read line start position from.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.LineAttribute.BoneTo">
      <summary>
            Internal name of the key that dictates which bone to use as parent for end position.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.LineAttribute.AttachmentTo">
      <summary>
            Internal name of the key that dictates which attachment to use as parent for end position.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.LineAttribute.OriginTo">
      <summary>
            Internal name of the key to read line end position from.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.LineAttribute.Enabled">
      <summary>
            Internal name of the key that controls whether this helper is visible or not.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.LineAttribute.Color">
      <summary>
            A string formatted color for this helper. Format is "255 255 255"
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.LineAttribute.Width">
      <summary>
            The width of the line helper
            </summary>
    </member>
    <member name="T:Sandbox.ModelEditor.ScaleBoneRelativeAttribute">
      <summary>
            Scales the vector with the "ScaleAndMirror" node, relative to associated bone.
            </summary>
    </member>
    <member name="T:Sandbox.ModelEditor.ScaleWorldAttribute">
      <summary>
            Scales the vector with the "ScaleAndMirror" node.
            </summary>
    </member>
    <member name="T:Sandbox.ModelEditor.Nodes.ModelBreakPiece">
      <summary>
            Defines a single breakable prop gib.
            </summary>
    </member>
    <member name="T:Sandbox.ModelEditor.Nodes.ModelPropData">
      <summary>
            Generic prop settings. Support for this depends on the entity.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.Nodes.ModelPropData.BakeLighting">
      <summary>
            When this model is used as prop_static, it will bake lighting by default depending on this value.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.Nodes.ModelPropData.Health">
      <summary>
            When this model is used as prop_physics, it's health will be set to this value.
            </summary>
    </member>
    <member name="T:Sandbox.ModelEditor.Nodes.ModelExplosionBehavior">
      <summary>
            Defines the model as explosive. Support for this depends on the entity.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.Nodes.ModelExplosionBehavior.Sound">
      <summary>
            Sound override for when the prop explodes.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.Nodes.ModelExplosionBehavior.Effect">
      <summary>
            Particle effect override for when the problem explodes.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.Nodes.ModelExplosionBehavior.Damage">
      <summary>
            Amount of damage to do at the center on the explosion. It will falloff over distance.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.Nodes.ModelExplosionBehavior.Radius">
      <summary>
            Range of explosion's damage.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.Nodes.ModelExplosionBehavior.Force">
      <summary>
            Scale of the force applied to entities damaged by the explosion and the models break pieces.
            </summary>
    </member>
    <member name="T:Sandbox.ModelEditor.Nodes.ModelEye">
      <summary>
            Defines an eye on a character model.
            </summary>
    </member>
    <member name="T:Sandbox.ModelEditor.Nodes.ModelNavData">
      <summary>
            Carries navigation related data.
            </summary>
    </member>
    <member name="P:Sandbox.ModelEditor.Nodes.ModelNavData.Avoid">
      <summary>
            During map compile this model would mark its volume as an area that should be avoided by AI.
            </summary>
    </member>
    <member name="T:Sandbox.AutoGenerateAttribute">
      <summary>
            Indicates that this type should generate meta data. Tagging your asset with this will
            mean that the .asset file is automatically generated - which means you don't have to do that.
            </summary>
    </member>
    <member name="T:Sandbox.FGDTypeAttribute">
      <summary>
            Overrides the auto generated FGD type.
            </summary>
    </member>
    <member name="M:Sandbox.FGDTypeAttribute.#ctor(System.String,System.String,System.String)">
      <param name="type">The FGD type override.</param>
      <param name="editor">The name of a custom editor to use for this property.</param>
      <param name="editorArgs">Arguments for given editor override. Format depends on each editor.</param>
    </member>
    <member name="T:Sandbox.ResourceTypeAttribute">
      <summary>
            Allows you to specify a string property as a resource type. This will
            give the property a resource finder. Type should be the file extension, ie "vmdl"
            </summary>
    </member>
    <member name="T:Sandbox.BitFlagsAttribute">
      <summary>
            This choices type is bitflags, so we should be able to choose more than one option at a time.
            </summary>
      <remarks>
            TODO: Once this is no longer used in assets it can be deleted.
                  It should be derived from [System.Flags]
            </remarks>
    </member>
    <member name="T:Sandbox.AssetPathAttribute">
      <summary>
            When added to a string property, will becomes a selector for AssetTypeExtension
            </summary>
    </member>
    <member name="T:Sandbox.ImageAssetPathAttribute">
      <summary>
            When added to a string property, will become an image string selector
            </summary>
    </member>
    <member name="T:Sandbox.TextureImagePathAttribute">
      <summary>
            When added to a string property, will allow selection of anything that a Texture can be
            </summary>
    </member>
    <member name="T:Sandbox.MapAssetPathAttribute">
      <summary>
            When added to a string property, will become a map string selector
            </summary>
    </member>
    <member name="F:Sandbox.HotloadManager.PerTypeAssertThresholdMillis">
      <summary>
            Assert if any one type takes more than this duration to process, AND more than
            <see cref="F:Sandbox.HotloadManager.PerTypeAssertThresholdFraction" /> of the total time.
            </summary>
    </member>
    <member name="F:Sandbox.HotloadManager.PerTypeAssertThresholdFraction">
      <summary>
            Assert if any one type takes more than this fraction of the total time to process,
            AND more than <see cref="F:Sandbox.HotloadManager.PerTypeAssertThresholdMillis" />.
            </summary>
    </member>
    <member name="M:Sandbox.HotloadManager.DoSwap">
      <summary>
            Does the actual hotload
            </summary>
    </member>
    <member name="M:Sandbox.HotloadManager.Replace(System.Reflection.Assembly,System.Reflection.Assembly)">
      <summary>
            Lets the hotload system know that something has changed. If we detect that we are
            replacing a dll (instead of just adding one) we'll queue up a swap. We should still
            call this even if <paramref name="oldAssembly" /> or <paramref name="newAssembly" />
            is null, since that will tell the hotload system to start / stop watching static
            members of the assembly.
            </summary>
    </member>
    <member name="P:Sandbox.Controller.Gyroscope">
      <summary>
            Gets a sensor reading from the device's gyroscope (if it has one)
            </summary>
    </member>
    <member name="P:Sandbox.Controller.Accelerometer">
      <summary>
            Gets a sensor reading from the device's accelerometer (if it has one)
            </summary>
    </member>
    <member name="P:Sandbox.Controller.LEDColor">
      <summary>
            Sets the color of the gamepad if supported
            </summary>
    </member>
    <member name="P:Sandbox.Controller.ControllerType">
      <summary>
            What type of controller is this?
            </summary>
    </member>
    <member name="P:Sandbox.Controller.GlyphVendor">
      <summary>
            Which glyph vendor are we using for this controller?
            - default "The default vendor type, which uses Xbox glyphs"
            - playstation
            - switch 
            </summary>
    </member>
    <member name="M:Sandbox.Controller.Rumble(System.Int32,System.Int32,System.Int32)">
      <summary>
            Rumbles the controller.
            </summary>
      <param name="leftMotor">The speed of the left motor, between 0 and 0xFFFF</param>
      <param name="rightMotor">The speed of the right motor, between 0 and 0xFFFF</param>
      <param name="duration">The duration of the vibration in ms</param>
    </member>
    <member name="M:Sandbox.Controller.RumbleTriggers(System.Int32,System.Int32,System.Int32)">
      <summary>
            Rumbles the controller's triggers (if supported)
            </summary>
      <param name="leftTrigger">The speed of the left trigger motor, between 0 and 0xFFFF</param>
      <param name="rightTrigger">The speed of the right trigger motor, between 0 and 0xFFFF</param>
      <param name="duration">The duration of the vibration in ms</param>
    </member>
    <member name="M:Sandbox.Controller.StopAllHaptics">
      <summary>
            Stops all rumble and haptic events on this controller.
            </summary>
    </member>
    <member name="M:Sandbox.Controller.StopAllVibrations">
      <summary>
            Stop all vibration events on this controller.
            </summary>
    </member>
    <member name="M:Sandbox.Controller.TriggerHapticEffect(Sandbox.HapticEffect,System.Single,System.Single,System.Single)">
      <summary>
            Trigger a vibration based on a predefined <see cref="T:Sandbox.HapticPattern" />.
            All <see cref="T:Sandbox.HapticPattern" />s are normalized (start at 0, peak at 1).
            </summary>
      <param name="effect">The pattern to use</param>
      <param name="lengthScale">The amount to scale the pattern's length by.</param>
      <param name="frequencyScale">The amount to scale the pattern's frequency by.</param>
      <param name="amplitudeScale">The amount to scale the pattern's amplitude by.</param>
    </member>
    <member name="P:Sandbox.Controller.All">
      <summary>
            A list of all of the controllers, active and inactive.
            </summary>
    </member>
    <member name="P:Sandbox.Controller.First">
      <summary>
            Get the first controller that's connected (shortcut)
            </summary>
    </member>
    <member name="P:Sandbox.Controller.InputContext">
      <summary>
            The input context for this controller.
            </summary>
    </member>
    <member name="F:Sandbox.Controller.AXIS_RANGE">
            SDL reports values between this range
        </member>
    <member name="M:Sandbox.Controller.GetAxis(NativeEngine.GameControllerAxis,System.Single)">
      <summary>
            Get an axis
            </summary>
      <param name="axis" />
      <param name="defaultValue" />
      <returns />
    </member>
    <member name="T:Sandbox.Controller.InputAxis">
      <summary>
            An axis
            </summary>
    </member>
    <member name="T:Sandbox.Input">
      <summary>
            Allows querying of player button presses and other inputs.
            </summary>
    </member>
    <member name="P:Sandbox.Input.CurrentPlayerScope">
      <summary>
            What's our current player index (for input scoping)?
            -1 is the default behavior, where it'll accept keyboard AND gamepad inputs.
            Anything above that, is targeting a specific controller.
            </summary>
    </member>
    <member name="P:Sandbox.Input.ControllerCount">
      <summary>
            How many controllers are active right now?
            </summary>
    </member>
    <member name="P:Sandbox.Input.EnableVirtualCursor">
      <summary>
            Whether or not the Virtual Cursor should show when using a controller. Disable this to control the cursor manually.
            </summary>
    </member>
    <member name="P:Sandbox.Input.CurrentController">
      <summary>
            Tries to find the current controller to use.
            </summary>
    </member>
    <member name="M:Sandbox.Input.GetAnalog(Sandbox.InputAnalog)">
      <summary>
            An analog input, when fetched, is between -1 and 1 (0 being default)
            </summary>
    </member>
    <member name="M:Sandbox.Input.ProcessControllerInput(System.Int32)">
      <summary>
            Processes controller inputs based on a player index (for input scoping). This can be called many times a frame.
            </summary>
    </member>
    <member name="M:Sandbox.Input.PlayerScope(System.Int32)">
      <summary>
            Push a specific player scope to be active
            </summary>
    </member>
    <member name="P:Sandbox.Input.UsingController">
      <summary>
            Was the last button pressed a game controller button?
            </summary>
    </member>
    <member name="P:Sandbox.Input.MissingActions">
      <summary>
            Missing action names that we've warned about already.
            This gets cleared when actions are initialized again.
            </summary>
    </member>
    <member name="M:Sandbox.Input.GetActionIndex(System.String)">
      <summary>
            We pack actions bit-by-bit in CUserCmd, using the index (which is shared between realms) to map it to an action.
            This is an accessor to grab that index easily from its action.
            </summary>
      <param name="actionName" />
      <returns />
    </member>
    <member name="M:Sandbox.Input.GetActionIndex(Sandbox.InputAction)">
      <inheritdoc cref="M:Sandbox.Input.GetActionIndex(System.String)" />
    </member>
    <member name="P:Sandbox.Input.EscapePressed">
      <summary>
            True if escape was pressed
            </summary>
    </member>
    <member name="M:Sandbox.Input.Down(System.String,System.Boolean)">
      <summary>
            Action is currently pressed down
            </summary>
    </member>
    <member name="M:Sandbox.Input.Pressed(System.String)">
      <summary>
            Action wasn't pressed but now it is
            </summary>
    </member>
    <member name="M:Sandbox.Input.Released(System.String)">
      <summary>
            Action was pressed but now it isn't
            </summary>
    </member>
    <member name="M:Sandbox.Input.SetAction(Sandbox.InputAction,System.Boolean)">
      <inheritdoc cref="M:Sandbox.Input.SetAction(System.Int32,System.Boolean)" />
    </member>
    <member name="M:Sandbox.Input.SetAction(System.String,System.Boolean)">
      <inheritdoc cref="M:Sandbox.Input.SetAction(System.Int32,System.Boolean)" />
    </member>
    <member name="M:Sandbox.Input.Clear(System.String)">
      <summary>
            Remove this action, so it's no longer being pressed.
            </summary>
      <param name="action" />
    </member>
    <member name="M:Sandbox.Input.ClearActions">
      <summary>
            Clears the current input actions, so that none of them are active.
            </summary>
    </member>
    <member name="M:Sandbox.Input.ReleaseActions">
      <summary>
            Clears the current input actions, so that none of them are active. Unlike ClearActions
            this will unpress the buttons, so they won't be active again until they're pressed again.
            </summary>
    </member>
    <member name="M:Sandbox.Input.ReleaseAction(System.String)">
      <summary>
            Releases the action, and it won't be active again until it's pressed again.
            </summary>
    </member>
    <member name="M:Sandbox.Input.SetAction(System.Int32,System.Boolean)">
      <summary>
            Activates / Deactivates an action when building input.
            </summary>
      <param name="index" />
      <param name="down" />
    </member>
    <member name="M:Sandbox.Input.OnButton(NativeEngine.ButtonCode,System.String,System.Boolean)">
      <summary>
            Called when a compatible button is pressed.
            </summary>
    </member>
    <member name="M:Sandbox.Input.GetActions">
      <summary>
            Copies all input actions to be used publicly
            </summary>
      <returns />
    </member>
    <member name="P:Sandbox.Input.ActionNames">
      <summary>
            Names of all actions from the current game's input settings.
            </summary>
    </member>
    <member name="M:Sandbox.Input.GetGroupName(System.String)">
      <summary>
            Finds the <see cref="P:Sandbox.InputAction.GroupName" /> of the given action.
            </summary>
      <param name="action">Action name to find the group name of.</param>
    </member>
    <member name="M:Sandbox.Input.ReadConfig(Sandbox.InputSettings)">
      <summary>
            Read the config from this source
            </summary>
    </member>
    <member name="P:Sandbox.Input.CurrentContext">
      <summary>
            The current input context, pushed using Context.Push
            </summary>
    </member>
    <member name="P:Sandbox.Input.Contexts">
      <summary>
            Get all of the contexts
            </summary>
    </member>
    <member name="T:Sandbox.Input.Context">
      <summary>
            Allows tracking states of button changes and input deltas in a custom period (such as a tick) rather
            than in a per frame manner. This allows frame and tick to have legit data.
            </summary>
    </member>
    <member name="M:Sandbox.Input.Context.Flip">
      <summary>
            Copy accumulated values. Flip previous actions to current actions etc.
            </summary>
    </member>
    <member name="M:Sandbox.Input.Context.Push">
      <summary>
            Make this the current active context. You can optionally use the returned
            IDisposable to restore back to the previous context when you're done.
            </summary>
    </member>
    <member name="P:Sandbox.Input.VR">
      <summary>
            Virtual Reality specific input data.
            </summary>
    </member>
    <member name="P:Sandbox.Input.MouseDelta">
      <summary>
            Movement delta from the mouse.
            </summary>
    </member>
    <member name="P:Sandbox.Input.MouseWheel">
      <summary>
            The state of the mouse wheel.
            </summary>
    </member>
    <member name="P:Sandbox.Input.MouseCursorVisible">
      <summary>
            True if the mouse cursor is visible (using UI etc)
            </summary>
    </member>
    <member name="P:Sandbox.Input.AnalogLook">
      <summary>
            Analog look value from the default input device. This is scaled by Preferences.Sensitivity - so you don't need to scale it afterwards.
            </summary>
    </member>
    <member name="P:Sandbox.Input.AnalogMove">
      <summary>
            Analog move value from the default input device.
            </summary>
    </member>
    <member name="M:Sandbox.Input.Process(System.Single)">
      <summary>
            Called multiple times between ticks.
            </summary>
    </member>
    <member name="P:Sandbox.Input.MotionData">
      <summary>
            Current state of the current input device's motion sensor(s) if supported.
            This is only supported on: Dualshock 4+, Switch Controllers, Steam Controller, Steam Deck.
            </summary>
    </member>
    <member name="M:Sandbox.Input.GetButtonOrigin(Sandbox.InputAction,System.Boolean)">
      <inheritdoc cref="M:Sandbox.Input.GetButtonOrigin(System.String,System.Boolean)" />
    </member>
    <member name="M:Sandbox.Input.GetButtonOrigin(System.String,System.Boolean)">
      <summary>
            Returns the name of a key bound to this InputAction
            <example>For example:
            <code>Input.GetButtonOrigin( "Undo" )</code>
            could return <c>SPACE</c> if using keyboard or <c>A Button</c> when using a controller.
            </example></summary>
    </member>
    <member name="M:Sandbox.Input.LoadGlyphTexture(System.String,Sandbox.InputGlyphSize,System.Boolean)">
      <summary>
            Tries to load a glyph texture, will seek the current vendor controller (Xbox, PlayStation, Nintendo) and fall back to Xbox if not found.
            </summary>
      <param name="file" />
      <param name="size" />
      <param name="outline" />
      <returns />
    </member>
    <member name="M:Sandbox.Input.GetButtonName(System.String)">
      <summary>
            Some keys can't be parsed by files because they're symbols, so we change them into something readable
            </summary>
      <param name="key" />
      <returns />
    </member>
    <member name="M:Sandbox.Input.GetGlyph(System.String,Sandbox.InputGlyphSize,System.Boolean)">
      <summary>
            Get a glyph texture from the controller bound to the action.
            If no binding is found will return an 'UNBOUND' glyph.
            </summary>
      <remarks>You should update your UI with this every frame, it's very cheap to call and context can change.</remarks>
    </member>
    <member name="M:Sandbox.Input.GetGlyph(System.String,Sandbox.InputGlyphSize,Sandbox.GlyphStyle)">
      <inheritdoc cref="M:Sandbox.Input.GetGlyph(System.String,Sandbox.InputGlyphSize,System.Boolean)" />
    </member>
    <member name="M:Sandbox.Input.GetGlyph(Sandbox.InputAnalog,Sandbox.InputGlyphSize,System.Boolean)">
      <summary>
            Get a glyph texture from an analog input on a controller.
            </summary>
    </member>
    <member name="M:Sandbox.Input.GetButtonOrigin(Sandbox.InputAnalog)">
      <summary>
            Returns the name of the analog axis bound to this <see cref="T:Sandbox.InputAnalog" />.
            <example>For example:
            <code>Input.GetButtonOrigin( InputAnalog.Move )</code>
            could return <c>Left Joystick</c></example></summary>
    </member>
    <member name="M:Sandbox.Input.TriggerHaptics(System.Single,System.Single,System.Single,System.Single,System.Int32)">
      <summary>
            Trigger a haptic event on supported controllers including Xbox trigger impulse rumble.
            </summary>
      <remarks>
            SDL will translate these commands into haptic pulses that should work on all controller types.
            </remarks>
      <param name="leftMotor">The speed of the left motor, between 0.0 and 1.0.</param>
      <param name="rightMotor">The speed of the right motor, between 0.0 and 1.0.</param>
      <param name="leftTrigger">(Xbox One controller only) The speed of the left trigger motor, between 0.0 and 1.0.</param>
      <param name="rightTrigger">(Xbox One controller only) The speed of the right trigger motor, between 0.0 and 1.0.</param>
      <param name="duration">How long (in milliseconds) should we apply this for?</param>
    </member>
    <member name="M:Sandbox.Input.TriggerHaptics(Sandbox.HapticEffect,System.Single,System.Single,System.Single)">
      <summary>
            Trigger haptics based on a predefined <see cref="T:Sandbox.HapticEffect" />.
            All <see cref="T:Sandbox.HapticEffect" />s are normalized (start at 0, peak at 1).
            </summary>
      <param name="pattern">The pattern to use</param>
      <param name="lengthScale">The amount to scale the pattern's length by.</param>
      <param name="frequencyScale">The amount to scale the pattern's frequency by.</param>
      <param name="amplitudeScale">The amount to scale the pattern's amplitude by.</param>
    </member>
    <member name="M:Sandbox.Input.TriggerHaptics(Sandbox.HapticEffect,System.Single,System.Single)">
      <summary>
            Trigger haptics based on a predefined <see cref="T:Sandbox.HapticEffect" />.
            All <see cref="T:Sandbox.HapticEffect" />s are normalized (start at 0, peak at 1).
            </summary>
      <param name="pattern">The pattern to use</param>
      <param name="frequencyScale">The amount to scale the pattern's frequency by.</param>
      <param name="amplitudeScale">The amount to scale the pattern's amplitude by.</param>
    </member>
    <member name="M:Sandbox.Input.StopAllHaptics">
      <summary>
            Stop all vibration events on the current controller.
            </summary>
    </member>
    <member name="M:Sandbox.Input.Keyboard.Down(System.String)">
      <summary>
            Keyboard key is held down
            </summary>
    </member>
    <member name="M:Sandbox.Input.Keyboard.Pressed(System.String)">
      <summary>
            Keyboard key wasn't pressed but now it is
            </summary>
    </member>
    <member name="M:Sandbox.Input.Keyboard.Released(System.String)">
      <summary>
            Keyboard key was pressed but now it isn't
            </summary>
    </member>
    <member name="T:Sandbox.InputAnalog">
      <summary>
            An analog input, when fetched, is between -1 and 1 (0 being default)
            </summary>
    </member>
    <member name="T:Sandbox.InputMotionData">
      <summary>
            Represents the current state of a device's motion sensor(s).
            </summary>
    </member>
    <member name="F:Sandbox.InputMotionData.Gyroscope">
      <summary>
            The raw value from the input device's gyroscope.
            </summary>
    </member>
    <member name="F:Sandbox.InputMotionData.Accelerometer">
      <summary>
            The raw value from the input device's accelerometer.
            </summary>
    </member>
    <member name="T:Sandbox.GamepadCode">
      <summary>
            Game controller codes, driven from SDL.
            </summary>
    </member>
    <member name="T:Sandbox.HapticEffect">
      <summary>
            Contains a haptic effect, which consists of patterns for the controller and triggers.
            </summary>
    </member>
    <member name="P:Sandbox.HapticEffect.SoftImpact">
      <summary>
            A haptic pattern that represents a light, soft impact.
            </summary>
    </member>
    <member name="P:Sandbox.HapticEffect.HardImpact">
      <summary>
            A haptic pattern that represents a hard, sudden impact.
            </summary>
    </member>
    <member name="P:Sandbox.HapticEffect.Rumble">
      <summary>
            Applies a simple rumble to the controller.
            </summary>
    </member>
    <member name="P:Sandbox.HapticEffect.RumbleLeftTrigger">
      <summary>
            Applies a simple rumble to the left trigger.
            </summary>
    </member>
    <member name="P:Sandbox.HapticEffect.RumbleRightTrigger">
      <summary>
            Applies a simple rumble to the right trigger.
            </summary>
    </member>
    <member name="P:Sandbox.HapticEffect.Heartbeat">
      <summary>
            A haptic effect that feels like a heartbeat.
            </summary>
    </member>
    <member name="T:Sandbox.HapticPattern">
      <summary>
            Contains a haptic pattern, which consists of frequency and amplitude values that can change over time.
            </summary>
    </member>
    <member name="M:Sandbox.HapticPattern.#ctor(System.Single,Sandbox.Curve,Sandbox.Curve)">
      <summary>
            Contains a haptic pattern, which consists of frequency and amplitude values that can change over time.
            </summary>
    </member>
    <member name="P:Sandbox.HapticPattern.SoftImpact">
      <summary>
            A haptic pattern that represents a light, soft impact.
            </summary>
    </member>
    <member name="P:Sandbox.HapticPattern.HardImpact">
      <summary>
            A haptic pattern that represents a hard, sudden impact.
            </summary>
    </member>
    <member name="P:Sandbox.HapticPattern.Rumble">
      <summary>
            A haptic pattern that represents a constant low-frequency rumble.
            </summary>
    </member>
    <member name="P:Sandbox.HapticPattern.Heartbeat">
      <summary>
            A haptic pattern that feels like a heartbeat.
            </summary>
    </member>
    <member name="T:Sandbox.HapticTarget">
      <summary>
            Places you can trigger haptics on
            </summary>
    </member>
    <member name="F:Sandbox.HapticTarget.Controller">
      <summary>
            Controller
            </summary>
    </member>
    <member name="F:Sandbox.HapticTarget.LeftTrigger">
      <summary>
            Left impulse trigger (Xbox)
            </summary>
    </member>
    <member name="F:Sandbox.HapticTarget.RightTrigger">
      <summary>
            Right impulse trigger (Xbox)
            </summary>
    </member>
    <member name="F:Sandbox.InputGlyphSize.Small">
      <summary>
            Small 32x32 ( Keyboard glyphs can be wider for long key names )
            </summary>
    </member>
    <member name="F:Sandbox.InputGlyphSize.Medium">
      <summary>
            Medium 128x128 ( Keyboard glyphs can be wider for long key names )
            </summary>
    </member>
    <member name="F:Sandbox.InputGlyphSize.Large">
      <summary>
            Large 256x256 ( Keyboard glyphs can be wider for long key names )
            </summary>
    </member>
    <member name="M:Sandbox.SandboxGameExtensions.ToPixels(Sandbox.InputGlyphSize)">
      <summary>
            Translates this enum to pixel size.
            </summary>
    </member>
    <member name="F:Sandbox.GlyphStyle.Knockout">
      <summary>
            Face buttons will have colored labels/outlines on a knocked out background
            Rest of inputs will have white detail/borders on a knocked out background
            </summary>
    </member>
    <member name="F:Sandbox.GlyphStyle.Light">
      <summary>
            Black detail/borders on a white background
            </summary>
    </member>
    <member name="F:Sandbox.GlyphStyle.Dark">
      <summary>
            White detail/borders on a black background
            </summary>
    </member>
    <member name="M:Sandbox.GlyphStyle.WithNeutralColorABXY">
      <summary>
            ABXY Buttons will match the base style color instead of their normal associated color
            </summary>
    </member>
    <member name="M:Sandbox.GlyphStyle.WithSolidABXY">
      <summary>
            ABXY Buttons will have a solid fill
            </summary>
    </member>
    <member name="T:Sandbox.GlyphStyleMask">
      <summary>
            Internal bit flags for glyph styles, matches Steam Input ones.
            </summary>
    </member>
    <member name="T:Sandbox.InputAction">
      <summary>
            An input action defined by a game project.
            </summary>
    </member>
    <member name="P:Sandbox.InputAction.Name">
      <summary>
            The name of the input action. Used by Input.Down|Pressed|Released.
            </summary>
    </member>
    <member name="P:Sandbox.InputAction.GroupName">
      <summary>
            A group name for this input when showing in a binding system
            </summary>
    </member>
    <member name="P:Sandbox.InputAction.Title">
      <summary>
            A friendly name for this input action when showing in a binding system
            </summary>
    </member>
    <member name="P:Sandbox.InputAction.KeyboardCode">
      <summary>
            The key or key combo we'll be watching for.
            </summary>
    </member>
    <member name="P:Sandbox.InputAction.GamepadCode">
      <summary>
            What gamepad button should this action map to?
            </summary>
    </member>
    <member name="T:Sandbox.MouseButtons">
      <summary>
            State of mouse buttons being pressed or not.
            </summary>
    </member>
    <member name="F:Sandbox.MouseButtons.None">
      <summary>
            No buttons are being pressed.
            </summary>
    </member>
    <member name="F:Sandbox.MouseButtons.Left">
      <summary>
            Left mouse button is being pressed.
            </summary>
    </member>
    <member name="F:Sandbox.MouseButtons.Right">
      <summary>
            Right mouse button is being pressed.
            </summary>
    </member>
    <member name="F:Sandbox.MouseButtons.Middle">
      <summary>
            Middle mouse button (mouse wheel) is being pressed in.
            </summary>
    </member>
    <member name="F:Sandbox.MouseButtons.Back">
      <summary>
            The "back" mouse button (mouse4) being pressed in.
            </summary>
    </member>
    <member name="F:Sandbox.MouseButtons.Forward">
      <summary>
            The "forward" mouse button (mouse5) being pressed in.
            </summary>
    </member>
    <member name="T:Sandbox.VR.AnalogInput">
      <summary>
            Represents a VR analog input action (e.g. trigger)
            </summary>
    </member>
    <member name="P:Sandbox.VR.AnalogInput.Value">
      <summary>
            The current value of this input, from 0 to 1.
            </summary>
    </member>
    <member name="P:Sandbox.VR.AnalogInput.Delta">
      <summary>
            How much <see cref="P:Sandbox.VR.AnalogInput.Value" /> has changed since the last update, from 0 to 1.
            </summary>
    </member>
    <member name="P:Sandbox.VR.AnalogInput.Active">
      <summary>
            Whether or not this action is currently accessible (if false, then <see cref="P:Sandbox.VR.AnalogInput.Value" /> will always be 0 and will never change).
            </summary>
    </member>
    <member name="M:Sandbox.VR.AnalogInput.op_Implicit(Sandbox.VR.AnalogInput)~System.Single">
      <summary>
            Implicitly returns <see cref="P:Sandbox.VR.AnalogInput.Value" /> as a <see cref="T:System.Single" />.
            </summary>
    </member>
    <member name="T:Sandbox.VR.AnalogInput2D">
      <summary>
            Represents a two-dimensional VR analog input action (e.g. joysticks)
            </summary>
    </member>
    <member name="P:Sandbox.VR.AnalogInput2D.Value">
      <summary>
            The current value of this input, with both axes ranging from 0 to 1.
            </summary>
    </member>
    <member name="P:Sandbox.VR.AnalogInput2D.Delta">
      <summary>
            How much <see cref="P:Sandbox.VR.AnalogInput2D.Value" /> has changed since the last update, with both axes ranging from 0 to 1.
            </summary>
    </member>
    <member name="P:Sandbox.VR.AnalogInput2D.Active">
      <summary>
            Whether or not this action is currently accessible (if false, then <see cref="P:Sandbox.VR.AnalogInput2D.Value" /> will always be 0 and will never change).
            </summary>
    </member>
    <member name="M:Sandbox.VR.AnalogInput2D.op_Implicit(Sandbox.VR.AnalogInput2D)~Vector2">
      <summary>
            Implicitly returns <see cref="P:Sandbox.VR.AnalogInput2D.Value" /> as a <see cref="T:Vector2" />.
            </summary>
    </member>
    <member name="T:Sandbox.VR.DigitalInput">
      <summary>
            Represents a VR digital input action (e.g. X button)
            </summary>
    </member>
    <member name="P:Sandbox.VR.DigitalInput.IsPressed">
      <summary>
            The current value of this input - true if pressed, false if not pressed.
            </summary>
    </member>
    <member name="P:Sandbox.VR.DigitalInput.WasPressed">
      <summary>
            The previous value of this input - true if it was pressed, false if it was not pressed.
            </summary>
    </member>
    <member name="P:Sandbox.VR.DigitalInput.Delta">
      <summary>
            How much <see cref="P:Sandbox.VR.DigitalInput.IsPressed" /> has changed since the last update.
            </summary>
    </member>
    <member name="P:Sandbox.VR.DigitalInput.Active">
      <summary>
            Whether or not this action is currently accessible (if false, then <see cref="P:Sandbox.VR.DigitalInput.IsPressed" /> will always be false and will never change).
            </summary>
    </member>
    <member name="M:Sandbox.VR.DigitalInput.op_Implicit(Sandbox.VR.DigitalInput)~System.Boolean">
      <summary>
            Implicitly returns <see cref="P:Sandbox.VR.DigitalInput.IsPressed" /> as a <see cref="T:System.Boolean" />.
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRInput.Current">
      <summary>
            The current relevant <see cref="T:Sandbox.VR.VRInput" /> instance.
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRInput.Scale">
      <summary>
            Get or set the player's scale in the world. If you set it to 2 the player will be twice as big.
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRInput.Anchor">
      <summary>
            Gets or sets where the center of the VR play area is in world space.
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRInput.ControllersAreDrawing">
      <summary>
            Returns true if SteamVR is drawing the controllers
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRInput.IsLeftHandDominant">
      <summary>
            Returns true if the left hand is dominant
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRInput.Head">
      <summary>
            Position and rotation of the Head Mounted Display in local space coordinates.
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRInput.LeftHand">
      <summary>
            Information about the left hand input.
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRInput.RightHand">
      <summary>
            Information about the right hand input.
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRInput.TrackedObjects">
      <summary>
            A list of available trackers.
            </summary>
    </member>
    <member name="F:Sandbox.VR.MotionRange.Hand">
      <summary>
            The default motion range. Provides hand poses that either estimate or fully represent the user's hand.
            </summary>
    </member>
    <member name="F:Sandbox.VR.MotionRange.Controller">
      <summary>
            Provides hand poses that estimate how the user's hand wraps around a controller, if they're using one.
            </summary>
    </member>
    <member name="T:Sandbox.VR.TrackedObject">
      <summary>
            Represents a physically tracked VR object with a transform
            </summary>
    </member>
    <member name="P:Sandbox.VR.TrackedObject.Active">
      <summary>
            Whether or not this object is currently accessible (if false, then the transform will not update).
            </summary>
    </member>
    <member name="P:Sandbox.VR.TrackedObject.Velocity">
      <summary>
            Local velocity of this object.
            </summary>
    </member>
    <member name="P:Sandbox.VR.TrackedObject.AngularVelocity">
      <summary>
            Local angular velocity of this object (degrees/s)
            </summary>
    </member>
    <member name="P:Sandbox.VR.TrackedObject.Transform">
      <summary>
            The position and rotation of this tracked object in world space (based on the anchor position)
            </summary>
    </member>
    <member name="P:Sandbox.VR.TrackedObject.Role">
      <summary>
            Which part of the body this tracked object represents - waist, left shoulder, etc.
            </summary>
    </member>
    <member name="P:Sandbox.VR.TrackedObject.Type">
      <summary>
            What type of object this is - tracker, controller, etc.
            </summary>
    </member>
    <member name="T:Sandbox.VR.VRController">
      <summary>
            Represents a VR controller, along with its transform, velocity, and inputs.
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRController.IsHandTracked">
      <summary>
            Is this controller currently being represented using full hand tracking?
            </summary>
    </member>
    <member name="M:Sandbox.VR.VRController.GetModel">
      <summary>
            Retrieves or creates a cached model that can be used to render this controller.
            </summary>
    </member>
    <member name="M:Sandbox.VR.VRController.TriggerHapticVibration(System.Single,System.Single,System.Single)">
      <summary>
            Triggers a haptic vibration event on the controller for this hand.
            </summary>
      <remarks>
            If a haptic event is already running it will be interrupted immediately.
            </remarks>
      <param name="duration">How long the haptic action should last (in seconds - can be 0 to "pulse" it)</param>
      <param name="frequency">How often the haptic motor should bounce (0 - 320 in hz. The lower end being more useful)</param>
      <param name="amplitude">How intense the haptic should be (0 - 1)</param>
    </member>
    <member name="M:Sandbox.VR.VRController.StopAllVibrations">
      <summary>
            Stop all vibration events on this controller.
            </summary>
    </member>
    <member name="M:Sandbox.VR.VRController.TriggerHaptics(Sandbox.HapticEffect,System.Single,System.Single,System.Single)">
      <summary>
            Trigger a vibration based on a predefined <see cref="T:Sandbox.HapticPattern" />.
            All <see cref="T:Sandbox.HapticPattern" />s are normalized (start at 0, peak at 1).
            </summary>
      <param name="effect">The pattern to use</param>
      <param name="lengthScale">The amount to scale the pattern's length by.</param>
      <param name="frequencyScale">The amount to scale the pattern's frequency by.</param>
      <param name="amplitudeScale">The amount to scale the pattern's amplitude by.</param>
    </member>
    <member name="M:Sandbox.VR.VRController.StopAllHaptics">
      <summary>
            Stops all rumble and haptic events on this controller.
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRController.Trigger">
      <summary>
            The trigger input on this controller
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRController.Grip">
      <summary>
            The grip input on this controller
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRController.Joystick">
      <summary>
            The primary joystick input on this controller
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRController.JoystickPress">
      <summary>
            The primary joystick press on this controller
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRController.ButtonA">
      <summary>
            The primary button on this controller (Usually A, can be X for Oculus Touch)
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRController.ButtonB">
      <summary>
            The secondary button on this controller (Usually B, can be Y for Oculus Touch)
            </summary>
    </member>
    <member name="M:Sandbox.VR.VRController.GetJoints(Sandbox.VR.MotionRange)">
      <summary>
            Returns joint data for a specific motion range.
            </summary>
      <param name="motionRange">Whether the joints returned represent a raw hand pose, or one that represents the hand wrapping around the controller.</param>
    </member>
    <member name="M:Sandbox.VR.VRController.GetFingerValue(Sandbox.VR.FingerValue)">
      <summary>
            Get the skeletal value (from 0 to 1) of a specified <see cref="T:Sandbox.VR.FingerValue" /> - includes curl and splay.
            </summary>
    </member>
    <member name="M:Sandbox.VR.VRController.GetFingerCurl(System.Int32)">
      <summary>
            Get the skeletal value (from 0 to 1) of a specified finger curl index.
            </summary>
    </member>
    <member name="M:Sandbox.VR.VRController.GetFingerSplay(System.Int32)">
      <summary>
            Get the skeletal value (from 0 to 1) of a specified finger splay index.
            </summary>
    </member>
    <member name="T:Sandbox.VR.FingerValue">
      <summary>
            Accessors for <see cref="M:Sandbox.VR.VRController.GetFingerValue(Sandbox.VR.FingerValue)" /></summary>
    </member>
    <member name="F:Sandbox.VR.FingerValue.ThumbCurl">
      <summary>
            Represents the curling motion of the thumb.
            </summary>
    </member>
    <member name="F:Sandbox.VR.FingerValue.IndexCurl">
      <summary>
            Represents the curling motion of the index finger.
            </summary>
    </member>
    <member name="F:Sandbox.VR.FingerValue.MiddleCurl">
      <summary>
            Represents the curling motion of the middle finger.
            </summary>
    </member>
    <member name="F:Sandbox.VR.FingerValue.RingCurl">
      <summary>
            Represents the curling motion of the ring finger.
            </summary>
    </member>
    <member name="F:Sandbox.VR.FingerValue.PinkyCurl">
      <summary>
            Represents the curling motion of the pinky finger.
            </summary>
    </member>
    <member name="F:Sandbox.VR.FingerValue.ThumbIndexSplay">
      <summary>
            Represents the splaying motion between the thumb and index finger.
            </summary>
    </member>
    <member name="F:Sandbox.VR.FingerValue.IndexMiddleSplay">
      <summary>
            Represents the splaying motion between the index and middle fingers.
            </summary>
    </member>
    <member name="F:Sandbox.VR.FingerValue.MiddleRingSplay">
      <summary>
            Represents the splaying motion between the middle and ring fingers.
            </summary>
    </member>
    <member name="F:Sandbox.VR.FingerValue.RingPinkySplay">
      <summary>
            Represents the splaying motion between the ring and pinky fingers.
            </summary>
    </member>
    <member name="F:Sandbox.VR.VRSystem.States.Shutdown">
      <summary>
            The VR system is currently shut down.
            </summary>
    </member>
    <member name="F:Sandbox.VR.VRSystem.States.Standby">
      <summary>
            The VR system is not updating or rendering, but is ready.
            </summary>
    </member>
    <member name="F:Sandbox.VR.VRSystem.States.PreInit">
      <summary>
            The VR system has begun to initialise. An OpenXR instance has been created.
            </summary>
    </member>
    <member name="F:Sandbox.VR.VRSystem.States.Active">
      <summary>
            The VR system is active and updating.
            </summary>
    </member>
    <member name="M:Sandbox.VR.VRSystem.Init">
      <summary>
            Initialise the VR instance.
            </summary>
    </member>
    <member name="M:Sandbox.VR.VRSystem.Disable">
      <summary>
            Disable the VR instance.
            </summary>
    </member>
    <member name="M:Sandbox.VR.VRSystem.Shutdown">
      <summary>
            Shut down the VR instance.
            </summary>
    </member>
    <member name="T:Sandbox.VR.TrackedDevice">
      <summary>
            Describes a tracked VR device
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDevice.Transform">
      <summary>
            This device's transform in absolute space
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDevice.Velocity">
      <summary>
            Velocity in tracker space in inch/s
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDevice.AngularVelocity">
      <summary>
            Angular velocity in degrees/s
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDevice.DeviceRole">
      <summary>
            Where is this device (left hand, right hand, left ankle, chest, etc.)?
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDevice.DeviceType">
      <summary>
            What type of device is this (HMD, controller, tracker, etc.)?
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDevice.InputSource">
      <summary>
            The input source for this device
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDevice.InputSourceHandle">
      <summary>
            Handle we should use internally for performance-sensitive calls
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDevice.IsActive">
      <summary>
            Is this tracked device currently active (connected)?
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDevice.DeviceIndex">
      <summary>
            Index we can use when referring to poses retrieved through WaitGetPose and similar functions
            </summary>
    </member>
    <member name="M:Sandbox.VR.TrackedDevice.Update">
      <summary>
            Update this tracked device's position, velocity, etc.
            </summary>
    </member>
    <member name="T:Sandbox.VR.TrackedDeviceInfo">
      <summary>
            Information about a tracked device - vendor info, serial number, battery data
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceInfo.VendorName">
      <summary>
            Which tracking system does this use (e.g. "oculus")? <br />
            Represents the value given by <c>Prop_TrackingSystemName_String</c>.
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceInfo.ManufacturerName">
      <summary>
            Who manufactured this device (e.g. "Oculus")? <br />
            Represents the value given by <c>Prop_ManufacturerName_String</c>.
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceInfo.DisplayName">
      <summary>
            What is this device called (e.g. "Oculus Rift S (Left Controller)")? <br />
            Represents the value given by <c>Prop_ModelNumber_String</c>.
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceInfo.RenderModelName">
      <summary>
            Which render model should this use (e.g. "oculus_rifts_controller_left")? <br />
            Represents the value given by <c>Prop_RenderModelName_String</c>.
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceInfo.SerialNumber">
      <summary>
            What is the serial number for this device (e.g. "1WMGH---------_Controller_Left")? <br />
            Represents the value given by <c>Prop_SerialNumber_String</c>.
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceInfo.BatteryPercentage">
      <summary>
            Battery percentage from 0 to 100
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceInfo.TypeString">
      <summary>
            If this is a controller, then represents the value given by <c>Prop_ControllerType_String</c>, otherwise "unknown".
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.Unknown">
      <summary>
            Unknown device role
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.LeftHand">
      <summary>
            Represents the left hand
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.RightHand">
      <summary>
            Represents the right hand
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.Head">
      <summary>
            Represents the head
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.Gamepad">
      <summary>
            Represents a gamepad
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.Treadmill">
      <summary>
            Represents a treadmill
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.Stylus">
      <summary>
            Represents a stylus
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.LeftFoot">
      <summary>
            Represents the left foot
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.RightFoot">
      <summary>
            Represents the right foot
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.LeftShoulder">
      <summary>
            Represents the left shoulder
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.RightShoulder">
      <summary>
            Represents the right shoulder
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.LeftElbow">
      <summary>
            Represents the left elbow
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.RightElbow">
      <summary>
            Represents the right elbow
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.LeftKnee">
      <summary>
            Represents the left knee
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.RightKnee">
      <summary>
            Represents the right knee
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.LeftWrist">
      <summary>
            Represents the left wrist
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.RightWrist">
      <summary>
            Represents the right wrist
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.LeftAnkle">
      <summary>
            Represents the left ankle
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.RightAnkle">
      <summary>
            Represents the right ankle
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.Waist">
      <summary>
            Represents the waist
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.Chest">
      <summary>
            Represents the chest
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.Camera">
      <summary>
            Represents a camera - such as a base station
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceRole.Keyboard">
      <summary>
            Represents a keyboard
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceType.Invalid">
      <summary>
            The ID was not valid.
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceType.Hmd">
      <summary>
            Head-mounted display (your headset)
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceType.Controller">
      <summary>
            Tracked controllers
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceType.Tracker">
      <summary>
            Generic trackers
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceType.BaseStation">
      <summary>
            Camera and base stations that serve as tracking reference points
            </summary>
    </member>
    <member name="F:Sandbox.VR.TrackedDeviceType.Redirect">
      <summary>
            Accessories that aren't necessarily tracked themselves, but may redirect video output from other tracked devices
            </summary>
    </member>
    <member name="T:Sandbox.VR.VROverlay">
      <summary>
        <para>VR overlays draw over the top of the 3D scene, they will not be affected by lighting,
            post processing effects or anything else in the world.<br />
            This makes them ideal for HUDs or menus, or anything else that should be local to the
            HMD or tracked devices.</para>
        <para>If you need something in the world, consider using WorldPanel
            and WorldInput instead.</para>
      </summary>
    </member>
    <member name="M:Sandbox.VR.VROverlay.Dispose">
      <summary>
            Destroys this overlay.
            </summary>
    </member>
    <member name="M:Sandbox.VR.VROverlay.Dispose(System.Boolean)">
      <summary>
            Destroys this overlay.
            </summary>
    </member>
    <member name="P:Sandbox.VR.VROverlay.Visible">
      <summary>
            Shows or hides the VR overlay.
            </summary>
    </member>
    <member name="P:Sandbox.VR.VROverlay.Transform">
      <summary>
            Sets the transform to absolute tracking origin
            </summary>
    </member>
    <member name="M:Sandbox.VR.VROverlay.SetTransformAbsolute(Transform)">
      <summary>
            Sets the transform to absolute tracking origin
            </summary>
    </member>
    <member name="P:Sandbox.VR.VROverlay.SortOrder">
      <summary>
            Sets the rendering sort order for the overlay.
            </summary>
    </member>
    <member name="P:Sandbox.VR.VROverlay.Width">
      <summary>
            The width of the overlay quad.
            By default overlays are rendered on a quad that is 1 meter across.
            </summary>
    </member>
    <member name="P:Sandbox.VR.VROverlay.Curvature">
      <summary>
            Use to draw overlay as a curved surface. Curvature is a percentage from (0..1] where 1 is a fully closed cylinder.
            For a specific radius, curvature can be computed as: overlay.width / (2 PI r).
            </summary>
    </member>
    <member name="P:Sandbox.VR.VROverlay.Color">
      <summary>
            Sets the color tint of the overlay quad. Use 0.0 to 1.0 per channel.
            Sets the alpha of the overlay quad. Use 1.0 for 100 percent opacity to 0.0 for 0 percent opacity.
            </summary>
    </member>
    <member name="P:Sandbox.VR.VROverlay.Texture">
      <summary>
            Texture that is rendered on the overlay quad.
            <see cref="T:Sandbox.TextureBuilder" /></summary>
    </member>
    <member name="P:Sandbox.VR.VROverlay.MouseScale">
      <summary>
            Sets the mouse scaling factor that is used for mouse events. 
            </summary>
    </member>
    <member name="M:Sandbox.VR.VROverlay.TriggerLaserMouseHapticVibration(System.Single,System.Single,System.Single)">
      <summary>
            Triggers a haptic event on the laser mouse controller for this overlay
            </summary>
    </member>
    <member name="T:Sandbox.VR.VRNative">
      <summary>
            Native helpers for VR
            </summary>
      <summary>
            Native helpers for VR
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRNative.IPD">
      <summary>
            Private store for distance between user's pupils, in inches.
            Accessed and converted through <see cref="P:Sandbox.VR.VRNative.IPDMillimetres" /> and <see cref="P:Sandbox.VR.VRNative.IPDInches" /></summary>
    </member>
    <member name="P:Sandbox.VR.VRNative.IPDMillimetres">
      <summary>
            Distance between user's pupils, in millimetres
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRNative.IPDInches">
      <summary>
            Distance between user's pupils, in inches
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRNative.RefreshRate">
      <summary>
            Headset refresh rate, in Hz
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRNative.IsDashboardVisible">
      <summary>
            Is the SteamVR dashboard currently visible?
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRNative.IsLeftHandDominant">
      <summary>
            Has the user selected that they're left hand dominant in SteamVR?
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRNative.FullRenderTargetSize">
      <summary>
            Spans both eyes - equivalent to (eye width * 2, eye height)
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRNative.EyeRenderTargetSize">
      <summary>
            Spans one eye
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRNative.WorldScale">
      <summary>
            Scales the relative position between the two eyes
            </summary>
    </member>
    <member name="M:Sandbox.Modals.IModalSystem.PauseMenu">
      <summary>
            The menu that is shown when escape is pressed while playing.
            </summary>
    </member>
    <member name="P:Sandbox.Modals.FriendsListModalOptions.ShowOfflineMembers">
      <summary>
            Show offline members
            </summary>
    </member>
    <member name="P:Sandbox.Modals.FriendsListModalOptions.ShowOnlineMembers">
      <summary>
            Show online (but not in-game) members
            </summary>
    </member>
    <member name="T:Sandbox.Modals.CreateGameOptions">
      <summary>
            Passed to IModalSystem.CreateGame
            </summary>
    </member>
    <member name="T:Sandbox.Rendering.SceneViewRenderTargetHandle">
      <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.GrabFrameTexture(System.String,System.Boolean)">
      <summary>
            Takes a copy of the framebuffer and returns a handle to it
            </summary>
      <param name="token" />
      <param name="withMips">Generates mipmaps on the grabbed texture filtered with gaussian blur for each mip</param>
      <returns />
    </member>
    <member name="M:Sandbox.Rendering.CommandList.GrabDepthTexture(System.String,System.Boolean)">
      <summary>
            Takes a copy of the depthbuffer and returns a handle to it
            </summary>
      <param name="token" />
      <param name="withMips">Generates mipmaps on the grabbed texture filtered with gaussian blur for each mip</param>
      <returns />
    </member>
    <member name="M:Sandbox.Rendering.CommandList.InsertList(Sandbox.Rendering.CommandList)">
      <summary>
            Run this CommandList here
            </summary>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.ExecuteOnRenderThread">
      <summary>
            Run this command list
            </summary>
    </member>
    <member name="T:Sandbox.Rendering.CommandList.Flag">
      <summary>
            Command buffer flags allow us to skip command buffers if the camera 
            doesn't want a particular thing. Like post processing.
            </summary>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.DrawModel(Sandbox.Model,Transform,Sandbox.RenderAttributes)">
      <summary>
            Draws a single model at the given Transform immediately.
            </summary>
      <param name="model">The model to draw</param>
      <param name="transform">Transform to draw the model at</param>
      <param name="attributes">Optional attributes to apply only for this draw call</param>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.DrawModelInstanced(Sandbox.Model,System.Span{Transform},Sandbox.RenderAttributes)">
      <summary>
            Draws multiple instances of a model using GPU instancing, assuming standard implemented shaders.
            
            Use `CalculateInstancingObjectToWorldMatrix` in shaders to access the instance transform.
            
            There is a limit of 1,048,576 transform slots per frame when using this method.
            </summary>
      <param name="model">The model to draw</param>
      <param name="transforms">Instance transform data to draw</param>
      <param name="attributes">Optional attributes to apply only for this draw call</param>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.DrawModelInstancedIndirect(Sandbox.Model,Sandbox.GpuBuffer,System.Int32,Sandbox.RenderAttributes)">
      <summary>
            Draws multiple instances of a model using GPU instancing with the number of instances being provided by indirect draw arguments.
            Use `SV_InstanceID` semantic in shaders to access the rendered instance.
            </summary>
      <param name="model">The model to draw</param>
      <param name="buffer">The GPU buffer containing the DrawIndirectArguments</param>
      <param name="bufferOffset">Optional offset in the GPU buffer</param>
      <param name="attributes">Optional attributes to apply only for this draw call</param>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.DrawModelInstanced(Sandbox.Model,System.Int32,Sandbox.RenderAttributes)">
      <summary>
            Draws multiple instances of a model using GPU instancing.
            This is similar to <see cref="M:Sandbox.Rendering.CommandList.DrawModelInstancedIndirect(Sandbox.Model,Sandbox.GpuBuffer,System.Int32,Sandbox.RenderAttributes)" />,
            except the count is provided from the CPU rather than via a GPU buffer.
            
            Use `SV_InstanceID` semantic in shaders to access the rendered instance.
            </summary>
      <param name="model">The model to draw</param>
      <param name="count">The number of instances to draw</param>
      <param name="attributes">Optional attributes to apply only for this draw call</param>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.Draw``1(Sandbox.GpuBuffer{``0},Sandbox.Material,System.Int32,System.Int32,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
      <summary>
            Draws geometry using a vertex buffer and material.
            </summary>
      <typeparam name="T">The vertex type used for vertex layout.</typeparam>
      <param name="vertexBuffer">The GPU buffer containing vertex data.</param>
      <param name="material">The material to use for rendering.</param>
      <param name="startVertex">The starting vertex index for rendering.</param>
      <param name="vertexCount">The number of vertices to render. If 0, uses all vertices in the buffer.</param>
      <param name="attributes">Optional render attributes to apply only for this draw call.</param>
      <param name="primitiveType">The type of primitives to render. Defaults to triangles.</param>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.DrawIndexed``1(Sandbox.GpuBuffer{``0},Sandbox.GpuBuffer,Sandbox.Material,System.Int32,System.Int32,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
      <summary>
            Draws indexed geometry using vertex and index buffers.
            </summary>
      <typeparam name="T">The vertex type used for vertex layout.</typeparam>
      <param name="vertexBuffer">The GPU buffer containing vertex data.</param>
      <param name="indexBuffer">The GPU buffer containing index data.</param>
      <param name="material">The material to use for rendering.</param>
      <param name="startIndex">The starting index for rendering.</param>
      <param name="indexCount">The number of indices to render. If 0, uses all indices in the buffer.</param>
      <param name="attributes">Optional render attributes to apply only for this draw call.</param>
      <param name="primitiveType">The type of primitives to render. Defaults to triangles.</param>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.DrawInstancedIndirect``1(Sandbox.GpuBuffer{``0},Sandbox.Material,Sandbox.GpuBuffer,System.UInt32,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
      <summary>
            Draws instanced geometry using a vertex buffer and indirect draw arguments stored in a GPU buffer.
            </summary>
      <typeparam name="T">The vertex type used for vertex layout.</typeparam>
      <param name="vertexBuffer">The GPU buffer containing vertex data.</param>
      <param name="material">The material to use for rendering.</param>
      <param name="indirectBuffer">The GPU buffer containing indirect draw arguments.</param>
      <param name="bufferOffset">Optional byte offset into the indirect buffer.</param>
      <param name="attributes">Optional render attributes to apply only for this draw call.</param>
      <param name="primitiveType">The type of primitives to render. Defaults to triangles.</param>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.DrawInstancedIndirect(Sandbox.Material,Sandbox.GpuBuffer,System.UInt32,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
      <summary>
            Draws instanced geometry using a vertex buffer and indirect draw arguments stored in a GPU buffer.
            </summary>
      <remarks>
            Vertex data is accessed in shader through buffer attribute and SV_VertexID.
            </remarks>
      <param name="material">The material to use for rendering.</param>
      <param name="indirectBuffer">The GPU buffer containing indirect draw arguments.</param>
      <param name="bufferOffset">Optional byte offset into the indirect buffer.</param>
      <param name="attributes">Optional render attributes to apply only for this draw call.</param>
      <param name="primitiveType">The type of primitives to render. Defaults to triangles.</param>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.DrawIndexedInstancedIndirect``1(Sandbox.GpuBuffer{``0},Sandbox.GpuBuffer,Sandbox.Material,Sandbox.GpuBuffer,System.UInt32,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
      <summary>
            Draws instanced indexed geometry using indirect draw arguments stored in a GPU buffer.
            </summary>
      <typeparam name="T">The vertex type used for vertex layout.</typeparam>
      <param name="vertexBuffer">The GPU buffer containing vertex data.</param>
      <param name="indexBuffer">The GPU buffer containing index data.</param>
      <param name="material">The material to use for rendering.</param>
      <param name="indirectBuffer">The GPU buffer containing indirect draw arguments.</param>
      <param name="bufferOffset">Optional byte offset into the indirect buffer.</param>
      <param name="attributes">Optional render attributes to apply only for this draw call.</param>
      <param name="primitiveType">The type of primitives to render. Defaults to triangles.</param>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.DrawIndexedInstancedIndirect(Sandbox.GpuBuffer,Sandbox.Material,Sandbox.GpuBuffer,System.UInt32,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
      <summary>
            Draws instanced indexed geometry using indirect draw arguments stored in a GPU buffer.
            </summary>
      <remarks>
            Vertex data is accessed in shader through buffer attribute and SV_VertexID.
            </remarks>
      <param name="indexBuffer">The GPU buffer containing index data.</param>
      <param name="material">The material to use for rendering.</param>
      <param name="indirectBuffer">The GPU buffer containing indirect draw arguments.</param>
      <param name="bufferOffset">Optional byte offset into the indirect buffer.</param>
      <param name="attributes">Optional render attributes to apply only for this draw call.</param>
      <param name="primitiveType">The type of primitives to render. Defaults to triangles.</param>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.GetRenderTarget(System.String,Sandbox.ImageFormat,System.Int32,System.Int32)">
      <summary>
            Get a screen size render target. 
            </summary>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.ReleaseRenderTarget(Sandbox.Rendering.RenderTargetHandle)">
      <summary>
            We're no longer using this RT, return it to the pool
            </summary>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.Set(Sandbox.StringToken,Sandbox.Rendering.RenderTargetHandle.ColorTextureRef,System.Int32)">
      <summary>
            Set the color texture from this named render target to this attribute
            </summary>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.SetGlobal(Sandbox.StringToken,Sandbox.Rendering.RenderTargetHandle.ColorIndexRef)">
      <summary>
            Set the color texture from this named render target to this attribute
            </summary>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.DispatchCompute(Sandbox.ComputeShader,System.Int32,System.Int32,System.Int32)">
      <inheritdoc cref="M:Sandbox.ComputeShader.Dispatch(System.Int32,System.Int32,System.Int32)" />
    </member>
    <member name="M:Sandbox.Rendering.CommandList.DispatchComputeIndirect(Sandbox.ComputeShader,Sandbox.GpuBuffer,System.UInt32)">
      <inheritdoc cref="M:Sandbox.ComputeShader.DispatchIndirect(Sandbox.GpuBuffer,System.UInt32)" />
    </member>
    <member name="P:Sandbox.Rendering.CommandList.ViewportSize">
      <summary>
            A handle to the viewport size
            </summary>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.DispatchCompute(Sandbox.ComputeShader,Sandbox.Rendering.RenderTargetHandle.SizeHandle)">
      <summary>
            Dispatch a compute shader
            </summary>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.GetDimension(System.String)">
      <summary>
            Called during rendering, convert RenderTargetHandle.SizeHandle to a dimension
            </summary>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.TransferRenderTarget(Sandbox.Rendering.RenderTargetHandle,Sandbox.Rendering.CommandList)">
      <summary>
            Transfers ownership of a render target from this command list to another.
            The target command list becomes responsible for the render target.
            </summary>
      <param name="handle">The render target handle to transfer</param>
      <param name="targetCommandList">The command list to transfer the render target to</param>
      <returns>A new handle that can be used with the target command list</returns>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.Clear(Color,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Clear the current drawing context to given color.
            </summary>
      <param name="color">Color to clear to.</param>
      <param name="clearColor">Whether to clear the color buffer at all.</param>
      <param name="clearDepth">Whether to clear the depth buffer.</param>
      <param name="clearStencil">Whether to clear the stencil buffer.</param>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.ResourceBarrierTransition(Sandbox.Texture,Sandbox.Rendering.ResourceState)">
      <summary>
            Executes a barrier transition for the given GPU Texture Resource.
            Transitions the texture resource to a new pipeline stage and access state.
            </summary>
      <param name="texture">The texture to transition.</param>
      <param name="state">The new resource state for the texture.</param>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.ResourceBarrierTransition(Sandbox.GpuBuffer,Sandbox.Rendering.ResourceState)">
      <summary>
            Executes a barrier transition for the given GPU Buffer Resource.
            Transitions the buffer resource to a new pipeline stage and access state.
            </summary>
      <param name="buffer">The GPU buffer to transition.</param>
      <param name="state">The new resource state for the buffer.</param>
    </member>
    <member name="M:Sandbox.Rendering.CommandList.ResourceBarrierTransition(Sandbox.GpuBuffer,Sandbox.Rendering.ResourceState,Sandbox.Rendering.ResourceState)">
      <summary>
            Executes a barrier transition for the given GPU Buffer Resource.
            Transitions the buffer resource from a known source state to a specified destination state.
            </summary>
      <param name="buffer">The GPU buffer to transition.</param>
      <param name="before">The current resource state of the buffer.</param>
      <param name="after">The desired resource state of the buffer after the transition.</param>
    </member>
    <member name="P:Sandbox.Rendering.RenderTargetHandle.ColorTexture">
      <summary>
            Reference to the color texture of this target
            </summary>
    </member>
    <member name="P:Sandbox.Rendering.RenderTargetHandle.ColorIndex">
      <summary>
            Reference to the index of the color texture of this target
            </summary>
    </member>
    <member name="P:Sandbox.Rendering.RenderTargetHandle.Size">
      <summary>
            Reference to the size of the texture
            </summary>
    </member>
    <member name="F:Sandbox.Rendering.LayerFlags.DiscardColorBuffersStore">
      <summary>
            This layer does not need to store the results of its color target rendering 
            </summary>
    </member>
    <member name="F:Sandbox.Rendering.LayerFlags.DiscardDepthStencilBufferStore">
      <summary>
            This layer does not need to store the results of its depth/stencil rendering
            </summary>
    </member>
    <member name="F:Sandbox.Rendering.LayerFlags.SortAcrossPartitions">
      <summary>
            Similar to FullSort, but instead of using depth (or custom sort key), use default sorting
            </summary>
    </member>
    <member name="F:Sandbox.Rendering.LayerFlags.NoOverrideDepthMaterial">
      <summary>
            Any layer marked IsDepthRenderingPass is subject to ShouldOverrideDepthMaterial.
            Setting this disables ShouldOverrideDepthMaterial for depth rendering.
            </summary>
    </member>
    <member name="F:Sandbox.Rendering.LayerFlags.UseVolumePyramidSpotlightGeo">
      <summary>
            Use pyramid geometry for light rendering instead of cone geo. Don't restrict to geometry
            </summary>
    </member>
    <member name="T:Sandbox.Rendering.RenderLayer">
      <summary>
            ISceneLayer which is basically a render pass
            </summary>
      <remarks>Maybe we just call this RenderPass like every other engine.</remarks>
    </member>
    <member name="P:Sandbox.Rendering.RenderLayer.ShaderMode">
      <summary>
            Renders all matching scene objects with this shader mode if applicable
            </summary>
    </member>
    <member name="P:Sandbox.Rendering.RenderLayer.ObjectFlagsRequired">
      <summary>
            Scene objects must have these flags to be included in the layer
            </summary>
    </member>
    <member name="P:Sandbox.Rendering.RenderLayer.ObjectFlagsExcluded">
      <summary>
            Scene objects with these flags will be excluded from the layer
            </summary>
    </member>
    <member name="P:Sandbox.Rendering.RenderLayer.RenderTargetAttributes">
      <summary>
            Deferred render target attributes
            </summary>
    </member>
    <member name="M:Sandbox.Rendering.RenderLayer.AddToView(NativeEngine.ISceneView,NativeEngine.RenderViewport)">
      <summary>
            Add to view
            </summary>
      <remarks>Passing viewport here might not be what we want</remarks>
    </member>
    <member name="T:Sandbox.Rendering.ProceduralRenderLayer">
      <summary>
            A render layer with a callback
            </summary>
    </member>
    <member name="T:Sandbox.Rendering.RenderPipeline">
      <summary>
            Start moving the c++ render pipeline here
            It won't be the prettiest to start, but we can start simplifying afterwards
            </summary>
    </member>
    <member name="T:Sandbox.Rendering.ResourceState">
      <summary>
            Used to describe a GPU resources state for barrier transitions.
            </summary>
      <remarks>
            These match DX12's D3D12_RESOURCE_STATES as it's a nice high level description of resource states,
            which can be translated to lower level graphics APIs.
            </remarks>
    </member>
    <member name="F:Sandbox.Rendering.SceneObjectFlags.HideInCubemaps">
      <summary>
            Not rendered in cubemaps
            </summary>
    </member>
    <member name="T:Sandbox.DelegateFunctionPointer">
      <summary>
            Helper to wrap <see cref="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)" /> while keeping
            a reference to the original delegate, so it won't be garbage collected. <see cref="M:Sandbox.DelegateFunctionPointer.Dispose" />
            must be called to remove the reference.
            </summary>
    </member>
    <member name="M:Sandbox.DelegateFunctionPointer.op_Implicit(Sandbox.DelegateFunctionPointer)~System.IntPtr">
      <summary>
            Gets the raw function pointer.
            </summary>
    </member>
    <member name="M:Sandbox.DelegateFunctionPointer.Get``1(``0)">
      <inheritdoc cref="T:Sandbox.DelegateFunctionPointer" />
    </member>
    <member name="M:Sandbox.DelegateFunctionPointer.Dispose">
      <summary>
            Removes the reference to the original delegate, and sets the function pointer to null.
            </summary>
    </member>
    <member name="T:Sandbox.IHandle">
      <summary>
            A base interface that all handles should use
            </summary>
    </member>
    <member name="T:Sandbox.HandleCreationData">
      <summary>
            This struct exists to differentiate the constructor of a handle object
            from the regular constructors. This way we can prevent clients creating
            the object manually, but still be able to create them at runtime.
            </summary>
    </member>
    <member name="T:Sandbox.HandleIndex">
      <summary>
            An index that can convert from a handle (int) to a class. This is
            usually a static on your Handle object called HandleIndex.
            </summary>
    </member>
    <member name="M:Sandbox.Interop.GetString(System.IntPtr)">
      <summary>
            Convert a native utf pointer to a string
            </summary>
    </member>
    <member name="M:Sandbox.Interop.GetString(System.IntPtr,System.Int32)">
      <summary>
            Convert a native utf pointer to a string
            </summary>
    </member>
    <member name="M:Sandbox.Interop.GetUtf8Length(System.Byte*,System.Int32)">
      <summary>
            Get the length of a null-terminated UTF-8 string using AVX2 (fallback to scalar if unavailable)
            </summary>
    </member>
    <member name="M:Sandbox.Interop.GetWString(System.IntPtr)">
      <summary>
            Convert a native utf pointer to a string
            </summary>
    </member>
    <member name="M:Sandbox.Interop.GetWString(System.IntPtr,System.Int32)">
      <summary>
            Convert a native utf pointer to a string
            </summary>
    </member>
    <member name="M:Sandbox.Interop.BindingException(System.String,System.String,System.Exception)">
      <summary>
            Called by the binding system to log an exception when calling a binding
            </summary>
    </member>
    <member name="T:Sandbox.Interop.PassBackString">
      <summary>
            used to pass a string back to native
            </summary>
    </member>
    <member name="M:Sandbox.Interop.GetTemporaryStringPointerForNative(System.String)">
      <summary>
            This is called when native calls a managed function and it returns a string. In this case
            we can't free the string immediately, so we store it in a list and free it at the end of the frame.
            This has potential to crash, if we free the string before the thread uses it but this would be super 
            rare and the other option is to never return strings like this.
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsBodyType.Static">
      <inheritdoc cref="F:Sandbox.PhysicsMotionType.Static" />
    </member>
    <member name="F:Sandbox.PhysicsBodyType.Keyframed">
      <inheritdoc cref="F:Sandbox.PhysicsMotionType.Keyframed" />
    </member>
    <member name="F:Sandbox.PhysicsBodyType.Dynamic">
      <inheritdoc cref="F:Sandbox.PhysicsMotionType.Dynamic" />
    </member>
    <member name="T:Sandbox.PhysicsMotionType">
      <summary>
            Represents <see cref="T:Sandbox.PhysicsBody">Physics body's</see> motion type.
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsMotionType.Invalid">
      <summary>
            Invalid type.
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsMotionType.Dynamic">
      <summary>
            Physically simulated body.
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsMotionType.Static">
      <summary>
            Cannot move at all.
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsMotionType.Keyframed">
      <summary>
            No physics simulation, but can be moved via setting position/rotation.
            </summary>
    </member>
    <member name="P:Sandbox.Network.ServerInfo.IsDeveloperHost">
      <summary>
            If true then this host is being run from an editor, as such the assemblies
            are sent via network tables and loading assemblies from the package is not required.
            </summary>
    </member>
    <member name="T:Sandbox.Network.ServerCommand">
      <summary>
            A console command was run on a client but is being forwarded to the server. This is the message
            that contains the details of that command.
            </summary>
    </member>
    <member name="T:Sandbox.Network.UserInfoUpdate">
      <summary>
            A UserInfo ConVar value was changed on a client. This message is intended for the host so that they
            can propagate this change to all clients.
            </summary>
    </member>
    <member name="T:Sandbox.Network.LogMsg">
      <summary>
            A simple log message packet. This is used by <see cref="M:Sandbox.Connection.SendLog(Sandbox.LogLevel,System.String)" /> when logging
            to another client's console.
            </summary>
    </member>
    <member name="T:Sandbox.Network.ReconnectMsg">
      <summary>
            Sent to the server to tell clients to reconnect. This is sent when
            the server is changing games, or maps, and wants the current players
            to follow them to the new game, or map.
            We send the Game and Map to the best of our knowledge, so the client
            can maybe preload them, while we are.
            </summary>
    </member>
    <member name="M:Sandbox.Network.ConnectionInfoManager.Get(System.Guid)">
      <summary>
            Get info for this connection
            </summary>
    </member>
    <member name="T:Sandbox.Network.ConnectionInfo">
      <summary>
            Information about a connection. The difference between this and the actual connections is that
            this can be networked between clients, so all clients have the same information about each other.
            This is going to be required in p2p games, where players need to take over hosting from each other.
            In a game like Rust, with a dedicated server, this won't need to be networked to other clients.
            </summary>
    </member>
    <member name="P:Sandbox.Network.ConnectionInfo.UserData">
      <summary>
            Key values that come straight from the user. Can't be trusted, they could send anything. Used
            for things like preferences, avatar clothing etc.
            </summary>
    </member>
    <member name="F:Sandbox.Network.ConnectionInfo._localMock">
      <summary>
            When a user isn't connected to a server, or hosting a server, the
            client info table doesn't exist. So we provide info here for the
            local connection.
            </summary>
    </member>
    <member name="P:Sandbox.Network.ConnectionStats.Ping">
      <summary>
            Current ping for this connection.
            </summary>
    </member>
    <member name="P:Sandbox.Network.ConnectionStats.OutPacketsPerSecond">
      <summary>
            How many packets per second we're sending to this connection.
            </summary>
    </member>
    <member name="P:Sandbox.Network.ConnectionStats.OutBytesPerSecond">
      <summary>
            How many bytes per second we're sending to this connection.
            </summary>
    </member>
    <member name="P:Sandbox.Network.ConnectionStats.InPacketsPerSecond">
      <summary>
            How many packets per second we're receiving from this connection.
            </summary>
    </member>
    <member name="P:Sandbox.Network.ConnectionStats.InBytesPerSecond">
      <summary>
            How many bytes per second we're receiving from this connection.
            </summary>
    </member>
    <member name="P:Sandbox.Network.ConnectionStats.SendRateBytesPerSecond">
      <summary>
            Estimate rate that we believe we can send data to this connection.
            </summary>
    </member>
    <member name="P:Sandbox.Network.ConnectionStats.ConnectionQuality">
      <summary>
            From 0 to 1 how good is our connection to this?
            </summary>
    </member>
    <member name="T:Sandbox.Network.GameNetworkSystem">
      <summary>
            An instance of this is created by the NetworkSystem when a server is joined, or created.
            You should not try to create this manually.
            </summary>
    </member>
    <member name="M:Sandbox.Network.GameNetworkSystem.AcceptConnection(Sandbox.Connection,System.String@)">
      <summary>
            Called on the host to decide whether to accept a <see cref="T:Sandbox.Connection" />.
            </summary>
      <param name="channel" />
      <param name="reason">The reason to display to the client.</param>
    </member>
    <member name="M:Sandbox.Network.GameNetworkSystem.OnInitialize">
      <summary>
            Called when the network system should handle initialization.
            </summary>
    </member>
    <member name="M:Sandbox.Network.GameNetworkSystem.OnConnected(Sandbox.Connection)">
      <summary>
            A client has connected to the server but hasn't fully finished joining yet.
            </summary>
    </member>
    <member name="M:Sandbox.Network.GameNetworkSystem.OnJoined(Sandbox.Connection)">
      <summary>
            Fully joined the server. Can be called when changing the map too. The game should usually create
            some object for the player to control here.
            </summary>
    </member>
    <member name="M:Sandbox.Network.GameNetworkSystem.OnLeave(Sandbox.Connection)">
      <summary>
            A client has disconnected from the server.
            </summary>
    </member>
    <member name="M:Sandbox.Network.GameNetworkSystem.OnBecameHost(Sandbox.Connection)">
      <summary>
            The host left the server and you are now in charge.
            </summary>
    </member>
    <member name="M:Sandbox.Network.GameNetworkSystem.OnHostChanged(Sandbox.Connection,Sandbox.Connection)">
      <summary>
            The current host has been changed.
            </summary>
    </member>
    <member name="P:Sandbox.Network.GameNetworkSystem.IsHostBusy">
      <summary>
            Whether the host is busy right now. This can be used to determine if
            the host can be changed.
            </summary>
    </member>
    <member name="M:Sandbox.Network.GameNetworkSystem.Push">
      <summary>
            Allows to push some kind of scope when reading network messages. This is useful if you
            need to adjust Time.Now etc.
            </summary>
    </member>
    <member name="M:Sandbox.Network.GameNetworkSystem.Tick">
      <summary>
            Called every frame
            </summary>
    </member>
    <member name="M:Sandbox.Network.GameNetworkSystem.OnHeartbeat(System.Single)">
      <summary>
            A heartbeat has been received from the host. We should make sure our times are in sync.
            </summary>
    </member>
    <member name="M:Sandbox.Network.GameNetworkSystem.OnDeltaSnapshotMessage(Sandbox.Network.InternalMessageType,Sandbox.ByteStream,Sandbox.Connection)">
      <summary>
            A delta snapshot message has been received from another connection.
            </summary>
    </member>
    <member name="P:Sandbox.Network.GameNetworkSystem.IsHost">
      <summary>
            True if we can be considered the host of this session. Either we're not connected to a server, or we are and we are the host.
            </summary>
    </member>
    <member name="P:Sandbox.Network.GameNetworkSystem.IsClient">
      <summary>
            True if we're connected to a server and not the host.
            </summary>
    </member>
    <member name="P:Sandbox.Network.GameNetworkSystem.IsConnecting">
      <summary>
            True if we're currently connecting to the server
            </summary>
    </member>
    <member name="P:Sandbox.Network.GameNetworkSystem.IsActive">
      <summary>
            True if we're currently connected etc
            </summary>
    </member>
    <member name="M:Sandbox.Network.GameNetworkSystem.OnLoadedScene(System.String)">
      <summary>
            Called after we've loaded a new scene.
            </summary>
    </member>
    <member name="P:Sandbox.Network.LobbyInformation.IsFull">
      <summary>
            True if this lobby is full (Members &gt;= MaxMembers).
            </summary>
    </member>
    <member name="P:Sandbox.Network.LobbyInformation.IsHidden">
      <summary>
            True if this lobby should be hidden from server lists.
            </summary>
    </member>
    <member name="P:Sandbox.Network.LobbyInformation.ContainsFriends">
      <summary>
            Return true if this lobby contains a friend.
            </summary>
    </member>
    <member name="P:Sandbox.Network.DedicatedServer.Data">
      <summary>
            All metadata for this dedicated server.
            </summary>
    </member>
    <member name="P:Sandbox.Network.DedicatedServer.Name">
      <summary>
            The current name of the dedicated server.
            </summary>
    </member>
    <member name="P:Sandbox.Network.DedicatedServer.MapName">
      <summary>
            The current map name of the dedicated server.
            </summary>
    </member>
    <member name="M:Sandbox.Network.DedicatedServer.SetData(System.String,System.String)">
      <summary>
            Set data for this dedicated server. This data is used when querying or filtering servers. Uses game tags
            internally, which have a hardcoded character limit enforced by Steam.
            </summary>
    </member>
    <member name="M:Sandbox.Network.DedicatedServer.GetData(System.String)">
      <summary>
            Get data for this dedicated server. This data is used when querying or filtering servers.
            </summary>
    </member>
    <member name="T:Sandbox.Network.InternalMessageType">
      <summary>
            A network system is a bunch of connections that people can send messages 
            over. Right now it can be a dedicated server, a listen server, a pure client,
            or a p2p system.
            </summary>
    </member>
    <member name="F:Sandbox.Network.InternalMessageType.HeartbeatPing">
      <summary>
            A small message sent from the host to the client, and then returned to measure latency and keep
            everything in sync.
            </summary>
    </member>
    <member name="F:Sandbox.Network.InternalMessageType.Chunk">
      <summary>
            Is multiple chunks of the same message
            </summary>
    </member>
    <member name="F:Sandbox.Network.InternalMessageType.Packed">
      <summary>
            Is a struct packed using TypeLibrary
            </summary>
    </member>
    <member name="F:Sandbox.Network.InternalMessageType.DeltaSnapshot">
      <summary>
            Is a delta snapshot message
            </summary>
    </member>
    <member name="F:Sandbox.Network.InternalMessageType.DeltaSnapshotCluster">
      <summary>
            Is a delta snapshot cluster message
            </summary>
    </member>
    <member name="F:Sandbox.Network.InternalMessageType.DeltaSnapshotAck">
      <summary>
            Is a delta snapshot acknowledgement
            </summary>
    </member>
    <member name="F:Sandbox.Network.InternalMessageType.DeltaSnapshotClusterAck">
      <summary>
            Is a delta snapshot cluster acknowledgement
            </summary>
    </member>
    <member name="F:Sandbox.Network.InternalMessageType.Request">
      <summary>
            A request, this is a guid, then another message
            </summary>
    </member>
    <member name="F:Sandbox.Network.InternalMessageType.Response">
      <summary>
            A response, this is a guid, then another message
            </summary>
    </member>
    <member name="P:Sandbox.Network.LobbyConfig.DestroyWhenHostLeaves">
      <summary>
            Whether to automatically destroy this lobby when the host leaves. This is only
            applicable to P2P lobbies.
            </summary>
    </member>
    <member name="P:Sandbox.Network.LobbyConfig.AutoSwitchToBestHost">
      <summary>
            Whether to periodically switch to the best possible host candidate. This is only
            applicable to P2P lobbies.
            </summary>
    </member>
    <member name="P:Sandbox.Network.LobbyConfig.Hidden">
      <summary>
            Whether to hide this lobby from appearing in the server list. It will still be
            queryable programatically, so long as the <see cref="P:Sandbox.Network.LobbyConfig.Privacy" /> mode allows it.
            </summary>
    </member>
    <member name="P:Sandbox.Network.LobbyConfig.Privacy">
      <summary>
            Determines who is able to connect to this lobby. This will be public by default.
            </summary>
    </member>
    <member name="P:Sandbox.Network.LobbyConfig.MaxPlayers">
      <summary>
            The maximum amount of players this lobby can hold. By default, this will be
            the Max Players set in the current Game Package's project settings.
            </summary>
    </member>
    <member name="P:Sandbox.Network.LobbyConfig.Name">
      <summary>
            The name of this lobby. If this isn't set, a default lobby name will be chosen instead.
            </summary>
    </member>
    <member name="F:Sandbox.Network.LobbyPrivacy.Public">
      <summary>
            This lobby is open to everyone.
            </summary>
    </member>
    <member name="F:Sandbox.Network.LobbyPrivacy.Private">
      <summary>
            Nobody can join this lobby unless they are invited.
            </summary>
    </member>
    <member name="F:Sandbox.Network.LobbyPrivacy.FriendsOnly">
      <summary>
            Only friends can join this lobby.
            </summary>
    </member>
    <member name="P:Sandbox.Network.NetworkSocket.AutoDispose">
      <summary>
            Whether this socket should be disposed automatically when the network system
            it belongs to is disconnected.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSocket.ProcessMessagesInThread">
      <summary>
            This is called on a worker thread and should handle any threaded processing of messages.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSocket.Initialize(Sandbox.Network.NetworkSystem)">
      <summary>
            Called when everything has just been hooked up to the network system.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSocket.OnConnectionInfoUpdated(Sandbox.Network.NetworkSystem)">
      <summary>
            ConnectionInfo table has been updated
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSocket.OnSessionFailed(Sandbox.SteamId)">
      <summary>
            Called when a session has failed with a user. Steam Networking Messages will invoke this callback
            if an attempt to send a message to a user failed because of a broken session.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSocket.SetData(System.String,System.String)">
      <summary>
            Set data about this socket. For example, this might be used to change whether a lobby
            should be visible for players depending on the game state.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSocket.SetServerName(System.String)">
      <summary>
            Set the name of the server. This will be displayed to other players when they
            query servers.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSocket.SetMapName(System.String)">
      <summary>
            Set the current map name. This will be displayed to other players when they
            query servers.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSocket.Tick(Sandbox.Network.NetworkSystem)">
      <summary>
            Called once a second
            </summary>
    </member>
    <member name="T:Sandbox.Network.NetworkSystem">
      <summary>
            A network system is a bunch of connections that people can send messages 
            over. Right now it can be a dedicated server, a listen server, a pure client,
            or a p2p system.
            </summary>
      <summary>
            A network system is a bunch of connections that people can send messages 
            over. Right now it can be a dedicated server, a listen server, a pure client,
            or a p2p system.
            </summary>
      <summary>
            A network system is a bunch of connections that people can send messages 
            over. Right now it can be a dedicated server, a listen server, a pure client,
            or a p2p system.
            </summary>
    </member>
    <member name="P:Sandbox.Network.NetworkSystem.IsConnecting">
      <summary>
            True if we're currently connecting to the server. We're not yet spawned etc.
            </summary>
    </member>
    <member name="P:Sandbox.Network.NetworkSystem.IsDeveloperHost">
      <summary>
            If true then this host is sending assemblies and other files via network tables
            and as such, does not need to load assemblies from the package (if it even exists).
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.IsHandshaking">
      <summary>
            Get whether there are any connections still doing the handshake process.
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.FindConnection(System.Guid)">
      <summary>
            Find a connection by its unique id.
            </summary>
      <param name="id" />
      <returns />
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.StartHandshake(Sandbox.Connection)">
      <summary>
            Start the handshaking process with the specified client <see cref="P:Sandbox.Network.NetworkSystem.Connection" />.
            </summary>
      <param name="channel" />
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.RestartHandshake">
      <summary>
            Restart the handshaking process. This could be used if the host changed
            while we're connecting.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.AddConnection(Sandbox.Connection,Sandbox.UserInfo)">
      <summary>
            Called from the host to add a connection to the ConnectionInfo table
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.OnServerDisconnection(System.Int32,System.String)">
      <summary>
            We were disconnected from the server. This will almost always be when we're on a dedicated server
            and it has closed down.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.OnConnectionInfoUpdated">
      <summary>
            Called any time we suspect the connection info might have changed, which
            lets us tell the sockets/connections to update any information they hold.
            </summary>
    </member>
    <member name="P:Sandbox.Network.NetworkSystem.IsHost">
      <summary>
            Are we the owner of this network system? True if we're hosting
            the server, or we're the current owner of a p2p system.
            </summary>
    </member>
    <member name="P:Sandbox.Network.NetworkSystem.IsDisconnected">
      <summary>
            Has this network system been disconnected?
            </summary>
    </member>
    <member name="P:Sandbox.Network.NetworkSystem.IsHostBusy">
      <summary>
            Whether the host is busy right now. This can be used to determine if
            the host can be changed.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.OnLogMsg(Sandbox.Network.LogMsg,Sandbox.Connection,System.Guid)">
      <summary>
            We have received a log message from another client.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.OnUserInfoUpdate(Sandbox.Network.UserInfoUpdate,Sandbox.Connection,System.Guid)">
      <summary>
            We have received a UserInfo ConVar value update from a client.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.OnServerCommand(Sandbox.Network.ServerCommand,Sandbox.Connection,System.Guid)">
      <summary>
            We have received a console command from a client that should be run on the server.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.OnReceiveHostStats(Sandbox.Network.HostStats,Sandbox.Connection,System.Guid)">
      <summary>
            We have received network / performance stats from the server.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.OnReceiveServerName(Sandbox.Network.ServerNameMsg,Sandbox.Connection,System.Guid)">
      <summary>
            We have received a changed server name.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.OnReceiveMapName(Sandbox.Network.MapNameMsg,Sandbox.Connection,System.Guid)">
      <summary>
            We have received a changed map name.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.OnReceiveServerData(Sandbox.Network.ServerDataMsg,Sandbox.Connection,System.Guid)">
      <summary>
            We have received changed data from the server.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.OnReconnectMsg(Sandbox.Network.ReconnectMsg,Sandbox.Connection,System.Guid)">
      <summary>
            The server has told us to reconnect
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.OnTargetedInternalMessage(Sandbox.Network.TargetedInternalMessage,Sandbox.Connection,System.Guid)">
      <summary>
            We have received a message intended for a different connection.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.OnTargetedMessage(Sandbox.Network.TargetedMessage,Sandbox.Connection,System.Guid)">
      <summary>
            We have received a message intended for a different connection.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.Tick">
      <summary>
            Called to read and process incoming messages.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.On_Handshake_ServerInfo(Sandbox.Network.ServerInfo,Sandbox.Connection,System.Guid)">
      <summary>
            Server says hello to the client. It tells the client some basic information about itself.
            The client can determine here whether they still want to join or not.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.ProcessMessagesInThread">
      <summary>
            Process any incoming or outgoing messages. This would usually be called on a worker thread unless
            threaded networking is disabled.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.Broadcast(Sandbox.ByteStream,Sandbox.Connection.ChannelState,System.Nullable{Sandbox.Connection.Filter},Sandbox.NetFlags)">
      <summary>
            Send a message to all connections. You can optionally pass in a filter to determine who actually receives the message.
            </summary>
      <param name="msg">The message to send.</param>
      <param name="minimumState">The minumum state the connection must be to receive the message.</param>
      <param name="filter">If specified, the connection must pass this filter to receive the message.</param>
      <param name="flags">Network message flags that may dictate how the message is sent.</param>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.Broadcast``1(``0,Sandbox.Connection.ChannelState,System.Nullable{Sandbox.Connection.Filter},Sandbox.NetFlags)">
      <summary>
            Broadcast a packed message to all connections.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.GetFilteredConnections(Sandbox.Connection.ChannelState,System.Nullable{Sandbox.Connection.Filter})">
      <summary>
            Get a list of connections that meet a specific criteria.
            </summary>
      <param name="minimumState">The minumum state the connection must be to receive the message.</param>
      <param name="filter">If specified, the connection must pass this filter to receive the message.</param>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.InstallStringTables">
      <summary>
            String tables should all get installed at this point.
            </summary>
    </member>
    <member name="M:Sandbox.Network.NetworkSystem.InstallTable(Sandbox.Network.StringTable)">
      <summary>
            Install a network table. If we're the host then this table will
            be sent to all clients.. but only if they have the same named network
            table installed.
            </summary>
    </member>
    <member name="F:Sandbox.Network.StringTable.MaxSnapshotEntrySize">
      <summary>
            The maximum size of a snapshot entry in megabytes.
            </summary>
    </member>
    <member name="F:Sandbox.Network.StringTable.OnChangeOrAdd">
      <summary>
            Called when a table entry is changed or added from the network
            </summary>
    </member>
    <member name="F:Sandbox.Network.StringTable.OnSnapshot">
      <summary>
            The table has been fully replaced. Anything or everything could have changed.
            </summary>
    </member>
    <member name="F:Sandbox.Network.StringTable.OnRemoved">
      <summary>
            Called when a table entry is removed by the network
            </summary>
    </member>
    <member name="F:Sandbox.Network.StringTable.PostNetworkUpdate">
      <summary>
            Called after a network update of the table is complete. Not called after snapshots!
            </summary>
    </member>
    <member name="M:Sandbox.Network.StringTable.Entry.Read``1">
      <summary>
            Read an unmanaged struct from the data
            </summary>
    </member>
    <member name="T:Sandbox.Network.LocalConnection">
      <summary>
            A mock channel. Allows passing this to RPCs when they're being called locally.
            </summary>
    </member>
    <member name="T:Sandbox.Network.MockConnection">
      <summary>
            A mock channel. Allows passing this to RPCs when they're being called locally. Mock connections
            will also exist for other clients when connected to a dedicated server. If we try to send a message
            to one, we'll route that message through the server instead.
            </summary>
    </member>
    <member name="T:Sandbox.Network.SteamLobbyConnection">
      <summary>
            A direct connection to a peer in a lobby.
            </summary>
    </member>
    <member name="T:Sandbox.Network.SteamLobbySocket">
      <summary>
            A fake socket that wraps around a Steam lobby.
            </summary>
    </member>
    <member name="F:Sandbox.Network.SteamLobbySocket.nextTryFindHost">
      <summary>
            The time until we should try to find a new host.
            </summary>
    </member>
    <member name="P:Sandbox.Network.SteamLobbySocket.HostSteamId">
      <summary>
            The SteamId of the host of this lobby.
            </summary>
    </member>
    <member name="P:Sandbox.Network.SteamLobbySocket.LobbySteamId">
      <summary>
            The SteamId of the host of this lobby.
            </summary>
    </member>
    <member name="P:Sandbox.Network.SteamLobbySocket.LobbyMemberCount">
      <summary>
            How many cunts are in this lobby.
            </summary>
    </member>
    <member name="F:Sandbox.Network.SteamLobbySocket.Owner">
      <summary>
            Current owner of this lobby.
            </summary>
    </member>
    <member name="F:Sandbox.Network.SteamLobbySocket.SteamLobby">
      <summary>
            The underlying Steam lobby.
            </summary>
    </member>
    <member name="F:Sandbox.Network.SteamLobbySocket.config">
      <summary>
            Current config of this lobby.
            </summary>
    </member>
    <member name="M:Sandbox.Network.SteamLobbySocket.SendMessage(System.UInt64,System.Byte[]@,System.Int32)">
      <summary>
            Enqueue a message to be sent to a user on a different thread.
            </summary>
      <param name="steamId" />
      <param name="data" />
      <param name="flags" />
    </member>
    <member name="M:Sandbox.Network.SteamLobbySocket.ProcessIncomingMessages(ISteamNetworkingMessages@,System.Int32)">
      <summary>
            Process any incoming messages from Steam networking and enqueue them to be
            handled by the main thread.
            </summary>
      <param name="net" />
      <param name="channel" />
    </member>
    <member name="M:Sandbox.Network.SteamLobbySocket.ProcessOutgoingMessage(ISteamNetworkingMessages,Sandbox.Network.SteamLobbySocket.OutgoingMessage@)">
      <summary>
            Send any queued outgoing messages via Steam Networking API. 
            </summary>
    </member>
    <member name="M:Sandbox.Network.SteamLobbySocket.ProcessMessagesInThread">
      <summary>
            Send any queued outgoing messages and process any incoming messages to be queued for handling
            on the main thread.
            </summary>
    </member>
    <member name="M:Sandbox.Network.SteamLobbySocket.SetConnectionId(System.UInt64,Sandbox.Network.ConnectionInfo)">
      <summary>
            Make sure this steamid has this connection id
            </summary>
    </member>
    <member name="T:Sandbox.Network.SteamNetwork.IdConnection">
      <summary>
            A connection to a SteamId. This can be a SteamId of an individual Steam user
            or an assigned SteamId for a game server.
            </summary>
    </member>
    <member name="T:Sandbox.Network.SteamNetwork.IpConnection">
      <summary>
            A connection to an IP and port.
            </summary>
    </member>
    <member name="T:Sandbox.Network.SteamNetwork.SocketConnection">
      <summary>
            A connection from a listen socket.
            </summary>
    </member>
    <member name="M:Sandbox.Network.SteamNetwork.Connection.ProcessMessagesInThread">
      <summary>
            Send any queued outgoing messages and process any incoming messages to be queued for handling
            on the main thread.
            </summary>
    </member>
    <member name="M:Sandbox.Network.SteamNetwork.Connection.ProcessIncomingMessages(ISteamNetworkingSockets)">
      <summary>
            Process any incoming messages from Steam networking and enqueue them to be
            handled by the main thread.
            </summary>
      <param name="net" />
    </member>
    <member name="M:Sandbox.Network.SteamNetwork.Connection.ProcessOutgoingMessage(Sandbox.Network.OutgoingSteamMessage@)">
      <summary>
            Send any queued outgoing messages via Steam Networking API. 
            </summary>
      <param name="msg" />
    </member>
    <member name="M:Sandbox.Network.SteamNetwork.RunCallbacks">
      <summary>
            This gets called by the SteamAPI, so only really need to call this in unit tests.
            </summary>
    </member>
    <member name="T:Sandbox.Network.SteamNetwork.IdListenSocket">
      <summary>
            A socket that listens on a SteamId and virtual port.
            </summary>
    </member>
    <member name="T:Sandbox.Network.SteamNetwork.IpListenSocket">
      <summary>
            A socket that listens on an IP address and port.
            </summary>
    </member>
    <member name="T:Sandbox.Network.SteamNetwork.Socket">
      <summary>
            A listen socket, one socket to many. We should really use this just for dedicated servers.
            </summary>
    </member>
    <member name="M:Sandbox.Network.SteamNetwork.Socket.SendMessage(Sandbox.Network.HSteamNetConnection,System.Byte[]@,System.Int32)">
      <summary>
            Enqueue a message to be sent to a user on a different thread.
            </summary>
      <param name="connection" />
      <param name="data" />
      <param name="flags" />
    </member>
    <member name="M:Sandbox.Network.SteamNetwork.Socket.ProcessMessagesInThread">
      <summary>
            Send any queued outgoing messages and process any incoming messages to be queued for handling
            on the main thread.
            </summary>
    </member>
    <member name="M:Sandbox.Network.SteamNetwork.Socket.ProcessIncomingMessages(ISteamNetworkingSockets@)">
      <summary>
            Process any incoming messages from Steam networking and enqueue them to be
            handled by the main thread.
            </summary>
      <param name="net" />
    </member>
    <member name="M:Sandbox.Network.SteamNetwork.Socket.ProcessOutgoingMessage(Sandbox.Network.OutgoingSteamMessage@)">
      <summary>
            Send any queued outgoing messages via Steam Networking API. 
            </summary>
      <param name="msg" />
    </member>
    <member name="T:Sandbox.Network.HSteamNetConnection">
      <summary>
            A handle to a connection.
            </summary>
    </member>
    <member name="T:Sandbox.Network.HSteamListenSocket">
      <summary>
            A handle to a listen socket
            </summary>
    </member>
    <member name="T:Sandbox.Network.HSteamNetPollGroup">
      <summary>
            A handle to a poll group
            </summary>
    </member>
    <member name="T:Sandbox.Network.TcpChannel">
      <summary>
            A listen socket, one socket to many. We should really use this just dedicated servers imo.
            </summary>
    </member>
    <member name="M:Sandbox.Network.TcpChannel.SendThread(System.Threading.CancellationToken)">
      <summary>
            Send the network data in a thread. This prevents the client from freezing
            up when running a client and server in the same process. In reality this only
            really happens in unit tests, but better safe than sorry.
            </summary>
    </member>
    <member name="T:Sandbox.Network.TcpSocket">
      <summary>
            A listen socket over TCP. For testing locally.
            </summary>
    </member>
    <member name="T:Sandbox.Networking">
      <summary>
            Global manager to hold and tick the singleton instance of NetworkSystem.
            </summary>
    </member>
    <member name="M:Sandbox.Networking.SetData(System.String,System.String)">
      <summary>
            Set data about the current server or lobby. Other players can query this
            when searching for a game. Note: for now, try to keep the key and value as short
            as possible, Steam enforce a character limit on server tags, so it could be possible
            to reach that limit when running a Dedicated Server. In the future we'll store this
            stuff on our backend, so that won't be a problem.
            </summary>
    </member>
    <member name="M:Sandbox.Networking.GetData(System.String,System.String)">
      <summary>
            Get data about the current server or lobby. This data can be used for filtering
            when querying lobbies.
            </summary>
    </member>
    <member name="P:Sandbox.Networking.ServerName">
      <summary>
            The name of the server you are currently connected to.
            </summary>
    </member>
    <member name="P:Sandbox.Networking.MapName">
      <summary>
            The name of the map being used on the server you're connected to.
            </summary>
    </member>
    <member name="P:Sandbox.Networking.MaxPlayers">
      <summary>
            The maximum number of players allowed on the server you're connected to.
            </summary>
    </member>
    <member name="P:Sandbox.Networking.LastConnectionString">
      <summary>
            The last connection string used to connect to a server.
            </summary>
    </member>
    <member name="P:Sandbox.Networking.HostStats">
      <summary>
            Get the latest host stats such as bandwidth used and the current frame rate.
            </summary>
    </member>
    <member name="P:Sandbox.Networking.IsHost">
      <summary>
            True if we can be considered the host of this session. Either we're not connected to a server, or we are host of a server.
            </summary>
    </member>
    <member name="P:Sandbox.Networking.IsClient">
      <summary>
            True if we're currently connected to a server, and we are not the host
            </summary>
    </member>
    <member name="P:Sandbox.Networking.IsConnecting">
      <summary>
            True if we're currently connecting to the server
            </summary>
    </member>
    <member name="P:Sandbox.Networking.IsActive">
      <summary>
            True if we're currently connecting to the server
            </summary>
    </member>
    <member name="P:Sandbox.Networking.IsDisconnecting">
      <summary>
            True if we're currently disconnecting from the server
            </summary>
    </member>
    <member name="P:Sandbox.Networking.HostConnection">
      <summary>
            The connection of the current network host.
            </summary>
    </member>
    <member name="P:Sandbox.Networking.IsHostBusy">
      <summary>
            Whether the host is busy right now. This can be used to determine if
            the host can be changed.
            </summary>
    </member>
    <member name="P:Sandbox.Networking.Connections">
      <summary>
            A list of connections that are currently on this server. If you're not on a server
            this will return only one connection (Connection.Local). Some games restrict the 
            connection list - in which case you will get an empty list.
            </summary>
    </member>
    <member name="M:Sandbox.Networking.UpdateServerName(System.String)">
      <summary>
            Internally update the server name without propagating to sockets.
            </summary>
      <param name="name" />
    </member>
    <member name="M:Sandbox.Networking.GetSteamRelayStatus(System.String@)">
      <summary>
            Get the status of our connection to the Steam Datagram Relay service.
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.Networking.Reset">
      <summary>
            Reset any static members to their defaults or clear them.
            </summary>
    </member>
    <member name="M:Sandbox.Networking.JoinBestLobby(System.String)">
      <summary>
            Try to join the best lobby. Return true on success.
            </summary>
    </member>
    <member name="P:Sandbox.Networking.EditorLobbyPrivacy">
      <summary>
            When creating a lobby from the editor, we'll use this override for the lobby privacy.
            </summary>
    </member>
    <member name="M:Sandbox.Networking.CreateLobby(Sandbox.Network.LobbyConfig)">
      <summary>
            Will create a new lobby with the specified <see cref="T:Sandbox.Network.LobbyConfig" /> to
            customize the lobby further.
            </summary>
    </member>
    <member name="M:Sandbox.Networking.CreateLobby">
      <summary>
            Will create a new lobby.
            </summary>
    </member>
    <member name="M:Sandbox.Networking.Disconnect">
      <summary>
            Disconnect from current multiplayer session.
            </summary>
    </member>
    <member name="M:Sandbox.Networking.Connect(System.String)">
      <summary>
            Will try to determine the right method for connection, and then try to connect.
            </summary>
    </member>
    <member name="M:Sandbox.Networking.TryConnectSteamId(Sandbox.SteamId)">
      <summary>
            Will try to connect to a server. Will return false if failed to connect.
            </summary>
    </member>
    <member name="M:Sandbox.Networking.QueryLobbies">
      <summary>
            Get all lobbies for the current game.
            </summary>
    </member>
    <member name="M:Sandbox.Networking.QueryLobbies(System.String)">
      <summary>
            Get all lobbies for a specific game.
            </summary>
    </member>
    <member name="M:Sandbox.Networking.QueryLobbies(System.String,System.String)">
      <summary>
            Get all lobbies for a specific game and map.
            </summary>
    </member>
    <member name="M:Sandbox.Networking.QueryLobbies(System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Get all lobbies that match the specified filters.
            </summary>
      <param name="filters" />
      <returns />
    </member>
    <member name="M:Sandbox.Networking.StartReconnecting(Sandbox.Network.ReconnectMsg)">
      <summary>
            The client has been told to reconnect to the server. So disconnect and keep trying to connect.
            </summary>
    </member>
    <member name="M:Sandbox.Networking.Reconnect(Sandbox.Network.ReconnectMsg,System.String)">
      <summary>
            The client has been told to reconnect to the server. Keep trying for 30 seconds.
            </summary>
    </member>
    <member name="P:Sandbox.UserInfo.Local">
      <summary>
            Build info for the local user, which will then get sent to the server and possibly shared between all clients
            </summary>
    </member>
    <member name="T:Sandbox.Connection">
      <summary>
            A connection, usually to a server or a client.
            </summary>
    </member>
    <member name="M:Sandbox.Connection.OnReceiveServerInfo(Sandbox.UserInfo@,Sandbox.Network.ServerInfo)">
      <summary>
            Called when we receive <see cref="T:Sandbox.Network.ServerInfo" /> from this <see cref="T:Sandbox.Connection" />.
            </summary>
      <param name="userInfo">Our outgoing <see cref="T:Sandbox.UserInfo" /> data.</param>
      <param name="serverInfo" />
      <returns>Whether or not we want to continue to connect.</returns>
    </member>
    <member name="M:Sandbox.Connection.OnReceiveUserInfo(Sandbox.UserInfo)">
      <summary>
            Called when we receive <see cref="T:Sandbox.UserInfo" /> from this <see cref="T:Sandbox.Connection" />.
            </summary>
      <param name="info" />
      <returns>Whether or not we want to allow this connection</returns>
    </member>
    <member name="M:Sandbox.Connection.HasPermission(System.String)">
      <summary>
            Get whether this connection has a specific permission.
            </summary>
    </member>
    <member name="P:Sandbox.Connection.Id">
      <summary>
            This connection's unique identifier.
            </summary>
    </member>
    <member name="P:Sandbox.Connection.HandshakeId">
      <summary>
            A unique identifier that is set when the connection starts handshaking. This identifier will
            be passed into all handshake messages, so that if a new handshaking process starts while one
            is already active, old handshake messages will be ignored.
            </summary>
    </member>
    <member name="P:Sandbox.Connection.System">
      <summary>
            The <see cref="T:Sandbox.Network.NetworkSystem" /> this connection belongs to.
            </summary>
    </member>
    <member name="P:Sandbox.Connection.CanSpawnObjects">
      <summary>
            Can this connection spawn networked objects?
            </summary>
    </member>
    <member name="P:Sandbox.Connection.CanRefreshObjects">
      <summary>
            Can this connection refresh networked objects that they own?
            </summary>
    </member>
    <member name="P:Sandbox.Connection.IsConnecting">
      <summary>
            True if this channel is still currently connecting.
            </summary>
    </member>
    <member name="P:Sandbox.Connection.IsActive">
      <summary>
            True if this channel is fully connnected and fully logged on.
            </summary>
    </member>
    <member name="P:Sandbox.Connection.MessagesSent">
      <summary>
            How many messages have been sent to this connection?
            </summary>
    </member>
    <member name="P:Sandbox.Connection.MessagesRecieved">
      <summary>
            How many messages have been received from this connection?
            </summary>
    </member>
    <member name="M:Sandbox.Connection.Kick(System.String)">
      <summary>
            Kick this <see cref="T:Sandbox.Connection" /> from the server. Only the host can kick clients.
            </summary>
      <param name="reason">The reason to display to this client.</param>
    </member>
    <member name="M:Sandbox.Connection.SendLog(Sandbox.LogLevel,System.String)">
      <summary>
            Log a message to the console for this connection.
            </summary>
    </member>
    <member name="P:Sandbox.Connection.Stats">
      <summary>
            Get stats about this connection such as bandwidth usage and how many packets are being
            sent and received.
            </summary>
    </member>
    <member name="M:Sandbox.Connection.SendMessage``1(``0)">
      <summary>
            Send a message to this connection.
            </summary>
    </member>
    <member name="M:Sandbox.Connection.ProcessMessagesInThread">
      <summary>
            This is called on a worker thread and should handle any threaded processing of messages.
            </summary>
    </member>
    <member name="P:Sandbox.Connection.State">
      <summary>
            Current internal progression of this connection.
            </summary>
    </member>
    <member name="M:Sandbox.Connection.GenerateConnectionId">
      <summary>
            Generate an ID for this connection. This is called by the server to allocate
            the connection an identifier. We're avoiding sequential, allocated ids because
            who needs to deal with that bullshit.
            </summary>
    </member>
    <member name="M:Sandbox.Connection.UpdateFrom(Sandbox.Network.ChannelInfo)">
      <summary>
            Update this channel's info. Usually called from the host.
            </summary>
    </member>
    <member name="M:Sandbox.Connection.Tick(Sandbox.Network.NetworkSystem)">
      <summary>
            Called once a second.
            </summary>
    </member>
    <member name="P:Sandbox.Connection.Ping">
      <summary>
            The ping of this connection (in milliseconds.)
            </summary>
    </member>
    <member name="M:Sandbox.Connection.UpdateRtt(System.Single)">
      <summary>
            The server has worked out the round trip time on a connection using the heartbeat.
            We want to keep a sliding window of this timing and use it to predict the latency.
            </summary>
    </member>
    <member name="P:Sandbox.Connection.PreInfo">
      <summary>
            The connection info before connection is added
            </summary>
    </member>
    <member name="P:Sandbox.Connection.PartyId">
      <summary>
            The Id of the party that this user is a part of. This can be used to compare to other users to 
            group them into parties.
            </summary>
    </member>
    <member name="M:Sandbox.Connection.UpdateUserData(System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            New, updated UserInfo data arrived. Replace our old data with this.
            </summary>
    </member>
    <member name="M:Sandbox.Connection.SetUserData(System.String,System.String)">
      <summary>
            Set or update an individual UserInfo data key.
            </summary>
      <param name="key" />
      <param name="value" />
    </member>
    <member name="F:Sandbox.Connection.Filter.FilterType.Include">
      <summary>
            Only include the connections in the filter when sending a message.
            </summary>
    </member>
    <member name="F:Sandbox.Connection.Filter.FilterType.Exclude">
      <summary>
            Exclude the connections in the filter when sending a message.
            </summary>
    </member>
    <member name="M:Sandbox.Connection.Filter.IsRecipient(Sandbox.Connection)">
      <summary>
            Is the specified <see cref="T:Sandbox.Connection" /> a valid recipient?
            </summary>
    </member>
    <member name="M:Sandbox.Connection.SendRequest``1(``0)">
      <summary>
            Send a message to this connection, wait for a response
            </summary>
    </member>
    <member name="M:Sandbox.Connection.SendResponse``1(System.Guid,``0)">
      <summary>
            Send a response message to this connection.
            </summary>
    </member>
    <member name="M:Sandbox.Connection.OnResponse(System.Guid,System.Object)">
      <summary>
            A response to a message has arrived, route it to the correct async function
            </summary>
    </member>
    <member name="P:Sandbox.Connection.Local">
      <summary>
            This is a "fake" connection for the local player. It is passed to RPCs when calling them
            locally etc.
            </summary>
    </member>
    <member name="P:Sandbox.Connection.All">
      <summary>
            A list of connections that are currently on this server. If you're not on a server
            this will return only one connection (Connection.Local). Some games restrict the 
            connection list - in which case you will get an empty list.
            </summary>
    </member>
    <member name="P:Sandbox.Connection.Host">
      <summary>
            The connection of the current network host.
            </summary>
    </member>
    <member name="M:Sandbox.Connection.Find(System.Guid)">
      <summary>
            Find a <see cref="T:Sandbox.Connection" /> for a Connection Id.
            </summary>
    </member>
    <member name="M:Sandbox.Connection.Reset">
      <summary>
            Reset any static members to their defaults or clear them.
            </summary>
    </member>
    <member name="F:Sandbox.NetFlags.Unreliable">
      <summary>
            Message will be sent unreliably. It may not arrive and it may be received out of order. But chances
            are that it will arrive on time and everything will be fine. This is good for sending position updates,
            or spawning effects. This is the fastest way to send a message. It is also the cheapest.
            </summary>
    </member>
    <member name="F:Sandbox.NetFlags.Reliable">
      <summary>
            Message will be sent reliably. Multiple attempts will be made until the recipient has received it. Use this for things
            like chat messages, or important events. This is the slowest way to send a message. It is also the most expensive.
            </summary>
    </member>
    <member name="F:Sandbox.NetFlags.SendImmediate">
      <summary>
            Message will not be grouped up with other messages, and will be sent immediately. This is most useful for things like 
            streaming voice data, where packets need to stream in real-time, rather than arriving with a bunch of other packets.
            </summary>
    </member>
    <member name="F:Sandbox.NetFlags.DiscardOnDelay">
      <summary>
            Message will be dropped if it can't be sent quickly. Only applicable to unreliable messages.
            </summary>
    </member>
    <member name="F:Sandbox.NetFlags.HostOnly">
      <summary>
            Only the host may call this action
            </summary>
    </member>
    <member name="F:Sandbox.NetFlags.OwnerOnly">
      <summary>
            Only the owner may call this action
            </summary>
    </member>
    <member name="F:Sandbox.NetFlags.UnreliableNoDelay">
      <summary>
            Message will be sent unreliably, not grouped up with other messages and will be dropped if it can't be sent quickly.
            </summary>
    </member>
    <member name="T:Sandbox.RpcMode">
      <summary>
            Specifies who can invoke an action over the network.
            </summary>
    </member>
    <member name="F:Sandbox.RpcMode.Broadcast">
      <summary>
            Send to everyone
            </summary>
    </member>
    <member name="F:Sandbox.RpcMode.Owner">
      <summary>
            Send to the owner of this
            </summary>
    </member>
    <member name="F:Sandbox.RpcMode.Host">
      <summary>
            Only send to the host.
            </summary>
    </member>
    <member name="M:Sandbox.NetFlagExtensions.ToSteamFlags(Sandbox.NetFlags)">
      <summary>
            Convert these flags to an integer usable with the Steam Networking API.
            </summary>
      <param name="flags" />
      <returns />
    </member>
    <member name="M:Sandbox.LargeNetworkFiles.Reset">
      <summary>
            Reset the string table.
            </summary>
    </member>
    <member name="M:Sandbox.LargeNetworkFiles.Refresh">
      <summary>
            Add all files from the network.
            </summary>
    </member>
    <member name="M:Sandbox.LargeNetworkFiles.AddFile(System.String)">
      <summary>
            Add a file to be networked.
            </summary>
    </member>
    <member name="M:Sandbox.LargeNetworkFiles.RemoveFile(System.String)">
      <summary>
            Remove a networked file.
            </summary>
    </member>
    <member name="T:Sandbox.ServerPackages">
      <summary>
            Manages the network string table "ServerPackages", which contains a list of packages that the client should
            have installed. During join the client will install these packages before loading in.
            </summary>
    </member>
    <member name="M:Sandbox.SmallNetworkFiles.Reset">
      <summary>
            Reset the string table.
            </summary>
    </member>
    <member name="M:Sandbox.SmallNetworkFiles.Refresh">
      <summary>
            Add all files from the network.
            </summary>
    </member>
    <member name="M:Sandbox.SmallNetworkFiles.AddFile(Sandbox.BaseFileSystem,System.String,System.Byte[])">
      <summary>
            Add a file to be networked.
            </summary>
    </member>
    <member name="M:Sandbox.SmallNetworkFiles.RemoveFile(System.String)">
      <summary>
            Remove a networked file.
            </summary>
    </member>
    <member name="T:Sandbox.UserPermission">
      <summary>
            A static class that handles user permissions.
            </summary>
    </member>
    <member name="T:Sandbox.UserPermission.User">
      <summary>
            Represents a user in the user permissions config.
            </summary>
    </member>
    <member name="M:Sandbox.UserPermission.Has(Sandbox.SteamId,System.String)">
      <summary>
            Get whether or not the specified <see cref="T:Sandbox.SteamId" /> has this permission.
            </summary>
    </member>
    <member name="M:Sandbox.UserPermission.Save">
      <summary>
            Save user permissions to disk.
            </summary>
    </member>
    <member name="M:Sandbox.UserPermission.Load">
      <summary>
            Load user permissions from disk. The file location should be <b>"config/users.json"</b>.
            </summary>
    </member>
    <member name="T:Sandbox.Physics.BallSocketJoint">
      <summary>
            A ballsocket constraint.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.BallSocketJoint.Friction">
      <summary>
            Constraint friction.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.BallSocketJoint.SwingLimit">
      <summary>
            Maximum angle it should be allowed to swing to
            </summary>
    </member>
    <member name="T:Sandbox.Physics.FixedJoint">
      <summary>
            A generic "rope" type constraint.
            </summary>
      <remarks>
            TODO: How is this different from <see cref="T:Sandbox.Physics.SpringJoint" />? Should they be merged?
            </remarks>
    </member>
    <member name="P:Sandbox.Physics.FixedJoint.SpringLinear">
      <summary>
            How springy and tight the joint will be in its movement.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.FixedJoint.SpringAngular">
      <summary>
            How springy and tight the joint will be in its rotation.
            </summary>
    </member>
    <member name="T:Sandbox.Physics.HingeJoint">
      <summary>
            A hinge-like constraint.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.HingeJoint.MaxAngle">
      <summary>
            Maximum angle it should be allowed to go
            </summary>
    </member>
    <member name="P:Sandbox.Physics.HingeJoint.MinAngle">
      <summary>
            Minimum angle it should be allowed to go
            </summary>
    </member>
    <member name="P:Sandbox.Physics.HingeJoint.Friction">
      <summary>
            Hinge friction.
            </summary>
    </member>
    <member name="T:Sandbox.Physics.PulleyJoint">
      <summary>
             A pulley constraint. Consists of 2 ropes which share same length, and the ratio changes via physics interactions.
            
             Typical setup looks like this:
             <code>
                @-----------------@
                |                 |
                |                 |
             Object A          Object B
             </code></summary>
    </member>
    <member name="T:Sandbox.Physics.SliderJoint">
      <summary>
            A slider constraint, basically allows movement only on the arbitrary axis between the 2 constrained objects on creation.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.SliderJoint.MaxLength">
      <summary>
            Maximum length it should be allowed to go
            </summary>
    </member>
    <member name="P:Sandbox.Physics.SliderJoint.MinLength">
      <summary>
            Minimum length it should be allowed to go
            </summary>
    </member>
    <member name="P:Sandbox.Physics.SliderJoint.Friction">
      <summary>
            Slider friction.
            </summary>
    </member>
    <member name="T:Sandbox.Physics.SpringJoint">
      <summary>
            A rope-like constraint that is has springy/bouncy.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.SpringJoint.SpringLinear">
      <summary>
            How springy and tight the joint will be
            </summary>
    </member>
    <member name="P:Sandbox.Physics.SpringJoint.MaxLength">
      <summary>
            Maximum length it should be allowed to go
            </summary>
    </member>
    <member name="P:Sandbox.Physics.SpringJoint.MinLength">
      <summary>
            Minimum length it should be allowed to go. At which point it acts a bit like a rod.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.SpringJoint.ReferenceMass">
      <summary>
            You shouldn't really ever need to change this, the default works out
            what the reference mass should be based on actual physics.
            </summary>
    </member>
    <member name="T:Sandbox.Physics.PhysicsJoint">
      <summary>
            A physics constraint.
            </summary>
    </member>
    <member name="M:Sandbox.Physics.PhysicsJoint.Remove">
      <summary>
            Removes this joint.
            </summary>
    </member>
    <member name="E:Sandbox.Physics.PhysicsJoint.OnBreak">
      <summary>
            Called when the joint breaks.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.PhysicsJoint.World">
      <summary>
            The <see cref="T:Sandbox.PhysicsWorld" /> this joint belongs to.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.PhysicsJoint.Body1">
      <summary>
            The source physics body this joint is attached to.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.PhysicsJoint.Body2">
      <summary>
            The target physics body this joint is constraining.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.PhysicsJoint.Point1">
      <summary>
            A specific point this joint is attached at on <see cref="P:Sandbox.Physics.PhysicsJoint.Body1" /></summary>
    </member>
    <member name="P:Sandbox.Physics.PhysicsJoint.Point2">
      <summary>
            A specific point this joint is attached at on <see cref="P:Sandbox.Physics.PhysicsJoint.Body2" /></summary>
    </member>
    <member name="P:Sandbox.Physics.PhysicsJoint.IsActive">
      <summary>
            Whether this constraint is active. (i.e. is enabled, is not broken)
            </summary>
    </member>
    <member name="P:Sandbox.Physics.PhysicsJoint.Collisions">
      <summary>
            Enables or disables collisions between the 2 constrained physics bodies.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.PhysicsJoint.Strength">
      <summary>
            Strength of the linear constraint. If it takes any more energy than this, it'll break.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.PhysicsJoint.AngularStrength">
      <summary>
            Strength of the angular constraint. If it takes any more energy than this, it'll break.
            </summary>
    </member>
    <member name="M:Sandbox.Physics.PhysicsJoint.CreateFixed(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint)">
      <summary>
            Creates an almost solid constraint between two physics bodies.
            </summary>
    </member>
    <member name="M:Sandbox.Physics.PhysicsJoint.CreateLength(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint,System.Single)">
      <summary>
            Creates a constraint like a rope, where it has no minimum length but its max length is restrained.
            </summary>
    </member>
    <member name="M:Sandbox.Physics.PhysicsJoint.CreateSpring(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint,System.Single,System.Single)">
      <summary>
            Creates a constraint that will try to stay the same length, like a spring, or a rod.
            </summary>
    </member>
    <member name="M:Sandbox.Physics.PhysicsJoint.CreateSlider(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint,System.Single,System.Single)">
      <summary>
            Creates a slider constraint between two physics bodies via <see cref="T:Sandbox.Physics.PhysicsPoint" />s.
            </summary>
    </member>
    <member name="M:Sandbox.Physics.PhysicsJoint.CreateBallSocket(Sandbox.PhysicsBody,Sandbox.PhysicsBody,Vector3)">
      <summary>
            Creates a ball socket constraint.
            </summary>
      <param name="body1">The source physics body.</param>
      <param name="body2">The target physics body to constrain to.</param>
      <param name="origin">The origin of the hinge in world coordinates. The 2 bodies will rotate around this point.</param>
      <returns>The created ball socket joint.</returns>
    </member>
    <member name="M:Sandbox.Physics.PhysicsJoint.CreateBallSocket(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint)">
      <summary>
            Creates a ball socket constraint.
            </summary>
      <param name="a">The source physics body.</param>
      <param name="b">The target physics body to constrain to.</param>
      <returns>The created ball socket joint.</returns>
    </member>
    <member name="T:Sandbox.Physics.PhysicsPoint">
      <summary>
            Used to describe a point on a physics body. This is used for things like joints where
            you want to pass in just a body, or sometimes you want to pass in a body with a specific
            location and rotation to attach to.
            </summary>
    </member>
    <member name="F:Sandbox.Physics.PhysicsPoint.Body">
      <summary>
            The physics body this point is attached to.
            </summary>
    </member>
    <member name="F:Sandbox.Physics.PhysicsPoint.LocalPosition">
      <summary>
            Position offset from the body's position.
            </summary>
    </member>
    <member name="F:Sandbox.Physics.PhysicsPoint.LocalRotation">
      <summary>
            Rotation offset from the body's position.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.PhysicsPoint.LocalTransform">
      <summary>
            A transform relative to <see cref="F:Sandbox.Physics.PhysicsPoint.Body" />, containing <see cref="F:Sandbox.Physics.PhysicsPoint.LocalPosition" /> and <see cref="F:Sandbox.Physics.PhysicsPoint.LocalRotation" /> with scale of 1.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.PhysicsPoint.Transform">
      <summary>
            Transform of this point in world space.
            </summary>
    </member>
    <member name="M:Sandbox.Physics.PhysicsPoint.Local(Sandbox.PhysicsBody,System.Nullable{Vector3},System.Nullable{Rotation})">
      <summary>
            Describe an attachment using a position/rotation local to the body
            </summary>
    </member>
    <member name="M:Sandbox.Physics.PhysicsPoint.World(Sandbox.PhysicsBody,System.Nullable{Vector3},System.Nullable{Rotation})">
      <summary>
            Describe an attachment using a position/rotation from the world
            </summary>
    </member>
    <member name="T:Sandbox.Physics.PhysicsSpring">
      <summary>
            Spring related settings for joints such as <see cref="T:Sandbox.Physics.FixedJoint" />.
            </summary>
    </member>
    <member name="F:Sandbox.Physics.PhysicsSpring.Frequency">
      <summary>
            The stiffness of the spring
            </summary>
    </member>
    <member name="F:Sandbox.Physics.PhysicsSpring.Damping">
      <summary>
            The damping ratio of the spring, usually between 0 and 1
            </summary>
    </member>
    <member name="F:Sandbox.Physics.PhysicsSpring.Maximum">
      <summary>
            For weld joints only, maximum force. Not for breaking.
            </summary>
    </member>
    <member name="T:Sandbox.Physics.CollisionRules">
      <summary>
            This is a JSON serializable description of the physics's collision rules. This allows us to send it
            to the engine - and store it in a string table (which is networked to the client). You shouldn't really
            ever have to mess with this, it's just used internally.
            </summary>
    </member>
    <member name="T:Sandbox.Physics.CollisionRules.Result">
      <summary>
            Result of a collision between <see cref="T:Sandbox.Physics.CollisionRules.Pair">two objects</see>.
            </summary>
    </member>
    <member name="F:Sandbox.Physics.CollisionRules.Result.Unset">
      <summary>
            Fallback to default behavior.
            </summary>
    </member>
    <member name="F:Sandbox.Physics.CollisionRules.Result.Collide">
      <summary>
            Collide.
            </summary>
    </member>
    <member name="F:Sandbox.Physics.CollisionRules.Result.Trigger">
      <summary>
            Do not collide, but trigger touch callbacks.
            </summary>
    </member>
    <member name="F:Sandbox.Physics.CollisionRules.Result.Ignore">
      <summary>
            Do not collide.
            </summary>
    </member>
    <member name="T:Sandbox.Physics.CollisionRules.Pair">
      <summary>
            A pair of case- and order-insensitive tags, used as a key to look up a <see cref="T:Sandbox.Physics.CollisionRules.Result" />.
            </summary>
    </member>
    <member name="M:Sandbox.Physics.CollisionRules.Pair.op_Implicit(System.ValueTuple{System.String,System.String})~Sandbox.Physics.CollisionRules.Pair">
      <summary>
            Initializes from a pair of tags.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.CollisionRules.Pair.Left">
      <summary>
            First of the two tags.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.CollisionRules.Pair.Right">
      <summary>
            Second of the two tags.
            </summary>
    </member>
    <member name="M:Sandbox.Physics.CollisionRules.Pair.#ctor(System.String,System.String)">
      <summary>
            Initializes from a pair of tags.
            </summary>
    </member>
    <member name="M:Sandbox.Physics.CollisionRules.Pair.Contains(System.String)">
      <summary>
            Returns true if either <see cref="P:Sandbox.Physics.CollisionRules.Pair.Left" /> or <see cref="P:Sandbox.Physics.CollisionRules.Pair.Right" /> matches the given tag.
            </summary>
    </member>
    <member name="M:Sandbox.Physics.CollisionRules.Pair.Equals(Sandbox.Physics.CollisionRules.Pair)">
      <inheritdoc />
    </member>
    <member name="M:Sandbox.Physics.CollisionRules.Pair.Equals(System.Object)">
      <inheritdoc />
    </member>
    <member name="M:Sandbox.Physics.CollisionRules.Pair.GetEnumerator">
      <inheritdoc />
    </member>
    <member name="M:Sandbox.Physics.CollisionRules.Pair.System#Collections#IEnumerable#GetEnumerator">
      <inheritdoc />
    </member>
    <member name="M:Sandbox.Physics.CollisionRules.Pair.GetHashCode">
      <inheritdoc />
    </member>
    <member name="P:Sandbox.Physics.CollisionRules.Defaults">
      <summary>
            If no pair matching is found, this is what we'll use
            </summary>
    </member>
    <member name="P:Sandbox.Physics.CollisionRules.Pairs">
      <summary>
            What happens when a pair collides
            </summary>
    </member>
    <member name="P:Sandbox.Physics.CollisionRules.Tags">
      <summary>
            All tags with either an entry in <see cref="P:Sandbox.Physics.CollisionRules.Defaults" /> or <see cref="P:Sandbox.Physics.CollisionRules.Pairs" />.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.CollisionRules.SerializedPairs">
      <summary>
            Gets or sets <see cref="P:Sandbox.Physics.CollisionRules.Pairs" /> in its serialized form for JSON.
            </summary>
    </member>
    <member name="M:Sandbox.Physics.CollisionRules.LeastColliding(Sandbox.Physics.CollisionRules.Result,Sandbox.Physics.CollisionRules.Result)">
      <summary>
            Selects the result with the highest precedence (least colliding).
            </summary>
    </member>
    <member name="M:Sandbox.Physics.CollisionRules.GetCollisionRule(System.String,System.String)">
      <summary>
            Gets the specific collision rule for a pair of tags.
            </summary>
    </member>
    <member name="M:Sandbox.Physics.CollisionRules.GetCollisionRules(System.String)">
      <summary>
            For each known tag, what result does it have when tested against the given <paramref name="tag" />?
            </summary>
    </member>
    <member name="M:Sandbox.Physics.CollisionRules.GetCollisionRules(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            For each known tag, what result does it have when tested against the given set of <paramref name="tags" />?
            </summary>
    </member>
    <member name="M:Sandbox.Physics.CollisionRules.Clean">
      <summary>
            Remove duplicates etc
            </summary>
    </member>
    <member name="P:Sandbox.Physics.PhysicsSettings.UseFixedUpdate">
      <summary>
            If false, then instead of operating physics, and UpdateFixed in a fixed update frequency
            they will be called the same as Update - every frame, with a variable time delta.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.PhysicsSettings.SubSteps">
      <summary>
            If you're seeing objects go through other objects or you have a low tickrate, you might want to increase the number of physics substeps.
            This breaks physics steps down into this many substeps. The default is 1 and works pretty good.
            Be aware that the number of physics ticks per second is going to be tickrate * substeps.
            So if you're ticking at 90 and you have SubSteps set to 1000 then you're going to do 90,000 steps per second. So be careful here.
            </summary>
    </member>
    <member name="P:Sandbox.Physics.PhysicsSettings.FixedUpdateFrequency">
      <summary>
            How many times a second FixedUpdate runs
            </summary>
    </member>
    <member name="P:Sandbox.Physics.PhysicsSettings.MaxFixedUpdates">
      <summary>
            If the frame took longer than a FixedUpdate step, we need to run multiple
            steps for that frame, to catch up. How many are allowed? Too few, and the 
            simluation will run slower than the game. If you allow an unlimited amount
            then the frame time could snowball to infinity and never catch up.
            </summary>
    </member>
    <member name="T:Sandbox.PhysicsBody">
      <summary>
            Represents a physics object. An entity can have multiple physics objects. See <see cref="P:Sandbox.PhysicsBody.PhysicsGroup">PhysicsGroup</see>.
            A physics objects consists of one or more <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see>s.
            </summary>
      <summary>
            Represents a physics object. An entity can have multiple physics objects. See <see cref="P:Sandbox.PhysicsBody.PhysicsGroup">PhysicsGroup</see>.
            A physics objects consists of one or more <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see>s.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.GameObject">
      <summary>
            The GameObject that created this body
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.Component">
      <summary>
            The component that created this body
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.Hitbox">
      <summary>
            The Hitbox that this physics body represents
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.Position">
      <summary>
            Position of this body in world coordinates.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.World">
      <summary>
            The physics world this body belongs to.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.Rotation">
      <summary>
            Rotation of the physics body in world space.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.Velocity">
      <summary>
            Linear velocity of this body in world space.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.AngularVelocity">
      <summary>
            Angular velocity of this body in world space.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.MassCenter">
      <summary>
            Center of mass for this physics body in world space coordinates.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.LocalMassCenter">
      <summary>
            Center of mass for this physics body relative to its <see cref="P:Sandbox.PhysicsBody.Position">origin</see>.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.OverrideMassCenter">
      <summary>
            Is this physics body mass calculated or set directly.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.Mass">
      <summary>
            Mass of this physics body.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.GravityEnabled">
      <summary>
            Whether gravity is enabled for this body or not.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.EnableCollisionSounds">
      <summary>
            Whether to play collision sounds 
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.GravityScale">
      <summary>
            Scale the gravity relative to <see cref="P:Sandbox.PhysicsWorld.Gravity" />. 2 is double the gravity, etc.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.UseController">
      <summary>
            If true we'll create a controller for this physics body. This is useful
            for keyframed physics objects that need to push things. The controller will
            sweep as the entity moves, rather than teleporting the object.. which works better
            when pushing dynamic objects etc.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.EnableTouch">
      <summary>
            Enables Touch callbacks on all <see cref="T:Sandbox.PhysicsShape">PhysicsShapes</see> of this body.
            Returns true if ANY of the physics shapes have touch events enabled.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.EnableTouchPersists">
      <summary>
            Sets <see cref="P:Sandbox.PhysicsShape.EnableTouchPersists" /> on all shapes of this body.
            <br /><br />
            Returns true if ANY of the physics shapes have persistent touch events enabled.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.EnableSolidCollisions">
      <summary>
            Sets <see cref="P:Sandbox.PhysicsShape.EnableSolidCollisions" /> on all shapes of this body.
            <br /><br />
            Returns true if ANY of the physics shapes have solid collisions enabled.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.BodyType">
      <summary>
            Movement type of physics body, either Static, Keyframed, Dynamic
            Note: If this body is networked and dynamic, it will return Keyframed on the client
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.NavmeshBodyTypeOverride">
      <summary>
            The bodytype may change between edit and game time.
            For navmesh generation we always need to know the bodytype at game time.
            This override can be set to inform the navmesh generation of the correct game time bodytype.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.AutoSleep">
      <summary>
            Whether this body is allowed to automatically go into "sleep" after a certain amount of time of inactivity.
            <see cref="P:Sandbox.PhysicsBody.Sleeping" /> for more info on the sleep mechanic.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.Transform">
      <summary>
            Transform of this physics body.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.Move(Transform,System.Single)">
      <summary>
            Move to a new position. Unlike Transform, if you have `UseController` enabled, this will sweep the shadow
            to the new position, rather than teleporting there.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.ShapeCount">
      <summary>
            How many shapes belong to this body.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.Shapes">
      <summary>
            All shapes that belong to this body.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.AddSphereShape(Vector3,System.Single,System.Boolean)">
      <summary>
            Add a sphere shape to this body.
            </summary>
      <param name="center">Center of the sphere, relative to <see cref="P:Sandbox.PhysicsBody.Position" /> of this body.</param>
      <param name="radius">Radius of the sphere.</param>
      <param name="rebuildMass">Whether the mass should be <see cref="M:Sandbox.PhysicsBody.RebuildMass">recalculated</see> after adding the shape.</param>
      <returns>The newly created shape, if any.</returns>
    </member>
    <member name="M:Sandbox.PhysicsBody.AddSphereShape(Sandbox.Sphere@,System.Boolean)">
      <summary>
            Add a sphere shape to this body.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.AddCapsuleShape(Vector3,Vector3,System.Single,System.Boolean)">
      <summary>
            Add a capsule shape to this body.
            </summary>
      <param name="center">Point A of the capsule, relative to <see cref="P:Sandbox.PhysicsBody.Position" /> of this body.</param>
      <param name="center2">Point B of the capsule, relative to <see cref="P:Sandbox.PhysicsBody.Position" /> of this body.</param>
      <param name="radius">Radius of the capsule end caps.</param>
      <param name="rebuildMass">Whether the mass should be <see cref="M:Sandbox.PhysicsBody.RebuildMass">recalculated</see> after adding the shape.</param>
      <returns>The newly created shape, or null on failure.</returns>
    </member>
    <member name="M:Sandbox.PhysicsBody.AddBoxShape(Vector3,Rotation,Vector3,System.Boolean)">
      <summary>
            Add a box shape to this body.
            </summary>
      <param name="position">Center of the box, relative to <see cref="P:Sandbox.PhysicsBody.Position" /> of this body.</param>
      <param name="rotation">Rotation of the box, relative to <see cref="P:Sandbox.PhysicsBody.Rotation" /> of this body.</param>
      <param name="extent">The extents of the box. The box will extend from its center by this much in both negative and positive directions of each axis.</param>
      <param name="rebuildMass">Whether the mass should be <see cref="M:Sandbox.PhysicsBody.RebuildMass">recalculated</see> after adding the shape.</param>
      <returns>The newly created shape, or null on failure.</returns>
    </member>
    <member name="M:Sandbox.PhysicsBody.AddBoxShape(BBox,Rotation,System.Boolean)">
      <summary>
            Add a box shape to this body.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.AddHullShape(Vector3,Rotation,System.Collections.Generic.List{Vector3},System.Boolean)">
      <inheritdoc cref="M:Sandbox.PhysicsBody.AddHullShape(Vector3,Rotation,System.Span{Vector3},System.Boolean)" />
    </member>
    <member name="M:Sandbox.PhysicsBody.AddHullShape(Vector3,Rotation,System.Span{Vector3},System.Boolean)">
      <summary>
            Add a convex hull shape to this body.
            </summary>
      <param name="position">Center of the hull, relative to <see cref="P:Sandbox.PhysicsBody.Position" /> of this body.</param>
      <param name="rotation">Rotation of the hull, relative to <see cref="P:Sandbox.PhysicsBody.Rotation" /> of this body.</param>
      <param name="points">Points for the hull. They will be used to generate a convex shape.</param>
      <param name="rebuildMass">Whether the mass should be <see cref="M:Sandbox.PhysicsBody.RebuildMass">recalculated</see> after adding the shape.</param>
      <returns>The newly created shape, or null on failure.</returns>
    </member>
    <member name="M:Sandbox.PhysicsBody.AddCylinderShape(Vector3,Rotation,System.Single,System.Single,System.Int32)">
      <summary>
            Add a cylinder shape to this body.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.AddConeShape(Vector3,Rotation,System.Single,System.Single,System.Single,System.Int32)">
      <summary>
            Add a cone shape to this body.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.AddMeshShape(System.Collections.Generic.List{Vector3},System.Collections.Generic.List{System.Int32})">
      <inheritdoc cref="M:Sandbox.PhysicsBody.AddMeshShape(System.Span{Vector3},System.Span{System.Int32})" />
    </member>
    <member name="M:Sandbox.PhysicsBody.AddMeshShape(System.Span{Vector3},System.Span{System.Int32})">
      <summary>
            Adds a mesh type shape to this physics body. Mesh shapes cannot be physically simulated!
            </summary>
      <param name="vertices">Vertices of the mesh.</param>
      <param name="indices">Indices of the mesh.</param>
      <returns>The created shape, or null on failure.</returns>
    </member>
    <member name="M:Sandbox.PhysicsBody.AddCloneShape(Sandbox.PhysicsShape)">
      <summary>
            Clones given shape and adds it to this body.
            </summary>
      <param name="shape">The shape to clone.</param>
      <returns>The cloned shape.</returns>
      <exception cref="T:System.ArgumentException">Thrown when given invalid shape.</exception>
    </member>
    <member name="M:Sandbox.PhysicsBody.ClearShapes">
      <summary>
            Remove all physics shapes, but not the physics body itself.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.RemoveShape(Sandbox.PhysicsShape)">
      <summary>
            Called from Shape.Remove()
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.RebuildMass">
      <summary>
            Meant to be only used on <b>dynamic</b> bodies, rebuilds mass from all shapes of this body based on their volume and <see cref="P:Sandbox.PhysicsBody.Surface">physics properties</see>, for cases where they may have changed.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.Remove">
      <summary>
            Completely removes this physics body.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.ApplyImpulse(Vector3)">
      <summary>
            Applies instant linear impulse (i.e. a bullet impact) to this body at its center of mass.
            For continuous force (i.e. a moving car), use <see cref="M:Sandbox.PhysicsBody.ApplyForce(Vector3)" /></summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.ApplyImpulseAt(Vector3,Vector3)">
      <summary>
            Applies instant linear impulse (i.e. a bullet impact) to this body at given position.
            For continuous force (i.e. a moving car), use <see cref="M:Sandbox.PhysicsBody.ApplyForceAt(Vector3,Vector3)" /></summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.ApplyAngularImpulse(Vector3)">
      <summary>
            Applies instant angular impulse (i.e. a bullet impact) to this body.
            For continuous force (i.e. a moving car), use <see cref="M:Sandbox.PhysicsBody.ApplyTorque(Vector3)" /></summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.ApplyForce(Vector3)">
      <summary>
            Applies force to this body at the center of mass.
            This force will only be applied on the next physics frame and is scaled with physics timestep.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.ApplyForceAt(Vector3,Vector3)">
      <summary>
            Applies force to this body at given position.
            This force will only be applied on the next physics frame and is scaled with physics timestep.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.ApplyTorque(Vector3)">
      <summary>
            Applies angular velocity to this body.
            This force will only be applied on the next physics frame and is scaled with physics timestep.
            </summary>
      <param name="force" />
    </member>
    <member name="M:Sandbox.PhysicsBody.ClearForces">
      <summary>
            Clear accumulated linear forces (<see cref="M:Sandbox.PhysicsBody.ApplyForce(Vector3)" /> and <see cref="M:Sandbox.PhysicsBody.ApplyForceAt(Vector3,Vector3)" />) during this physics frame that were not yet applied to the physics body.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.ClearTorque">
      <summary>
            Clear accumulated torque (angular force, <see cref="M:Sandbox.PhysicsBody.ApplyTorque(Vector3)" />) during this physics frame that were not yet applied to the physics body.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.GetVelocityAtPoint(Vector3)">
      <summary>
            Returns the world space velocity of a point of the object. This is useful for objects rotating around their own axis/origin.
            </summary>
      <param name="point">The point to test, in world coordinates.</param>
      <returns>Velocity at the given point.</returns>
    </member>
    <member name="P:Sandbox.PhysicsBody.Enabled">
      <summary>
            Whether this body is enabled or not. Disables collisions, physics simulation, touch events, trace queries, etc.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.MotionEnabled">
      <summary>
            Controls physics simulation on this body.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.Sleeping">
      <summary>
            Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance.
            You can use this to wake the body up, or prematurely send it to sleep.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.SpeculativeContactEnabled">
      <summary>
            If enabled, this physics body will move slightly ahead each frame based on its velocities.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.Parent">
      <summary>
            The physics body we are attached to, if any
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.SelfOrParent">
      <summary>
            A convenience property, returns <see cref="P:Sandbox.PhysicsBody.Parent">Parent</see>, or if there is no parent, returns itself.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.PhysicsGroup">
      <summary>
            The physics group we belong to.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.FindClosestPoint(Vector3)">
      <summary>
            Returns the closest point to the given one between all convex shapes of this body.
            </summary>
      <param name="vec">Input position.</param>
      <returns>The closest possible position on the surface of the physics body to the given position.</returns>
    </member>
    <member name="P:Sandbox.PhysicsBody.LinearDamping">
      <summary>
            Generic linear damping, i.e. how much the physics body will slow down on its own.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.AngularDamping">
      <summary>
            Generic angular damping, i.e. how much the physics body will slow down on its own.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.Inertia">
      <summary>
            The diagonal elements of the local inertia tensor matrix.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.InertiaRotation">
      <summary>
            The orientation of the principal axes of local inertia tensor matrix.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.SetInertiaTensor(Vector3,Rotation)">
      <summary>
            Sets the inertia tensor using the given moments and rotation.
            </summary>
      <param name="inertia">Principal moments (Ixx, Iyy, Izz).</param>
      <param name="rotation">Rotation of the principal axes.</param>
    </member>
    <member name="M:Sandbox.PhysicsBody.ResetInertiaTensor">
      <summary>
            Resets the inertia tensor to its calculated values.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.GetBounds">
      <summary>
            Returns Axis-Aligned Bounding Box (AABB) of this physics body.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.Density">
      <summary>
            Returns average of densities for all physics shapes of this body. This is based on <see cref="P:Sandbox.PhysicsShape.SurfaceMaterial" /> of each shape.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.LastWaterEffect">
      <summary>
            Time since last water splash effect. Used internally.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.SurfaceMaterial">
      <summary>
            Sets <see cref="P:Sandbox.PhysicsShape.SurfaceMaterial" /> on all child <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see>s.
            </summary>
      <returns>
            The most commonly occurring surface name between all <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see>s of this <see cref="T:Sandbox.PhysicsShape">PhysicsBody</see>.
            </returns>
    </member>
    <member name="M:Sandbox.PhysicsBody.LocalPoint(Vector3)">
      <summary>
            Convenience function that returns a <see cref="T:Sandbox.Physics.PhysicsPoint" /> from a position relative to this body.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.WorldPoint(Vector3)">
      <summary>
            Convenience function that returns a <see cref="T:Sandbox.Physics.PhysicsPoint" /> for this body from a world space position.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.MassCenterPoint">
      <summary>
            Returns a <see cref="T:Sandbox.Physics.PhysicsPoint" /> at the center of mass of this body.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.GroupName">
      <summary>
            What is this body called in the group?
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsBody.GroupIndex">
      <summary>
            Return the index of this body in its PhysicsGroup
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.CheckOverlap(Sandbox.PhysicsBody)">
      <summary>
            Checks if another body overlaps us, ignoring all collision rules
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.CheckOverlap(Sandbox.PhysicsBody,Transform)">
      <summary>
            Checks if another body overlaps us at a given transform, ignoring all collision rules
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.IsTouching(Sandbox.PhysicsBody,System.Boolean)">
      <summary>
            Checks if there's any contact points with another body
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.IsTouching(Sandbox.PhysicsShape,System.Boolean)">
      <summary>
            Checks if there's any contact points with another shape
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.AddShape(Sandbox.PhysicsGroupDescription.BodyPart.HullPart,Transform,System.Boolean)">
      <summary>
            Add a shape from a physics hull
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.AddShape(Sandbox.PhysicsGroupDescription.BodyPart.MeshPart,Transform,System.Boolean,System.Boolean)">
      <summary>
            Add a shape from a mesh hull
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsBody.prevStepTransform">
      <summary>
            Transform, on previous step
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsBody.stepTransform">
      <summary>
            Transform on current step
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.OnActive(Transform@,Vector3@,Vector3@)">
      <summary>
            Called on each active body after a "step"
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.GetLerpedTransform(System.Single)">
      <summary>
            When the physics world is run at a fixed timestep, getting the positions of bodies will not be smooth.
            You can use this function to get the lerped position between steps, to make things super awesome.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.SmoothMove(Vector3@,System.Single,System.Single)">
      <summary>
            Move body to this position in a way that cooperates with the physics system. This is quite
            good for things like grabbing and moving objects.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.SmoothMove(Transform@,System.Single,System.Single)">
      <summary>
            Move body to this position in a way that cooperates with the physics system. This is quite
            good for things like grabbing and moving objects.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsBody.SmoothRotate(Rotation@,System.Single,System.Single)">
      <summary>
            Rotate the body to this position in a way that cooperates with the physics system.
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsBody.OnDirty">
      <summary>
            Called when anything significant changed about this physics object. Like its position,
            or its enabled status.
            </summary>
    </member>
    <member name="T:Sandbox.PhysicsGroup">
      <summary>
            Represents a set of <see cref="T:Sandbox.PhysicsBody">PhysicsBody</see> objects. Think ragdoll.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsGroup.World">
      <summary>
            The world in which this group belongs
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsGroup.Pos">
      <summary>
            Returns position of the first physics body of this group, or zero vector if it has none.
            </summary>
      <remarks>
            TODO: How useful is this in its current form? Should it be removed, or at least renamed to Position?
            </remarks>
    </member>
    <member name="P:Sandbox.PhysicsGroup.MassCenter">
      <summary>
            Returns the center of mass for this group of physics bodies.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsGroup.AddVelocity(Vector3)">
      <summary>
            Adds given amount of velocity (<see cref="M:Sandbox.PhysicsBody.ApplyForce(Vector3)" />) to all physics bodies in this group.
            </summary>
      <param name="vel">How much linear force to add?</param>
    </member>
    <member name="M:Sandbox.PhysicsGroup.AddAngularVelocity(Vector3)">
      <summary>
            Adds given amount of angular velocity to all physics bodies in this group.
            </summary>
      <param name="vel">How much angular force to add?</param>
    </member>
    <member name="M:Sandbox.PhysicsGroup.ApplyImpulse(Vector3,System.Boolean)">
      <summary>
            Adds given amount of linear impulse (<see cref="M:Sandbox.PhysicsBody.ApplyImpulse(Vector3)" />) to all physics bodies in this group.
            </summary>
      <param name="vel">Velocity to apply.</param>
      <param name="withMass">Whether to multiply the velocity by mass of the <see cref="T:Sandbox.PhysicsBody" /> on a per-body basis.</param>
    </member>
    <member name="M:Sandbox.PhysicsGroup.ApplyAngularImpulse(Vector3,System.Boolean)">
      <summary>
            Adds given amount of angular linear impulse (<see cref="M:Sandbox.PhysicsBody.ApplyAngularImpulse(Vector3)" />) to all physics bodies in this group.
            </summary>
      <param name="vel">Angular velocity to apply.</param>
      <param name="withMass">Whether to multiply the velocity by mass of the <see cref="T:Sandbox.PhysicsBody" /> on a per-body basis.</param>
    </member>
    <member name="P:Sandbox.PhysicsGroup.Velocity">
      <summary>
            Sets <see cref="P:Sandbox.PhysicsBody.Velocity" /> on all bodies of this group.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsGroup.AngularVelocity">
      <summary>
            Sets <see cref="P:Sandbox.PhysicsBody.AngularVelocity" /> on all bodies of this group.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsGroup.Sleeping">
      <summary>
            Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance.
            You can use this to wake the body up, or prematurely send it to sleep.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsGroup.RebuildMass">
      <summary>
            Calls <see cref="M:Sandbox.PhysicsBody.RebuildMass" /> on all bodies of this group.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsGroup.Mass">
      <summary>
            The total mass of all the <b>dynamic</b><see cref="T:Sandbox.PhysicsBody">PhysicsBodies</see> in this group.
            When setting the total mass, it will be set on each body proportionally to each of their old masses,
            i.e. if a body had 25% of previous total mass, it will have 25% of new total mass.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsGroup.LinearDamping">
      <summary>
            Sets <see cref="P:Sandbox.PhysicsBody.LinearDamping" /> on all bodies in this group.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsGroup.AngularDamping">
      <summary>
            Sets <see cref="P:Sandbox.PhysicsBody.AngularDamping" /> on all bodies in this group.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsGroup.Bodies">
      <summary>
            Returns all physics bodies that belong to this physics group.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsGroup.BodyCount">
      <summary>
            Returns amount of physics bodies that belong to this physics group.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsGroup.GetBody(System.Int32)">
      <summary>
            Gets a <see cref="T:Sandbox.PhysicsBody" /> at given index within this physics group. See <see cref="P:Sandbox.PhysicsGroup.BodyCount" />.
            </summary>
      <param name="groupIndex">Index for the body to look up, in range from 0 to <see cref="P:Sandbox.PhysicsGroup.BodyCount" />.</param>
    </member>
    <member name="M:Sandbox.PhysicsGroup.GetBody(System.String)">
      <summary>
            Returns a <see cref="T:Sandbox.PhysicsBody" /> by its <see cref="P:Sandbox.PhysicsBody.GroupName" /> within this group.
            </summary>
      <param name="groupName">Name of the physics body to look up.</param>
      <returns>The physics body, or null if body with given name is not found.</returns>
    </member>
    <member name="P:Sandbox.PhysicsGroup.Joints">
      <summary>
            Any and all joints that are attached to any body in this group.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsGroup.SetSurface(System.String)">
      <summary>
            Sets the physical properties of each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> of this group.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsGroup.Remove">
      <summary>
            Delete this group, and all of its bodies
            </summary>
    </member>
    <member name="T:Sandbox.PhysicsShape">
      <summary>
            Represents a basic, convex shape. A <see cref="T:Sandbox.PhysicsBody">PhysicsBody</see> consists of one or more of these.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.Body">
      <summary>
            The physics body we belong to.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.BoneIndex">
      <summary>
            The bone index that this physics shape represents
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.Collider">
      <summary>
            The collider object that created / owns this shape
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.IsTrigger">
      <summary>
            This is a trigger (!)
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.SurfaceVelocity">
      <summary>
            Set the local velocity of the surface so things can slide along it, like a conveyor belt
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsShape.EnableAllCollision">
      <summary>
            Enable contact, trace and touch
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsShape.DisableAllCollision">
      <summary>
            Disable contact, trace and touch
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.EnableSolidCollisions">
      <summary>
            Controls whether this shape has solid collisions.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.EnableTouch">
      <summary>
            Controls whether this shape can fire touch events for its owning entity. (Entity.StartTouch, Touch and EndTouch)
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.EnableTouchPersists">
      <summary>
            Controls whether this shape can fire continuous touch events for its owning entity (i.e. calling Entity.Touch every frame)
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.IsMeshShape">
      <summary>
            Is this a MeshShape
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.IsHullShape">
      <summary>
            Is this a HullShape
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.IsSphereShape">
      <summary>
            Is this a SphereShape
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.IsCapsuleShape">
      <summary>
            Is this a CapsuleShape
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.IsHeightfieldShape">
      <summary>
            Is this a HeightfieldShape
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.Sphere">
      <summary>
            Get sphere properties if we're a sphere type
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.Capsule">
      <summary>
            Get capsule properties if we're a capsule type
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsShape.UpdateCapsuleShape(Vector3,Vector3,System.Single)">
      <summary>
            Recreate the collision mesh (Only if this physics shape is type Capsule)
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsShape.UpdateBoxShape(Vector3,Rotation,Vector3)">
      <summary>
            Recreate the collision mesh (Only if this physics shape is type Hull)
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsShape.UpdateMesh(System.Collections.Generic.List{Vector3},System.Collections.Generic.List{System.Int32})">
      <summary>
            Recreate the collision mesh (Only if this physics shape is type Mesh)
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsShape.UpdateMesh(System.Span{Vector3},System.Span{System.Int32})">
      <summary>
            Recreate the mesh of the shape (Only if this physics shape is type Mesh)
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsShape.UpdateHull(Vector3,Rotation,System.Span{Vector3})">
      <summary>
            Recreate the hull of the shape (Only if this physics shape is type Hull)
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.SurfaceMaterial">
      <summary>
            Controls physical properties of this shape.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.Surfaces">
      <summary>
            Multiple surfaces referenced by mesh or heightfield collision.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsShape.Remove">
      <summary>
            Remove this shape. After calling this the shape should be considered released and not used again.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsShape.Triangulate(Vector3[]@,System.UInt32[]@)">
      <summary>
            Triangulate this shape.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsShape.Friction">
      <summary>
            The friction value
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsShape.OnDirty">
      <summary>
            Called when anything significant changed about this physics object. Like its position,
            or its enabled status.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsShape.HasTag(System.String)">
      <summary>
            Does this shape have a specific tag?
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsShape.AddTag(System.String)">
      <summary>
            Add a tag to this shape.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsShape.RemoveTag(System.String)">
      <summary>
            Remove a tag from this shape.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsShape.ClearTags">
      <summary>
            Clear all tags from this shape.
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsTraceBuilder.filterCallback">
      <summary>
            Do not expose! We want to force this whole thing into as tight of a box as possible!
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Sphere(System.Single,Vector3@,Vector3@)">
      <summary>
            Casts a sphere from point A to point B.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Sphere(System.Single,Ray@,System.Single@)">
      <summary>
            Casts a sphere from a given position and direction, up to a given distance.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Box(Vector3,Vector3@,Vector3@)">
      <summary>
            Casts a box from point A to point B.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Box(Vector3,Ray@,System.Single@)">
      <summary>
            Casts a box from a given position and direction, up to a given distance.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Box(BBox,Vector3@,Vector3@)">
      <summary>
            Casts a box from point A to point B.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Box(BBox,Ray@,System.Single@)">
      <summary>
            Casts a box from a given position and direction, up to a given distance.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Capsule(Capsule)">
      <summary>
            Casts a capsule
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Capsule(Capsule,Vector3@,Vector3@)">
      <summary>
            Casts a capsule from point A to point B.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Capsule(Capsule,Ray@,System.Single@)">
      <summary>
            Casts a capsule from a given position and direction, up to a given distance.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Cylinder(System.Single,System.Single)">
      <summary>
            Casts a cylinder
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Cylinder(System.Single,System.Single,Vector3@,Vector3@)">
      <summary>
            Casts a cylinder from point A to point B.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Cylinder(System.Single,System.Single,Ray@,System.Single@)">
      <summary>
            Casts a cylinder from a given position and direction, up to a given distance.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Ray(Vector3@,Vector3@)">
      <summary>
            Casts a ray from point A to point B.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Ray(Ray@,System.Single@)">
      <summary>
            Casts a ray from a given position and direction, up to a given distance.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Body(Sandbox.PhysicsBody,Vector3@)">
      <summary>
            Casts a PhysicsBody from its current position and rotation to desired end point.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Body(Sandbox.PhysicsBody,Transform@,Vector3@)">
      <summary>
            Casts a PhysicsBody from a position and rotation to desired end point.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Sweep(Sandbox.PhysicsBody@,Transform@,Transform@)">
      <summary>
            Sweeps each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> of given PhysicsBody and returns the closest collision. Does not support Mesh PhysicsShapes.
            Basically 'hull traces' but with physics shapes.
            Same as tracing a body but allows rotation to change during the sweep.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Sweep(Sandbox.PhysicsBody@,Transform@)">
      <summary>
            Creates a Trace.Sweep using the <see cref="T:Sandbox.PhysicsBody">PhysicsBody</see>'s position as the starting position.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.FromTo(Vector3@,Vector3@)">
      <summary>
            Sets the start and end positions of the trace request
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.FromTo(Transform@,Vector3@)">
      <summary>
            Sets the start transform and end position of the trace request
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Rotated(Rotation@)">
      <summary>
            Sets the start rotation of the trace request
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.HitTriggers">
      <summary>
            Include triggers in the trace
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.HitTriggersOnly">
      <summary>
            Only hit triggers
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.IgnoreStatic">
      <summary>
            Ignore static objects in the trace
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.IgnoreDynamic">
      <summary>
            Ignore dynamic objects in the trace
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.IgnoreKeyframed">
      <summary>
            Ignore keyframed objects in the trace
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.UseHitPosition(System.Boolean)">
      <summary>
            Compute hit position.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Size(BBox@)">
      <summary>
            Makes this trace an axis aligned box of given size. Extracts mins and maxs from the Bounding Box.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Size(Vector3@)">
      <summary>
            Makes this trace an axis aligned box of given size. Calculates mins and maxs by assuming given size is (maxs-mins) and the center is in the middle.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Size(Vector3@,Vector3@)">
      <summary>
            Makes this trace an axis aligned box of given size.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Radius(System.Single)">
      <summary>
            Makes this trace a sphere of given radius.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.Run">
      <summary>
            Run the trace and return the result. The result will return the first hit.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.RunAll">
      <summary>
            Run the trace and return all hits as a result.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.WithTag(Sandbox.StringToken)">
      <summary>
            Only return entities with this tag. Subsequent calls to this will add multiple requirements
            and they'll all have to be met (ie, the entity will need all tags).
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.WithAllTags(System.String[])">
      <summary>
            Only return with all of these tags
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.WithAllTags(Sandbox.ITagSet)">
      <summary>
            Only return with all of these tags
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.WithAnyTags(System.String[])">
      <summary>
            Only return entities with any of these tags
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.WithAnyTags(System.Collections.Generic.IReadOnlySet{System.UInt32})">
      <summary>
            Only return entities with any of these tags (using ints)
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.WithAnyTags(Sandbox.ITagSet)">
      <summary>
            Only return with any of these tags
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.WithoutTag(System.String)">
      <summary>
            Only return with any of these tags
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.WithoutTags(System.String[])">
      <summary>
            Only return without any of these tags
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.WithoutTags(Sandbox.ITagSet)">
      <summary>
            Only return without any of these tags
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.WithCollisionRules(System.String,System.Boolean)">
      <summary>
            Use the collision rules of the given tag.
            </summary>
      <param name="tag">Which tag this trace will adopt the collision rules of.</param>
      <param name="asTrigger">If true, trace against triggers only. Otherwise, trace for collisions (default).</param>
    </member>
    <member name="M:Sandbox.PhysicsTraceBuilder.WithCollisionRules(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
      <summary>
            Use the collision rules for the given set of tags.
            </summary>
      <param name="tags">Which tags this trace will adopt the collision rules of.</param>
      <param name="asTrigger">If true, trace against triggers only. Otherwise, trace for collisions (default).</param>
    </member>
    <member name="F:Sandbox.PhysicsTraceResult.Hit">
      <summary>
            Whether the trace hit something or not
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsTraceResult.StartedSolid">
      <summary>
            Whether the trace started in a solid
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsTraceResult.StartPosition">
      <summary>
            The start position of the trace
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsTraceResult.EndPosition">
      <summary>
            The end or hit position of the trace
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsTraceResult.HitPosition">
      <summary>
            The hit position of the trace
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsTraceResult.Normal">
      <summary>
            The hit surface normal (direction vector)
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsTraceResult.Fraction">
      <summary>
            A fraction [0..1] of where the trace hit between the start and the original end positions
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsTraceResult.Body">
      <summary>
            The physics object that was hit, if any
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsTraceResult.Shape">
      <summary>
            The physics shape that was hit, if any
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsTraceResult.Surface">
      <summary>
            The physical properties of the hit surface
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsTraceResult.Bone">
      <summary>
            The id of the hit bone (either from hitbox or physics shape)
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsTraceResult.Direction">
      <summary>
            The direction of the trace ray
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsTraceResult.Triangle">
      <summary>
            The triangle index hit, if we hit a mesh <see cref="T:Sandbox.PhysicsShape">physics shape</see></summary>
    </member>
    <member name="F:Sandbox.PhysicsTraceResult.Tags">
      <summary>
            The tags that the hit shape had
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsTraceResult.Distance">
      <summary>
            The distance between start and end positions.
            </summary>
    </member>
    <member name="T:Sandbox.PhysicsSimulationMode">
      <summary>
            Physics simulation mode. For use with <see cref="P:Sandbox.PhysicsWorld.SimulationMode" />.
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsSimulationMode.Discrete">
      <summary>
            Discrete collision detection.
            In this mode physics bodies can fly through thin walls when moving very quickly, but it is has better performance.
            </summary>
    </member>
    <member name="F:Sandbox.PhysicsSimulationMode.Continuous">
      <summary>
            Continuous collision detection. This is the default mode.
            </summary>
    </member>
    <member name="T:Sandbox.PhysicsWorld">
      <summary>
            A world in which physics objects exist. You can create your own world but you really don't need to. A world for the map is created clientside and serverside automatically.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsWorld.Bodies">
      <summary>
            All bodies in the world
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsWorld.CollisionRules">
      <summary>
            Set or retrieve the collision rules for this <see cref="T:Sandbox.PhysicsWorld" />.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsWorld.#ctor">
      <summary>
            Create a new physics world. You should only do this if you want to simulate an extra world for some reason.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsWorld.SetupPhysicsFromModel(Sandbox.Model,Sandbox.PhysicsMotionType)">
      <summary>
            Temp function for creating model physics until entity system handles it
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsWorld.SetupPhysicsFromModel(Sandbox.Model,Transform,Sandbox.PhysicsMotionType)">
      <summary>
            Temp function for creating model physics until entity system handles it
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsWorld.Delete">
      <summary>
            Delete this world and all objects inside. Will throw an exception if you try to delete a world that you didn't manually create.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsWorld.Step(System.Single)">
      <summary>
            Step simulation of this physics world. You can only do this on physics worlds that you manually create.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsWorld.Step(System.Single,System.Int32)">
      <summary>
            Step simulation of this physics world. You can only do this on physics worlds that you manually create.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsWorld.Step(System.Single,System.Single,System.Int32)">
      <summary>
            Step simulation of this physics world. You can only do this on physics worlds that you manually create.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsWorld.DebugSceneWorld">
      <summary>
            A SceneWorld where debug SceneObjects exist.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsWorld.DebugDraw">
      <summary>
            Updates all the SceneObjects in the <see cref="P:Sandbox.PhysicsWorld.DebugSceneWorld" />, call once per tick or frame.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsWorld.Gravity">
      <summary>
            Access the world's current gravity.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsWorld.AirDensity">
      <summary>
            Air density of this physics world, for things like air drag.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsWorld.Body">
      <summary>
            The body of this physics world.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsWorld.Group">
      <summary>
            The physics group of this physics world. A physics world will contain only 1 body.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsWorld.SleepingEnabled">
      <summary>
            If true then bodies will be able to sleep after a period of inactivity
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsWorld.SimulationMode">
      <summary>
            Physics simulation mode. See <see cref="T:Sandbox.PhysicsSimulationMode" /> for explanation of each mode.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsWorld.PositionIterations">
      <summary>
            Used for constraints (joints). Higher values should result in more accurate simulation (TODO: Confirm this)
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsWorld.VelocityIterations">
      <summary>
            Used for constraints (joints). Higher values should result in more accurate simulation (TODO: Confirm this)
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsWorld.SubSteps">
      <summary>
            If you're seeing objects go through other objects or you have a low tickrate, you might want to increase the number of physics substeps.
            This breaks physics steps down into this many substeps. The default is 1 and works pretty good.
            Be aware that the number of physics ticks per second is going to be tickrate * substeps.
            So if you're ticking at 90 and you have SubSteps set to 1000 then you're going to do 90,000 steps per second. So be careful here.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsWorld.SetCollisionRules(Sandbox.Physics.CollisionRules)">
      <summary>
            Used internally to set collision rules from gamemode's project settings.
            You shouldn't need to call this yourself.
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsWorld.GetCollisionRule(System.String,System.String)">
      <summary>
            Gets the specific collision rule for a pair of tags.
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsWorld.Trace">
      <summary>
            Raytrace against this world
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsWorld.RunTrace(Sandbox.PhysicsTraceBuilder@)">
      <summary>
            Like calling PhysicsTraceBuilder.Run, except will re-target this world if it's not already the target
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsWorld.RunTraceAll(Sandbox.PhysicsTraceBuilder@)">
      <summary>
            Like calling PhysicsTraceBuilder.RunAll, except will re-target this world if it's not already the target
            </summary>
    </member>
    <member name="T:Sandbox.ConfigData">
      <summary>
            Project configuration data is derived from this class
            </summary>
    </member>
    <member name="M:Sandbox.ConfigData.OnValidate">
      <summary>
            Called after deserialization, and before serialization. A place to error check and make sure everything is fine.
            </summary>
    </member>
    <member name="T:Sandbox.InputSettings">
      <summary>
            A class that holds all configured input settings for a game.
            This is serialized as a config and shared from the server to the client.
            </summary>
    </member>
    <member name="P:Sandbox.InputSettings.Actions">
      <summary>
            A list of actions used by the game.
            </summary>
    </member>
    <member name="T:Sandbox.NetworkingSettings">
      <summary>
            A class that holds all configured networking settings for a game.
            This is serialized as a config and shared from the server to the client.
            </summary>
    </member>
    <member name="P:Sandbox.NetworkingSettings.DestroyLobbyWhenHostLeaves">
      <summary>
            Whether to disband the game lobby when the host leaves.
            </summary>
    </member>
    <member name="P:Sandbox.NetworkingSettings.AutoSwitchToBestHost">
      <summary>
            Whether to periodically switch to the best host candidate. Candidates are
            scored based on their average ping and connection quality to all other peers.
            </summary>
    </member>
    <member name="P:Sandbox.NetworkingSettings.ClientsCanSpawnObjects">
      <summary>
            By default can clients create objects. This can be changed per connection after join.
            </summary>
    </member>
    <member name="P:Sandbox.NetworkingSettings.ClientsCanRefreshObjects">
      <summary>
            By default can clients refresh objects. This can be changed per connection after join.
            </summary>
    </member>
    <member name="P:Sandbox.NetworkingSettings.UpdateRate">
      <summary>
            The frequency at which the network system will send updates to clients. Higher is better but
            you probably want to stay in the 10-60 range.
            </summary>
    </member>
    <member name="P:Sandbox.ProjectSettings.Collision">
      <summary>
            Get the <see cref="T:Sandbox.Physics.CollisionRules" /> from the active project settings.
            </summary>
    </member>
    <member name="P:Sandbox.ProjectSettings.Input">
      <summary>
            Get the <see cref="P:Sandbox.ProjectSettings.Input" /> from the active project settings.
            </summary>
    </member>
    <member name="P:Sandbox.ProjectSettings.Networking">
      <summary>
            Get the <see cref="T:Sandbox.NetworkingSettings" /> from the active project settings.
            </summary>
    </member>
    <member name="P:Sandbox.ProjectSettings.Mixer">
      <summary>
            Get the <see cref="T:Sandbox.Audio.MixerSettings" /> from the active project settings.
            </summary>
    </member>
    <member name="P:Sandbox.ProjectSettings.Cursor">
      <summary>
            Get the <see cref="T:Sandbox.CursorSettings" /> from the active project settings.
            </summary>
    </member>
    <member name="P:Sandbox.ProjectSettings.Physics">
      <summary>
            Get the <see cref="P:Sandbox.ProjectSettings.Physics" /> from the active project settings.
            </summary>
    </member>
    <member name="M:Sandbox.ProjectSettings.ClearCache">
      <summary>
            Reset any stored references to Project Settings.
            </summary>
    </member>
    <member name="M:Sandbox.ProjectSettings.Get``1(System.String)">
      <summary>
            Gets or creates a default version of this config data. You can safely call this multiple times
            and it will return the same object. The cache is cleared automatically when the project changes, 
            or when it's hotloaded.
            </summary>
    </member>
    <member name="T:Sandbox.Project">
      <summary>
            Represents an on-disk project.
            </summary>
      <summary>
            Represents an on-disk project.
            </summary>
    </member>
    <member name="P:Sandbox.Project.HasCompiler">
      <summary>
            Whether the project's code has a compiler assigned.
            </summary>
    </member>
    <member name="P:Sandbox.Project.BaseReferencingTypes">
      <summary>
            These package types should reference package.base
            </summary>
    </member>
    <member name="M:Sandbox.Project.UpdateEditorCompiler">
      <summary>
            If required, create the editor compiler
            </summary>
    </member>
    <member name="M:Sandbox.Project.FindByCompiler(Sandbox.Compiler)">
      <summary>
            Find a project from a compiler
            </summary>
    </member>
    <member name="M:Sandbox.Project.LoadPrecompiled">
      <summary>
            Loads precompiled assemblies that might exist (menu) as long as we're not in editor or headless or anything
            </summary>
    </member>
    <member name="P:Sandbox.Project.ProjectSourceObject">
      <summary>
            If this is a single asset project, this will be the asset object
            </summary>
    </member>
    <member name="P:Sandbox.Project.ConfigFilePath">
      <summary>
            Absolute path to the .addon file
            </summary>
    </member>
    <member name="P:Sandbox.Project.RootDirectory">
      <summary>
            Root directory of this project
            </summary>
    </member>
    <member name="P:Sandbox.Project.Active">
      <summary>
            True if this project is active
            </summary>
    </member>
    <member name="P:Sandbox.Project.Pinned">
      <summary>
            True if this project is pinned, we'll prioritise it when sorting
            </summary>
    </member>
    <member name="P:Sandbox.Project.LastOpened">
      <summary>
            When did the user last open this project?
            </summary>
    </member>
    <member name="P:Sandbox.Project.Broken">
      <summary>
            True if this project failed to load properly for some reason
            </summary>
    </member>
    <member name="P:Sandbox.Project.IsPublished">
      <summary>
            Returns true if this project has previously been published. This is kind of a guess though
            because all it does is look to see if we have a published package cached with the same ident.
            </summary>
    </member>
    <member name="P:Sandbox.Project.EditUrl">
      <summary>
            The URL to the package's page for editing
            </summary>
    </member>
    <member name="P:Sandbox.Project.ViewUrl">
      <summary>
            The URL to the package's page for viewing/linking
            </summary>
    </member>
    <member name="P:Sandbox.Project.Config">
      <summary>
            Configuration of the project.
            </summary>
    </member>
    <member name="P:Sandbox.Project.IsTransient">
      <summary>
            If true this project isn't a 'real' project. It's likely a temporary project created with the
            intention to configure and publish a single asset.
            </summary>
    </member>
    <member name="P:Sandbox.Project.IsBuiltIn">
      <summary>
            If true this project isn't a 'real' project. It's likely a temporary project created with the
            intention to configure and publish a single asset.
            </summary>
    </member>
    <member name="P:Sandbox.Project.OnSaveProject">
      <summary>
            Called when the project is about to save
            </summary>
    </member>
    <member name="P:Sandbox.Project.AssemblyFileSystem">
      <summary>
            A filesystem into which compiled assemblies are written
            </summary>
    </member>
    <member name="M:Sandbox.Project.GetRootPath">
      <summary>
            Absolute path to the location of the <c>.sbproj</c> file of the project.
            </summary>
    </member>
    <member name="M:Sandbox.Project.GetCodePath">
      <summary>
            Absolute path to the code folder of the project.
            </summary>
    </member>
    <member name="M:Sandbox.Project.HasCodePath">
      <summary>
            Returns true if the Code path exists
            </summary>
    </member>
    <member name="M:Sandbox.Project.GetAssetsPath">
      <summary>
            Absolute path to the assets folder of the project, or <see langword="null" /> if not set.
            </summary>
    </member>
    <member name="M:Sandbox.Project.GetLocalizationPath">
      <summary>
            Absolute path to the localization folder of the project, or <see langword="null" /> if not set.
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.Project.HasAssetsPath">
      <summary>
            Returns true if the Assets path exists
            </summary>
    </member>
    <member name="P:Sandbox.Project.Package">
      <summary>
            The package for this project. This is a mock up of the actual package.
            </summary>
    </member>
    <member name="M:Sandbox.Project.IsSourcePublish">
      <summary>
            Return true if this project type uploads all the source files when it's published
            </summary>
    </member>
    <member name="P:Sandbox.Project.Current">
      <summary>
            Current open project.
            </summary>
    </member>
    <member name="M:Sandbox.Project.Clear">
      <summary>
            Remove all local packages. Used by unit tests to reset state.
            </summary>
    </member>
    <member name="M:Sandbox.Project.Tick">
      <summary>
            Check whether the group needs recompiling, and recompiles
            </summary>
    </member>
    <member name="M:Sandbox.Project.InitializeBuiltIn(System.Boolean)">
      <summary>
            Initializes all the base projects
            </summary>
    </member>
    <member name="M:Sandbox.Project.SyncWithPackageManager">
      <summary>
            Takes all of the active projects and makes sure we're in sync
            with the package manager. Creates mock packages that act like real ones.
            Removes packages that are no longer active. If nothing changed then this should
            do nothing.
            </summary>
    </member>
    <member name="M:Sandbox.Project.GenerateSolution">
      <summary>
            (Re)generate the active project's solution file.
            </summary>
    </member>
    <member name="M:Sandbox.Project.AddFromFileBuiltIn(System.String)">
      <summary>
            Like AddFromFile but the project is marked as "built in" - which means
            it's always automatically loaded and can't be unloaded.
            </summary>
    </member>
    <member name="M:Sandbox.Project.ResolveCompiler(System.Reflection.Assembly)">
      <summary>
            Resolve an assemblt to a compiler using the assembly name
            </summary>
    </member>
    <member name="P:Sandbox.AnimationSequence.Duration">
      <summary>
            The duration of the currently playing sequence (seconds)
            </summary>
    </member>
    <member name="P:Sandbox.AnimationSequence.IsFinished">
      <summary>
            Get whether the current animation sequence has finished
            </summary>
    </member>
    <member name="P:Sandbox.AnimationSequence.Name">
      <summary>
            The name of the currently playing animation sequence
            </summary>
    </member>
    <member name="P:Sandbox.AnimationSequence.TimeNormalized">
      <summary>
            The normalized (between 0 and 1) elapsed time of the currently playing
            animation sequence
            </summary>
    </member>
    <member name="P:Sandbox.AnimationSequence.Time">
      <summary>
            The elapsed time of the currently playing animation sequence (seconds)
            </summary>
    </member>
    <member name="P:Sandbox.AnimationSequence.Looping">
      <summary>
            Get or set whether the current animation sequence is looping
            </summary>
    </member>
    <member name="P:Sandbox.AnimationSequence.SequenceNames">
      <summary>
            The list of sequences that can be used
            </summary>
    </member>
    <member name="T:Sandbox.AnimGraphDirectPlayback">
      <summary>
            For communicating with a Direct Playback Anim Node, which allows code to tell it to play a given sequence
            </summary>
    </member>
    <member name="P:Sandbox.AnimGraphDirectPlayback.StartTime">
      <summary>
            Set the time at which the currently playing sequence should have had a cycle of zero.
            This will adjust the current cycle of the sequence to match.
            </summary>
    </member>
    <member name="P:Sandbox.AnimGraphDirectPlayback.TimeNormalized">
      <summary>
            Get the cycle of the currently playing sequence.  Will return 0 if no sequence is playing.
            </summary>
    </member>
    <member name="P:Sandbox.AnimGraphDirectPlayback.Duration">
      <summary>
            The duration of the currently playing sequence (seconds)
            </summary>
    </member>
    <member name="P:Sandbox.AnimGraphDirectPlayback.Time">
      <summary>
            The elapsed time of the currently playing animation sequence (seconds)
            </summary>
    </member>
    <member name="P:Sandbox.AnimGraphDirectPlayback.Name">
      <summary>
            Returns the currently playing sequence.
            </summary>
    </member>
    <member name="P:Sandbox.AnimGraphDirectPlayback.AnimationCount">
      <summary>
            Get the number of animations that can be used.
            </summary>
    </member>
    <member name="P:Sandbox.AnimGraphDirectPlayback.Animations">
      <summary>
            Get the list of animations that can be used.
            </summary>
    </member>
    <member name="P:Sandbox.AnimGraphDirectPlayback.Sequences">
      <summary>
            Get the list of sequences that can be used.
            </summary>
    </member>
    <member name="M:Sandbox.AnimGraphDirectPlayback.Play(System.String)">
      <summary>
            Play the given sequence until it ends, then blend back.
            Calling this function with a new sequence while another one is playing will immediately start blending from the old one to the new one.  
            </summary>
    </member>
    <member name="M:Sandbox.AnimGraphDirectPlayback.Play(System.String,Vector3,System.Single,System.Single)">
      <summary>
            Same as the other Play function, but also sets a target position and heading for the sequence.
            Over interpTime seconds, the entity's root motion will be augmented to move it to target and rotate it to heading. 
            </summary>
    </member>
    <member name="M:Sandbox.AnimGraphDirectPlayback.Cancel">
      <summary>
            Stop playing the override sequence.
            </summary>
    </member>
    <member name="F:Sandbox.ComputeBufferType.Structured">
      <summary>
            Structured Buffer (HLSL RWStructuredBuffer)
            </summary>
    </member>
    <member name="F:Sandbox.ComputeBufferType.ByteAddress">
      <summary>
            Byte Address Buffer (HLSL RWByteAddressBuffer)
            </summary>
    </member>
    <member name="F:Sandbox.ComputeBufferType.Append">
      <summary>
            Append Structured Buffer (HLSL AppendStructuredBuffer)
            </summary>
    </member>
    <member name="F:Sandbox.ComputeBufferType.IndirectDrawArguments">
      <summary>
            Indirect argument buffer for indirect draws
            <seealso cref="T:Sandbox.GpuBuffer.IndirectDrawArguments" /></summary>
    </member>
    <member name="T:Sandbox.ComputeShader">
      <summary>
            A compute shader is a program that runs on the GPU, often with data provided to/from the CPU by means of a <see cref="T:Sandbox.GpuBuffer`1" /> or a <see cref="T:Sandbox.Texture" />.
            </summary>
      <seealso cref="T:Sandbox.GpuBuffer`1" />
    </member>
    <member name="P:Sandbox.ComputeShader.Attributes">
      <summary>
            Attributes that are passed to the compute shader on dispatch.
            </summary>
    </member>
    <member name="M:Sandbox.ComputeShader.#ctor(System.String)">
      <summary>
            Create a compute shader from the specified path.
            </summary>
    </member>
    <member name="M:Sandbox.ComputeShader.Dispatch(System.Int32,System.Int32,System.Int32)">
      <summary>
            Dispatch this compute shader using explicit thread counts.
            </summary>
      <remarks>
            The specified thread counts will be automatically divided by the thread group size
            defined in the shader to compute the final dispatch group count.
            <para>
            When called outside a graphics context, the dispatch runs immediately.  
            When called inside a graphics context, the dispatch runs async.
            </para></remarks>
      <param name="threadsX">The number of threads to dispatch in the X dimension.</param>
      <param name="threadsY">The number of threads to dispatch in the Y dimension.</param>
      <param name="threadsZ">The number of threads to dispatch in the Z dimension.</param>
    </member>
    <member name="M:Sandbox.ComputeShader.DispatchIndirect(Sandbox.GpuBuffer,System.UInt32)">
      <summary>
            Dispatch this compute shader by reading thread group counts (x, y, z)
            from an indirect buffer of type <see cref="T:Sandbox.GpuBuffer.IndirectDispatchArguments" />.
            </summary>
      <remarks>
        <para>
          <paramref name="indirectBuffer" /> must be created with <see cref="F:Sandbox.GpuBuffer.UsageFlags.IndirectDrawArguments" />  
            and have an element size of 12 bytes.
            </para>
        <para>
          <paramref name="indirectElementOffset" /> is an element index into <paramref name="indirectBuffer" />, not a byte offset.
            </para>
        <para>
            When called outside a graphics context, the dispatch runs immediately.  
            When called inside a graphics context, the dispatch runs async.
            </para>
      </remarks>
      <param name="indirectBuffer">The GPU buffer containing one or more dispatch argument entries.</param>
      <param name="indirectElementOffset">The index of the dispatch arguments element to use (each element = 12 bytes).</param>
    </member>
    <member name="M:Sandbox.ComputeShader.DispatchWithAttributes(Sandbox.RenderAttributes,System.Int32,System.Int32,System.Int32)">
      <inheritdoc cref="M:Sandbox.ComputeShader.Dispatch(System.Int32,System.Int32,System.Int32)" />
    </member>
    <member name="M:Sandbox.ComputeShader.DispatchIndirectWithAttributes(Sandbox.RenderAttributes,Sandbox.GpuBuffer,System.UInt32)">
      <inheritdoc cref="M:Sandbox.ComputeShader.DispatchIndirect(Sandbox.GpuBuffer,System.UInt32)" />
    </member>
    <member name="T:Sandbox.CubemapRendering">
      <summary>
            Provides functionality for rendering and filtering cubemap textures.
            Used for environment mapping and image-based lighting in PBR rendering.
            </summary>
    </member>
    <member name="T:Sandbox.CubemapRendering.GGXFilterType">
      <summary>
            Specifies the quality level for GGX filtering of environment maps.
            </summary>
    </member>
    <member name="F:Sandbox.CubemapRendering.GGXFilterType.Fast">
      <summary>
            Faster filtering with lower sample count.
            </summary>
    </member>
    <member name="F:Sandbox.CubemapRendering.GGXFilterType.Quality">
      <summary>
            Higher quality filtering with more samples.
            </summary>
    </member>
    <member name="M:Sandbox.CubemapRendering.Render(Sandbox.SceneWorld,Sandbox.Texture,Transform,System.Single,System.Single,Sandbox.CubemapRendering.GGXFilterType)">
      <summary>
            Renders a cubemap from a scene at the specified transform position and applies filtering.
            </summary>
      <param name="world">The scene world to render.</param>
      <param name="cubemapTexture">The texture to render the cubemap to.</param>
      <param name="cubemapTransform">The position and rotation of the cubemap camera.</param>
      <param name="znear">The near plane distance for the camera.</param>
      <param name="zfar">The far plane distance for the camera.</param>
      <param name="filterType">The quality level for GGX filtering.</param>
    </member>
    <member name="M:Sandbox.CubemapRendering.Filter(Sandbox.Texture,Sandbox.CubemapRendering.GGXFilterType)">
      <summary>
            Applies filtering to a cubemap texture, generating both downsample and GGX filtering.
            </summary>
      <param name="cubemapTexture">The cubemap texture to filter.</param>
      <param name="filterType">The quality level for GGX filtering.</param>
      <exception cref="T:System.Exception">Thrown when the cubemap texture doesn't meet requirements.</exception>
    </member>
    <member name="M:Sandbox.CubemapRendering.FilterDownsample(Sandbox.Texture)">
      <summary>
            Downsamples a cubemap texture to generate its mip chain.
            </summary>
      <param name="cubemapTexture">The cubemap texture to downsample.</param>
    </member>
    <member name="M:Sandbox.CubemapRendering.FilterGGX(Sandbox.Texture,Sandbox.CubemapRendering.GGXFilterType)">
      <summary>
            Applies GGX filtering to a cubemap texture for image-based lighting.
            This generates the pre-filtered environment map used in PBR workflows.
            </summary>
      <param name="cubemapTexture">The cubemap texture to filter.</param>
      <param name="filterType">The quality level for GGX filtering.</param>
    </member>
    <member name="M:Sandbox.CubemapRendering.SumOfSquaresTwo(System.Int32)">
      <summary>
            Calculates the sum of squares of powers of two up to n.
            Formula: 1² + 2² + 4² + 8² + ... + (2^k)² where 2^k ≤ n
            Used for determining compute shader dispatch dimensions.
            </summary>
      <param name="n">The upper limit for powers of two.</param>
      <returns>The sum of squares of powers of two up to n.</returns>
    </member>
    <member name="T:Sandbox.GpuBuffer">
      <summary>
             A GPU data buffer intended for use with a <see cref="T:Sandbox.ComputeShader" />.
             
             You can read and write arbitrary data to and from the CPU and GPU.
             This allows for efficient parallel data processing on the GPU.
             
             Different GPU buffer types can be used depending on the provided <see cref="T:Sandbox.GpuBuffer.UsageFlags" />.
             Using the default <see cref="F:Sandbox.GpuBuffer.UsageFlags.Structured" /> type buffers map to StructuredBuffer&lt;T&gt; and RWStructuredBuffer&lt;T&gt; in HLSL.
             </summary>
      <example>
             This example shows how to use the GpuBuffer class to send data to a compute shader:
             <code>
             struct MyData
             {
                 public float Value;
             }
             
             // Allocate the GPU buffer
             using (var buffer = new GpuBuffer&lt;MyData&gt;( 2 ))
             {
            		// Upload data to the GPU buffer
            		var data = new MyData[] { new MyData { Value = 1.0f }, new MyData { Value = 2.0f } };
            		buffer.SetData( data );
             
                 // Pass the buffer to a compute shader
                 ComputeShader.Attributes.Set( "myData", buffer );
                 
                 // Dispatch the shader
                 ComputeShader.Dispatch();
             }
             </code></example>
      <example>
             This example shows how to retrieve data from a GPU using the GpuBuffer class:
             <code>
             struct MyData
             {
                 public float Value;
             }
             
             using (var buffer = new GpuBuffer&lt;MyData&gt;( 8 ))
             {
                 // Pass the buffer to a compute shader
                 ComputeShader.Attributes.Set( "myData", buffer );
                 
                 // Dispatch the shader
                 ComputeShader.Dispatch();
                 
            		// Retrieve the data from the GPU
            		var data = new MyData[ 8 ];
            		buffer.GetData( data, 0, 8 );
             }
             </code></example>
      <seealso cref="T:Sandbox.ComputeShader" />
      <seealso cref="M:Sandbox.RenderAttributes.Set(Sandbox.StringToken@,Sandbox.GpuBuffer@)" />
    </member>
    <member name="P:Sandbox.GpuBuffer.ElementCount">
      <summary>
            Number of elements in the buffer.
            </summary>
    </member>
    <member name="P:Sandbox.GpuBuffer.ElementSize">
      <summary>
            Size of a single element in the buffer.
            </summary>
    </member>
    <member name="P:Sandbox.GpuBuffer.Usage">
      <summary>
            What sort of buffer this is
            </summary>
    </member>
    <member name="M:Sandbox.GpuBuffer.#ctor(System.Int32,System.Int32,Sandbox.GpuBuffer.UsageFlags,System.String)">
      <summary>
            Creates a new GPU buffer with a specified number of elements and a specific buffer type.
            </summary>
      <param name="elementCount">The total number of elements that the GpuBuffer can hold. This represents the buffer's size in terms of elements, not bytes.</param>
      <param name="elementSize">The total number of elements that the GpuBuffer can hold. This represents the buffer's size in terms of elements, not bytes.</param>
      <param name="flags">Defines the usage pattern of the GPU buffer. This can affect performance depending on how the buffer is utilized.</param>
      <param name="debugName">Test</param>
    </member>
    <member name="M:Sandbox.GpuBuffer.Dispose">
      <summary>
            Destroys the GPU buffer, don't use it no more
            </summary>
    </member>
    <member name="M:Sandbox.GpuBuffer.GetData``1(System.Span{``0})">
      <summary>
            Retrieves the GPU buffer and copies them into a provided Span.
            </summary>
      <remarks>
            This operation is synchronous and will block until the data has been fully downloaded from the GPU.
            </remarks>
      <param name="data">A Span of type T which the GPU buffer's contents will be copied into.</param>
    </member>
    <member name="M:Sandbox.GpuBuffer.GetData``1(System.Span{``0},System.Int32,System.Int32)">
      <summary>
            Retrieves a number of elements from the GPU buffer and copies them into a provided Span.
            </summary>
      <remarks>
            This operation is synchronous and will block until the specified range of data has been fully downloaded from the GPU.
            </remarks>
      <param name="data">A Span of type T which the GPU buffer's contents will be copied into.</param>
      <param name="start">The starting index from which to begin retrieving data. This index is in terms of elements, not bytes.</param>
      <param name="count">The number of elements to retrieve from the GPU buffer. This count is also in terms of elements, not bytes.</param>
    </member>
    <member name="M:Sandbox.GpuBuffer.SetData``1(System.Span{``0},System.Int32)">
      <summary>
            Synchronously uploads data from a Span to the GPU, replacing the existing data in this GpuBuffer.
            </summary>
      <remarks>
            This operation is synchronous; it will block until the data has been fully uploaded to the GPU.
            </remarks>
      <param name="data">The Span of data to upload. It should contain items of type T, which is a struct.</param>
      <param name="elementOffset">The offset in terms of elements (not bytes) at which to start uploading data (default is 0).</param>
    </member>
    <member name="M:Sandbox.GpuBuffer.SetData``1(System.Collections.Generic.List{``0},System.Int32)">
      <summary>
            Synchronously uploads data from a List to the GPU, replacing the existing data in this GpuBuffer.
            </summary>
      <remarks>
            This operation is synchronous; it will block until the data has been fully uploaded to the GPU.
            </remarks>
      <param name="data">The List of data to upload. It should contain items of type T, which is a struct.</param>
      <param name="elementOffset">The offset in terms of elements (not bytes) at which to start uploading data (default is 0).</param>
    </member>
    <member name="M:Sandbox.GpuBuffer.CopyStructureCount(Sandbox.GpuBuffer,System.Int32)">
      <summary>
            For <see cref="F:Sandbox.GpuBuffer.UsageFlags.Append" /> buffers there is a hidden uint 32-bit atomic counter in the buffer that contains the number of 
            writes to the buffer after invocation of the compute shader.  In order to get the value of the counter, the data needs to be copied to
            another GPU buffer that can be used.
            </summary>
    </member>
    <member name="M:Sandbox.GpuBuffer.SetCounterValue(System.UInt32)">
      <summary>
            Sets the counter value for <see cref="F:Sandbox.GpuBuffer.UsageFlags.Append" /> or <see cref="F:Sandbox.GpuBuffer.UsageFlags.Counter" /> structured buffers.
            </summary>
    </member>
    <member name="T:Sandbox.GpuBuffer.UsageFlags">
      <summary>
            You can combine these e.g UsageFlags.Index | UsageFlags.ByteAddress for a buffer that can be used as an index buffer and in a compute shader.
            </summary>
    </member>
    <member name="F:Sandbox.GpuBuffer.UsageFlags.Vertex">
      <summary>
            Can be used as a vertex buffer.
            </summary>
    </member>
    <member name="F:Sandbox.GpuBuffer.UsageFlags.Index">
      <summary>
            Can be used as an index buffer.
            </summary>
    </member>
    <member name="F:Sandbox.GpuBuffer.UsageFlags.ByteAddress">
      <summary>
            Byte Address Buffer (HLSL RWByteAddressBuffer)
            </summary>
    </member>
    <member name="F:Sandbox.GpuBuffer.UsageFlags.Structured">
      <summary>
            Structured Buffer (HLSL RWStructuredBuffer)
            </summary>
    </member>
    <member name="F:Sandbox.GpuBuffer.UsageFlags.Append">
      <summary>
            Append Structured Buffer (HLSL AppendStructuredBuffer)
            </summary>
    </member>
    <member name="F:Sandbox.GpuBuffer.UsageFlags.IndirectDrawArguments">
      <summary>
            Indirect argument buffer for indirect draws
            <seealso cref="T:Sandbox.GpuBuffer.IndirectDrawArguments" /><seealso cref="T:Sandbox.GpuBuffer.IndirectDrawIndexedArguments" /></summary>
    </member>
    <member name="F:Sandbox.GpuBuffer.IndirectDrawArguments.VertexCount">
      <summary>
            Number of vertices to draw per instance.
            </summary>
    </member>
    <member name="F:Sandbox.GpuBuffer.IndirectDrawArguments.InstanceCount">
      <summary>
            Number of instances to draw.
            </summary>
    </member>
    <member name="F:Sandbox.GpuBuffer.IndirectDrawArguments.FirstVertex">
      <summary>
            Index of the first vertex to draw.
            </summary>
    </member>
    <member name="F:Sandbox.GpuBuffer.IndirectDrawArguments.FirstInstance">
      <summary>
            Instance ID of the first instance.
            </summary>
    </member>
    <member name="F:Sandbox.GpuBuffer.IndirectDrawIndexedArguments.IndexCount">
      <summary>
            Number of indices to draw per instance.
            </summary>
    </member>
    <member name="F:Sandbox.GpuBuffer.IndirectDrawIndexedArguments.InstanceCount">
      <summary>
            Number of instances to draw.
            </summary>
    </member>
    <member name="F:Sandbox.GpuBuffer.IndirectDrawIndexedArguments.FirstIndex">
      <summary>
            Index of the first index to draw.
            </summary>
    </member>
    <member name="F:Sandbox.GpuBuffer.IndirectDrawIndexedArguments.BaseVertex">
      <summary>
            Value added to each index before indexing into the vertex buffer.
            </summary>
    </member>
    <member name="F:Sandbox.GpuBuffer.IndirectDrawIndexedArguments.FirstInstance">
      <summary>
            Instance ID of the first instance.
            </summary>
    </member>
    <member name="T:Sandbox.GpuBuffer`1">
      <summary>
            A typed GpuBuffer
            </summary>
      <typeparam name="T">
            The type of data that the GpuBuffer will store.
            Must be a <see href="https://docs.microsoft.com/en-us/dotnet/framework/interop/blittable-and-non-blittable-types">blittable</see> value type.
            </typeparam>
    </member>
    <member name="T:Sandbox.Graphics">
      <summary>
            Used to render to the screen using your Graphics Card, or whatever you
            kids are using in your crazy future computers. Whatever it is I'm sure
            it isn't fungible and everyone has free money and no-one has to ever work.
            </summary>
    </member>
    <member name="P:Sandbox.Graphics.IsActive">
      <summary>
            If true then we're currently rendering and
            you are safe to use the contents of this class
            </summary>
    </member>
    <member name="P:Sandbox.Graphics.LayerType">
      <summary>
            The current layer type. This is useful to tell whether you're meant to be drawing opaque, transparent or shadow. You mainly
            don't need to think about this, but when you do, it's here.
            </summary>
    </member>
    <member name="F:Sandbox.Graphics.grabbedTextures">
      <summary>
            When Frame grabbing, we store the result in this pooled render target. It stays checked out
            until the end of this render scope.
            </summary>
    </member>
    <member name="P:Sandbox.Graphics.Viewport">
      <summary>
            In pixel size, where are we rendering to?
            </summary>
    </member>
    <member name="P:Sandbox.Graphics.Attributes">
      <summary>
            Access to the current render context's attributes. These will be used
            to set attributes in materials/shaders. This is cleared at the end of the render block.
            </summary>
    </member>
    <member name="P:Sandbox.Graphics.FrameAttributes">
      <summary>
            Access to the current frame's attributes.
            These will live until the end of the frame.
            </summary>
    </member>
    <member name="P:Sandbox.Graphics.CameraPosition">
      <summary>
            The camera position of the currently rendering view
            </summary>
    </member>
    <member name="T:Sandbox.Graphics.Scope">
      <summary>
            Creates a scope where Graphics is safe to use.
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.SetupLighting(Sandbox.SceneObject,Sandbox.RenderAttributes)">
      <summary>
            Setup the lighting attributes for this current object. Place them in the targetAttributes
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.GrabFrameTexture(System.String,Sandbox.RenderAttributes,System.Boolean)">
      <summary>
            Grabs the current viewport's color texture and stores it in targetName on renderAttributes.
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.GrabDepthTexture(System.String,Sandbox.RenderAttributes,System.Boolean)">
      <summary>
            Grabs the current depth texture and stores it in targetName on renderAttributes.
            </summary>
    </member>
    <member name="P:Sandbox.Graphics.RenderTarget">
      <summary>
            Get or set the current render target. Setting this will bind the render target and change the viewport to match it.
            </summary>
    </member>
    <member name="P:Sandbox.Graphics.NativeLayerRenderTarget">
      <summary>
            Get the current color and depth MSAA render targets that this layer is rendering to.
            This should be set on start of scope but is causing problems, left here for advanced usage.
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.Clear(Color,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Clear the current drawing context to given color.
            </summary>
      <param name="color">Color to clear to.</param>
      <param name="clearColor">Whether to clear the color buffer at all.</param>
      <param name="clearDepth">Whether to clear the depth buffer.</param>
      <param name="clearStencil">Whether to clear the stencil buffer.</param>
    </member>
    <member name="M:Sandbox.Graphics.Clear(System.Boolean,System.Boolean)">
      <summary>
            Clear the current drawing context to given color.
            </summary>
      <param name="clearColor">Whether to clear the color buffer to transparent color.</param>
      <param name="clearDepth">Whether to clear the depth buffer.</param>
    </member>
    <member name="M:Sandbox.Graphics.RenderToTexture(Sandbox.SceneCamera,Sandbox.Texture)">
      <summary>
            Render this camera to the specified texture target
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.CopyTexture(Sandbox.Texture,Sandbox.Texture)">
      <summary>
            Copies pixel data from one texture to another on the GPU.
            This does not automatically resize or scale the texture, format and size should be equal.
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.CopyTexture(Sandbox.Texture,Sandbox.Texture,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Copies pixel data from one texture to another on the GPU.
            This does not automatically resize or scale the texture, format and size should be equal.
            This one lets you copy to/from arrays / specific mips.
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.Draw``1(Sandbox.GpuBuffer{``0},Sandbox.Material,System.Int32,System.Int32,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
      <summary>
            Draws geometry using a vertex buffer and material.
            </summary>
      <typeparam name="T">The vertex type used for vertex layout.</typeparam>
      <param name="vertexBuffer">The GPU buffer containing vertex data.</param>
      <param name="material">The material to use for rendering.</param>
      <param name="startVertex">The starting vertex index for rendering.</param>
      <param name="vertexCount">The number of vertices to render. If 0, uses all vertices in the buffer.</param>
      <param name="attributes">Optional render attributes to apply only for this draw call.</param>
      <param name="primitiveType">The type of primitives to render. Defaults to triangles.</param>
    </member>
    <member name="M:Sandbox.Graphics.Draw``1(Sandbox.GpuBuffer{``0},Sandbox.GpuBuffer,Sandbox.Material,System.Int32,System.Int32,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
      <summary>
            Draws indexed geometry using vertex and index buffers.
            </summary>
      <typeparam name="T">The vertex type used for vertex layout.</typeparam>
      <param name="vertexBuffer">The GPU buffer containing vertex data.</param>
      <param name="indexBuffer">The GPU buffer containing index data.</param>
      <param name="material">The material to use for rendering.</param>
      <param name="startIndex">The starting index for rendering.</param>
      <param name="indexCount">The number of indices to render. If 0, uses all indices in the buffer.</param>
      <param name="attributes">Optional render attributes to apply only for this draw call.</param>
      <param name="primitiveType">The type of primitives to render. Defaults to triangles.</param>
    </member>
    <member name="M:Sandbox.Graphics.DrawInternal``1(``0*,System.Int32,System.UInt16*,System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
      <summary>
            This is our entry point into the engine for all draws
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.Draw(System.Span{Sandbox.Vertex},System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
      <summary>
            Draw a bunch of vertices
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.Draw``1(System.Span{``0},System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
      <summary>
            Draw a bunch of vertices
            TODO: make this public
            TODO: Is this safe to be public
            TODO: Is VertexLayoutManager.Get Safe 
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.Draw(System.Collections.Generic.List{Sandbox.Vertex},System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
      <summary>
            Draw a bunch of vertices
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.Draw``1(System.Collections.Generic.List{``0},System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
      <summary>
            Draw a bunch of vertices
            TODO: make this public
            TODO: Is this safe to be public
            TODO: Is VertexLayoutManager.Get Safe 
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.Draw(System.Span{Sandbox.Vertex},System.Int32,System.Span{System.UInt16},System.Int32,Sandbox.Material,Sandbox.RenderAttributes,Sandbox.Graphics.PrimitiveType)">
      <summary>
            Draw a bunch of vertices
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.Blit(Sandbox.Material,Sandbox.RenderAttributes)">
      <summary>
            Draw a screen space quad using the passed material. Your material should be using a
            screenspace shader so it will actually render to the screen and not in worldspace at 0,0,0
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.Render(Sandbox.SceneObject,System.Nullable{Transform},System.Nullable{Color},Sandbox.Material)">
      <summary>
            Render a SceneObject
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.DrawQuad(Sandbox.Rect@,Sandbox.Material@,Color@,Sandbox.RenderAttributes)">
      <summary>
            Draw a quad in screenspace
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.DrawQuad(Sandbox.Rect@,System.Single@,Sandbox.Material@,Color@,Sandbox.RenderAttributes)">
      <summary>
            Draw a rotated quad in screenspace
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.DrawText(Sandbox.Rect@,System.String,Color,System.String,System.Single,System.Single,Sandbox.TextFlag)">
      <summary>
            Draws a text quad in screenspace using the Material.UI.Text material.
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.DrawText(Sandbox.Rect@,Sandbox.TextRendering.Scope@,Sandbox.TextFlag)">
      <summary>
            Draws a text quad in screenspace using the Material.UI.Text material.
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.DrawText(Sandbox.Rect@,System.Single,Sandbox.TextRendering.Scope@,Sandbox.TextFlag)">
      <summary>
            Draws a rotated text quad in screenspace using the Material.UI.Text material.
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.DrawText(Vector2@,System.String,Color,System.String,System.Single,System.Single)">
      <summary>
            Draws a text quad in screenspace using the Material.UI.Text material.
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.MeasureText(Sandbox.Rect@,System.String,System.String,System.Single,System.Single,Sandbox.TextFlag)">
      <summary>
            Measure how big some text will be, without having to render it
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.MeasureText(Sandbox.Rect@,Sandbox.TextRendering.Scope@,Sandbox.TextFlag)">
      <summary>
            Measure how big some text will be, without having to render it
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.DrawIcon(Sandbox.Rect,System.String,Color,System.Single,Sandbox.TextFlag)">
      <summary>
            Calls DrawText with "Material Icons" font. You can get a list of icons here https://fonts.google.com/icons?selected=Material+Icons
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.DrawRoundedRectangle(Sandbox.Rect@,Color@,Vector4@,Vector4@,Color@)">
      <summary>
            Draw a rounded rectangle, with optional border, in Material.UI.Box
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.DrawModel(Sandbox.Model,Transform,Sandbox.RenderAttributes)">
      <summary>
            Draws a single model at the given Transform immediately.
            </summary>
      <param name="model">The model to draw</param>
      <param name="transform">Transform to draw the model at</param>
      <param name="attributes">Optional attributes to apply only for this draw call</param>
    </member>
    <member name="M:Sandbox.Graphics.DrawModelInstanced(Sandbox.Model,System.Span{Transform},Sandbox.RenderAttributes)">
      <summary>
            Draws multiple instances of a model using GPU instancing, assuming standard implemented shaders.
            
            Use `CalculateInstancingObjectToWorldMatrix` in shaders to access the instance transform.
            
            There is a limit of 1,048,576 transform slots per frame when using this method.
            </summary>
      <param name="model">The model to draw</param>
      <param name="transforms">Instance transform data to draw</param>
      <param name="attributes">Optional attributes to apply only for this draw call</param>
    </member>
    <member name="M:Sandbox.Graphics.DrawModelInstancedIndirect(Sandbox.Model,Sandbox.GpuBuffer,System.Int32,Sandbox.RenderAttributes)">
      <summary>
            Draws multiple instances of a model using GPU instancing with the number of instances being provided by indirect draw arguments.
            Use `SV_InstanceID` semantic in shaders to access the rendered instance.
            </summary>
      <param name="model">The model to draw</param>
      <param name="buffer">The GPU buffer containing the DrawIndirectArguments</param>
      <param name="bufferOffset">Optional offset in the GPU buffer</param>
      <param name="attributes">Optional attributes to apply only for this draw call</param>
    </member>
    <member name="M:Sandbox.Graphics.DrawModelInstanced(Sandbox.Model,System.Int32,Sandbox.RenderAttributes)">
      <summary>
            Draws multiple instances of a model using GPU instancing.
            This is similar to <see cref="M:Sandbox.Graphics.DrawModelInstancedIndirect(Sandbox.Model,Sandbox.GpuBuffer,System.Int32,Sandbox.RenderAttributes)" />,
            except the count is provided from the CPU rather than via a GPU buffer.
            
            Use `SV_InstanceID` semantic in shaders to access the rendered instance.
            </summary>
      <param name="model">The model to draw</param>
      <param name="count">The number of instances to draw</param>
      <param name="attributes">Optional attributes to apply only for this draw call</param>
    </member>
    <member name="M:Sandbox.Graphics.OnLayer(System.Int32,ManagedRenderSetup_t)">
      <summary>
            Called by the engine during pipeline. This could be rendering the scene from any camera.
            That means you can't assume this is the game view. This might be a tools view, or another view
            </summary>
    </member>
    <member name="T:Sandbox.Graphics.DownsampleMethod">
      <summary>
            Which method to use when downsampling a texture
            </summary>
    </member>
    <member name="F:Sandbox.Graphics.DownsampleMethod.Box">
      <summary>
            Uses a box filter to downsample the texture
            </summary>
    </member>
    <member name="F:Sandbox.Graphics.DownsampleMethod.GaussianBlur">
      <summary>
            Uses a gaussian filter to downsample the texture
            </summary>
    </member>
    <member name="F:Sandbox.Graphics.DownsampleMethod.GGX">
      <summary>
            Downsamples the texture using GGX normal distribution function, suitable for using with PBR materials
            </summary>
    </member>
    <member name="F:Sandbox.Graphics.DownsampleMethod.Max">
      <summary>
            Downsamples the texture using a max operator filter ( brightest pixel )
            </summary>
    </member>
    <member name="F:Sandbox.Graphics.DownsampleMethod.Min">
      <summary>
            Downsamples the texture using a min operator filter ( darkest pixel )
            </summary>
    </member>
    <member name="F:Sandbox.Graphics.DownsampleMethod.MinMax">
      <summary>
            Downsamples the texture in red and green channels using a Min/Max filter ( darkest and brightest pixel )
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.GenerateMipMaps(Sandbox.Texture,Sandbox.Graphics.DownsampleMethod,System.Int32,System.Int32)">
      <summary>
            Generate the mip maps for this texture. Obviously the texture needs to support mip maps.
            </summary>
    </member>
    <member name="M:Sandbox.Graphics.ResourceBarrierTransition(Sandbox.Texture,Sandbox.Rendering.ResourceState)">
      <summary>
            Executes a barrier transition for the given GPU Texture Resource.
            Transitions the texture resource to a new pipeline stage and access state.
            </summary>
      <param name="texture">The texture to transition.</param>
      <param name="state">The new resource state for the texture.</param>
    </member>
    <member name="M:Sandbox.Graphics.ResourceBarrierTransition``1(Sandbox.GpuBuffer{``0},Sandbox.Rendering.ResourceState)">
      <summary>
            Executes a barrier transition for the given GPU Buffer Resource.
            Transitions the buffer resource to a new pipeline stage and access state.
            </summary>
      <typeparam name="T">The unmanaged type of the buffer elements.</typeparam>
      <param name="buffer">The GPU buffer to transition.</param>
      <param name="state">The new resource state for the buffer.</param>
    </member>
    <member name="M:Sandbox.Graphics.ResourceBarrierTransition(Sandbox.GpuBuffer,Sandbox.Rendering.ResourceState)">
      <summary>
            Executes a barrier transition for the given GPU Buffer Resource.
            Transitions the buffer resource to a new pipeline stage and access state.
            </summary>
      <param name="buffer">The GPU buffer to transition.</param>
      <param name="state">The new resource state for the buffer.</param>
    </member>
    <member name="M:Sandbox.Graphics.ResourceBarrierTransition``1(Sandbox.GpuBuffer{``0},Sandbox.Rendering.ResourceState,Sandbox.Rendering.ResourceState)">
      <summary>
            Executes a barrier transition for the given GPU Buffer Resource.
            Transitions the buffer resource from a known source state to a specified destination state.
            </summary>
      <typeparam name="T">The unmanaged type of the buffer elements.</typeparam>
      <param name="buffer">The GPU buffer to transition.</param>
      <param name="before">The current resource state of the buffer.</param>
      <param name="after">The desired resource state of the buffer after the transition.</param>
    </member>
    <member name="M:Sandbox.Graphics.ResourceBarrierTransition(Sandbox.GpuBuffer,Sandbox.Rendering.ResourceState,Sandbox.Rendering.ResourceState)">
      <summary>
            Executes a barrier transition for the given GPU Buffer Resource.
            Transitions the buffer resource from a known source state to a specified destination state.
            </summary>
      <param name="buffer">The GPU buffer to transition.</param>
      <param name="before">The current resource state of the buffer.</param>
      <param name="after">The desired resource state of the buffer after the transition.</param>
    </member>
    <member name="M:Sandbox.Graphics.ResourceStateToVulkanFlags(Sandbox.Rendering.ResourceState,NativeEngine.RenderBarrierPipelineStageFlags_t@,NativeEngine.RenderBarrierAccessFlags_t@,NativeEngine.RenderImageLayout_t@)">
      <summary>
            Figure out what flags Vulkan needs for the given ResourceState
            </summary>
    </member>
    <member name="T:Sandbox.MorphCollection">
      <summary>
            Used to access and manipulate morphs.
            </summary>
    </member>
    <member name="M:Sandbox.MorphCollection.ResetAll">
      <summary>
            Reset all morphs to their default values.
            </summary>
    </member>
    <member name="M:Sandbox.MorphCollection.Reset(System.Int32)">
      <summary>
            Reset morph number i to its default value.
            </summary>
    </member>
    <member name="M:Sandbox.MorphCollection.Reset(System.String)">
      <summary>
            Reset named morph to its default value.
            </summary>
    </member>
    <member name="M:Sandbox.MorphCollection.Set(System.Int32,System.Single)">
      <summary>
            Set indexed morph to this value.
            </summary>
    </member>
    <member name="M:Sandbox.MorphCollection.Set(System.String,System.Single)">
      <summary>
            Set named morph to this value.
            </summary>
    </member>
    <member name="M:Sandbox.MorphCollection.Get(System.Int32)">
      <summary>
            Get indexed morph value (Note: Currently, this only gets the override morph value)
            </summary>
    </member>
    <member name="M:Sandbox.MorphCollection.Get(System.String)">
      <summary>
            Get named morph value (Note: Currently, this only gets the override morph value)
            </summary>
    </member>
    <member name="M:Sandbox.MorphCollection.GetName(System.Int32)">
      <summary>
            Retrieve name of a morph at given index.
            </summary>
    </member>
    <member name="P:Sandbox.MorphCollection.Count">
      <summary>
            Amount of morphs.
            </summary>
    </member>
    <member name="T:Sandbox.MusicPlayer">
      <summary>
            Enables music playback. Use this for music, not for playing game sounds.
            </summary>
    </member>
    <member name="P:Sandbox.MusicPlayer.SampleRate">
      <summary>
            Sample rate of the audio being played.
            </summary>
    </member>
    <member name="P:Sandbox.MusicPlayer.Channels">
      <summary>
            Number of channels of the audio being played.
            </summary>
    </member>
    <member name="P:Sandbox.MusicPlayer.Duration">
      <summary>
            Gets the total duration of the video in seconds.
            </summary>
    </member>
    <member name="P:Sandbox.MusicPlayer.PlaybackTime">
      <summary>
            Gets the current playback time in seconds.
            </summary>
    </member>
    <member name="P:Sandbox.MusicPlayer.OnFinished">
      <summary>
            Invoked when the audio has finished playing.
            </summary>
    </member>
    <member name="P:Sandbox.MusicPlayer.OnRepeated">
      <summary>
            Invoked when the audio has repeated.
            </summary>
    </member>
    <member name="P:Sandbox.MusicPlayer.ListenLocal">
      <summary>
            Place the listener at 0,0,0 facing 1,0,0.
            </summary>
    </member>
    <member name="P:Sandbox.MusicPlayer.Position">
      <summary>
            Position of the sound.
            </summary>
    </member>
    <member name="P:Sandbox.MusicPlayer.Paused">
      <summary>
            Pause playback of audio.
            </summary>
    </member>
    <member name="P:Sandbox.MusicPlayer.Repeat">
      <summary>
            Audio will repeat when reaching the end.
            </summary>
    </member>
    <member name="P:Sandbox.MusicPlayer.Volume">
      <summary>
            Change the volume of this music.
            </summary>
    </member>
    <member name="P:Sandbox.MusicPlayer.LipSync">
      <summary>
            Enables lipsync processing.
            </summary>
    </member>
    <member name="P:Sandbox.MusicPlayer.TargetMixer">
      <summary>
            Which mixer do we want to write to
            </summary>
    </member>
    <member name="P:Sandbox.MusicPlayer.Distance">
      <inheritdoc cref="P:Sandbox.SoundHandle.Distance" />
    </member>
    <member name="P:Sandbox.MusicPlayer.Falloff">
      <inheritdoc cref="P:Sandbox.SoundHandle.Falloff" />
    </member>
    <member name="P:Sandbox.MusicPlayer.Visemes">
      <summary>
            A list of 15 lipsync viseme weights. Requires <see cref="P:Sandbox.MusicPlayer.LipSync" /> to be enabled.
            </summary>
    </member>
    <member name="P:Sandbox.MusicPlayer.Title">
      <summary>
            Get title of the track.
            </summary>
    </member>
    <member name="P:Sandbox.MusicPlayer.Spectrum">
      <summary>
            512 FFT magnitudes used for audio visualization.
            </summary>
    </member>
    <member name="P:Sandbox.MusicPlayer.Amplitude">
      <summary>
            Approximate measure of audio loudness.
            </summary>
    </member>
    <member name="M:Sandbox.MusicPlayer.PlayUrl(System.String)">
      <summary>
            Plays a music stream from a URL.
            </summary>
    </member>
    <member name="M:Sandbox.MusicPlayer.Play(Sandbox.BaseFileSystem,System.String)">
      <summary>
            Plays a music file from a relative path.
            </summary>
    </member>
    <member name="M:Sandbox.MusicPlayer.Stop">
      <summary>
            Stops audio playback.
            </summary>
    </member>
    <member name="M:Sandbox.MusicPlayer.Seek(System.Single)">
      <summary>
            Sets the playback position to a specified time in the audio, given in seconds.
            </summary>
    </member>
    <member name="M:Sandbox.MusicPlayer.GetMeta(System.String)">
      <summary>
            Get meta data string.
            </summary>
    </member>
    <member name="T:Sandbox.VideoPlayer">
      <summary>
            Enables video playback and access to the video texture and audio.
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.OnLoaded">
      <summary>
            Video successfully loaded.
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.OnAudioReady">
      <summary>
            Event that is invoked when the audio stream is created and ready to use.
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.OnTextureData">
      <summary>
            If this event is set, texture data will be provided instead of rendering to the texture.
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.Repeat">
      <summary>
            Sets whether the video should loop when it reaches the end.
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.Duration">
      <summary>
            Gets the total duration of the video in seconds.
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.PlaybackTime">
      <summary>
            Gets the current playback time in seconds.
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.SampleRate">
      <summary>
            Audio sample rate.
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.Channels">
      <summary>
            Number of audio channels.
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.HasAudio">
      <summary>
            Does the loaded video have audio?
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.IsPaused">
      <summary>
            Has the video been paused?
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.Texture">
      <summary>
            Texture of the video frame.
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.Width">
      <summary>
            Width of the video.
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.Height">
      <summary>
            Height of the video.
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.Audio">
      <summary>
            Access audio properties for this video playback.
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.AudioAccessor.ListenLocal">
      <summary>
            Place the listener at 0,0,0 facing 1,0,0.
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.AudioAccessor.Position">
      <summary>
            Position of the sound.
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.AudioAccessor.TargetMixer">
      <summary>
            Which mixer do we want to write to
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.AudioAccessor.Volume">
      <summary>
            Volume of the sound.
            </summary>
    </member>
    <member name="M:Sandbox.VideoPlayer.Play(System.String)">
      <summary>
            Plays a video file from a URL. If there's already a video playing, it will stop.
            </summary>
    </member>
    <member name="M:Sandbox.VideoPlayer.Play(Sandbox.BaseFileSystem,System.String)">
      <summary>
            Plays a video file from a relative path. If there's already a video playing, it will stop.
            </summary>
    </member>
    <member name="M:Sandbox.VideoPlayer.Resume">
      <summary>
            Resumes video playback.
            </summary>
    </member>
    <member name="M:Sandbox.VideoPlayer.Stop">
      <summary>
            Stops video playback.
            </summary>
    </member>
    <member name="M:Sandbox.VideoPlayer.Pause">
      <summary>
            Pauses video playback.
            </summary>
    </member>
    <member name="M:Sandbox.VideoPlayer.TogglePause">
      <summary>
            Toggle video playback
            </summary>
    </member>
    <member name="M:Sandbox.VideoPlayer.Seek(System.Single)">
      <summary>
            Sets the playback position to a specified time in the video, given in seconds.
            </summary>
    </member>
    <member name="M:Sandbox.VideoPlayer.Present">
      <summary>
            Present a video frame.
            </summary>
    </member>
    <member name="P:Sandbox.VideoPlayer.Muted">
      <summary>
            The video is muted
            </summary>
    </member>
    <member name="T:Sandbox.VideoWriter">
      <summary>
            Allows the creation of video content by encoding a sequence of frames.
            </summary>
    </member>
    <member name="M:Sandbox.VideoWriter.Config.IsCodecSupported">
      <summary>
            Can this container support the codec.
            </summary>
    </member>
    <member name="F:Sandbox.VideoWriter.Codec.H264">
      <summary>
            H.264 codec (does not support transparency)
            </summary>
    </member>
    <member name="F:Sandbox.VideoWriter.Codec.H265">
      <summary>
            H.265 codec (does not support transparency)
            Only supported on modern GPUS, will fallback to H.264 if not supported.
            </summary>
    </member>
    <member name="F:Sandbox.VideoWriter.Codec.VP8">
      <summary>
            VP8 codec (does not support transparency)
            </summary>
    </member>
    <member name="F:Sandbox.VideoWriter.Codec.VP9">
      <summary>
            VP9 codec (supports transparency)
            </summary>
    </member>
    <member name="F:Sandbox.VideoWriter.Codec.WebP">
      <summary>
            WebP codec (supports transparency)
            </summary>
    </member>
    <member name="F:Sandbox.VideoWriter.Container.MP4">
      <summary>
            MP4 container (does not support transparency)
            </summary>
    </member>
    <member name="F:Sandbox.VideoWriter.Container.WebM">
      <summary>
            WebM container (supports transparency)
            </summary>
    </member>
    <member name="F:Sandbox.VideoWriter.Container.WebP">
      <summary>
            WebP container (supports transparency)
            </summary>
    </member>
    <member name="M:Sandbox.VideoWriter.Dispose">
      <summary>
            Dispose this recorder, the encoder will be flushed and video finalized.
            </summary>
    </member>
    <member name="M:Sandbox.VideoWriter.FinishAsync">
      <summary>
            Finish creating this video. The encoder will be flushed and video finalized.
            </summary>
    </member>
    <member name="M:Sandbox.VideoWriter.AddFrame(System.ReadOnlySpan{System.Byte},System.Nullable{System.TimeSpan})">
      <summary>
            Add a frame of data to be encoded. Timestamp is in microseconds. 
            If a timestamp is not specified, it will use an incremented 
            frame count as the timestamp.
            </summary>
      <param name="data">The frame data to be encoded.</param>
      <param name="timestamp">The timestamp for the frame in microseconds. If not specified, an incremented frame count will be used.</param>
    </member>
    <member name="M:Sandbox.RenderAttributes.SetPointer(Sandbox.StringToken@,System.IntPtr@)">
      <summary>
            Internal for a reason - don't expose!
            </summary>
    </member>
    <member name="M:Sandbox.RenderAttributes.SetData``1(Sandbox.StringToken@,System.Span{``0})">
      <summary>
            Set a constant buffer to a specific value
            </summary>
    </member>
    <member name="M:Sandbox.RenderAttributes.SetData``1(Sandbox.StringToken@,``0)">
      <summary>
            Set a constant buffer to a specific value
            </summary>
    </member>
    <member name="M:Sandbox.RenderAttributes.SetData``1(Sandbox.StringToken@,``0[])">
      <summary>
            Set a constant buffer to a specific value
            </summary>
    </member>
    <member name="M:Sandbox.RenderAttributes.SetData``1(Sandbox.StringToken@,System.Collections.Generic.List{``0})">
      <summary>
            Set a constant buffer to a specific value
            </summary>
    </member>
    <member name="M:Sandbox.RenderAttributes.GetBool(Sandbox.StringToken@,System.Boolean@)">
      <summary>
            Get a bool value - else defaultValue if missing
            </summary>
    </member>
    <member name="M:Sandbox.RenderAttributes.GetVector(Sandbox.StringToken@,Vector3@)">
      <summary>
            Get a vector3 value - else defaultValue if missing
            </summary>
    </member>
    <member name="M:Sandbox.RenderAttributes.GetVector4(Sandbox.StringToken@,Vector4@)">
      <summary>
            Get a vector4 value - else defaultValue if missing
            </summary>
    </member>
    <member name="M:Sandbox.RenderAttributes.GetAngles(Sandbox.StringToken@,Angles@)">
      <summary>
            Get a vector4 value - else defaultValue if missing
            </summary>
    </member>
    <member name="M:Sandbox.RenderAttributes.GetFloat(Sandbox.StringToken@,System.Single@)">
      <summary>
            Get a float value - else defaultValue if missing
            </summary>
    </member>
    <member name="M:Sandbox.RenderAttributes.GetInt(Sandbox.StringToken@,System.Int32@)">
      <summary>
            Get a int value - else defaultValue if missing
            </summary>
    </member>
    <member name="M:Sandbox.RenderAttributes.GetMatrix(Sandbox.StringToken@,Matrix@)">
      <summary>
            Get a matrix value - else defaultValue if missing
            </summary>
    </member>
    <member name="M:Sandbox.RenderAttributes.GetTexture(Sandbox.StringToken@,Sandbox.Texture@)">
      <summary>
            Get a texture value - else defaultValue if missing
            </summary>
    </member>
    <member name="M:Sandbox.RenderingWorldSession.AddSceneWorld(Sandbox.SceneWorld)">
      <summary>
            Add a world to this camera, along with any child worlds
            </summary>
    </member>
    <member name="P:Sandbox.RenderingWorldSession.CustomProjectionMatrix">
      <summary>
            Allows specifying a custom projection matrix for this camera
            </summary>
    </member>
    <member name="T:Sandbox.RenderTarget">
      <summary>
            Essentially wraps a couple of textures that we're going to render to. The color texture and the depth texture.
            </summary>
    </member>
    <member name="M:Sandbox.RenderTarget.GetTemporary(System.Int32,System.Int32,Sandbox.ImageFormat,Sandbox.ImageFormat,Sandbox.MultisampleAmount,System.Int32)">
      <summary>
            Get a temporary render target. You should dispose the returned handle when you're done to return the textures to the pool.
            </summary>
      <param name="width">Width of the render target you want.</param>
      <param name="height">Height of the render target you want.</param>
      <param name="colorFormat">The format for the color buffer. If set to default we'll use whatever the current pipeline is using.</param>
      <param name="depthFormat">The format for the depth buffer.</param>
      <param name="msaa">The number of msaa samples you'd like. Msaa render textures are a pain in the ass so you're probably gonna regret trying to use this.</param>
      <param name="numMips">Number of mips you want in this texture. You probably don't want this unless you want to generate mips in a second pass.</param>
      <returns>A RenderTarget that is ready to render to.</returns>
    </member>
    <member name="M:Sandbox.RenderTarget.GetTemporary(System.Int32,Sandbox.ImageFormat,Sandbox.ImageFormat,Sandbox.MultisampleAmount,System.Int32)">
      <summary>
            Get a temporary render target. You should dispose the returned handle when you're done to return the textures to the pool.
            </summary>
      <param name="sizeFactor">Divide the screen size by this factor. 2 would be half screen sized. 1 for full screen sized.</param>
      <param name="colorFormat">The format for the color buffer. If null we'll choose the most appropriate for where you are in the pipeline.</param>
      <param name="depthFormat">The format for the depth buffer.</param>
      <param name="msaa">The number of msaa samples you'd like. Msaa render textures are a pain in the ass so you're probably gonna regret trying to use this.</param>
      <param name="numMips">Number of mips you want in this texture. You probably don't want this unless you want to generate mips in a second pass.</param>
      <returns>A RenderTarget that is ready to render to.</returns>
    </member>
    <member name="M:Sandbox.RenderTarget.EndOfFrame">
      <summary>
            Called at the end of the frame. At this point none of the render targets that were loaned out
            should be being used, so we can put them all back in the pool.
            </summary>
    </member>
    <member name="M:Sandbox.RenderTarget.Flush">
      <summary>
            Flush all the render targets out. Useful to do when screen size changes
            </summary>
    </member>
    <member name="P:Sandbox.RenderTarget.Loaned">
      <summary>
            Is this currently loaned out (Active)
            </summary>
    </member>
    <member name="P:Sandbox.RenderTarget.FramesSinceUsed">
      <summary>
            The amount of time since this texture was last used
            </summary>
    </member>
    <member name="P:Sandbox.RenderTarget.CreationHash">
      <summary>
            The hash of the parameters used to create this
            </summary>
    </member>
    <member name="P:Sandbox.RenderTarget.Width">
      <summary>
            Width of the render target
            </summary>
    </member>
    <member name="P:Sandbox.RenderTarget.Height">
      <summary>
            Height of the render target
            </summary>
    </member>
    <member name="P:Sandbox.RenderTarget.ColorTarget">
      <summary>
            The target colour texture
            </summary>
    </member>
    <member name="P:Sandbox.RenderTarget.DepthTarget">
      <summary>
            The target depth texture
            </summary>
    </member>
    <member name="M:Sandbox.RenderTarget.Dispose">
      <summary>
            Stop using this texture, return it to the pool
            </summary>
    </member>
    <member name="M:Sandbox.RenderTarget.Destroy">
      <summary>
            Destroy this buffer. It shouldn't be used anymore after this.
            </summary>
    </member>
    <member name="M:Sandbox.RenderTarget.From(Sandbox.Texture,Sandbox.Texture)">
      <summary>
            Create a render target from these textures
            </summary>
    </member>
    <member name="M:Sandbox.FontManager.GetBestTypeface(Topten.RichTextKit.IStyle)">
      <summary>
            Tries to get the best matching font for the given style.
            Will return a matching font family with the closest font weight and optionally slant.
            </summary>
    </member>
    <member name="M:Sandbox.TextRendering.GetOrCreateTexture(Sandbox.TextRendering.Scope@,Vector2,Sandbox.TextFlag,Sandbox.UI.FontSmooth)">
      <summary>
            Create a texture from the scope. The texture will either be a cached version or will be rendered immediately
            </summary>
    </member>
    <member name="M:Sandbox.TextRendering.GetOrCreateTextBlock(System.Int32,System.Boolean@)">
      <summary>
            We don't expose this because we don't want them to do something stupid like free
            a textblock that they're still using
            </summary>
    </member>
    <member name="M:Sandbox.TextRendering.Tick">
      <summary>
            Free old, unused textblocks (and their textures)
            </summary>
    </member>
    <member name="T:Sandbox.TextRendering.Scope">
      <summary>
            Defines a scope of text, all using the same style.
            </summary>
    </member>
    <member name="T:Sandbox.TextRendering.TextBlock">
      <summary>
            We'll expose this at some point, but will probably be as Sandbox.TextBlock - and then need to think about ownership and caching
            </summary>
    </member>
    <member name="T:Sandbox.VertexLayout">
      <summary>
            Allows for the definition of custom vertex layouts
            </summary>
    </member>
    <member name="M:Sandbox.VertexLayout.FreeAll">
      <summary>
            Should probably be calling this on hotload, when types are changed?
            </summary>
    </member>
    <member name="P:Sandbox.VolumetricFogParameters.Enabled">
      <summary>
            Indicates whether the fog system is enabled.
            </summary>
    </member>
    <member name="P:Sandbox.VolumetricFogParameters.Anisotropy">
      <summary>
            Level of anisotropy.
            </summary>
    </member>
    <member name="P:Sandbox.VolumetricFogParameters.Scattering">
      <summary>
            Scattering value.
            </summary>
    </member>
    <member name="P:Sandbox.VolumetricFogParameters.DrawDistance">
      <summary>
            Draw distance.
            </summary>
    </member>
    <member name="P:Sandbox.VolumetricFogParameters.FadeInStart">
      <summary>
            Start distance where fading begins.
            </summary>
    </member>
    <member name="P:Sandbox.VolumetricFogParameters.FadeInEnd">
      <summary>
            End distance where fading concludes.
            </summary>
    </member>
    <member name="P:Sandbox.VolumetricFogParameters.IndirectStrength">
      <summary>
            Strength of indirect illumination.
            </summary>
    </member>
    <member name="P:Sandbox.VolumetricFogParameters.BakedIndirectTexture">
      <summary>
            Provides indirect lighting from a baked volume texture.
            This gets compiled with your map and is provided by an env_volumetric_controller.
            </summary>
      <remarks>
            You shouldn't expect to be able to add new runtime fog volumes if using this.
            </remarks>
    </member>
    <member name="T:Sandbox.AnimParam`1">
      <summary>
            Anim param values contain any value for a limited set of types
            </summary>
    </member>
    <member name="P:Sandbox.AnimationGraph.IsError">
      <summary>
            Whether the animation graph is invalid, or has not yet loaded.
            </summary>
    </member>
    <member name="P:Sandbox.AnimationGraph.Name">
      <summary>
            Animation graph file name.
            </summary>
    </member>
    <member name="M:Sandbox.AnimationGraph.#ctor(NativeEngine.HAnimationGraph,System.String)">
      <summary>
            Private constructor, use <see cref="M:Sandbox.AnimationGraph.FromNative(NativeEngine.HAnimationGraph,System.String)" /></summary>
    </member>
    <member name="P:Sandbox.AnimationGraph.ParamCount">
      <summary>
            Number of parameters in this animgraph
            </summary>
    </member>
    <member name="M:Sandbox.AnimationGraph.GetParameterType(System.Int32)">
      <summary>
            Get value type of parameter at given index
            </summary>
    </member>
    <member name="M:Sandbox.AnimationGraph.GetParameterType(System.String)">
      <summary>
            Get value type of parameter with the given <paramref name="name" />, or <see langword="null" /> if not found.
            </summary>
    </member>
    <member name="M:Sandbox.AnimationGraph.GetParameterName(System.Int32)">
      <summary>
            Get name of parameter at given index
            </summary>
    </member>
    <member name="M:Sandbox.AnimationGraph.TryGetParameterIndex(System.String,System.Int32@)">
      <summary>
            Try to get parameter index at given name
            </summary>
    </member>
    <member name="M:Sandbox.AnimationGraph.GetParameter``1(System.String)">
      <summary>
            Get parameter at given name
            </summary>
    </member>
    <member name="M:Sandbox.AnimationGraph.GetParameter``1(System.Int32)">
      <summary>
            Get parameter at given index
            </summary>
    </member>
    <member name="M:Sandbox.AnimationGraph.Load(System.String)">
      <summary>
            Load an animation graph from given file.
            </summary>
    </member>
    <member name="M:Sandbox.AnimationGraph.FromNative(NativeEngine.HAnimationGraph,System.String)">
      <summary>
            Try to make it so only one AnimationGraph class exists for each animation graph
            </summary>
    </member>
    <member name="T:Sandbox.Resources.EmbeddedResource">
      <summary>
            A JSON definition of an embedded resource. This is a resource that can be either standalone (in a .vtex file) or 
            embedded in a GameResource's Json data. 
            
            When it's detected in a GameResource we will create the named compiler and create the resource. When compiling the
            GameResource this can optionally create a compiled version of the resource on disk.
            
            When we compile a regular resource that contains this $compiler structure, it operates like any other compile, except
            it's totally managed by c# instead of resourcecompiler.
            </summary>
    </member>
    <member name="P:Sandbox.Resources.EmbeddedResource.ResourceCompiler">
      <summary>
            The name of the ResourceCompiler to use
            </summary>
    </member>
    <member name="P:Sandbox.Resources.EmbeddedResource.ResourceGenerator">
      <summary>
            The name of the ResourceGenerator that created this resource. This is basically a sub-compiler.
            </summary>
    </member>
    <member name="P:Sandbox.Resources.EmbeddedResource.Data">
      <summary>
            Data that is serialized/deserialized from the ResourceGenerator
            </summary>
    </member>
    <member name="P:Sandbox.Resources.EmbeddedResource.CompiledPath">
      <summary>
            If this resource has been compiled to disk then this is the path to that resource.
            This avoids the need to generate this resource again.
            </summary>
    </member>
    <member name="P:Sandbox.Resources.ResourceCompileContext.AbsolutePath">
      <summary>
            The absolute path to the resource on disk
            </summary>
    </member>
    <member name="P:Sandbox.Resources.ResourceCompileContext.RelativePath">
      <summary>
            The path relative to the assets folder
            </summary>
    </member>
    <member name="P:Sandbox.Resources.ResourceCompileContext.ResourceVersion">
      <summary>
            The resource version can be important
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceCompileContext.AddRuntimeReference(System.String)">
      <summary>
            Add a reference. This means that the resource we're compiling depends on this resource.
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceCompileContext.AddCompileReference(System.String)">
      <summary>
            Add a reference that is needed to compile this resource, but isn't actually needed once compiled.
            </summary>
    </member>
    <member name="P:Sandbox.Resources.ResourceCompileContext.StreamingData">
      <summary>
            Get the streaming data to write to
            </summary>
    </member>
    <member name="P:Sandbox.Resources.ResourceCompileContext.Data">
      <summary>
            Get the data to write to
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceCompileContext.CreateChild(System.String)">
      <summary>
            Create a child resource
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceCompileContext.ScanJson(System.String)">
      <summary>
            Load the json and scan it for paths or any embedded resources
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceCompileContext.ReadSource">
      <summary>
            Read the source, either from in memory, or from disk
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceCompileContext.ReadSourceAsString">
      <summary>
            Read the source, either from in memory, or from disk
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceCompileContext.ReadSourceAsJson">
      <summary>
            Read the source, either from in memory, or from disk
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceCompileContext.DataStream.Write(System.String)">
      <summary>
            Write a string with a null terminator
            </summary>
    </member>
    <member name="T:Sandbox.Resources.ResourceCompiler">
      <summary>
            Takes the "source" of a resource and creates a compiled version. The compiled version
            can create a number of child resources and store binary data.
            </summary>
    </member>
    <member name="T:Sandbox.Resources.ResourceCompiler.ResourceIdentityAttribute">
      <summary>
            Mark a ResourceCompiler. This is used to identify the compiler for a specific file extension, or compiler.
            </summary>
    </member>
    <member name="T:Sandbox.Resources.ResourceGenerator">
      <summary>
            Creates a resource from a json definition
            </summary>
    </member>
    <member name="P:Sandbox.Resources.ResourceGenerator.Options.ForDisk">
      <summary>
            True if we're compiling this resource to write to disk
            </summary>
    </member>
    <member name="P:Sandbox.Resources.ResourceGenerator.Options.Compiler">
      <summary>
            Will be set to the compiler that is currently compiling this resource. Or null, if we're generating in another method.
            </summary>
    </member>
    <member name="P:Sandbox.Resources.ResourceGenerator.CacheToDisk">
      <summary>
            If true then the generation will create a real resource and store it on disk.
            Use this if creating the resource takes a while, or you won't be shipping the generator
            with the game, or if it relies on data that won't be available in the shipped game.
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceGenerator.Create``1(System.String)">
      <summary>
            Create a ResourceGenerator by name
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceGenerator.Create``1(Sandbox.Resources.EmbeddedResource)">
      <summary>
            Create a ResourceGenerator by name and deserialize it
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceGenerator.Deserialize(System.Text.Json.Nodes.JsonObject)">
      <summary>
            Copy properties from obj to us
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceGenerator.GetHash">
      <summary>
            Returns a hash to be used when loading/saving. We use this to determine if the resource has changed.
            By default we serialize the generator to a json string and return the CRC64 of that value. You can
            override this in your generator if you need to make it faster, or ignore some stuff.
            </summary>
    </member>
    <member name="T:Sandbox.Resources.ResourceGenerator`1">
      <summary>
            A resource generator targetting a specific type
            </summary>
    </member>
    <member name="P:Sandbox.Resources.ResourceGenerator`1.UseMemoryCache">
      <summary>
            If true then the generation will avoid creating duplicate resources by checking
            hash codes of previously generated resources and re-using them if possible.
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceGenerator`1.FindCached">
      <summary>
            Find a previously created of this resource
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceGenerator`1.AddToCache(`0)">
      <summary>
            Add this resource to the cache for our current hash
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceGenerator`1.FindOrCreate(Sandbox.Resources.ResourceGenerator.Options)">
      <summary>
            If we generated this before, then find the current cache'd value.
            If not, then generate a new one.
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceGenerator`1.FindOrCreateAsync(Sandbox.Resources.ResourceGenerator.Options,System.Threading.CancellationToken)">
      <summary>
            If we generated this before, then find the current cache'd value.
            If not, then generate a new one.
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceGenerator`1.Create(Sandbox.Resources.ResourceGenerator.Options)">
      <summary>
            Create the resource blocking
            </summary>
    </member>
    <member name="M:Sandbox.Resources.ResourceGenerator`1.CreateAsync(Sandbox.Resources.ResourceGenerator.Options,System.Threading.CancellationToken)">
      <summary>
            Create the resource asyncronously
            </summary>
    </member>
    <member name="M:Sandbox.Resources.TextureGenerator.CreateTexture(Sandbox.Resources.ResourceGenerator.Options,System.Threading.CancellationToken)">
      <summary>
            Find an existing texture for this
            </summary>
    </member>
    <member name="M:Sandbox.Resources.TextureGenerator.Create(Sandbox.Resources.ResourceGenerator.Options)">
      <summary>
            Create a texture. Will replace a placeholder texture, which will turn into the generated texture later, if it's not immediately available.
            </summary>
    </member>
    <member name="M:Sandbox.Resources.TextureGenerator.CreateAsync(Sandbox.Resources.ResourceGenerator.Options,System.Threading.CancellationToken)">
      <summary>
            Create a texture. Will wait until the texture is fully loaded and return when done.
            </summary>
    </member>
    <member name="T:Sandbox.Resources.ColorTextureGenerator">
      <summary>
            Generate a texture which is just a single color
            </summary>
    </member>
    <member name="T:Sandbox.Resources.ImageFileGenerator">
      <summary>
            Load images from disk and convert them to textures
            </summary>
    </member>
    <member name="T:Sandbox.Resources.VTexWriter">
      <summary>
            The VTex format is:
            
            1. Header (width, depth etc)
            2. Extra data blocks
            3. Streaming Data (encoded textures)
            	- smallest mip 
            	- mip
            	- mip
            	- main texture
            
            </summary>
    </member>
    <member name="M:Sandbox.Resources.VTexWriter.CalculateFormat">
      <summary>
            Given what we know, work out the best texture
            </summary>
    </member>
    <member name="T:Sandbox.DecalDefinition">
      <summary>
            A decal which can be applied to objects and surfaces.
            </summary>
    </member>
    <member name="P:Sandbox.DecalDefinition.DecalEntry.Material">
      <summary>
            Material to use.
            </summary>
    </member>
    <member name="P:Sandbox.DecalDefinition.DecalEntry.Width">
      <summary>
            Width of the decal.
            </summary>
    </member>
    <member name="P:Sandbox.DecalDefinition.DecalEntry.Height">
      <summary>
            Height of the decal.
            </summary>
    </member>
    <member name="P:Sandbox.DecalDefinition.DecalEntry.KeepAspect">
      <summary>
            Keep aspect ratio of the decal image when using randomly generating Width and Height.
            </summary>
    </member>
    <member name="P:Sandbox.DecalDefinition.DecalEntry.Depth">
      <summary>
            TODO: Describe me
            </summary>
    </member>
    <member name="P:Sandbox.DecalDefinition.DecalEntry.Rotation">
      <summary>
            Rotation to apply when placing the decal.
            </summary>
    </member>
    <member name="P:Sandbox.DecalDefinition.DecalEntry.FadeTime">
      <summary>
            How long until the decal starts to fade out.
            </summary>
    </member>
    <member name="P:Sandbox.DecalDefinition.DecalEntry.FadeDuration">
      <summary>
            How long the decal takes to fade out.
            </summary>
    </member>
    <member name="P:Sandbox.DecalDefinition.Decals">
      <summary>
            A list of decals, from which an entry will be randomly selected when this decal is placed.
            </summary>
    </member>
    <member name="T:Sandbox.GameResource">
      <summary>
            Assets defined in C# and created through tools.
            You can define your own <a href="https://sbox.game/dev/doc/assetsresources/custom-assets/">Custom Asset Types</a>.
            </summary>
    </member>
    <member name="P:Sandbox.GameResource.ProcessSerializedObject">
      <summary>
            Allows tools to post process the serialized json object
            </summary>
    </member>
    <member name="F:Sandbox.GameResource._jsonHash">
      <summary>
            The last saved compiled hash for this file.
            </summary>
    </member>
    <member name="P:Sandbox.GameResource.LastSavedSourceHash">
      <summary>
            The last saved uncompiled hash for this file. We use this to detect external changes in the editor, it's never serialized.
            </summary>
    </member>
    <member name="P:Sandbox.GameResource.ActionGraphCache">
      <summary>
            Re-use ActionGraph instances when deserializing this resource.
            </summary>
    </member>
    <member name="P:Sandbox.GameResource.HasUnsavedChanges">
      <summary>
            True if this resource has changed but the changes aren't written to disk
            </summary>
    </member>
    <member name="M:Sandbox.GameResource.StateHasChanged">
      <summary>
            Should be called after the resource has been edited by the inspector
            </summary>
    </member>
    <member name="F:Sandbox.GameResource._awaitingLoad">
      <summary>
            True if we're waiting for our load to complete
            </summary>
    </member>
    <member name="P:Sandbox.GameResource.IsPromise">
      <summary>
            True if we're a promise, waiting to finalize the load
            </summary>
    </member>
    <member name="M:Sandbox.GameResource.GetReferencedPackages">
      <summary>
            Get a list of packages that are needed to load this asset
            </summary>
    </member>
    <member name="M:Sandbox.GameResource.PostLoad">
      <summary>
            Called when the asset is first loaded from disk.
            </summary>
    </member>
    <member name="M:Sandbox.GameResource.PostReload">
      <summary>
            Called when the asset is recompiled/reloaded from disk.
            </summary>
    </member>
    <member name="M:Sandbox.GameResource.GetPromise(System.Type,System.String)">
      <summary>
            Creates an instance of this type that will get loaded into later. This allows us to
            have resources that reference other resources that aren't loaded yet (or are missing).
            </summary>
    </member>
    <member name="M:Sandbox.GameResource.Register(System.String)">
      <summary>
            Makes sure all properties are derived properly from filename, and then registered to ResourceLibrary
            </summary>
    </member>
    <member name="M:Sandbox.GameResource.Load``1(System.String)">
      <summary>
            Loads a game resource from given file.
            </summary>
    </member>
    <member name="P:Sandbox.GameResource.ActionGraphTargetType">
      <summary>
            Target type used for any action graphs contained in this resource.
            Defaults to this resource's type.
            </summary>
    </member>
    <member name="P:Sandbox.GameResource.ActionGraphTarget">
      <summary>
            Target instance used for any action graphs contained in this resource.
            Defaults to this resource itself.
            </summary>
    </member>
    <member name="M:Sandbox.GameResource.PushSerializationScope">
      <summary>
            Pushes a context in which action graphs belonging to this resource can be serialized or deserialized.
            </summary>
    </member>
    <member name="M:Sandbox.GameResource.Serialize">
      <summary>
            Serialize the current state to a JsonObject
            </summary>
    </member>
    <member name="M:Sandbox.GameResource.JsonUpgrade(System.Text.Json.Nodes.JsonObject)">
      <summary>
            called to upgrade a bunch of json to the latest version
            </summary>
      <param name="node" />
    </member>
    <member name="P:Sandbox.GameResource.ResourceVersion">
      <summary>
            The version of the component. Used by <see cref="T:Sandbox.JsonUpgrader" />.
            </summary>
    </member>
    <member name="M:Sandbox.GameResource.Deserialize(System.Text.Json.Nodes.JsonObject)">
      <summary>
            Deserialize values from a JsonObject
            </summary>
    </member>
    <member name="M:Sandbox.GameResource.OnJsonSerialize(System.Text.Json.Nodes.JsonObject)">
      <summary>
            Called after we serialize, allowing you to store any extra or modify the output.
            </summary>
    </member>
    <member name="M:Sandbox.GameResource.OnDestroy">
      <summary>
            Called when this resource is being unloaded.
            Clean up any resources owned by this instance here.
            </summary>
    </member>
    <member name="T:Sandbox.GameResourceAttribute">
      <summary>
            Should be applied to a class that inherits from <see cref="T:Sandbox.GameResource" />.
            Makes the class able to be stored as an asset on disk.
            </summary>
    </member>
    <member name="P:Sandbox.GameResourceAttribute.Name">
      <summary>
            The title of this game resource.
            </summary>
    </member>
    <member name="P:Sandbox.GameResourceAttribute.Description">
      <summary>
            Description of this game resource.
            </summary>
    </member>
    <member name="P:Sandbox.GameResourceAttribute.Extension">
      <summary>
            File extension for this game resource.
            </summary>
    </member>
    <member name="P:Sandbox.GameResourceAttribute.Icon">
      <summary>
            Icon to be used for this asset
            Can be an absolute path of a PNG
            Or a <a href="https://fonts.google.com/icons">material icon</a> for this game resource's thumbnail.
            </summary>
    </member>
    <member name="P:Sandbox.GameResourceAttribute.IconBgColor">
      <summary>
            Background color for this resource's thumbnail.
            </summary>
    </member>
    <member name="P:Sandbox.GameResourceAttribute.IconFgColor">
      <summary>
            Foreground color (icon color) for this resource's thumbnail.
            </summary>
    </member>
    <member name="P:Sandbox.GameResourceAttribute.Category">
      <summary>
            Category of this game resource, for grouping in UI.
            </summary>
    </member>
    <member name="T:Sandbox.Material">
      <summary>
            A material. Uses several <see cref="T:Sandbox.Texture" />s and a <see cref="P:Sandbox.Material.Shader" /> with specific settings for more interesting visual effects.
            </summary>
    </member>
    <member name="P:Sandbox.Material.Name">
      <summary>
            Name (or path) of the material.
            </summary>
    </member>
    <member name="P:Sandbox.Material.Attributes">
      <summary>
            Access to all of the attributes of this material.
            </summary>
    </member>
    <member name="M:Sandbox.Material.Create(System.String,System.String)">
      <summary>
            Create a new empty material at runtime.
            </summary>
      <param name="materialName">Name of the new material.</param>
      <param name="shader">Shader that the new material will use.</param>
      <returns>The new material.</returns>
    </member>
    <member name="M:Sandbox.Material.FromShader(Sandbox.Shader)">
      <summary>
            Get an empty material based on the specified shader. This will cache the material so that subsequent calls
            will return the same material.
            </summary>
    </member>
    <member name="M:Sandbox.Material.FromShader(System.String)">
      <summary>
            Get an empty material based on the specified shader. This will cache the material so that subsequent calls
            will return the same material.
            </summary>
    </member>
    <member name="M:Sandbox.Material.#ctor(NativeEngine.IMaterial,System.String)">
      <summary>
            Private constructor, use <see cref="M:Sandbox.Material.FromNative(NativeEngine.IMaterial,System.String)" /></summary>
      <param name="native" />
      <param name="name" />
      <exception cref="T:System.Exception" />
    </member>
    <member name="M:Sandbox.Material.CreateCopy">
      <summary>
            Create a copy of this material
            </summary>
    </member>
    <member name="M:Sandbox.Material.Set(System.String,Vector4)">
      <summary>
            Overrides/Sets an Vector4 within the material
            </summary>
    </member>
    <member name="M:Sandbox.Material.Set(System.String,Sandbox.Texture)">
      <summary>
            Override/Sets texture parameter (Color, Normal, etc)
            </summary>
    </member>
    <member name="M:Sandbox.Material.Set(System.String,Color)">
      <summary>
            Overrides/Sets an color within the material as a color value within the material
            </summary>
    </member>
    <member name="M:Sandbox.Material.Set(System.String,Vector3)">
      <summary>
            Overrides/Sets an Vector3 within the material
            </summary>
    </member>
    <member name="M:Sandbox.Material.Set(System.String,Vector2)">
      <summary>
            Overrides/Sets an Vector2 within the material
            </summary>
    </member>
    <member name="M:Sandbox.Material.Set(System.String,System.Single)">
      <summary>
            Overrides/Sets an float within the material
            </summary>
    </member>
    <member name="M:Sandbox.Material.Set(System.String,System.Int32)">
      <summary>
            Overrides/Sets an int within the material
            </summary>
    </member>
    <member name="M:Sandbox.Material.Set(System.String,System.Boolean)">
      <summary>
            Overrides/Sets an bool within the material
            </summary>
    </member>
    <member name="P:Sandbox.Material.ShaderName">
      <summary>
            Gets the underlying shader name for this material.
            </summary>
    </member>
    <member name="P:Sandbox.Material.Shader">
      <summary>
            Gets the material's shader
            </summary>
    </member>
    <member name="P:Sandbox.Material.Flags">
      <summary>
            Access flags on this material, which usually hint about the contents. These are generally added by 
            the shader procedurally - but developers can add these in material editor too.
            </summary>
    </member>
    <member name="M:Sandbox.Material.Load(System.String)">
      <summary>
            Load a material from disk. Has internal cache.
            </summary>
      <param name="filename">The filepath to load the material from.</param>
      <returns>The loaded material, or null</returns>
    </member>
    <member name="M:Sandbox.Material.LoadAsync(System.String)">
      <summary>
            Load a material from disk. Has internal cache.
            </summary>
      <param name="filename">The filepath to load the material from.</param>
      <returns>The loaded material, or null</returns>
    </member>
    <member name="M:Sandbox.Material.FromNative(NativeEngine.IMaterial,System.String)">
      <summary>
            Try to make it so only one Material class exists for each material
            </summary>
    </member>
    <member name="T:Sandbox.Material.UI">
      <summary>
            Static materials for UI rendering purposes.
            </summary>
    </member>
    <member name="P:Sandbox.Material.UI.Basic">
      <summary>
            As basic 2D drawing material. Supports Texture and vertex color.
            </summary>
    </member>
    <member name="P:Sandbox.Material.UI.Box">
      <summary>
            CSS Box rendering
            </summary>
    </member>
    <member name="P:Sandbox.Material.UI.BoxShadow">
      <summary>
            CSS Box Shadow rendering
            </summary>
    </member>
    <member name="P:Sandbox.Material.UI.Text">
      <summary>
            CSS Text Rendering
            </summary>
    </member>
    <member name="P:Sandbox.Material.UI.BorderWrap">
      <summary>
            For filter: border-wrap( ... );
            </summary>
    </member>
    <member name="P:Sandbox.Material.UI.DropShadow">
      <summary>
            For filter: drop-shadow( ... );
            </summary>
    </member>
    <member name="T:Sandbox.MeshPrimitiveType">
      <summary>
            Possible primitive types of a <see cref="T:Sandbox.Mesh" />.
            </summary>
    </member>
    <member name="T:Sandbox.Mesh">
      <summary>
             A <a href="https://en.wikipedia.org/wiki/Polygon_mesh">mesh</a> is a basic version of a <see cref="T:Sandbox.Model" />,
             containing a set of vertices and indices which make up faces that make up a shape.
            
             <para>A set of meshes can be used to create a <see cref="T:Sandbox.Model" /> via the <see cref="T:Sandbox.ModelBuilder" /> class.</para></summary>
    </member>
    <member name="P:Sandbox.Mesh.IsValid">
      <inheritdoc cref="P:Sandbox.IValid.IsValid" />
    </member>
    <member name="P:Sandbox.Mesh.PrimitiveType">
      <summary>
            Sets the primitive type for this mesh.
            </summary>
    </member>
    <member name="P:Sandbox.Mesh.Material">
      <summary>
            Sets material for this mesh.
            </summary>
    </member>
    <member name="P:Sandbox.Mesh.Bounds">
      <summary>
            Sets AABB bounds for this mesh.
            </summary>
    </member>
    <member name="P:Sandbox.Mesh.UvDensity">
      <summary>
            Used to calculate texture size for texture streaming.
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.SetVertexRange(System.Int32,System.Int32)">
      <summary>
            Set how many vertices this mesh draws (if there's no index buffer)
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.SetIndexRange(System.Int32,System.Int32)">
      <summary>
            Set how many indices this mesh draws
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.CreateBuffers(Sandbox.VertexBuffer,System.Boolean)">
      <summary>
            Create vertex and index buffers.
            </summary>
      <param name="vb">Input vertex buffer. If it is indexed (<see cref="P:Sandbox.VertexBuffer.Indexed" />), then index buffer will also be created.</param>
      <param name="calculateBounds">Whether to recalculate bounds from the vertex buffer.</param>
    </member>
    <member name="M:Sandbox.Mesh.TriangulatePolygon(System.Span{Vector3})">
      <summary>
            Triangulate a polygon made up of points, returns triangle indices into the list of vertices.
            </summary>
    </member>
    <member name="P:Sandbox.Mesh.HasIndexBuffer">
      <summary>
            Whether this mesh has an index buffer.
            </summary>
    </member>
    <member name="P:Sandbox.Mesh.IndexCount">
      <summary>
            Number of indices this mesh has.
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.CreateIndexBuffer">
      <summary>
            Create an empty index buffer, it can be resized later
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.CreateIndexBuffer(System.Int32,System.Collections.Generic.List{System.Int32})">
      <summary>
            Create a index buffer with a number of indices
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.CreateIndexBuffer(System.Int32,System.Span{System.Int32})">
      <summary>
            Create a index buffer with a number of indices
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.SetIndexBufferData(System.Collections.Generic.List{System.Int32},System.Int32)">
      <summary>
            Set data of this buffer
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.SetIndexBufferData(System.Span{System.Int32},System.Int32)">
      <summary>
            Set data of this buffer
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.SetIndexBufferSize(System.Int32)">
      <summary>
            Resize the index buffer.
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.LockIndexBuffer(Sandbox.Mesh.IndexBufferLockHandler)">
      <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.LockIndexBuffer(System.Int32,Sandbox.Mesh.IndexBufferLockHandler)">
      <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.LockIndexBuffer(System.Int32,System.Int32,Sandbox.Mesh.IndexBufferLockHandler)">
      <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
    </member>
    <member name="P:Sandbox.Mesh.HasVertexBuffer">
      <summary>
            Whether this mesh has a vertex buffer.
            </summary>
    </member>
    <member name="P:Sandbox.Mesh.VertexCount">
      <summary>
            Number of vertices this mesh has.
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.CreateVertexBuffer``1(Sandbox.VertexAttribute[])">
      <summary>
            Create an empty vertex buffer, it can be resized later
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.CreateVertexBuffer``1(System.Int32,Sandbox.VertexAttribute[],System.Collections.Generic.List{``0})">
      <summary>
            Create a vertex buffer with a number of vertices
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.CreateVertexBuffer``1(System.Int32,Sandbox.VertexAttribute[],System.Span{``0})">
      <summary>
            Create a vertex buffer with a number of vertices
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.SetVertexBufferData``1(System.Collections.Generic.List{``0},System.Int32)">
      <summary>
            Set data of this buffer
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.SetVertexBufferData``1(System.Span{``0},System.Int32)">
      <summary>
            Set data of this buffer
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.SetVertexBufferSize(System.Int32)">
      <summary>
            Resize the vertex buffer
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.LockVertexBuffer``1(Sandbox.Mesh.VertexBufferLockHandler{``0})">
      <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.LockVertexBuffer``1(System.Int32,Sandbox.Mesh.VertexBufferLockHandler{``0})">
      <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
    </member>
    <member name="M:Sandbox.Mesh.LockVertexBuffer``1(System.Int32,System.Int32,Sandbox.Mesh.VertexBufferLockHandler{``0})">
      <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
    </member>
    <member name="M:Sandbox.IndexBufferHandle.#ctor">
      <summary>
            Create an empty index buffer, it can be resized later
            </summary>
    </member>
    <member name="M:Sandbox.IndexBufferHandle.#ctor(System.Int32,System.Collections.Generic.List{System.Int32})">
      <summary>
            Create a index buffer with a number of indices
            </summary>
    </member>
    <member name="M:Sandbox.IndexBufferHandle.#ctor(System.Int32,System.Span{System.Int32})">
      <summary>
            Create a index buffer with a number of indices
            </summary>
    </member>
    <member name="M:Sandbox.IndexBufferHandle.SetData(System.Collections.Generic.List{System.Int32},System.Int32)">
      <summary>
            Set data of this buffer
            </summary>
    </member>
    <member name="M:Sandbox.IndexBufferHandle.SetData(System.Span{System.Int32},System.Int32)">
      <summary>
            Set data of this buffer
            </summary>
    </member>
    <member name="M:Sandbox.IndexBufferHandle.SetSize(System.Int32)">
      <summary>
            Resize the index buffer.
            </summary>
    </member>
    <member name="M:Sandbox.IndexBufferHandle.Lock(Sandbox.IndexBufferHandle.LockHandler)">
      <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
    </member>
    <member name="M:Sandbox.IndexBufferHandle.Lock(System.Int32,Sandbox.IndexBufferHandle.LockHandler)">
      <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
    </member>
    <member name="M:Sandbox.IndexBufferHandle.Lock(System.Int32,System.Int32,Sandbox.IndexBufferHandle.LockHandler)">
      <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
    </member>
    <member name="M:Sandbox.VertexBufferHandle.SetSize(System.Int32)">
      <summary>
            Resize the vertex buffer
            </summary>
    </member>
    <member name="M:Sandbox.VertexBufferHandle.SetData``1(System.Collections.Generic.List{``0},System.Int32)">
      <summary>
            Set data of this buffer
            </summary>
    </member>
    <member name="M:Sandbox.VertexBufferHandle.SetData``1(System.Span{``0},System.Int32)">
      <summary>
            Set data of this buffer
            </summary>
    </member>
    <member name="M:Sandbox.VertexBufferHandle.Lock``1(Sandbox.VertexBufferHandle.LockHandler{``0})">
      <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
    </member>
    <member name="M:Sandbox.VertexBufferHandle.Lock``1(System.Int32,Sandbox.VertexBufferHandle.LockHandler{``0})">
      <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
    </member>
    <member name="M:Sandbox.VertexBufferHandle.Lock``1(System.Int32,System.Int32,Sandbox.VertexBufferHandle.LockHandler{``0})">
      <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
    </member>
    <member name="M:Sandbox.VertexBufferHandle`1.#ctor(Sandbox.VertexAttribute[])">
      <summary>
            Create an empty vertex buffer, it can be resized later
            </summary>
    </member>
    <member name="M:Sandbox.VertexBufferHandle`1.#ctor(System.Int32,Sandbox.VertexAttribute[],System.Collections.Generic.List{`0})">
      <summary>
            Create a vertex buffer with a number of vertices
            </summary>
    </member>
    <member name="M:Sandbox.VertexBufferHandle`1.#ctor(System.Int32,Sandbox.VertexAttribute[],System.Span{`0})">
      <summary>
            Create a vertex buffer with a number of vertices
            </summary>
    </member>
    <member name="M:Sandbox.VertexBufferHandle`1.SetSize(System.Int32)">
      <summary>
            Resize the vertex buffer
            </summary>
    </member>
    <member name="M:Sandbox.VertexBufferHandle`1.SetData(System.Collections.Generic.List{`0},System.Int32)">
      <summary>
            Set data of this buffer
            </summary>
    </member>
    <member name="M:Sandbox.VertexBufferHandle`1.SetData(System.Span{`0},System.Int32)">
      <summary>
            Set data of this buffer
            </summary>
    </member>
    <member name="M:Sandbox.VertexBufferHandle`1.Lock(Sandbox.VertexBufferHandle{`0}.LockHandler)">
      <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
    </member>
    <member name="M:Sandbox.VertexBufferHandle`1.Lock(System.Int32,Sandbox.VertexBufferHandle{`0}.LockHandler)">
      <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
    </member>
    <member name="M:Sandbox.VertexBufferHandle`1.Lock(System.Int32,System.Int32,Sandbox.VertexBufferHandle{`0}.LockHandler)">
      <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
    </member>
    <member name="T:Sandbox.BoneCollection">
      <summary>
            A collection of bones. This could be from a model, or an entity
            </summary>
    </member>
    <member name="P:Sandbox.BoneCollection.Root">
      <summary>
            Root bone of the model.
            </summary>
    </member>
    <member name="P:Sandbox.BoneCollection.AllBones">
      <summary>
            List of all bones of our object.
            </summary>
    </member>
    <member name="M:Sandbox.BoneCollection.HasBone(System.String)">
      <summary>
            Whether the model or entity has a given bone by name.
            </summary>
    </member>
    <member name="M:Sandbox.BoneCollection.GetBone(System.String)">
      <summary>
            Retrieve a bone by name.
            </summary>
    </member>
    <member name="T:Sandbox.BoneCollection.Bone">
      <summary>
            A bone in a <see cref="T:Sandbox.BoneCollection" />.
            </summary>
    </member>
    <member name="P:Sandbox.BoneCollection.Bone.Index">
      <summary>
            Numerical index of this bone.
            </summary>
    </member>
    <member name="P:Sandbox.BoneCollection.Bone.Name">
      <summary>
            Name of this bone.
            </summary>
    </member>
    <member name="P:Sandbox.BoneCollection.Bone.Parent">
      <summary>
            The parent bone.
            </summary>
    </member>
    <member name="P:Sandbox.BoneCollection.Bone.LocalTransform">
      <summary>
            Transform on this bone, relative to the root bone.
            </summary>
    </member>
    <member name="P:Sandbox.BoneCollection.Bone.HasChildren">
      <summary>
            Whether this bone has any child bones.
            </summary>
    </member>
    <member name="P:Sandbox.BoneCollection.Bone.Children">
      <summary>
            List of all bones that descend from this bone.
            </summary>
    </member>
    <member name="M:Sandbox.BoneCollection.Bone.IsNamed(System.String)">
      <summary>
            Whether this bone has given name or not.
            </summary>
    </member>
    <member name="T:Sandbox.Model">
      <summary>
            A model.
            </summary>
    </member>
    <member name="P:Sandbox.Model.AnimationCount">
      <summary>
            Number of animations this model has.
            </summary>
    </member>
    <member name="M:Sandbox.Model.GetAnimationName(System.Int32)">
      <summary>
            Returns name of an animation at given animation index.
            </summary>
      <param name="animationIndex">Animation index to get name of, starting at 0.</param>
      <returns>Name of the animation.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,AnimationCount-1]</exception>
    </member>
    <member name="P:Sandbox.Model.AnimGraph">
      <summary>
            Get the animgraph this model uses.
            </summary>
    </member>
    <member name="P:Sandbox.Model.Attachments">
      <summary>
            Access to bones of this model.
            </summary>
    </member>
    <member name="P:Sandbox.Model.AttachmentCount">
      <summary>
            Returns amount of attachment points this model has.
            </summary>
    </member>
    <member name="M:Sandbox.Model.GetAttachment(System.String)">
      <summary>
            Retrieves attachment transform based on given attachment name.
            </summary>
      <param name="name">Name of the attachment to retrieve transform of.</param>
      <returns>The attachment transform, or null if attachment by given name is not found.</returns>
    </member>
    <member name="M:Sandbox.Model.GetAttachment(System.Int32)">
      <summary>
            Retrieves attachment transform based on given attachment index.
            </summary>
      <param name="index">&gt;Index of the attachment to look up, starting at 0.</param>
      <returns>The attachment transform.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,AttachmentCount-1]</exception>
    </member>
    <member name="M:Sandbox.Model.GetAttachmentName(System.Int32)">
      <summary>
            Returns name of an attachment at given index.
            </summary>
      <param name="index">Index of the attachment to look up, starting at 0.</param>
      <returns>The name of the attachment at given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,AttachmentCount-1]</exception>
    </member>
    <member name="T:Sandbox.Model.BodyGroupMaskAttribute">
      <summary>
            Used to mark properties as a body group mask, so the correct editor can be used
            </summary>
    </member>
    <member name="P:Sandbox.Model.Bounds">
      <summary>
            Total bounds of all the meshes.
            </summary>
    </member>
    <member name="P:Sandbox.Model.PhysicsBounds">
      <summary>
            Total bounds of all the physics shapes.
            </summary>
    </member>
    <member name="P:Sandbox.Model.RenderBounds">
      <summary>
            Render view bounds.
            </summary>
    </member>
    <member name="M:Sandbox.Model.#ctor(NativeEngine.IModel,System.String,System.Boolean)">
      <summary>
            Private constructor, use <see cref="M:Sandbox.Model.FromNative(NativeEngine.IModel,System.Boolean,System.String)" /></summary>
    </member>
    <member name="M:Sandbox.Model.OnReloaded">
      <summary>
            Called when the resource is reloaded. We should clear any cached values.
            </summary>
    </member>
    <member name="P:Sandbox.Model.IsError">
      <summary>
            Whether this model is an error model or invalid or not.
            </summary>
    </member>
    <member name="P:Sandbox.Model.Name">
      <summary>
            Name of the model, usually being its file path.
            </summary>
    </member>
    <member name="P:Sandbox.Model.IsProcedural">
      <summary>
            Whether this model is procedural, i.e. it was created at runtime via <see cref="M:Sandbox.ModelBuilder.Create" />.
            </summary>
    </member>
    <member name="P:Sandbox.Model.MeshCount">
      <summary>
            Total number of meshes this model is made out of.
            </summary>
    </member>
    <member name="P:Sandbox.Model.Trace">
      <summary>
            Trace against the triangles in this mesh
            </summary>
    </member>
    <member name="M:Sandbox.Model.TryGetData``1(``0@)">
      <summary>
            Tries to extract data from model based on the given type's <see cref="T:Sandbox.ModelEditor.GameDataAttribute">ModelDoc.GameDataAttribute</see>.
            </summary>
      <param name="data">The extracted data, or default on failure.</param>
      <returns>true if data was extracted successfully, false otherwise.</returns>
    </member>
    <member name="M:Sandbox.Model.TryGetData(System.Type,System.Object@)">
      <summary>
            Tries to extract data from model based on the given type's <see cref="T:Sandbox.ModelEditor.GameDataAttribute">ModelDoc.GameDataAttribute</see>.
            </summary>
      <param name="data">The extracted data, or default on failure.</param>
      <param name="t">The class with <see cref="T:Sandbox.ModelEditor.GameDataAttribute">ModelDoc.GameDataAttribute</see>.</param>
      <returns>true if data was extracted successfully, false otherwise.</returns>
    </member>
    <member name="M:Sandbox.Model.HasData``1">
      <summary>
            Tests if this model has generic data based on given type's <see cref="T:Sandbox.ModelEditor.GameDataAttribute">ModelDoc.GameDataAttribute</see>.
            This will be faster than testing this via GetData<![CDATA[<>]]>()
            </summary>
    </member>
    <member name="M:Sandbox.Model.GetData``1">
      <summary>
            Extracts data from model based on the given type's <see cref="T:Sandbox.ModelEditor.GameDataAttribute">ModelDoc.GameDataAttribute</see>.
            </summary>
    </member>
    <member name="M:Sandbox.Model.GetBreakCommands">
      <summary>
            Internal function used to get a list of break commands the model has.
            </summary>
    </member>
    <member name="P:Sandbox.Model.HitboxSet">
      <summary>
            Access to default hitbox set of this model
            </summary>
    </member>
    <member name="M:Sandbox.Model.Load(System.String)">
      <summary>
            Load a model by file path.
            </summary>
      <param name="filename">The file path to load as a model.</param>
      <returns>The loaded model, or null</returns>
    </member>
    <member name="M:Sandbox.Model.LoadAsync(System.String)">
      <summary>
            Load a model by file path.
            </summary>
      <param name="filename">The file path to load as a model.</param>
      <returns>The loaded model, or null</returns>
    </member>
    <member name="P:Sandbox.Model.MaterialGroupCount">
      <summary>
            Number of material groups this model has.
            </summary>
    </member>
    <member name="M:Sandbox.Model.GetMaterialGroupName(System.Int32)">
      <summary>
            Returns name of a material group at given group index.
            </summary>
      <param name="groupIndex">Group index to get name of, starting at 0.</param>
      <returns>Name of the group.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,MaterialGroupCount-1]</exception>
    </member>
    <member name="M:Sandbox.Model.GetMaterialGroupIndex(System.String)">
      <summary>
            Retrieves the index of a material group given its name.
            </summary>
      <param name="groupIndex">The name of the material group.</param>
      <returns>The index of the material group, or a negative value if the group does not exist.</returns>
    </member>
    <member name="P:Sandbox.Model.Materials">
      <summary>
            Retrieves an enumerable collection of all Materials on the meshes.
            </summary>
      <returns>An IEnumerable of Materials.</returns>
    </member>
    <member name="M:Sandbox.Model.GetMaterials(System.Int32)">
      <summary>
            Retrieves an enumerable collection of Materials belonging to a specified group.
            </summary>
      <param name="groupIndex">The index of the material group. Default value is 0.</param>
      <returns>An IEnumerable of Materials in the specified group.</returns>
    </member>
    <member name="M:Sandbox.Model.GetMaterials(System.String)">
      <summary>
            Retrieves an enumerable collection of Materials belonging to a specified group.
            </summary>
      <param name="groupName">The name of the material group.</param>
      <returns>An IEnumerable of Materials in the specified group.</returns>
      <exception cref="T:System.ArgumentException">Thrown when the provided group name does not exist.</exception>
    </member>
    <member name="T:Sandbox.Model.MaterialGroupAttribute">
      <summary>
            Used to mark a property as a material group, for the editor
            </summary>
    </member>
    <member name="T:Sandbox.Model.MaterialOverrideAttribute">
      <summary>
            Used to mark a property as a material material override dictionary, for the editor
            </summary>
    </member>
    <member name="P:Sandbox.Model.Morphs">
      <summary>
            Access to bones of this model.
            </summary>
    </member>
    <member name="P:Sandbox.Model.MorphCount">
      <summary>
            Number of morph controllers this model has.
            </summary>
    </member>
    <member name="M:Sandbox.Model.GetMorphName(System.Int32)">
      <summary>
            Returns name of a morph controller at given index.
            </summary>
      <param name="morph">Morph controller index to get name of, starting at 0.</param>
      <returns>Name of the morph controller at given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,MorphCount-1]</exception>
    </member>
    <member name="M:Sandbox.Model.GetVisemeMorph(System.String,System.Int32)">
      <summary>
            Get morph weight for viseme.
            </summary>
    </member>
    <member name="P:Sandbox.Model.SequenceNames">
      <summary>
            List of sequence names this model has.
            </summary>
    </member>
    <member name="P:Sandbox.Model.Bones">
      <summary>
            Access to bones of this model.
            </summary>
    </member>
    <member name="P:Sandbox.Model.BoneCount">
      <summary>
            Number of bones this model has.
            </summary>
    </member>
    <member name="M:Sandbox.Model.GetBoneName(System.Int32)">
      <summary>
            Returns name of a bone at given bone index.
            </summary>
      <param name="boneIndex">Bone index to get name of, starting at 0.</param>
      <returns>Name of the bone.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,BoneCount-1]</exception>
    </member>
    <member name="M:Sandbox.Model.GetBoneParent(System.Int32)">
      <summary>
            Returns the id of given bone's parent bone.
            </summary>
      <param name="boneIndex">The bone to look up parent of.</param>
      <returns>The id of the parent bone, or -1 if given bone has no parent.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,BoneCount-1]</exception>
    </member>
    <member name="M:Sandbox.Model.GetBoneTransform(System.Int32)">
      <summary>
            Returns transform of given bone at bind position.
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,BoneCount-1]</exception>
    </member>
    <member name="M:Sandbox.Model.GetBoneTransform(System.String)">
      <summary>
            Returns transform of given bone at bind position.
            </summary>
    </member>
    <member name="M:Sandbox.Model.FromNative(NativeEngine.IModel,System.Boolean,System.String)">
      <summary>
            Cached <see cref="T:Sandbox.Model" /> instance from native, or creates
            </summary>
    </member>
    <member name="P:Sandbox.Model.Builder">
      <summary>
            Returns a static <see cref="T:Sandbox.ModelBuilder" /> instance, allowing for runtime model creation.
            </summary>
    </member>
    <member name="P:Sandbox.Model.Cube">
      <summary>
            A cube model
            </summary>
    </member>
    <member name="P:Sandbox.Model.Sphere">
      <summary>
            A sphere model
            </summary>
    </member>
    <member name="P:Sandbox.Model.Plane">
      <summary>
            A plane model
            </summary>
    </member>
    <member name="P:Sandbox.Model.Error">
      <summary>
            An error model
            </summary>
    </member>
    <member name="M:Sandbox.Model.GetVertices">
      <summary>
            Experimental!
            </summary>
    </member>
    <member name="M:Sandbox.Model.GetIndices">
      <summary>
            Experimental!
            </summary>
    </member>
    <member name="T:Sandbox.AnimationBuilder">
      <summary>
            Provides ability to generate animations for a <see cref="T:Sandbox.Model" /> at runtime.
            See <see cref="M:Sandbox.ModelBuilder.AddAnimation(System.String,System.Single)" /></summary>
    </member>
    <member name="P:Sandbox.AnimationBuilder.Name">
      <summary>
            The name of the animation.
            </summary>
    </member>
    <member name="P:Sandbox.AnimationBuilder.FrameRate">
      <summary>
            The frames per second of the animation.
            </summary>
    </member>
    <member name="P:Sandbox.AnimationBuilder.Looping">
      <summary>
            This animation loops.
            </summary>
    </member>
    <member name="P:Sandbox.AnimationBuilder.Delta">
      <summary>
            This animation "adds" to the base result.
            </summary>
    </member>
    <member name="P:Sandbox.AnimationBuilder.DisableInterpolation">
      <summary>
            This animation disables interpolation between frames.
            </summary>
    </member>
    <member name="P:Sandbox.AnimationBuilder.FrameCount">
      <summary>
            The number of frames in the animation.
            </summary>
    </member>
    <member name="M:Sandbox.AnimationBuilder.WithName(System.String)">
      <summary>
            Sets the name of the animation.
            </summary>
    </member>
    <member name="M:Sandbox.AnimationBuilder.WithFrameRate(System.Single)">
      <summary>
            Sets the frames per second of the animation.
            </summary>
    </member>
    <member name="M:Sandbox.AnimationBuilder.WithLooping(System.Boolean)">
      <summary>
            Sets whether the animation loops.
            </summary>
    </member>
    <member name="M:Sandbox.AnimationBuilder.WithDelta(System.Boolean)">
      <summary>
            Sets whether the animation adds to the base result.
            </summary>
    </member>
    <member name="M:Sandbox.AnimationBuilder.WithInterpolationDisabled(System.Boolean)">
      <summary>
            Sets whether interpolation between frames is disabled.
            </summary>
    </member>
    <member name="M:Sandbox.AnimationBuilder.AddFrame(System.Span{Transform})">
      <summary>
            Add bone transforms for a frame of animation.
            </summary>
    </member>
    <member name="M:Sandbox.AnimationBuilder.AddFrame(System.Collections.Generic.List{Transform})">
      <summary>
            Add bone transforms for a frame of animation.
            </summary>
    </member>
    <member name="T:Sandbox.ModelBuilder">
      <summary>
            Provides ability to generate <see cref="T:Sandbox.Model" />s at runtime.
            A static instance of this class is available at <see cref="P:Sandbox.Model.Builder" /></summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.AddAnimation(System.String,System.Single)">
      <summary>
            Adds an animation to this model and returns a builder to construct the animation.
            </summary>
      <param name="name">The name of the animation.</param>
      <param name="frameRate">The frames per second of the animation.</param>
      <returns>An <see cref="T:Sandbox.AnimationBuilder" /> instance to construct the animation.</returns>
    </member>
    <member name="M:Sandbox.ModelBuilder.WithMass(System.Single)">
      <summary>
            Total mass of the physics body (Default is 1000)
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.WithSurface(System.String)">
      <summary>
            Surface property to use for collision
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.WithLodDistance(System.Int32,System.Single)">
      <summary>
            LOD switch distance increment for each Level of Detail (LOD) level. (Default is 50)
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.AddCollisionBox(Vector3,System.Nullable{Vector3},System.Nullable{Rotation})">
      <summary>
            Add box collision shape.
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.AddCollisionSphere(System.Single,Vector3)">
      <summary>
            Add sphere collision shape.
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.AddCollisionCapsule(Vector3,Vector3,System.Single)">
      <summary>
            Add capsule collision shape.
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.AddCollisionHull(System.Collections.Generic.List{Vector3},System.Nullable{Vector3},System.Nullable{Rotation})">
      <summary>
            Add a CONVEX hull collision shape.
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.AddCollisionHull(System.Span{Vector3},System.Nullable{Vector3},System.Nullable{Rotation})">
      <summary>
            Add a CONVEX hull collision shape.
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.AddCollisionMesh(System.Collections.Generic.List{Vector3},System.Collections.Generic.List{System.Int32})">
      <summary>
            Add a CONCAVE mesh collision shape. (This shape can NOT be physically simulated)
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.AddCollisionMesh(System.Span{Vector3},System.Span{System.Int32})">
      <summary>
            Add a CONCAVE mesh collision shape. (This shape can NOT be physically simulated)
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.AddTraceMesh(System.Collections.Generic.List{Vector3},System.Collections.Generic.List{System.Int32})">
      <summary>
            Add trace vertices for tracing against mesh
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.AddTraceMesh(System.Span{Vector3},System.Span{System.Int32})">
      <summary>
            Add trace vertices for tracing against mesh
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.AddMesh(Sandbox.Mesh)">
      <summary>
            Add a mesh.
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.AddMeshes(Sandbox.Mesh[])">
      <summary>
            Add a bunch of meshes.
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.AddMesh(Sandbox.Mesh,System.Int32)">
      <summary>
            Add a mesh to a Level of Detail (LOD) group.
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.AddMeshes(Sandbox.Mesh[],System.Int32)">
      <summary>
            Add a bunch of meshes to a Level of Detail (LOD) group.
            </summary>
    </member>
    <member name="T:Sandbox.ModelBuilder.Bone">
      <summary>
            A bone definition for use with <see cref="T:Sandbox.ModelBuilder" />.
            </summary>
      <param name="Name">Name of the bone.</param>
      <param name="ParentName">Name of the parent bone.</param>
      <param name="Position">Position of the bone, relative to its parent.</param>
      <param name="Rotation">Rotation of the bone, relative to its parent.</param>
    </member>
    <member name="M:Sandbox.ModelBuilder.Bone.#ctor(System.String,System.String,Vector3,Rotation)">
      <summary>
            A bone definition for use with <see cref="T:Sandbox.ModelBuilder" />.
            </summary>
      <param name="Name">Name of the bone.</param>
      <param name="ParentName">Name of the parent bone.</param>
      <param name="Position">Position of the bone, relative to its parent.</param>
      <param name="Rotation">Rotation of the bone, relative to its parent.</param>
    </member>
    <member name="P:Sandbox.ModelBuilder.Bone.Name">
      <summary>Name of the bone.</summary>
    </member>
    <member name="P:Sandbox.ModelBuilder.Bone.ParentName">
      <summary>Name of the parent bone.</summary>
    </member>
    <member name="P:Sandbox.ModelBuilder.Bone.Position">
      <summary>Position of the bone, relative to its parent.</summary>
    </member>
    <member name="P:Sandbox.ModelBuilder.Bone.Rotation">
      <summary>Rotation of the bone, relative to its parent.</summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.AddBone(Sandbox.ModelBuilder.Bone)">
      <summary>
            Add a bone to the skeleton via a <see cref="T:Sandbox.ModelBuilder.Bone" /> struct.
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.AddBones(Sandbox.ModelBuilder.Bone[])">
      <summary>
            Add multiple bones to the skeleton.
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.AddBone(System.String,Vector3,Rotation,System.String)">
      <summary>
            Add a bone to the skeleton.
            </summary>
    </member>
    <member name="M:Sandbox.ModelBuilder.WithName(System.String)">
      <summary>
            Provide a name to identify the model by
            </summary>
      <param name="name">Desired model name</param>
    </member>
    <member name="M:Sandbox.ModelBuilder.Create">
      <summary>
            Finish creation of the model.
            </summary>
    </member>
    <member name="P:Sandbox.ModelAttachments.Attachment.WorldTransform">
      <summary>
            Bone transformed LocalTransform
            </summary>
    </member>
    <member name="P:Sandbox.HitboxSet.Box.Shape">
      <summary>
            Either a Sphere, Capsule or BBox
            </summary>
    </member>
    <member name="P:Sandbox.HitboxSet.Box.RandomPointInside">
      <summary>
            Get a random point inside this hitbox
            </summary>
    </member>
    <member name="P:Sandbox.HitboxSet.Box.RandomPointOnEdge">
      <summary>
            Get a random point on the edge this hitbox
            </summary>
    </member>
    <member name="T:Sandbox.ModelMorphs">
      <summary>
            Allows fast lookups of morph variables
            </summary>
    </member>
    <member name="M:Sandbox.ModelMorphs.GetName(System.Int32)">
      <summary>
            Get the name of a morph by its index.
            </summary>
    </member>
    <member name="M:Sandbox.ModelMorphs.GetIndex(System.String)">
      <summary>
            Get the index of a morph by its name
            </summary>
    </member>
    <member name="M:Sandbox.ModelMorphs.Dispose">
      <summary>
            Clear it so it can't be used after disposed
            </summary>
    </member>
    <member name="P:Sandbox.PhysicsGroupDescription.Surfaces">
      <summary>
            Enumerate every <see cref="T:Sandbox.Surface" /> in this <see cref="T:Sandbox.Model" /></summary>
    </member>
    <member name="M:Sandbox.PhysicsGroupDescription.BodyPart.HullPart.GetLines">
      <summary>
            For debug rendering
            </summary>
    </member>
    <member name="M:Sandbox.PhysicsGroupDescription.BodyPart.MeshPart.GetTriangles">
      <summary>
            For debug rendering
            </summary>
    </member>
    <member name="T:Sandbox.ParticleSnapshot">
      <summary>
            A particle snapshot that can be created procedurally.
            Contains a set of vertices that particle effects can address.
            </summary>
    </member>
    <member name="T:Sandbox.ParticleSnapshot.Vertex">
      <summary>
            A vertex to update a particle snapshot with.
            </summary>
    </member>
    <member name="M:Sandbox.ParticleSnapshot.#ctor">
      <summary>
            Create new empty procedural particle snapshot.
            </summary>
    </member>
    <member name="M:Sandbox.ParticleSnapshot.Update(System.Span{Sandbox.ParticleSnapshot.Vertex})">
      <summary>
            Update this snapshot with a list of vertices.
            </summary>
    </member>
    <member name="T:Sandbox.ParticleSystem">
      <summary>
            A particle effect system that allows for complex visual effects, such as
            explosions, muzzle flashes, impact effects, etc.
            </summary>
    </member>
    <member name="P:Sandbox.ParticleSystem.IsError">
      <summary>
            Whether the particle system is invalid, or has not yet loaded.
            </summary>
    </member>
    <member name="P:Sandbox.ParticleSystem.Name">
      <summary>
            Particle system file name.
            </summary>
    </member>
    <member name="P:Sandbox.ParticleSystem.Bounds">
      <summary>
            Static bounding box of the resource.
            </summary>
    </member>
    <member name="M:Sandbox.ParticleSystem.#ctor(NativeEngine.HParticleSystemDefinition,System.String)">
      <summary>
            Private constructor, use <see cref="M:Sandbox.ParticleSystem.FromNative(NativeEngine.HParticleSystemDefinition,System.String)" /></summary>
    </member>
    <member name="P:Sandbox.ParticleSystem.ChildCount">
      <summary>
            How many child particle systems do we have
            </summary>
    </member>
    <member name="M:Sandbox.ParticleSystem.GetChild(System.Int32)">
      <summary>
            Returns child particle at given index.
            </summary>
      <param name="index">Index of child particle system, starting at 0.</param>
      <returns>Particle system</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown when given index exceeds range of [0,ChildCount-1]</exception>
    </member>
    <member name="M:Sandbox.ParticleSystem.Load(System.String)">
      <summary>
            Loads a particle system from given file.
            </summary>
    </member>
    <member name="M:Sandbox.ParticleSystem.LoadAsync(System.String)">
      <summary>
            Load a particle system by file path.
            </summary>
      <param name="filename">The file path to load as a particle system.</param>
      <returns>The loaded particle system, or null</returns>
    </member>
    <member name="M:Sandbox.ParticleSystem.FromNative(NativeEngine.HParticleSystemDefinition,System.String)">
      <summary>
            Try to make it so only one AnimationGraph class exists for each animation graph
            </summary>
    </member>
    <member name="T:Sandbox.Resource">
      <summary>
            A resource loaded in the engine, such as a <see cref="T:Sandbox.Model" /> or <see cref="T:Sandbox.Material" />.
            </summary>
    </member>
    <member name="P:Sandbox.Resource.ResourceId">
      <summary>
            ID of this resource,
            </summary>
    </member>
    <member name="P:Sandbox.Resource.ResourcePath">
      <summary>
            Path to this resource.
            </summary>
    </member>
    <member name="P:Sandbox.Resource.ResourceName">
      <summary>
            File name of the resource without the extension.
            </summary>
    </member>
    <member name="P:Sandbox.Resource.Manifest">
      <summary>
            This is what loads the resource. While this is alive the resource will be loaded.
            </summary>
    </member>
    <member name="P:Sandbox.Resource.HasUnsavedChanges">
      <summary>
            True if this resource has been changed but the changes aren't written to disk
            </summary>
    </member>
    <member name="M:Sandbox.Resource.SetIdFromResourcePath(System.String)">
      <summary>
            Sets the ResourcePath, ResourceName and ResourceId from a resource path
            </summary>
    </member>
    <member name="M:Sandbox.Resource.Load(System.Type,System.String)">
      <summary>
            Accessor for loading native resources, not great, doesn't need to handle GameResource
            </summary>
    </member>
    <member name="M:Sandbox.Resource.OnReloaded">
      <summary>
            Called by OnResourceReloaded when a resource has been reloaded
            </summary>
    </member>
    <member name="M:Sandbox.Resource.StateHasChanged">
      <summary>
            Should be called after the resource has been edited by the inspector
            </summary>
    </member>
    <member name="M:Sandbox.Resource.Sandbox#IJsonConvert#JsonRead(System.Text.Json.Utf8JsonReader@,System.Type)">
      <summary>
            Read the resource from a JSON element. This is usually a string, describing the path to the resource
            </summary>
    </member>
    <member name="M:Sandbox.Resource.Sandbox#IJsonConvert#JsonWrite(System.Object,System.Text.Json.Utf8JsonWriter)">
      <summary>
            Write the resource reference to a json element. This is usually a string, describing the path to the resource
            </summary>
    </member>
    <member name="M:Sandbox.Resource.WriteJsonReference(System.Text.Json.Utf8JsonWriter)">
      <summary>
            Allows a resource type to override how it reference entry is written. This is generally
            just going to be a path to the on disk resource, but we can use this to store metadata too.
            </summary>
    </member>
    <member name="T:Sandbox.IResourceExtension">
      <summary>
            Describes a resource extension at a base level
            </summary>
    </member>
    <member name="M:Sandbox.IResourceExtension.FindAllTargetting(Sandbox.Resource)">
      <summary>
            Find all resources that are targetting a specific resource
            </summary>
    </member>
    <member name="M:Sandbox.IResourceExtension.FindAllTypes(Sandbox.Internal.TypeLibrary,System.Type)">
      <summary>
            Find all extensions that target a specific type.
            </summary>
    </member>
    <member name="T:Sandbox.ResourceExtension`1">
      <summary>
            A GameResource type that adds extended properties to another resource type. You should prefer to use
            the type with to generic arguments, and define your own type as the second argument. That way you get
            access to the helper methods.
            </summary>
    </member>
    <member name="P:Sandbox.ResourceExtension`1.ExtensionDefault">
      <summary>
            If true then this is returned when calling FindForResourceOrDefault if
            no other extension is found targetting a specific resource.
            </summary>
    </member>
    <member name="P:Sandbox.ResourceExtension`1.ExtensionTargets">
      <summary>
            Extensions can target more than one resource.
            </summary>
    </member>
    <member name="T:Sandbox.ResourceExtension`2">
      <summary>
            An extension of ResourceExtension[t], this gives special helper methods for retrieving resources targetting
            specific assets.
            </summary>
    </member>
    <member name="T:Sandbox.ResourceLibrary">
      <summary>
            Keeps a library of all available <see cref="T:Sandbox.Resource" />.
            </summary>
    </member>
    <member name="M:Sandbox.ResourceLibrary.Get``1(System.Int32)">
      <summary>
            Get a cached resource by its hash.
            </summary>
      <typeparam name="T">Resource type to get.</typeparam>
      <param name="identifier">Resource hash to look up.</param>
    </member>
    <member name="M:Sandbox.ResourceLibrary.Get``1(System.String)">
      <summary>
            Get a cached resource by its file path.
            </summary>
      <typeparam name="T">Resource type to get.</typeparam>
      <param name="filepath">File path to the resource.</param>
    </member>
    <member name="M:Sandbox.ResourceLibrary.TryGet``1(System.String,``0@)">
      <summary>
            Try to get a cached resource by its file path.
            </summary>
      <typeparam name="T">Resource type to get.</typeparam>
      <param name="filepath">File path to the resource.</param>
      <param name="resource">The retrieved resource, if any.</param>
      <returns>True if resource was retrieved successfully.</returns>
    </member>
    <member name="M:Sandbox.ResourceLibrary.GetAll``1">
      <summary>
            Get all cached resources of given type.
            </summary>
      <typeparam name="T">Resource type to get.</typeparam>
    </member>
    <member name="M:Sandbox.ResourceLibrary.GetAll``1(System.String,System.Boolean)">
      <summary>
            Get all cached resources of given type in a specific folder.
            </summary>
      <typeparam name="T">Resource type to get.</typeparam>
      <param name="filepath">The path of the folder to check.</param>
      <param name="recursive">Whether or not to check folders within the specified folder.</param>
    </member>
    <member name="M:Sandbox.ResourceLibrary.ReadCompiledResourceJson(System.Span{System.Byte})">
      <summary>
            Read compiled resource as JSON from the provided buffer.
            </summary>
    </member>
    <member name="M:Sandbox.ResourceLibrary.ReadCompiledResourceJson(Sandbox.BaseFileSystem,System.String)">
      <summary>
            Read compiled resource as JSON from the provided file path.
            </summary>
    </member>
    <member name="M:Sandbox.ResourceLibrary.IEventListener.OnRegister(Sandbox.GameResource)">
      <summary>
            Called when a new resource has been registered
            </summary>
    </member>
    <member name="M:Sandbox.ResourceLibrary.IEventListener.OnUnregister(Sandbox.GameResource)">
      <summary>
            Called when a previously known resource has been unregistered
            </summary>
    </member>
    <member name="M:Sandbox.ResourceLibrary.IEventListener.OnExternalChanges(Sandbox.GameResource)">
      <summary>
            Called when the source file of a known resource has been externally modified on disk
            </summary>
    </member>
    <member name="P:Sandbox.PrefabFile.CachedScene">
      <summary>
            This is used as a reference
            </summary>
    </member>
    <member name="P:Sandbox.PrefabFile.OnUnregistered">
      <summary>
            Called when this prefab file is about to be unregistered.
            </summary>
    </member>
    <member name="P:Sandbox.PrefabFile.OnPostLoad">
      <summary>
            This is used to load the cached scene after this file is fully loaded
            </summary>
    </member>
    <member name="P:Sandbox.PrefabFile.ShowInMenu">
      <summary>
            If true then we'll show this in the right click menu, so people can create it
            </summary>
    </member>
    <member name="P:Sandbox.PrefabFile.MenuPath">
      <summary>
            If ShowInMenu is true, this is the path in the menu for this prefab
            </summary>
    </member>
    <member name="P:Sandbox.PrefabFile.MenuIcon">
      <summary>
            Icon to show to the left of the option in the menu
            </summary>
    </member>
    <member name="P:Sandbox.PrefabFile.DontBreakAsTemplate">
      <summary>
            If true then the prefab will not be broken when created as a template
            </summary>
    </member>
    <member name="M:Sandbox.PrefabFile.GetMetadata(System.String,System.String)">
      <summary>
            Read metadata saved using a ISceneMetadata based component, such as SceneInformation
            </summary>
    </member>
    <member name="F:Sandbox.PrefabFile._objectDictKey">
      <summary>
            If this instance is stored in <see cref="P:Sandbox.PrefabFile.ObjectsById" />, what's the key?
            </summary>
    </member>
    <member name="M:Sandbox.PrefabFile.Register">
      <summary>
            Add this instance to <see cref="P:Sandbox.PrefabFile.ObjectsById" />, indexed by Guid. If the Guid has changed,
            removes the old entry.
            </summary>
    </member>
    <member name="M:Sandbox.PrefabFile.Unregister">
      <summary>
            Remove this instance from <see cref="P:Sandbox.PrefabFile.ObjectsById" />.
            </summary>
    </member>
    <member name="P:Sandbox.PrefabFile.ObjectsById">
      <summary>
            We store each prefabfile in here indexed by their root object id, allowing
            us to discuss them over the network, because the net system will be able to
            look the GameObject up.
            </summary>
    </member>
    <member name="M:Sandbox.PrefabFile.FindByGuid(System.Guid)">
      <summary>
            We can look up prefabfile by their object guid
            </summary>
    </member>
    <member name="M:Sandbox.PrefabFile.Upgrader_v1(System.Text.Json.Nodes.JsonObject)">
      <summary>
            Version 0 to 1
            - "Id" changed to "__guid"
            </summary>
    </member>
    <member name="T:Sandbox.PrefabVariable">
      <summary>
            A prefab variable definition
            </summary>
    </member>
    <member name="P:Sandbox.PrefabVariable.Id">
      <summary>
            A unique id for this variable. This is what it will be referred to in code.
            </summary>
    </member>
    <member name="P:Sandbox.PrefabVariable.Title">
      <summary>
            A user friendly title for this variable
            </summary>
    </member>
    <member name="P:Sandbox.PrefabVariable.Description">
      <summary>
            A user friendly description for this variable
            </summary>
    </member>
    <member name="P:Sandbox.PrefabVariable.Group">
      <summary>
            An optional group for this variable to belong to
            </summary>
    </member>
    <member name="P:Sandbox.PrefabVariable.Order">
      <summary>
            Lower numbers appear first
            </summary>
    </member>
    <member name="P:Sandbox.PrefabVariable.Targets">
      <summary>
            Component variables that are being targetted
            </summary>
    </member>
    <member name="M:Sandbox.PrefabVariable.AddTarget(System.Guid,System.String)">
      <summary>
            Add a target property
            </summary>
    </member>
    <member name="T:Sandbox.PrefabVariable.PrefabVariableTarget">
      <summary>
            Targets a property in a component or gameobject.
            </summary>
      <param name="Id">The Id of the gameobject or component.</param>
      <param name="Property">The name of the parameter on the target.</param>
    </member>
    <member name="M:Sandbox.PrefabVariable.PrefabVariableTarget.#ctor(System.Guid,System.String)">
      <summary>
            Targets a property in a component or gameobject.
            </summary>
      <param name="Id">The Id of the gameobject or component.</param>
      <param name="Property">The name of the parameter on the target.</param>
    </member>
    <member name="P:Sandbox.PrefabVariable.PrefabVariableTarget.Id">
      <summary>The Id of the gameobject or component.</summary>
    </member>
    <member name="P:Sandbox.PrefabVariable.PrefabVariableTarget.Property">
      <summary>The name of the parameter on the target.</summary>
    </member>
    <member name="M:Sandbox.SceneFile.Upgrader_v1(System.Text.Json.Nodes.JsonObject)">
      <summary>
            Version 0 to 1
            - "Id" changed to "__guid"
            </summary>
    </member>
    <member name="M:Sandbox.SceneFile.Upgrader_v2(System.Text.Json.Nodes.JsonObject)">
      <summary>
            Version 1 to 2
            - Title and Description moved to SceneInformation metadata component
            </summary>
    </member>
    <member name="T:Sandbox.Shader">
      <summary>
            A <a href="https://en.wikipedia.org/wiki/Shader">shader</a> is a specialized and complex computer program that use
            world geometry, materials and textures to render graphics.
            </summary>
    </member>
    <member name="M:Sandbox.Shader.LoadFromCompiledUnlessOutOfDate(System.String)">
      <summary>
            Loads from the compiled resource, unless it's out of date by comparing the md5
            in which case it just returns false 
            </summary>
    </member>
    <member name="M:Sandbox.Shader.LoadFromSourceChecksums(System.String)">
      <summary>
            Loads all shader programs from the shader source file, except those that are already loaded (from above, assumably)
            </summary>
    </member>
    <member name="M:Sandbox.Shader.LoadFromSource(System.String)">
      <summary>
            Loads all shader programs from the shader source file, except those that are already loaded (from above, assumably)
            </summary>
    </member>
    <member name="M:Sandbox.Shader.FromNative(NativeEngine.CVfx,System.String)">
      <summary>
            Try to make it so only one Shader class exists for each shader
            </summary>
    </member>
    <member name="M:Sandbox.Shader.Load(System.String)">
      <summary>
            Load a shader by file path.
            </summary>
      <param name="filename">The file path to load as a shader.</param>
      <returns>The loaded shader, or null</returns>
    </member>
    <member name="T:Sandbox.Soundscape">
      <summary>
            A soundscape is used for environmental ambiance of a map by playing a set of random sounds at given intervals.
            </summary>
    </member>
    <member name="P:Sandbox.Soundscape.MasterVolume">
      <summary>
            All sound volumes in this soundscape will be scaled by this value.
            </summary>
    </member>
    <member name="P:Sandbox.Soundscape.LoopedSounds">
      <summary>
            Sounds that are played constantly on a loop.
            </summary>
    </member>
    <member name="P:Sandbox.Soundscape.StingSounds">
      <summary>
            Sounds that are played at intervals.
            </summary>
    </member>
    <member name="P:Sandbox.Soundscape.LoopedSound.SoundFile">
      <summary>
            The sound to play. It should have the looped flag set.
            </summary>
    </member>
    <member name="P:Sandbox.Soundscape.LoopedSound.Volume">
      <summary>
            Sound volume.
            </summary>
    </member>
    <member name="M:Sandbox.Soundscape.LoopedSound.ToString">
      <summary>
            If true then the sound will come from a random direction in the world
            </summary>
    </member>
    <member name="P:Sandbox.Soundscape.StingSound.SoundFile">
      <summary>
            The sound event to play.
            </summary>
    </member>
    <member name="P:Sandbox.Soundscape.StingSound.InstanceCount">
      <summary>
            How many instances of this sting should exist.
            </summary>
    </member>
    <member name="P:Sandbox.Soundscape.StingSound.RepeatTime">
      <summary>
            How often should this sound be repeated.
            </summary>
    </member>
    <member name="P:Sandbox.Soundscape.StingSound.Distance">
      <summary>
            How far away from the camera should the sound play.
            </summary>
    </member>
    <member name="T:Sandbox.SoundData">
      <summary>
            Raw PCM sound data, kind of like a bitmap but for sounds
            </summary>
    </member>
    <member name="T:Sandbox.SoundEvent">
      <summary>
            A sound event. It can play a set of random sounds with optionally random settings such as volume and pitch.
            </summary>
    </member>
    <member name="P:Sandbox.SoundEvent.UI">
      <summary>
            Is this sound 2D?
            </summary>
    </member>
    <member name="P:Sandbox.SoundEvent.Volume">
      <summary>
            How loud the sound should be.
            </summary>
    </member>
    <member name="P:Sandbox.SoundEvent.Pitch">
      <summary>
            The base pitch of the sound.
            </summary>
    </member>
    <member name="P:Sandbox.SoundEvent.Decibels">
      <summary>
            How loud is this sound, affects how far away it can be heard
            </summary>
    </member>
    <member name="P:Sandbox.SoundEvent.SelectionMode">
      <summary>
            Selection strategy to use when picking from multiple sounds.
            </summary>
    </member>
    <member name="P:Sandbox.SoundEvent.Sounds">
      <summary>
            A random sound from the list will be selected to be played.
            </summary>
    </member>
    <member name="P:Sandbox.SoundEvent.Occlusion">
      <summary>
            Allow this sound to be occluded by geometry 
            </summary>
    </member>
    <member name="P:Sandbox.SoundEvent.Reflections">
      <summary>
            Allow this sound to trace reflections, allowing it to be heard indirectly
            </summary>
    </member>
    <member name="P:Sandbox.SoundEvent.AirAbsorption">
      <summary>
            Allow this sound to be absorbed by air
            </summary>
    </member>
    <member name="P:Sandbox.SoundEvent.Transmission">
      <summary>
            Allow this sound to be transmitted through geometry
            </summary>
    </member>
    <member name="P:Sandbox.SoundEvent.OcclusionRadius">
      <summary>
            The radius of this sound's occlusion in inches.
            </summary>
    </member>
    <member name="P:Sandbox.SoundEvent.DistanceAttenuation">
      <summary>
            Should the sound fade out over distance
            </summary>
    </member>
    <member name="P:Sandbox.SoundEvent.Distance">
      <summary>
            How many units the sound can be heard from.
            </summary>
    </member>
    <member name="P:Sandbox.SoundEvent.Falloff">
      <summary>
            The falloff curve for the sound.
            </summary>
    </member>
    <member name="P:Sandbox.SoundEvent.DefaultMixer">
      <summary>
            Default mixer to play this sound with if one isn't provided on play.
            </summary>
    </member>
    <member name="P:Sandbox.SoundEvent.InputIndex">
      <summary>
            Used for selection mode
            </summary>
    </member>
    <member name="T:Sandbox.SoundFile">
      <summary>
            A sound resource.
            </summary>
    </member>
    <member name="P:Sandbox.SoundFile.OnSoundReloaded">
      <summary>
            Ran when the file is reloaded/recompiled, etc.
            </summary>
    </member>
    <member name="P:Sandbox.SoundFile.IsLoaded">
      <summary>
            true if sound is loaded
            </summary>
    </member>
    <member name="P:Sandbox.SoundFile.Format">
      <summary>
            Format of the audio file.
            </summary>
    </member>
    <member name="P:Sandbox.SoundFile.BitsPerSample">
      <summary>
            Bits per each sample of this sound file.
            </summary>
    </member>
    <member name="P:Sandbox.SoundFile.Channels">
      <summary>
            Number of channels this audio file has.
            </summary>
    </member>
    <member name="P:Sandbox.SoundFile.BytesPerSample">
      <summary>
            Bytes per each sample of this sound file.
            </summary>
    </member>
    <member name="P:Sandbox.SoundFile.SampleFrameSize">
      <summary>
            Size of one sample, typically this would be "sample size * channel count", but can vary on audio format.
            </summary>
    </member>
    <member name="P:Sandbox.SoundFile.Rate">
      <summary>
            Sample rate of this sound file, per second.
            </summary>
    </member>
    <member name="P:Sandbox.SoundFile.Duration">
      <summary>
            Duration of the sound this sound file contains, in seconds.
            </summary>
    </member>
    <member name="M:Sandbox.SoundFile.Load(System.String)">
      <summary>
            Load a new sound from disk. Includes automatic caching.
            </summary>
      <param name="filename">The file path to load the sound from.</param>
      <returns>The loaded sound file, or null if failed.</returns>
    </member>
    <member name="M:Sandbox.SoundFile.Create(System.String,System.Span{System.Byte},System.Int32,System.UInt32,System.Int32,System.UInt32,System.Single,System.Boolean)">
      <summary>
            Load from PCM.
            </summary>
    </member>
    <member name="M:Sandbox.SoundFile.FromWav(System.String,System.Span{System.Byte},System.Boolean)">
      <summary>
            Load from WAV.
            </summary>
    </member>
    <member name="M:Sandbox.SoundFile.GetSamplesAsync">
      <summary>
            Request decompressed audio samples.
            </summary>
    </member>
    <member name="T:Sandbox.Surface">
      <summary>
            A physics surface. This is applied to each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> and controls its physical properties and physics related sounds.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.BaseSurface">
      <summary>
            Filepath of the base surface. Use <see cref="M:Sandbox.Surface.SetBaseSurface(System.String)">SetBaseSurface</see> and <see cref="M:Sandbox.Surface.GetBaseSurface">GetBaseSurface</see>.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.AudioSurface">
      <summary>
            Defines the audio properties of this surface for Steam Audio
            </summary>
    </member>
    <member name="P:Sandbox.Surface.Description">
      <summary>
            A concise description explaining what this surface property should be used for.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.Friction">
      <summary>
            Friction of this surface material.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.Elasticity">
      <summary>
            Controls bounciness.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.Density">
      <summary>
            Density of this surface material. This affects things like automatic mass calculation.
            Density is in kg/m^3.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.Thickness">
      <summary>
            If above 0, the object is considered hollow, and its auto generated mass is affected accordingly.
            Thickness is in inches.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.Dampening">
      <summary>
            Currently unused and does nothing.
            </summary>
      <remarks>TODO: Implement or remove.</remarks>
    </member>
    <member name="P:Sandbox.Surface.RollingResistance">
      <summary>
            Controls how easily rolling shapes (sphere, capsule) roll on surfaces.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.BounceThreshold">
      <summary>
            Velocity threshold, below which objects will not bounce due to their elasticity.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.ImpactEffectData.Regular">
      <summary>
            Spawn one of these particles on impact.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.ImpactEffectData.Bullet">
      <summary>
            Spawn one of these particles when hit by a bullet.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.ImpactEffectData.BulletDecal">
      <summary>
            Use one of these as the bullet impact decal.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.ImpactEffectData.SoftParticles">
      <summary>
            Spawn one of these particles on impact.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.ImpactEffectData.SoftDecal">
      <summary>
            Use one of these as a physics impact decal.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.ImpactEffectData.HardParticles">
      <summary>
            Spawn one of these particles on impact.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.ImpactEffectData.HardDecal">
      <summary>
            Use one of these as a physics impact decal.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.ImpactEffects">
      <summary>
            Impact effects of this surface material.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.ScrapeEffectData.RoughnessFactor">
      <summary>
            Similar to friction but only affects whether a scrape is rough or smooth.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.ScrapeEffectData.RoughThreshold">
      <summary>
            Surface roughness greater than this results in rough scrapes.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.ScrapeEffectData.SmoothParticles">
      <summary>
            Spawn one of these particle effects during a smooth scrape.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.ScrapeEffectData.RoughParticles">
      <summary>
            Spawn one of these particle effects during a rough scrape.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.ScrapeEffectData.SmoothDecal">
      <summary>
            Use one of these particles during a smooth scrape.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.ScrapeEffectData.RoughDecal">
      <summary>
            Use one of these particles during a rough scrape.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.ScrapeEffects">
      <summary>
            Scrape effects of this surface material.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.SoundData.FootLeft">
      <summary>
            Left footstep sound.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.SoundData.FootRight">
      <summary>
            Right footstep sound.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.SoundData.FootLaunch">
      <summary>
            Jump sound for this surface.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.SoundData.FootLand">
      <summary>
            Landing sound for this surface.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.SoundData.Bullet">
      <summary>
            Bullet impact sound for this surface.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.SoundData.ImpactHard">
      <summary>
            Hard, high velocity impact sound.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.SoundData.ImpactSoft">
      <summary>
            Soft, low velocity impact sound.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.SoundData.ScrapeRough">
      <summary>
            Rough scraping sound when scraping against another surface.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.SoundData.ScrapeSmooth">
      <summary>
            Smooth scraping sound when scraping against another surface.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.Sounds">
      <summary>
            Sounds associated with this surface material.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.BreakablesInfo.BreakSound">
      <summary>
            Play this sound when a model/entity of this surface breaks. Models can override this value.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.BreakablesInfo.GenericGibs">
      <summary>
            These models will be used as gibs when a model of this surface breaks and has no gibs of its own.
            </summary>
    </member>
    <member name="P:Sandbox.Surface.Breakables">
      <summary>
            Breakable info for this surface material.
            </summary>
    </member>
    <member name="M:Sandbox.Surface.GetBaseSurface">
      <summary>
            Returns the base surface of this surface, or null if we are the default surface.
            </summary>
    </member>
    <member name="M:Sandbox.Surface.SetBaseSurface(System.String)">
      <summary>
            Sets the base surface by name.
            </summary>
    </member>
    <member name="M:Sandbox.Surface.GetRandomGib">
      <summary>
            Returns a random gib taking into account base surface.
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.Surface.FindByIndex(System.Int32)">
      <summary>
            Find a surface by its index in the array. This is the fastest way to lookup, so it's
            passed from things like Traces since the index is going to be the same. It's important to
            know that this index shouldn't be saved or networked because it could differ between loads or clients.
            Instead send the name hash and look up using that.
            </summary>
    </member>
    <member name="M:Sandbox.Surface.FindByName(System.String)">
      <summary>
            Returns a Surface from its name, or null
            </summary>
      <param name="name">The name of a surface property to look up</param>
      <returns>The surface with given name, or null if such surface property doesn't exist</returns>
    </member>
    <member name="F:Sandbox.Surface.TagList">
      <summary>
            Internal accessor for the surface's tags (stored as StringToken)
            </summary>
    </member>
    <member name="P:Sandbox.Surface.Tags">
      <summary>
            A list of tags as one string.
            </summary>
    </member>
    <member name="M:Sandbox.Surface.HasTag(System.String)">
      <summary>
            Do we have a tag?
            </summary>
      <param name="tag" />
      <returns />
    </member>
    <member name="M:Sandbox.Surface.HasAllTags(System.String[])">
      <summary>
            Do we have all the tags on this hitbox?
            </summary>
      <param name="tags" />
      <returns>True if all tags match, false if any tag does not match.</returns>
    </member>
    <member name="M:Sandbox.Surface.HasAnyTags(System.String[])">
      <summary>
            Do we have all the tags on this hitbox?
            </summary>
      <param name="tags" />
      <returns>True if any tag matches, false if all tags do not match.</returns>
    </member>
    <member name="T:Sandbox.AudioSurface">
      <summary>
            Defines acoustic properties of a surface, which defines how sound will bounce
            </summary>
    </member>
    <member name="T:Sandbox.TerrainMaterial">
      <summary>
            Description of a Terrain Material.
            </summary>
    </member>
    <member name="T:Sandbox.TerrainStorage">
      <summary>
            Stores heightmaps, control maps and materials.
            </summary>
    </member>
    <member name="P:Sandbox.TerrainStorage.TerrainSize">
      <summary>
            Uniform world size of the width and length of the terrain.
            </summary>
    </member>
    <member name="P:Sandbox.TerrainStorage.TerrainHeight">
      <summary>
            World size of the maximum height of the terrain.
            </summary>
    </member>
    <member name="T:Sandbox.TerrainStorage.TerrainMaps">
      <summary>
            Contains terrain maps that get compressed
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.#ctor(SkiaSharp.SKBitmap)">
      <summary>
            Used internally for resizing operations
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.Clear(Color)">
      <summary>
            Clears the bitmap to the specified color.
            </summary>
      <param name="color">The color to fill the bitmap with.</param>
    </member>
    <member name="M:Sandbox.Bitmap.GetPixels">
      <summary>
            Retrieves the pixel data of the bitmap as an array of colors.
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.GetPixels16">
      <summary>
            Retrieves the pixel data of the bitmap as an array of colors.
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.GetPixels32">
      <summary>
            Retrieves the pixel data of the bitmap as an array of colors.
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.GetPixel(System.Int32,System.Int32)">
      <summary>
            Retrieves the color of a specific pixel in the bitmap.
            </summary>
      <param name="x">The x-coordinate of the pixel.</param>
      <param name="y">The y-coordinate of the pixel.</param>
      <returns>The color of the pixel at the specified coordinates.</returns>
    </member>
    <member name="M:Sandbox.Bitmap.SetPixel(System.Int32,System.Int32,Color)">
      <summary>
            Sets the color of a specific pixel in the bitmap.
            </summary>
      <param name="x">The x-coordinate of the pixel.</param>
      <param name="y">The y-coordinate of the pixel.</param>
      <param name="color">The color to set the pixel to.</param>
    </member>
    <member name="M:Sandbox.Bitmap.AssertBounds(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Asserts that the specified region is within the bounds of the bitmap.
            Throws an exception if the bounds are out of range.
            </summary>
      <param name="x">The x-coordinate of the starting point.</param>
      <param name="y">The y-coordinate of the starting point.</param>
      <param name="width">The width of the region to check.</param>
      <param name="height">The height of the region to check.</param>
    </member>
    <member name="M:Sandbox.Bitmap.Clone">
      <summary>
            Copy the bitmap to a new one without any changes.
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.IsOpaque">
      <summary>
            Returns true if this bitmap is completely opaque (no alpha)
            This does a pixel by pixel search, so it's not the fastest.
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.DrawRect(Sandbox.Rect)">
      <summary>
            Draws a rectangle using the current pen settings.
            </summary>
      <param name="rect">The rectangle to draw.</param>
    </member>
    <member name="M:Sandbox.Bitmap.DrawRect(System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Draws a rectangle using the current pen settings.
            </summary>
      <param name="x">The x-coordinate of the top-left corner.</param>
      <param name="y">The y-coordinate of the top-left corner.</param>
      <param name="width">The width of the rectangle.</param>
      <param name="height">The height of the rectangle.</param>
    </member>
    <member name="M:Sandbox.Bitmap.DrawRoundRect(Sandbox.Rect,Sandbox.UI.Margin)">
      <summary>
            Draws a rectangle using the current pen settings.
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.DrawCircle(Vector2,System.Single)">
      <summary>
            Draws a circle using the current pen settings.
            </summary>
      <param name="center">The center of the circle.</param>
      <param name="radius">The radius of the circle.</param>
    </member>
    <member name="M:Sandbox.Bitmap.DrawCircle(System.Single,System.Single,System.Single)">
      <summary>
            Draws a circle using the current pen settings.
            </summary>
      <param name="x">The x-coordinate of the circle's center.</param>
      <param name="y">The y-coordinate of the circle's center.</param>
      <param name="radius">The radius of the circle.</param>
    </member>
    <member name="M:Sandbox.Bitmap.DrawPolygon(Vector2[])">
      <summary>
            Draws a polygon using the current pen settings.
            </summary>
      <param name="points">The points of the polygon.</param>
    </member>
    <member name="M:Sandbox.Bitmap.DrawArc(Sandbox.Rect,System.Single,System.Single)">
      <summary>
            Draws an arc using the current pen settings.
            </summary>
      <param name="rect">The bounding rectangle of the arc.</param>
      <param name="startAngle">The starting angle of the arc, in degrees.</param>
      <param name="sweepAngle">The sweep angle of the arc, in degrees.</param>
    </member>
    <member name="M:Sandbox.Bitmap.DrawArc(Sandbox.Rect,System.Single,System.Single,System.Boolean)">
      <summary>
            Draws an arc using the current pen settings, with an option to connect to the center.
            </summary>
      <param name="rect">The bounding rectangle of the arc.</param>
      <param name="startAngle">The starting angle of the arc, in degrees.</param>
      <param name="sweepAngle">The sweep angle of the arc, in degrees.</param>
      <param name="useCenter">If true, connects the arc endpoints to the center point, forming a pie shape.</param>
    </member>
    <member name="M:Sandbox.Bitmap.DrawBitmap(Sandbox.Bitmap,Sandbox.Rect)">
      <summary>
            Draws another bitmap onto this bitmap.
            </summary>
      <param name="bitmap">The bitmap to draw.</param>
      <param name="destRect">The destination rectangle for the drawn bitmap.</param>
    </member>
    <member name="M:Sandbox.Bitmap.DrawLine(Vector2,Vector2)">
      <summary>
            Draws a line using the current pen settings.
            </summary>
      <param name="start">The starting point of the line.</param>
      <param name="end">The ending point of the line.</param>
    </member>
    <member name="M:Sandbox.Bitmap.DrawLines(Vector2[])">
      <summary>
            Draws connected lines through a series of points using the current pen settings.
            </summary>
      <param name="points">The points to connect with lines.</param>
    </member>
    <member name="M:Sandbox.Bitmap.Blur(System.Single,System.Boolean)">
      <summary>
            Applies a Gaussian blur effect to the current bitmap.
            </summary>
      <param name="radius">The radius of the blur, controlling its intensity. Must be non-negative.</param>
      <param name="tileClamp">Determines the behavior at the edges of the bitmap:
            <c>true</c> to clamp the edges (default), or <c>false</c> to repeat the edges.</param>
    </member>
    <member name="M:Sandbox.Bitmap.Sharpen(System.Single,System.Boolean)">
      <summary>
            Applies a Gaussian blur effect to the current bitmap.
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.Adjust(System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Adjusts brightness, contrast, and saturation in one pass.
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.AdjustHue(System.Single)">
      <summary>
            Adjusts the hue of the bitmap.
            </summary>
      <param name="angle">The angle to rotate the hue, in degrees (0 to 360).</param>
    </member>
    <member name="M:Sandbox.Bitmap.Colorize(Color)">
      <summary>
            Color the bitmap using this color, respect alpha
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.InsertPadding(Sandbox.UI.Margin)">
      <summary>
            Shrink the image by adding padding all around - without resizing the bitmap
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.Posterize(System.Int32)">
      <summary>
            Applies a posterize effect to the bitmap.
            </summary>
      <param name="levels">The number of color levels to reduce to (e.g., 2, 4, 8).</param>
    </member>
    <member name="M:Sandbox.Bitmap.HeightmapToNormalMap(System.Single)">
      <summary>
            Converts a heightmap to a normal map using parallel processing.
            </summary>
      <param name="strength">The strength of the normal map effect (default is 1.0).</param>
      <returns>The generated normal map as an SKBitmap.</returns>
    </member>
    <member name="M:Sandbox.Bitmap.GetHeight(SkiaSharp.SKColor[],System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Gets the height value from the pixel array, clamped to the edges.
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.InvertColor">
      <summary>
            Inverts the colors of the bitmap while preserving alpha.
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.CreateFromBytes(System.Byte[])">
      <summary>
            Loads a bitmap from the specified byte array.
            </summary>
      <param name="data">The byte array containing the image data.</param>
      <returns>A new <see cref="T:Sandbox.Bitmap" /> instance.</returns>
    </member>
    <member name="M:Sandbox.Bitmap.IsIes(System.Byte[])">
      <summary>
            Return true if this data is a Ies file
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.CreateFromPsdBytes(System.Byte[])">
      <summary>
            Creates a Bitmap instance from PSD file data.
            </summary>
      <param name="data">Byte array containing the PSD file data.</param>
      <returns>A Bitmap instance if successful, or null if the data is not valid PSD.</returns>
    </member>
    <member name="M:Sandbox.Bitmap.IsPsd(System.Byte[])">
      <summary>
            Checks if the provided byte array is a valid PSD file.
            </summary>
      <param name="data">Byte array to check.</param>
      <returns>True if the data is a PSD file, otherwise false.</returns>
    </member>
    <member name="M:Sandbox.Bitmap.CreateFromSvgString(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{Vector2},System.Nullable{Vector2},System.Nullable{System.Single})">
      <summary>
            Create a bitmap from an SVG, with optional size
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.IsTga(System.Byte[])">
      <summary>
            Return true if this data is a Tga file
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.SetAntialias(System.Boolean)">
      <summary>
            Sets the pen for drawing with a solid color and stroke style.
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.SetBlendMode(Sandbox.BlendMode)">
      <summary>
            Sets the pen to use a specific blend mode.
            </summary>
      <param name="blendMode">The blend mode to apply.</param>
    </member>
    <member name="M:Sandbox.Bitmap.SetPen(Color,System.Single)">
      <summary>
            Sets the pen for drawing with a solid color and stroke style.
            </summary>
      <param name="color">The color of the pen.</param>
      <param name="width">The width of the pen in pixels.</param>
    </member>
    <member name="M:Sandbox.Bitmap.SetDashedPen(Color,System.Single,System.Single[])">
      <summary>
            Sets the pen for drawing dashed or dotted lines.
            </summary>
      <param name="color">The color of the pen.</param>
      <param name="width">The width of the pen in pixels.</param>
      <param name="dashPattern">An array defining the dash pattern (e.g., [10, 5] for 10px dash, 5px gap).</param>
    </member>
    <member name="M:Sandbox.Bitmap.SetFill(Color)">
      <summary>
            Sets the pen for drawing filled shapes with a solid color.
            </summary>
      <param name="color">The color to fill the shapes with.</param>
    </member>
    <member name="M:Sandbox.Bitmap.SetLinearGradient(Vector2,Vector2,Sandbox.Gradient)">
      <summary>
            Sets the pen for drawing with a linear gradient.
            </summary>
      <param name="start">the gradient's start point.</param>
      <param name="end">the gradient's end point.</param>
      <param name="gradient">The color of the gradient.</param>
    </member>
    <member name="M:Sandbox.Bitmap.SetRadialGradient(Vector2,System.Single,Sandbox.Gradient)">
      <summary>
            Sets the pen for drawing with a radial gradient.
            </summary>
      <param name="center">The gradient's center.</param>
      <param name="radius">The radius of the gradient.</param>
      <param name="gradient">The color of the gradient.</param>
    </member>
    <member name="M:Sandbox.Bitmap.ToJpg(System.Int32)">
      <summary>
            Exports the bitmap as a JPEG byte array with the specified quality.
            </summary>
      <param name="quality">The quality of the JPEG, between 0 and 100.</param>
      <returns>A byte array containing the JPEG image data.</returns>
    </member>
    <member name="M:Sandbox.Bitmap.ToPng">
      <summary>
            Exports the bitmap as a PNG byte array.
            </summary>
      <returns>A byte array containing the PNG image data.</returns>
    </member>
    <member name="M:Sandbox.Bitmap.ToBmp">
      <summary>
            Exports the bitmap as a BMP byte array.
            </summary>
      <returns>A byte array containing the BMP image data.</returns>
    </member>
    <member name="M:Sandbox.Bitmap.ToWebP(System.Int32)">
      <summary>
            Exports the bitmap as an HDR WebP byte array with the specified quality.
            </summary>
      <param name="quality">The quality of the WebP image, between 0 and 100.</param>
      <returns>A byte array containing the WebP HDR image data.</returns>
    </member>
    <member name="M:Sandbox.Bitmap.Encode(SkiaSharp.SKEncodedImageFormat,System.Int32)">
      <summary>
            Exports the bitmap to the specified image format with optional quality.
            </summary>
      <param name="format">The image format (e.g., PNG, JPEG, BMP).</param>
      <param name="quality">The quality of the image, used for formats like JPEG.</param>
      <returns>A byte array containing the image data.</returns>
    </member>
    <member name="M:Sandbox.Bitmap.ToFormat(Sandbox.ImageFormat)">
      <summary>
            Exports the bitmap to the specified engine format
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.DrawText(Sandbox.TextRendering.Scope,Sandbox.Rect,Sandbox.TextFlag)">
      <summary>
            Draws text onto this bitmap
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.ToTexture(System.Boolean)">
      <summary>
            Try to create a texture from this bitmap
            </summary>
    </member>
    <member name="M:Sandbox.Bitmap.Rotate(System.Single)">
      <summary>
            Rotates the bitmap by the specified angle.
            </summary>
      <param name="degrees">The angle in degrees to rotate the bitmap.</param>
      <returns>A new <see cref="T:Sandbox.Bitmap" /> instance with the rotated image.</returns>
    </member>
    <member name="M:Sandbox.Bitmap.Resize(System.Int32,System.Int32)">
      <summary>
            Resizes the bitmap to the specified dimensions and returns a new bitmap.
            </summary>
      <param name="newWidth">The new width of the bitmap.</param>
      <param name="newHeight">The new height of the bitmap.</param>
      <returns>A new <see cref="T:Sandbox.Bitmap" /> instance with the specified dimensions.</returns>
    </member>
    <member name="M:Sandbox.Bitmap.FlipVertical">
      <summary>
            Flips the bitmap vertically.
            </summary>
      <returns>A new <see cref="T:Sandbox.Bitmap" /> instance with the flipped image.</returns>
    </member>
    <member name="M:Sandbox.Bitmap.FlipHorizontal">
      <summary>
            Flips the bitmap horizontally.
            </summary>
      <returns>A new <see cref="T:Sandbox.Bitmap" /> instance with the flipped image.</returns>
    </member>
    <member name="M:Sandbox.Bitmap.Crop(Sandbox.Rect)">
      <summary>
            Crops the bitmap to the specified rectangle.
            </summary>
      <param name="rect">The rectangle to crop to.</param>
      <returns>A new <see cref="T:Sandbox.Bitmap" /> instance with the cropped image.</returns>
    </member>
    <member name="T:Sandbox.Texture">
      <summary>
            A texture is an image used in rendering. Can be a static texture loaded from disk, or a dynamic texture rendered to by code.
            Can also be 2D, 3D (multiple slices), or a cube texture (6 slices).
            </summary>
    </member>
    <member name="M:Sandbox.Texture.CreateCustom">
      <summary>
            Begins creation of a custom texture. Finish by calling <see cref="M:Sandbox.TextureBuilder.Create(System.String,System.Boolean,System.ReadOnlySpan{System.Byte},System.Int32)" />.
            </summary>
    </member>
    <member name="M:Sandbox.Texture.Create(System.Int32,System.Int32,Sandbox.ImageFormat)">
      <summary>
            Begins creation of a custom texture. Finish by calling <see cref="M:Sandbox.Texture2DBuilder.Finish" />.
            </summary>
    </member>
    <member name="M:Sandbox.Texture.CreateVolume(System.Int32,System.Int32,System.Int32,Sandbox.ImageFormat)">
      <summary>
            Begins creation of a custom 3D texture. Finish by calling <see cref="M:Sandbox.Texture3DBuilder.Finish" />.
            </summary>
    </member>
    <member name="M:Sandbox.Texture.CreateCube(System.Int32,System.Int32,Sandbox.ImageFormat)">
      <summary>
            Begins creation of a custom cube texture. (A texture with 6 sides) Finish by calling <see cref="M:Sandbox.TextureCubeBuilder.Finish" />.
            </summary>
    </member>
    <member name="M:Sandbox.Texture.CreateArray(System.Int32,System.Int32,System.Int32,Sandbox.ImageFormat)">
      <summary>
            Begins creation of a custom texture array. Finish by calling <see cref="M:Sandbox.TextureArrayBuilder.Finish" />.
            </summary>
    </member>
    <member name="M:Sandbox.Texture.CreateRenderTarget">
      <summary>
            Begins creation of a <a href="https://en.wikipedia.org/wiki/Render_Target">render target</a>. Finish by calling <see cref="M:Sandbox.TextureBuilder.Create(System.String,System.Boolean,System.ReadOnlySpan{System.Byte},System.Int32)" />.
            Render targets can be used for fancy things like <see cref="M:Sandbox.Graphics.RenderToTexture(Sandbox.SceneCamera,Sandbox.Texture)" />.
            </summary>
      <returns>The texture builder to help build the render target.</returns>
    </member>
    <member name="M:Sandbox.Texture.CreateRenderTarget(System.String,Sandbox.ImageFormat,Vector2)">
      <summary>
            A convenience function to quickly create a <a href="https://en.wikipedia.org/wiki/Render_Target">render target</a>.
            Render targets can be used for fancy things like <see cref="M:Sandbox.Graphics.RenderToTexture(Sandbox.SceneCamera,Sandbox.Texture)" />.
            </summary>
      <param name="name">A meaningless debug name for your texture.</param>
      <param name="format">The image format.</param>
      <param name="size">The size of the texture.</param>
      <returns>The newly created render target texture.</returns>
    </member>
    <member name="M:Sandbox.Texture.CreateRenderTarget(System.String,Sandbox.ImageFormat,Vector2,Sandbox.Texture)">
      <summary>
            This will create a <a href="https://en.wikipedia.org/wiki/Render_Target">render target</a> texture if <paramref name="oldTexture" /> is null or doesn't match what you've passed in. This is designed
            to be called regularly to resize your texture in response to other things changing (like the screen size, panel size etc).
            </summary>
      <param name="name">A meaningless debug name for your texture.</param>
      <param name="format">The image format.</param>
      <param name="size">The size of the texture.</param>
      <param name="oldTexture">A previously created texture.</param>
      <returns>Will return a new texture, or the <paramref name="oldTexture" />.</returns>
    </member>
    <member name="M:Sandbox.Texture.CreateFromSvgSource(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{Color})">
      <summary>
            Create a texture from an SVG source
            </summary>
    </member>
    <member name="F:Sandbox.Texture.ParentObject">
      <summary>
            Allow the texture to keep a reference to its parent object (like a videoplayer).
            </summary>
    </member>
    <member name="F:Sandbox.Texture.IsDirty">
      <summary>
            Has the native handle changed?
            </summary>
    </member>
    <member name="P:Sandbox.Texture.IsError">
      <summary>
            Whether this texture is an error or invalid or not.
            </summary>
    </member>
    <member name="M:Sandbox.Texture.#ctor(NativeEngine.ITexture)">
      <summary>
            Private constructor, use <see cref="M:Sandbox.Texture.FromNative(NativeEngine.ITexture)" /></summary>
    </member>
    <member name="P:Sandbox.Texture.Index">
      <summary>
            Texture index. Bit raw dog and needs a higher level abstraction.
            </summary>
    </member>
    <member name="M:Sandbox.Texture.CopyFrom(Sandbox.Texture)">
      <summary>
            Replace our strong handle with a copy of the strong handle of the passed texture
            Which means that this texture will invisibly become that texture.
            I suspect that there might be a decent way to do this in native using the resource system.
            In which case we should change all this code to use that way instead of doing this.
            </summary>
    </member>
    <member name="P:Sandbox.Texture.Width">
      <summary>
            Width of the texture in pixels.
            </summary>
    </member>
    <member name="P:Sandbox.Texture.Height">
      <summary>
            Height of the texture in pixels.
            </summary>
    </member>
    <member name="P:Sandbox.Texture.Depth">
      <summary>
            Depth of a 3D texture in pixels, or slice count for 2D texture arrays, or 6 for slices of cubemap.
            </summary>
    </member>
    <member name="P:Sandbox.Texture.Mips">
      <summary>
            Number of <a href="https://en.wikipedia.org/wiki/Mipmap">mip maps</a> this texture has.
            </summary>
    </member>
    <member name="P:Sandbox.Texture.Size">
      <summary>
            Returns a Vector2 representing the size of the texture (width, height)
            </summary>
    </member>
    <member name="P:Sandbox.Texture.IsLoaded">
      <summary>
            Whether this texture has finished loading or not.
            </summary>
    </member>
    <member name="P:Sandbox.Texture.ImageFormat">
      <summary>
            Image format of this texture.
            </summary>
    </member>
    <member name="P:Sandbox.Texture.LastUsed">
      <summary>
            Returns how many frames ago this texture was last used by the renderer
            </summary>
    </member>
    <member name="M:Sandbox.Texture.Dispose">
      <summary>
            Will release the handle for this texture. If the texture isn't referenced by anything
            else it'll be released properly. This will happen anyway because it's called in the destructor.
            By calling it manually you're just telling the engine you're done with this texture right now
            instead of waiting for the garbage collector.
            </summary>
    </member>
    <member name="P:Sandbox.Texture.SequenceData">
      <summary>
            If this texture is a sprite sheet, will return information about the sheet, which
            is generally used in the shader. You don't really need to think about the contents.
            </summary>
    </member>
    <member name="P:Sandbox.Texture.SequenceCount">
      <summary>
            The count of sequences in this texture, if any. The rest of the sequence data is encoded into the texture itself.
            </summary>
    </member>
    <member name="M:Sandbox.Texture.GetSequenceFrameCount(System.Int32)">
      <summary>
            Get the frame count for this sequence
            </summary>
    </member>
    <member name="M:Sandbox.Texture.GetSequenceLength(System.Int32)">
      <summary>
            Get the total length of this seqence
            </summary>
    </member>
    <member name="M:Sandbox.Texture.UpdateSheetInfo">
      <summary>
            TODO: Fill this out, build a structure of Sequence[] for people to access
            Then make it so we can actually preview them
            </summary>
    </member>
    <member name="M:Sandbox.Texture.MarkUsed(System.Int32)">
      <summary>
            Tells texture streaming this texture is being used.
            This is usually automatic, but useful for bindless pipelines.
            </summary>
    </member>
    <member name="M:Sandbox.Texture.ReplacementAsync(System.Threading.Tasks.Task{Sandbox.Texture})">
      <summary>
            Mark this texture as loading, create a texture in a task, replace this texture with it, mark it as loaded.
            This is for situations where you create a placeholder texture then replace it with the real texture later.
            </summary>
    </member>
    <member name="M:Sandbox.Texture.CreateGenerator">
      <summary>
            If this is a generated texture we'll create and return a generator for it.
            </summary>
    </member>
    <member name="M:Sandbox.Texture.LoadJsonReference(System.Text.Json.Utf8JsonReader@)">
      <summary>
            Given json input (usually a json object), find or load a texture reference.
            </summary>
    </member>
    <member name="P:Sandbox.Texture.GenerationData">
      <summary>
            Data used by the generator to create the texture
            </summary>
    </member>
    <member name="M:Sandbox.Texture.WriteJsonReference(System.Text.Json.Utf8JsonWriter)">
      <summary>
            Write a Json reference, if this is a procedural generating texture
            </summary>
    </member>
    <member name="M:Sandbox.Texture.Load(Sandbox.BaseFileSystem,System.String,System.Boolean)">
      <summary>
            Try to load a texture from given filesystem, by filename.
            </summary>
    </member>
    <member name="M:Sandbox.Texture.Load(System.String,System.Boolean)">
      <summary>
            Try to load a texture.
            This version is able to load http images - but not images from disk.
            </summary>
    </member>
    <member name="M:Sandbox.Texture.LoadAvatar(System.Int64)">
      <summary>
            Load avatar image of a Steam user.
            </summary>
      <param name="steamid">The SteamID of the user to load avatar of.</param>
      <returns>The avatar texture.</returns>
    </member>
    <member name="M:Sandbox.Texture.LoadAvatar(System.String)">
      <inheritdoc cref="M:Sandbox.Texture.LoadAvatar(System.Int64)" />
    </member>
    <member name="M:Sandbox.Texture.LoadAsync(Sandbox.BaseFileSystem,System.String,System.Boolean)">
      <summary>
            Load a texture asynchronously. Will return when the texture is loaded and valid.
            This is useful when loading textures from the web.
            </summary>
    </member>
    <member name="M:Sandbox.Texture.Find(System.String)">
      <summary>
            Try to get an already loaded texture.
            </summary>
      <param name="filepath">The filename of the texture.</param>
      <returns>The already loaded texture, or null if it was not yet loaded.</returns>
    </member>
    <member name="M:Sandbox.Texture.GetPixels(System.Int32)">
      <summary>
            Reads pixel colors from the texture at the specified mip level
            </summary>
    </member>
    <member name="M:Sandbox.Texture.GetPixels``1(System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32},System.Int32,System.Int32,System.Span{``0},Sandbox.ImageFormat,System.ValueTuple{System.Int32,System.Int32})">
      <summary>
            Reads a 2D range of pixel values from the texture at the specified mip level, writing to <paramref name="dstData" />.
            This reads one slice from a 2D texture array or 3D texture volume.
            </summary>
      <typeparam name="T">Pixel value type (e.g., <see cref="T:Color32" />, <see cref="T:System.Single" />, <see cref="T:System.UInt32" /> or <see cref="T:System.Byte" />)</typeparam>
      <param name="srcRect">Pixel region to read.</param>
      <param name="slice">For 2D texture arrays or 3D texture volumes, which slice to read from.</param>
      <param name="mip">Mip level to read from.</param>
      <param name="dstData">Array to write to, starting at index 0 for the first read pixel.</param>
      <param name="dstFormat">Pixel format to use when writing to <paramref name="dstData" />. We only support some common formats for now.</param>
      <param name="dstSize">Dimensions of destination pixel array. Matches <paramref name="srcRect" /> by default.</param>
    </member>
    <member name="M:Sandbox.Texture.GetPixels``1(System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32},System.Int32,System.Int32,System.Span{``0},Sandbox.ImageFormat,System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32},System.Int32)">
      <summary>
            Reads a 2D range of pixel values from the texture at the specified mip level, writing to <paramref name="dstData" />.
            This reads one slice from a 2D texture array or 3D texture volume.
            </summary>
      <typeparam name="T">Pixel value type (e.g., <see cref="T:Color32" />, <see cref="T:System.Single" />, <see cref="T:System.UInt32" /> or <see cref="T:System.Byte" />)</typeparam>
      <param name="srcRect">Pixel region to read.</param>
      <param name="slice">For 2D texture arrays or 3D texture volumes, which slice to read from.</param>
      <param name="mip">Mip level to read from.</param>
      <param name="dstData">Array to write to, starting at index 0 for the first read pixel.</param>
      <param name="dstFormat">Pixel format to use when writing to <paramref name="dstData" />. We only support some common formats for now.</param>
      <param name="dstRect">Dimensions of destination pixel array. Matches <paramref name="srcRect" /> by default.</param>
      <param name="dstStride">Stride of the destination array, this is likely your width in pixels.</param>
    </member>
    <member name="M:Sandbox.Texture.GetPixels3D``1(System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32},System.Int32,System.Span{``0},Sandbox.ImageFormat,System.ValueTuple{System.Int32,System.Int32,System.Int32})">
      <summary>
            Reads a 3D range of pixel values from the texture at the specified mip level, writing to <paramref name="dstData" />.
            This can be used with a 2D texture array, or a 3D volume texture.
            </summary>
      <typeparam name="T">Pixel value type (e.g., <see cref="T:Color32" />, <see cref="T:System.Single" />, <see cref="T:System.UInt32" /> or <see cref="T:System.Byte" />)</typeparam>
      <param name="srcBox">Pixel region to read.</param>
      <param name="mip">Mip level to read from.</param>
      <param name="dstData">Array to write to, starting at index 0 for the first read pixel.</param>
      <param name="dstFormat">Pixel format to use when writing to <paramref name="dstData" />. We only support some common formats for now.</param>
      <param name="dstSize">Dimensions of destination pixel array. Matches <paramref name="srcBox" /> by default.</param>
    </member>
    <member name="M:Sandbox.Texture.GetPixel(System.Single,System.Single,System.Int32)">
      <summary>
            Reads a single pixel color.
            </summary>
    </member>
    <member name="M:Sandbox.Texture.GetPixel3D(System.Single,System.Single,System.Single,System.Int32)">
      <summary>
            Reads a single pixel color from a volume or array texture.
            </summary>
    </member>
    <member name="P:Sandbox.Texture.Invalid">
      <summary>
            1x1 solid magenta colored texture.
            </summary>
    </member>
    <member name="P:Sandbox.Texture.White">
      <summary>
            1x1 solid white opaque texture.
            </summary>
    </member>
    <member name="P:Sandbox.Texture.Transparent">
      <summary>
            1x1 fully transparent texture.
            </summary>
    </member>
    <member name="M:Sandbox.Texture.Update(System.ReadOnlySpan{System.Byte},System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Update this texture with given raw data.
            </summary>
      <param name="data">The raw data pixels, appropriate for this textures format.</param>
      <param name="x">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
      <param name="y">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
      <param name="width">Width of the image contained in <paramref name="data" />.</param>
      <param name="height">Height of the image contained in <paramref name="data" />.</param>
    </member>
    <member name="M:Sandbox.Texture.Update``1(System.ReadOnlySpan{``0},System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Update this texture with given raw data.
            </summary>
      <param name="data">The raw data pixels, appropriate for this textures format.</param>
      <param name="x">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
      <param name="y">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
      <param name="width">Width of the image contained in <paramref name="data" />.</param>
      <param name="height">Height of the image contained in <paramref name="data" />.</param>
    </member>
    <member name="M:Sandbox.Texture.Update(System.ReadOnlySpan{Color32},System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Update this texture with given raw data.
            </summary>
      <param name="data">The raw data pixels, appropriate for this textures format.</param>
      <param name="x">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
      <param name="y">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
      <param name="width">Width of the image contained in <paramref name="data" />.</param>
      <param name="height">Height of the image contained in <paramref name="data" />.</param>
    </member>
    <member name="M:Sandbox.Texture.Update3D(System.ReadOnlySpan{System.Byte},System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Update this 3D texture with given raw data.
            </summary>
      <param name="data">The raw data pixels, appropriate for this textures format.</param>
      <param name="x">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
      <param name="y">If updating a subsegment of the texture, this will be start coordinates on the target texture. (Top Left)</param>
      <param name="z">If updating a subsegment of the texture, this will be start coordinates on the target texture.</param>
      <param name="width">Width of the image contained in <paramref name="data" />.</param>
      <param name="height">Height of the image contained in <paramref name="data" />.</param>
      <param name="depth">Depth of the image contained in <paramref name="data" />.</param>
    </member>
    <member name="M:Sandbox.Texture.Update(Color32,Sandbox.Rect)">
      <summary>
            Write a coloured rectangle to the texture
            </summary>
    </member>
    <member name="M:Sandbox.Texture.Update(Color32,System.Single,System.Single)">
      <summary>
            Write a coloured pixel to the texture
            </summary>
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithStaticUsage">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithStaticUsage" />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithSemiStaticUsage">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithSemiStaticUsage" />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithDynamicUsage">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithDynamicUsage" />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithGPUOnlyUsage">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithGPUOnlyUsage" />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithUAVBinding">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithUAVBinding(System.Boolean)" />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithMips">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMips(System.Int32)" />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithMips(System.Int32)">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMips(System.Int32)" />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithFormat(Sandbox.ImageFormat)">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithFormat(Sandbox.ImageFormat)" />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithScreenFormat">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenFormat" />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithDepthFormat">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithDepthFormat" />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithMultiSample2X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample2X" />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithMultiSample4X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample4X" />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithMultiSample6X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample6X" />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithMultiSample8X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample8X" />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithMultiSample16X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample16X" />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithScreenMultiSample">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenMultiSample" />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithName(System.String)">
      <summary>
            Provide a name to identify the texture by
            </summary>
      <param name="name">Desired texture name</param>
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithData(System.Byte[])">
      <inheritdoc cref="M:Sandbox.Texture2DBuilder.WithData(System.Byte[],System.Int32)" />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithData(System.Byte[],System.Int32)">
      <summary>
            Initialize texture with pre-existing texture data.
            </summary>
      <param name="data">Texture data.</param>
      <param name="dataLength">How big our texture data is.</param>
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithData``1(System.ReadOnlySpan{``0})">
      <summary>
            Initialize texture with pre-existing texture data.
            </summary>
      <typeparam name="T">Texture data type</typeparam>
      <param name="data">Texture data</param>
      <returns />
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithData(System.IntPtr,System.Int32)">
      <summary>
            Create a texture with data using an UNSAFE intptr
            </summary>
      <param name="data">Pointer to the data</param>
      <param name="dataLength">Length of the data</param>
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithMultisample(Sandbox.MultisampleAmount)">
      <summary>
            Use Multi-Sample Anti Aliasing (MSAA) of given sample count.
            </summary>
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithAnonymous(System.Boolean)">
      <summary>
            Set whether the texture is an anonymous texture or not
            </summary>
      <param name="isAnonymous">Set if it's anonymous or not</param>
    </member>
    <member name="M:Sandbox.Texture2DBuilder.Finish">
      <summary>
            Build and create the actual texture
            </summary>
    </member>
    <member name="M:Sandbox.Texture2DBuilder.WithSize(System.Int32,System.Int32)">
            Custom methods
            <summary>
            Create texture with a predefined size.
            </summary><param name="width">Width in pixel.</param><param name="height">Height in pixels.</param></member>
    <member name="M:Sandbox.Texture2DBuilder.WithSize(Vector2)">
      <summary>
            Create texture with a predefined size
            </summary>
      <param name="size">Width and Height in pixels</param>
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithStaticUsage">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithStaticUsage" />
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithSemiStaticUsage">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithSemiStaticUsage" />
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithDynamicUsage">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithDynamicUsage" />
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithGPUOnlyUsage">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithGPUOnlyUsage" />
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithUAVBinding">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithUAVBinding(System.Boolean)" />
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithMips(System.Int32)">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMips(System.Int32)" />
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithFormat(Sandbox.ImageFormat)">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithFormat(Sandbox.ImageFormat)" />
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithScreenFormat">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenFormat" />
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithDepthFormat">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithDepthFormat" />
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithMultiSample2X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample2X" />
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithMultiSample4X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample4X" />
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithMultiSample6X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample6X" />
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithMultiSample8X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample8X" />
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithMultiSample16X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample16X" />
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithScreenMultiSample">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenMultiSample" />
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithName(System.String)">
      <summary>
            Provide a name to identify the texture by
            </summary>
      <param name="name">Desired texture name</param>
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithData(System.Byte[])">
      <summary>
            Initialize texture with pre-existing texture data
            </summary>
      <param name="data">Texture data</param>
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithData(System.Byte[],System.Int32)">
      <summary>
            Initialize texture with pre-existing texture data
            </summary>
      <param name="data">Texture data</param>
      <param name="dataLength">How big our texture data is</param>
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithData(System.IntPtr,System.Int32)">
      <summary>
            Create a texture with data using an UNSAFE intptr
            </summary>
      <param name="data">Pointer to the data</param>
      <param name="dataLength">Length of the data</param>
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithMultisample(Sandbox.MultisampleAmount)">
      <summary>
            Define which how much multisampling the current texture should use
            </summary>
      <param name="amount">Multisampling amount</param>
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithAnonymous(System.Boolean)">
      <summary>
            Set whether the texture is an anonymous texture or not
            </summary>
      <param name="isAnonymous">Set if it's anonymous or not</param>
    </member>
    <member name="M:Sandbox.Texture3DBuilder.Finish">
      <summary>
            Build and create the actual texture
            </summary>
    </member>
    <member name="M:Sandbox.Texture3DBuilder.WithSize(System.Int32,System.Int32,System.Int32)">
            Custom methods
            <summary>
            Create texture with a predefined size
            </summary><param name="width">Width in pixel</param><param name="height">Height in pixels</param><param name="depth">Depth in pixels</param></member>
    <member name="M:Sandbox.Texture3DBuilder.WithSize(Vector3)">
      <summary>
            Create texture with a predefined size
            </summary>
      <param name="size">Width, Height and Depth in pixels</param>
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithStaticUsage">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithStaticUsage" />
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithSemiStaticUsage">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithSemiStaticUsage" />
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithDynamicUsage">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithDynamicUsage" />
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithGPUOnlyUsage">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithGPUOnlyUsage" />
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithUAVBinding">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithUAVBinding(System.Boolean)" />
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithMips(System.Int32)">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMips(System.Int32)" />
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithFormat(Sandbox.ImageFormat)">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithFormat(Sandbox.ImageFormat)" />
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithScreenFormat">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenFormat" />
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithDepthFormat">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithDepthFormat" />
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample2X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample2X" />
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample4X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample4X" />
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample6X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample6X" />
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample8X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample8X" />
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample16X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample16X" />
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithScreenMultiSample">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenMultiSample" />
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithName(System.String)">
      <summary>
            Provide a name to identify the texture by
            </summary>
      <param name="name">Desired texture name</param>
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithData(System.Byte[])">
      <summary>
            Initialize texture with pre-existing texture data
            </summary>
      <param name="data">Texture data</param>
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithData(System.Byte[],System.Int32)">
      <summary>
            Initialize texture with pre-existing texture data
            </summary>
      <param name="data">Texture data</param>
      <param name="dataLength">How big our texture data is</param>
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithData(System.IntPtr,System.Int32)">
      <summary>
            Create a texture with data using an UNSAFE intptr
            </summary>
      <param name="data">Pointer to the data</param>
      <param name="dataLength">Length of the data</param>
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithMultisample(Sandbox.MultisampleAmount)">
      <summary>
            Define which how much multisampling the current texture should use
            </summary>
      <param name="amount">Multisampling amount</param>
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithAnonymous(System.Boolean)">
      <summary>
            Set whether the texture is an anonymous texture or not
            </summary>
      <param name="isAnonymous">Set if it's anonymous or not</param>
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.Finish">
      <summary>
            Build and create the actual texture
            </summary>
    </member>
    <member name="M:Sandbox.TextureArrayBuilder.WithSize(System.Int32,System.Int32)">
            Custom methods
            <summary>
            Create texture with a predefined size
            </summary><param name="width">Width in pixel</param><param name="height">Height in pixels</param></member>
    <member name="M:Sandbox.TextureArrayBuilder.WithCount(System.Int32)">
      <summary>
            Create texture array with this many textures
            </summary>
    </member>
    <member name="M:Sandbox.TextureBuilder.WithStaticUsage">
      <summary>
            Provides a hint to the GPU that this texture will not be modified.
            </summary>
    </member>
    <member name="M:Sandbox.TextureBuilder.WithSemiStaticUsage">
      <summary>
            Provides a hint to the GPU that this texture will only be updated sometimes.
            </summary>
    </member>
    <member name="M:Sandbox.TextureBuilder.WithDynamicUsage">
      <summary>
            Provides a hint to the GPU that this texture will be updated regularly. (almost every frame)
            </summary>
    </member>
    <member name="M:Sandbox.TextureBuilder.WithGPUOnlyUsage">
      <summary>
            Specify the texture to ONLY be used on the GPU on not allow CPU access.
            </summary>
    </member>
    <member name="M:Sandbox.TextureBuilder.WithMultiSample2X">
      <summary>
            Sets the texture to use 2x multisampling.
            </summary>
    </member>
    <member name="M:Sandbox.TextureBuilder.WithMultiSample4X">
      <summary>
            Sets the texture to use 4x multisampling.
            </summary>
    </member>
    <member name="M:Sandbox.TextureBuilder.WithMultiSample6X">
      <summary>
            Sets the texture to use 6x multisampling.
            </summary>
    </member>
    <member name="M:Sandbox.TextureBuilder.WithMultiSample8X">
      <summary>
            Sets the texture to use 8x multisampling.
            </summary>
    </member>
    <member name="M:Sandbox.TextureBuilder.WithMultiSample16X">
      <summary>
            Sets the texture to use 16x multisampling.
            </summary>
    </member>
    <member name="M:Sandbox.TextureBuilder.WithScreenMultiSample">
      <summary>
            Sets the texture to use the same multisampling as whatever the screen/framebuffer uses
            </summary>
    </member>
    <member name="M:Sandbox.TextureBuilder.WithFormat(Sandbox.ImageFormat)">
      <summary>
            The internal texture format to use.
            </summary>
      <param name="format">Texture format</param>
    </member>
    <member name="M:Sandbox.TextureBuilder.WithScreenFormat">
      <summary>
            Sets the internal texture format to use the same format as the screen/frame buffer.
            </summary>
    </member>
    <member name="M:Sandbox.TextureBuilder.WithDepthFormat">
      <summary>
            Uses the same depth format as what the screen/framebuffer uses.
            </summary>
    </member>
    <member name="M:Sandbox.TextureBuilder.WithMips(System.Int32)">
      <summary>
            Generate amount of mip levels.
            </summary>
      <param name="mips">How many mips should be generated for this texture</param>
    </member>
    <member name="M:Sandbox.TextureBuilder.WithUAVBinding(System.Boolean)">
      <summary>
            Support binding the texture as a Unordered Access View in a compute or pixel shader.
            This is required for binding a texture within a compute shader.
            </summary>
    </member>
    <member name="M:Sandbox.TextureBuilder.Create(System.String,System.Boolean,System.ReadOnlySpan{System.Byte},System.Int32)">
      <summary>
            Finish creating the texture.
            </summary>
      <param name="name">Name for the new texture.</param>
      <param name="anonymous">Whether this texture is anonymous.</param>
      <param name="data">Raw color data in correct format for the texture.</param>
      <param name="dataLength">Length of the <paramref name="data" />.</param>
      <returns>The created texture.</returns>
      <exception cref="T:System.ArgumentException">Thrown when the texture size is invalid, i.e. less then or equal to 0 on either axis.</exception>
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithStaticUsage">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithStaticUsage" />
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithSemiStaticUsage">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithSemiStaticUsage" />
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithDynamicUsage">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithDynamicUsage" />
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithGPUOnlyUsage">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithGPUOnlyUsage" />
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithUAVBinding">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithUAVBinding(System.Boolean)" />
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithMips(System.Int32)">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMips(System.Int32)" />
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithFormat(Sandbox.ImageFormat)">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithFormat(Sandbox.ImageFormat)" />
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithScreenFormat">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenFormat" />
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithDepthFormat">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithDepthFormat" />
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample2X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample2X" />
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample4X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample4X" />
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample6X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample6X" />
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample8X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample8X" />
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample16X">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithMultiSample16X" />
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithScreenMultiSample">
      <inheritdoc cref="M:Sandbox.TextureBuilder.WithScreenMultiSample" />
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithName(System.String)">
      <summary>
            Provide a name to identify the texture by
            </summary>
      <param name="name">Desired texture name</param>
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithData(System.Byte[])">
      <summary>
            Initialize texture with pre-existing texture data
            </summary>
      <param name="data">Texture data</param>
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithData(System.Byte[],System.Int32)">
      <summary>
            Initialize texture with pre-existing texture data
            </summary>
      <param name="data">Texture data</param>
      <param name="dataLength">How big our texture data is</param>
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithData(System.IntPtr,System.Int32)">
      <summary>
            Create a texture with data using an UNSAFE intptr
            </summary>
      <param name="data">Pointer to the data</param>
      <param name="dataLength">Length of the data</param>
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithMultisample(Sandbox.MultisampleAmount)">
      <summary>
            Define which how much multisampling the current texture should use
            </summary>
      <param name="amount">Multisampling amount</param>
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithAnonymous(System.Boolean)">
      <summary>
            Set whether the texture is an anonymous texture or not
            </summary>
      <param name="isAnonymous">Set if it's anonymous or not</param>
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithArrayCount(System.Int32)">
      <summary />
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.Finish">
      <summary>
            Build and create the actual texture
            </summary>
    </member>
    <member name="M:Sandbox.TextureCubeBuilder.WithSize(System.Int32,System.Int32)">
            Custom methods
            <summary>
            Create texture with a predefined size
            </summary><param name="width">Width in pixel</param><param name="height">Height in pixels</param></member>
    <member name="M:Sandbox.TextureCubeBuilder.WithSize(Vector2)">
      <summary>
            Create texture with a predefined size
            </summary>
      <param name="size">Width and Height in pixels</param>
    </member>
    <member name="T:Sandbox.TextureLoader.Avatar">
      <summary>
            Facilitates loading of Steam user avatars.
            </summary>
    </member>
    <member name="F:Sandbox.TextureLoader.ImageUrl.Loaded">
      <summary>
            For textures loaded from the web we want to keep them around a bit longer
            </summary>
    </member>
    <member name="F:Sandbox.VertexBuffer.Vertex">
      <summary>
            List of all vertices in this buffer.
            </summary>
    </member>
    <member name="F:Sandbox.VertexBuffer.Index">
      <summary>
            All indices associated with the vertices of this buffer
            </summary>
    </member>
    <member name="P:Sandbox.VertexBuffer.Indexed">
      <summary>
            Whether this vertex buffer has any indexes. This is set by <see cref="M:Sandbox.VertexBuffer.Init(System.Boolean)" />.
            </summary>
    </member>
    <member name="M:Sandbox.VertexBuffer.Clear">
      <summary>
            Clear all vertices and indices, and resets <see cref="F:Sandbox.VertexBuffer.Default" />.
            </summary>
    </member>
    <member name="M:Sandbox.VertexBuffer.Init(System.Boolean)">
      <summary>
            Clear the buffer and set whether it will have indices.
            </summary>
      <param name="useIndexBuffer">Whether this buffer will have indices. Affects <see cref="P:Sandbox.VertexBuffer.Indexed" />.</param>
    </member>
    <member name="M:Sandbox.VertexBuffer.Add(Sandbox.Vertex)">
      <summary>
            Add a vertex
            </summary>
    </member>
    <member name="M:Sandbox.VertexBuffer.AddIndex(System.Int32)">
      <summary>
            Add an index. This is relative to the top of the vertex buffer. So 0 is Vertex.Count., 1 is Vertex.Count -1
            </summary>
      <exception cref="T:System.InvalidOperationException">Thrown when <see cref="P:Sandbox.VertexBuffer.Indexed" /> is false.</exception>
    </member>
    <member name="M:Sandbox.VertexBuffer.AddTriangleIndex(System.Int32,System.Int32,System.Int32)">
      <summary>
            Add a triangle by indices. This is relative to the top of the vertex buffer. So 0 is Vertex.Count.
            </summary>
      <exception cref="T:System.InvalidOperationException">Thrown when <see cref="P:Sandbox.VertexBuffer.Indexed" /> is false.</exception>
    </member>
    <member name="M:Sandbox.VertexBuffer.AddRawIndex(System.Int32)">
      <summary>
            Add an index. This is NOT relative to the top of the vertex buffer.
            </summary>
      <exception cref="T:System.InvalidOperationException">Thrown when <see cref="P:Sandbox.VertexBuffer.Indexed" /> is false.</exception>
    </member>
    <member name="P:Sandbox.CubemapFogController.LodBias">
      <summary>
            Adjust how quickly the cubemap blurs out at closer distances. A value of 0.0 always uses the lowest resolution MIP over the entire range, while a value of 1.0 uses the highest.
            </summary>
    </member>
    <member name="P:Sandbox.CubemapFogController.StartDistance">
      <summary>
            The distance from the player at which the fog will start to fade in.
            </summary>
    </member>
    <member name="P:Sandbox.CubemapFogController.EndDistance">
      <summary>
            The distance from the player at which the fog will be at full strength.
            </summary>
    </member>
    <member name="P:Sandbox.CubemapFogController.FalloffExponent">
      <summary>
            Exponent for distance falloff. For example, 2.0 is proportional to square of distance.
            </summary>
    </member>
    <member name="P:Sandbox.CubemapFogController.HeightWidth">
      <summary>
            The distance between the start of the height fog and where it is fully opaque. Setting this to 0 will disable height based blending.
            </summary>
    </member>
    <member name="P:Sandbox.CubemapFogController.HeightStart">
      <summary>
            The absolute height in the map at which the height fog will start to fade in.
            </summary>
    </member>
    <member name="P:Sandbox.CubemapFogController.HeightExponent">
      <summary>
            Exponent for height falloff. For example, 2.0 is proportional to square of distance.
            </summary>
    </member>
    <member name="P:Sandbox.CubemapFogController.Enabled">
      <summary>
            Is this cubemap fog active?
            </summary>
    </member>
    <member name="P:Sandbox.CubemapFogController.Texture">
      <summary>
            Cubemap texture to use for the fog.
            </summary>
    </member>
    <member name="P:Sandbox.CubemapFogController.Transform">
      <summary>
            Location of the fog.
            </summary>
    </member>
    <member name="P:Sandbox.CubemapFogController.Tint">
      <summary>
            Tint of the fog. 
            </summary>
    </member>
    <member name="T:Sandbox.DecalSceneObject">
      <summary>
            A decal. Use the Component.
            </summary>
    </member>
    <member name="P:Sandbox.GradientFogController.Enabled">
      <summary>
            Whether the fog is enabled.
            </summary>
    </member>
    <member name="P:Sandbox.GradientFogController.StartDistance">
      <summary>
            Start distance of the fog.
            </summary>
    </member>
    <member name="P:Sandbox.GradientFogController.EndDistance">
      <summary>
            End distance of the fog.
            </summary>
    </member>
    <member name="T:Sandbox.ProjectedDecalSceneObject">
      <summary>
            A projected decal. Can be placed in <see cref="T:Sandbox.SceneWorld" />s.
            </summary>
    </member>
    <member name="P:Sandbox.ProjectedDecalSceneObject.Size">
      <summary>
            The size of the decal. X being the width, Y being the height, and Z being the depth.
            </summary>
    </member>
    <member name="P:Sandbox.ProjectedDecalSceneObject.Material">
      <summary>
            The material for our decal.
            </summary>
    </member>
    <member name="M:Sandbox.ProjectedDecalSceneObject.Update(Sandbox.Material,Vector3)">
      <summary>
            Sets up the cube mesh with the specified material and size
            </summary>
      <param name="material" />
      <param name="size" />
    </member>
    <member name="T:Sandbox.SceneCamera">
      <summary>
            Represents a camera and holds render hooks. This camera can be used to draw tool windows and scene panels.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.Bloom">
      <summary>
            Access tonemapping properties of camera
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.BloomAccessor.Enabled">
      <summary>
            Enable or disable exposure.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.Current">
      <summary>
            The current camera that is being rendered
            </summary>
    </member>
    <member name="F:Sandbox.SceneCamera._frustum">
      <summary>
            This is a c++ object with a ton of useful shit.
            Don't access it directly because it might be dirty.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.Name">
      <summary>
            The name of this camera.. for debugging purposes.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.ExcludeTags">
      <summary>
            Scene objects with any of these tags won't be rendered by this camera.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.RenderTags">
      <summary>
            Only scene objects with one of these tags will be rendered by this camera.
            </summary>
    </member>
    <member name="F:Sandbox.SceneCamera.OnRenderStageHook">
      <summary>
            Keep hidden! CommandBuffers only!!
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.OnRenderOpaque">
      <summary>
            Called when rendering the transparent pass
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.OnRenderPostProcess">
      <summary>
            Called when rendering the post process pass
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.OnRenderTransparent">
      <summary>
            Called when rendering the transparent pass
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.OnRenderOverlay">
      <summary>
            Called when rendering the camera's overlay
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.Size">
      <summary>
            The size of the screen. Allows us to work out aspect ratio.
            For now will get updated automatically on render.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.VolumetricFog">
      <summary>
            Control volumetric fog parameters, expect this to take 1-2ms of your GPU frame time.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.CubemapFog">
      <summary>
            Control fog based on an image.
            </summary>
    </member>
    <member name="F:Sandbox.SceneCamera.CubeRotations">
      <summary>
            Define the rotations for each of the 6 cube faces (right, left, up, down, front, back)
            </summary>
    </member>
    <member name="M:Sandbox.SceneCamera.#ctor(System.Int32,System.String)">
      <summary>
             Hidden - allows us to make camera with special lookup indexes
            
              -1 = world main view camera
              -2 = menu, game ui camera
            
             </summary>
    </member>
    <member name="M:Sandbox.SceneCamera.CleanupCollected">
      <summary>
            keep the directory clean by trimming all the old ones
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.World">
      <summary>
            The world we're going to render.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.Worlds">
      <summary>
            Your camera can render multiple worlds.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.Position">
      <summary>
            The position of the scene's camera.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.Rotation">
      <summary>
            The rotation of the scene's camera.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.Angles">
      <summary>
            The rotation of the scene's camera.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.FieldOfView">
      <summary>
            The horizontal field of view of the Camera in degrees.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.ZFar">
      <summary>
            The camera's zFar distance. This is the furthest distance this camera will be able to render.
            This value totally depends on the game you're making. Shorter the better, sensible ranges would be
            between about 1000 and 30000, but if you want it to be further out you can balance that out by making
            znear larger.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.ZNear">
      <summary>
            The camera's zNear distance. This is the closest distance this camera will be able to render.
            A good value for this is about 5. Below 5 and particularly below 1 you're going to start to see
            a lot of artifacts like z-fighting.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.Ortho">
      <summary>
            Whether to use orthographic projection.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.OrthoWidth">
      <summary>
            No longer used
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.OrthoHeight">
      <summary>
            Height of the ortho when <see cref="P:Sandbox.SceneCamera.Ortho" /> is enabled.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.DebugMode">
      <summary>
            Render this camera using a different render mode
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.WireframeMode">
      <summary>
            Render this camera using a wireframe view.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.ClearFlags">
      <summary>
            What kind of clearing should we do before we begin?
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.Rect">
      <summary>
            The rect of the screen to render to. This is normalized, between 0 and 1.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.BackgroundColor">
      <summary>
            Color the scene camera clears the render target to.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.AmbientLightColor">
      <summary>
            The color of the ambient light. Set it to black for no ambient light, alpha is used for lerping between IBL and constant color.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.AntiAliasing">
      <summary>
            Enable or disable anti-aliasing for this render.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.EnablePostProcessing">
      <summary>
            Toggle all post processing effects for this camera. The default is on.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.TargetEye">
      <summary>
            The HMD eye that this camera is targeting.
            Use <see cref="F:Sandbox.StereoTargetEye.None" /> for the user's monitor (i.e. the companion window).
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.WantsStereoSubmit">
      <summary>
            Set this to false if you don't want the stereo renderer to submit this camera's texture to the compositor.
            This option isn't considered if <see cref="P:Sandbox.SceneCamera.TargetEye" /> is <see cref="F:Sandbox.StereoTargetEye.None" />.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.EnableDirectLighting">
      <summary>
            Enable or disable direct lighting
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.EnableIndirectLighting">
      <summary>
            Enable or disable indirect lighting
            </summary>
    </member>
    <member name="M:Sandbox.SceneCamera.OnPreRender(Vector2)">
      <summary>
            Should be called before a render
            </summary>
    </member>
    <member name="M:Sandbox.SceneCamera.SetViewModelCamera(System.Single,System.Single,System.Single)">
      <summary>
            Set attributes for rendering the viewmodel's camera.
            </summary>
    </member>
    <member name="M:Sandbox.SceneCamera.GetFrustum(Sandbox.Rect)">
      <summary>
            Given a pixel rect return a frustum on the current camera.
            </summary>
    </member>
    <member name="M:Sandbox.SceneCamera.GetFrustum(Sandbox.Rect,Vector3)">
      <summary>
            Given a pixel rect return a frustum on the current camera. Pass in 1 to ScreenSize to use normalized screen coords.
            </summary>
    </member>
    <member name="M:Sandbox.SceneCamera.GetRay(Vector3)">
      <summary>
            Given a cursor position get a scene aiming ray.
            </summary>
    </member>
    <member name="M:Sandbox.SceneCamera.GetRay(Vector3,Vector3)">
      <summary>
            Given a cursor position get a scene aiming ray.
            </summary>
    </member>
    <member name="M:Sandbox.SceneCamera.ToScreen(Vector3)">
      <summary>
            Convert from world coords to screen coords. The results for x and y will be from 0 to <see cref="P:Sandbox.SceneCamera.Size" />.
            </summary>
    </member>
    <member name="M:Sandbox.SceneCamera.ToScreen(Vector3,Vector2@)">
      <summary>
            Convert from world coords to screen coords. The results for x and y will be from 0 to <see cref="P:Sandbox.SceneCamera.Size" />.
            </summary>
    </member>
    <member name="M:Sandbox.SceneCamera.ToScreen(Line)">
      <summary>
            Projects a line in world space to screen coords, returning null if the line is
            fully behind the camera.
            </summary>
    </member>
    <member name="M:Sandbox.SceneCamera.ToScreenNormal(Vector3)">
      <summary>
            Convert from world coords to normal screen corrds. The results will be between 0 and 1
            </summary>
    </member>
    <member name="M:Sandbox.SceneCamera.ToScreenWithDirection(Vector3)">
      <summary>
            Convert from world coords to screen coords but the Z component stores whether this vector
            is behind the screen (&lt;0) or in front of it (&gt;0). The X and Y components are normalized
            from 0 to 1.
            </summary>
      <param name="world" />
      <returns />
    </member>
    <member name="M:Sandbox.SceneCamera.ToWorld(Vector2)">
      <summary>
            Convert from screen coords to world coords on the near frustum plane.
            </summary>
    </member>
    <member name="M:Sandbox.SceneCamera.RenderToCubeTexture(Sandbox.Texture,System.Action)">
      <summary>
            Renders the scene from the camera position to a cube texture, capturing all 6 directions.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.CustomProjectionMatrix">
      <summary>
            Allows specifying a custom projection matrix for this camera
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.Tonemap">
      <summary>
            Access tonemapping properties of camera
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.TonemapAccessor.Enabled">
      <summary>
            Enable or disable exposure.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.TonemapAccessor.Rate">
      <summary>
            The rate of change for exposure.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.TonemapAccessor.Fade">
      <summary>
            Set the speed at which exposure fades downwards (diminishes) in response to light changes.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.TonemapAccessor.MinExposure">
      <summary>
            Minimum auto exposure scale
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.TonemapAccessor.MaxExposure">
      <summary>
            Maximum auto exposure scale
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.TonemapAccessor.ExposureCompensation">
      <summary>
            Number of stops to adjust auto-exposure by
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.TonemapAccessor.PercentTarget">
      <summary>
            Set a custom brightness target to go along with 'Target Bright Pixel Percentage'. (-1 for default engine behavior)
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.TonemapAccessor.PercentBrightPixels">
      <summary>
            Set a target for percentage of pixels above a certain brightness. (-1 for default engine behavior)
            </summary>
    </member>
    <member name="P:Sandbox.SceneCamera.TonemapAccessor.MinAverageLuminance">
      <summary>
            Set the minimum average luminance. This ensures that certain regions aren't too dim after tonemapping
            </summary>
    </member>
    <member name="T:Sandbox.ClearFlags">
      <summary>
            Flags for clearing a RT before rendering a scene using a SceneCamera
            </summary>
    </member>
    <member name="M:Sandbox.SceneCubemap.RenderDirty">
      <summary>
            Marks the cubemap as dirty, to be re-rendered on the next render.
            </summary>
    </member>
    <member name="T:Sandbox.SceneCullingBox">
      <summary>
            A box which can be used to explicitly control scene visibility. 
            There are two modes:
            1. Cull inside, hide any objects fully inside the box (excluder)
            2. Cull outside, hide any objects not intersecting any cull boxes marked cull outside (includer)
            </summary>
    </member>
    <member name="T:Sandbox.SceneCullingBox.CullMode">
      <summary>
            Cull mode, either inside or outside
            </summary>
    </member>
    <member name="F:Sandbox.SceneCullingBox.CullMode.Inside">
      <summary>
            Hide any objects fully inside the box
            </summary>
    </member>
    <member name="F:Sandbox.SceneCullingBox.CullMode.Outside">
      <summary>
            Hide any objects not intersecting any boxes
            </summary>
    </member>
    <member name="P:Sandbox.SceneCullingBox.IsValid">
      <summary>
            Is this culling box valid, exists inside a scene world.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCullingBox.World">
      <summary>
            The scene world this culling box belongs to.
            </summary>
    </member>
    <member name="P:Sandbox.SceneCullingBox.Transform">
      <summary>
            Position and rotation of this box, scale will scale the box size
            </summary>
    </member>
    <member name="P:Sandbox.SceneCullingBox.Size">
      <summary>
            Size of this box, transform scale will scale this size
            </summary>
    </member>
    <member name="P:Sandbox.SceneCullingBox.Mode">
      <summary>
            Cull mode, either inside or outside
            </summary>
    </member>
    <member name="M:Sandbox.SceneCullingBox.#ctor(Sandbox.SceneWorld,Transform,Vector3,Sandbox.SceneCullingBox.CullMode)">
      <summary>
            Create a scene culling box.
            Each scene world can have a list of boxes which can be used to explicitly cull objects inside or outside the boxes.
            </summary>
    </member>
    <member name="M:Sandbox.SceneCullingBox.Delete">
      <summary>
            Delete this culling box. You shouldn't access it anymore.
            </summary>
    </member>
    <member name="T:Sandbox.SceneCustomObject">
      <summary>
            A scene object that allows custom rendering within a scene world.
            </summary>
    </member>
    <member name="F:Sandbox.SceneCustomObject.RenderOverride">
      <summary>
            Called by default version of <see cref="M:Sandbox.SceneCustomObject.RenderSceneObject" />.
            </summary>
    </member>
    <member name="M:Sandbox.SceneCustomObject.RenderSceneObject">
      <summary>
            Called when this scene object needs to be rendered.
            Invokes <see cref="F:Sandbox.SceneCustomObject.RenderOverride" /> by default. See the <see cref="T:Sandbox.Graphics" /> library for a starting point.
            </summary>
    </member>
    <member name="T:Sandbox.SceneDirectionalLight">
      <summary>
            A directional scene light that is used to mimic sun light in a <see cref="T:Sandbox.SceneWorld" />. Direction is controlled by this objects' <see cref="T:Rotation" />.
            </summary>
    </member>
    <member name="P:Sandbox.SceneDirectionalLight.SkyColor">
      <summary>
            Ambient light color outside of all light probes.
            </summary>
    </member>
    <member name="P:Sandbox.SceneDirectionalLight.ShadowCascadeCount">
      <summary>
            Control number of shadow cascades
            </summary>
    </member>
    <member name="M:Sandbox.SceneDirectionalLight.SetCascadeDistanceScale(System.Single)">
      <summary>
            Set the max distance of the shadow cascade
            </summary>
    </member>
    <member name="T:Sandbox.SceneFogVolume">
      <summary>
            Represents a volume of fog in a scene, contributing to volumetric fog effects set on <see cref="P:Sandbox.SceneCamera.VolumetricFog" />.
            </summary>
    </member>
    <member name="P:Sandbox.SceneFogVolume.Transform">
      <summary>
            The position and rotation of the fog volume in the scene.
            </summary>
    </member>
    <member name="P:Sandbox.SceneFogVolume.BoundingBox">
      <summary>
            Defines the spatial boundaries of the fog volume.
            </summary>
    </member>
    <member name="P:Sandbox.SceneFogVolume.FogStrength">
      <summary>
            The intensity of the fog. Higher values indicate denser fog.
            </summary>
    </member>
    <member name="P:Sandbox.SceneFogVolume.FalloffExponent">
      <summary>
            Controls how quickly the fog fades at the edges of the volume. Higher values give sharper transitions.
            </summary>
    </member>
    <member name="M:Sandbox.SceneFogVolume.Delete">
      <summary>
            Delete this fog volume. You shouldn't access it anymore.
            </summary>
    </member>
    <member name="T:Sandbox.SceneLight">
      <summary>
            Generic point light scene object for use with a <see cref="T:Sandbox.SceneWorld" />.
            </summary>
    </member>
    <member name="P:Sandbox.SceneLight.LightColor">
      <summary>
            Color and brightness of the light
            </summary>
    </member>
    <member name="P:Sandbox.SceneLight.Radius">
      <summary>
            Radius of the light in units
            </summary>
    </member>
    <member name="P:Sandbox.SceneLight.ConstantAttenuation">
      <summary>
            The light attenuation constant term
            </summary>
    </member>
    <member name="P:Sandbox.SceneLight.LinearAttenuation">
      <summary>
            The light attenuation linear term
            </summary>
    </member>
    <member name="P:Sandbox.SceneLight.QuadraticAttenuation">
      <summary>
            The light attenuation quadratic term
            </summary>
    </member>
    <member name="P:Sandbox.SceneLight.ShadowTextureResolution">
      <summary>
            Get or set the resolution of the shadow map. If this is zero the engine will decide what it should use.
            </summary>
    </member>
    <member name="P:Sandbox.SceneLight.ShadowsEnabled">
      <summary>
            Enable or disable shadow rendering
            </summary>
    </member>
    <member name="P:Sandbox.SceneLight.LightCookie">
      <summary>
            Access the LightCookie - which is a texture that gets drawn over the light
            </summary>
    </member>
    <member name="T:Sandbox.SceneLightProbe">
      <summary>
            Keep this internal for now
            </summary>
    </member>
    <member name="T:Sandbox.SceneLineObject">
      <summary>
            A scene object which is used to draw lines
            </summary>
    </member>
    <member name="P:Sandbox.SceneLoadOptions.DeleteEverything">
      <summary>
            If true, on load we'll even delete objects that are marked as DontDelete
            </summary>
    </member>
    <member name="T:Sandbox.SceneMap">
      <summary>
            Map geometry that can be rendered within a <see cref="T:Sandbox.SceneWorld" />.
            </summary>
    </member>
    <member name="P:Sandbox.SceneMap.World">
      <summary>
            The scene world this map belongs to.
            </summary>
    </member>
    <member name="P:Sandbox.SceneMap.IsValid">
      <summary>
            Is the map valid.
            </summary>
    </member>
    <member name="P:Sandbox.SceneMap.Bounds">
      <summary>
            Bounds of the map.
            </summary>
    </member>
    <member name="P:Sandbox.SceneMap.MapName">
      <summary>
            cs_assault
            </summary>
    </member>
    <member name="P:Sandbox.SceneMap.MapFolder">
      <summary>
            maps/davej/cs_assault
            </summary>
    </member>
    <member name="M:Sandbox.SceneMap.#ctor(Sandbox.SceneWorld,System.String)">
      <summary>
            Create a scene map within a scene world.
            </summary>
    </member>
    <member name="M:Sandbox.SceneMap.#ctor(Sandbox.SceneWorld,System.String,Sandbox.MapLoader)">
      <summary>
            Create a scene map within a scene world.
            </summary>
    </member>
    <member name="F:Sandbox.SceneMap.OnMapUpdated">
      <summary>
            Invoked when a map file is updated (re-compiled in Hammer.)
            </summary>
    </member>
    <member name="M:Sandbox.SceneMap.CreateAsync(Sandbox.SceneWorld,System.String,System.Threading.CancellationToken)">
      <summary>
            Create scene map asynchronously for when large maps take time to load.
            </summary>
    </member>
    <member name="M:Sandbox.SceneMap.CreateAsync(Sandbox.SceneWorld,System.String,Sandbox.MapLoader,System.Threading.CancellationToken)">
      <summary>
            Create scene map asynchronously for when large maps take time to load.
            </summary>
    </member>
    <member name="M:Sandbox.SceneMap.Delete">
      <summary>
            Delete this scene map. You shouldn't access it anymore.
            </summary>
    </member>
    <member name="T:Sandbox.SceneModel">
      <summary>
            A model scene object that supports animations and can be rendered within a <see cref="T:Sandbox.SceneWorld" />.
            </summary>
      <summary>
            A model scene object that supports animations and can be rendered within a <see cref="T:Sandbox.SceneWorld" />.
            </summary>
      <summary>
            A model scene object that supports animations and can be rendered within a <see cref="T:Sandbox.SceneWorld" />.
            </summary>
      <summary>
            A model scene object that supports animations and can be rendered within a <see cref="T:Sandbox.SceneWorld" />.
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.GetBoneVelocity(System.Int32,Vector3@,Vector3@)">
      <summary>
            Calculate velocity from previous and current bone transform 
            (I want to expose this public but want to make sure the math is correct first)
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.SetAnimGraph(System.String)">
      <summary>
            Override the anim graph this scene model uses
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.SetBoneWorldTransform(System.Int32,Transform)">
      <summary>
            Sets the world space bone transform of a bone by its index.
            </summary>
      <param name="boneIndex">Bone index to set transform of.</param>
      <param name="transform" />
    </member>
    <member name="M:Sandbox.SceneModel.GetBoneWorldTransform(System.Int32)">
      <summary>
            Returns the world space transform of a bone by its index.
            </summary>
      <param name="boneIndex">Index of the bone to calculate transform of.</param>
      <returns>The world space transform, or an identity transform on failure.</returns>
    </member>
    <member name="M:Sandbox.SceneModel.GetBoneWorldTransform(System.String)">
      <summary>
            Returns the world space transform of a bone by its name.
            </summary>
      <param name="boneName">Name of the bone to calculate transform of.</param>
      <returns>The world space transform, or an identity transform on failure.</returns>
    </member>
    <member name="M:Sandbox.SceneModel.GetBoneLocalTransform(System.Int32)">
      <summary>
            Returns the local space transform of a bone by its index.
            </summary>
      <param name="boneIndex">Index of the bone to calculate transform of.</param>
      <returns>The local space transform, or an identity transform on failure.</returns>
    </member>
    <member name="M:Sandbox.SceneModel.GetBoneLocalTransform(System.String)">
      <summary>
            Returns the local space transform of a bone by its name.
            </summary>
      <param name="boneName">Name of the bone to calculate transform of.</param>
      <returns>The local space transform, or an identity transform on failure.</returns>
    </member>
    <member name="M:Sandbox.SceneModel.SetMaterialGroup(System.String)">
      <summary>
            Set material group to replace materials of the model as set up in ModelDoc.
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.SetBodyGroup(System.String,System.Int32)">
      <summary>
            Set which body group to use.
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.GetAttachment(System.String,System.Boolean)">
      <summary>
            Get attachment transform by name.
            </summary>
      <param name="name">Name of the attachment to calculate transform of.</param>
      <param name="worldspace">Whether the transform should be in world space (relative to the scene world), or local space (relative to the scene object)</param>
      <returns />
    </member>
    <member name="P:Sandbox.SceneModel.UseAnimGraph">
      <summary>
            Allows the scene model to not use the anim graph so it can play sequences directly
            </summary>
    </member>
    <member name="P:Sandbox.SceneModel.RootMotion">
      <summary>
            Get the calculated motion from animgraph since last frame
            </summary>
    </member>
    <member name="P:Sandbox.SceneModel.CurrentSequence">
      <summary>
            Allows playback of sequences directly, rather than using an animation graph.
            Requires <see cref="P:Sandbox.SceneModel.UseAnimGraph" /> disabled if the scene model has one.
            </summary>
    </member>
    <member name="P:Sandbox.SceneModel.Morphs">
      <summary>
            Access this sceneobject's morph collection. Morphs are generally used in the model to control
            the face, for things like emotions and lip sync.
            </summary>
    </member>
    <member name="P:Sandbox.SceneModel.DirectPlayback">
      <summary>
            Access this sceneobject's direct playback. Direct playback is used to control the direct playback node in an animgraph
            to play sequences directly in code
            </summary>
    </member>
    <member name="P:Sandbox.SceneModel.OnFootstepEvent">
      <summary>
            Called when a footstep event happens
            </summary>
    </member>
    <member name="P:Sandbox.SceneModel.OnGenericEvent">
      <summary>
            Called when a generic event happens
            </summary>
    </member>
    <member name="P:Sandbox.SceneModel.OnSoundEvent">
      <summary>
            Called when a sound event happens
            </summary>
    </member>
    <member name="P:Sandbox.SceneModel.OnAnimTagEvent">
      <summary>
            Called when a anim tag event happens
            </summary>
    </member>
    <member name="T:Sandbox.SceneModel.AnimTagStatus">
      <summary>
            Enumeration that describes how the AnimGraph tag state changed. Used in <see cref="T:Sandbox.SceneModel.AnimTagEvent" />.
            </summary>
    </member>
    <member name="F:Sandbox.SceneModel.AnimTagStatus.Fired">
      <summary>
            Tag was activated and deactivated on the same frame
            </summary>
    </member>
    <member name="F:Sandbox.SceneModel.AnimTagStatus.Start">
      <summary>
            The tag has become active
            </summary>
    </member>
    <member name="F:Sandbox.SceneModel.AnimTagStatus.End">
      <summary>
            The tag has become inactive
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.SetAnimParameter(System.String,System.Boolean)">
      <summary>
            Sets a boolean animation graph parameter by name.
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.SetAnimParameter(System.String,System.Single)">
      <summary>
            Sets a float animation graph parameter by name.
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.SetAnimParameter(System.String,Vector3)">
      <summary>
            Sets a vector animation graph parameter by name.
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.SetAnimParameter(System.String,System.Int32)">
      <summary>
            Sets a integer animation graph parameter by name.
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.SetAnimParameter(System.String,Rotation)">
      <summary>
            Sets a rotation animation graph parameter by name.
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.ResetAnimParameters">
      <summary>
            Reset all animgraph parameters to their default values.
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.GetRotation(System.String)">
      <summary>
            Get an animated parameter
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.GetVector3(System.String)">
      <summary>
            Get an animated parameter
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.GetBool(System.String)">
      <summary>
            Get an animated parameter
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.GetFloat(System.String)">
      <summary>
            Get an animated parameter
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.GetInt(System.String)">
      <summary>
            Get an animated parameter
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.Update(System.Single)">
      <summary>
            Update this animation. Delta is the time you want to advance, usually RealTime.Delta
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.Update(System.Single,System.Action)">
      <summary>
            Update this animation. Delta is the time you want to advance, usually RealTime.Delta
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.UpdateToBindPose">
      <summary>
            Update all of the bones to the bind pose
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.UpdateToBindPose(System.Action)">
      <summary>
            Update all of the bones to the bind pose
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.FinishBoneUpdate">
      <summary>
            Updates attachments, ao proxies etc
            Should be called any time the world transform change
            </summary>
    </member>
    <member name="M:Sandbox.SceneModel.MergeBones(Sandbox.SceneModel)">
      <summary>
            Update our bones to match the target's bones. This is a manual bone merge.
            </summary>
    </member>
    <member name="T:Sandbox.SceneObject">
      <summary>
            A model scene object that can be rendered within a <see cref="T:Sandbox.SceneWorld" />.
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.World">
      <summary>
            The scene world this object belongs to.
            </summary>
    </member>
    <member name="M:Sandbox.SceneObject.Delete">
      <summary>
            Delete this scene object. You shouldn't access it anymore.
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.Transform">
      <summary>
            Transform of this scene object, relative to its <see cref="P:Sandbox.SceneObject.Parent" />, or <see cref="T:Sandbox.SceneWorld" /> if parent is not set.
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.Rotation">
      <summary>
            Rotation of this scene object, relative to its <see cref="P:Sandbox.SceneObject.Parent" />, or <see cref="T:Sandbox.SceneWorld" /> if parent is not set.
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.Position">
      <summary>
            Position of this scene object, relative to its <see cref="P:Sandbox.SceneObject.Parent" />, or <see cref="T:Sandbox.SceneWorld" /> if parent is not set.
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.Bounds">
      <summary>
            Set or get the axis aligned bounding box for this object.
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.LocalBounds">
      <summary>
            The world bounds translated to the local position. Note that this
            does NOT do any scaling or rotation.
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.RenderingEnabled">
      <summary>
            Whether this scene object should render or not.
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.ColorTint">
      <summary>
            Color tint of this scene object.
            </summary>
    </member>
    <member name="F:Sandbox.SceneObject.ClipPlane">
      <summary>
            Clipping plane for this scene object. Requires <see cref="F:Sandbox.SceneObject.ClipPlaneEnabled" /> to be <c>true</c>.
            </summary>
    </member>
    <member name="F:Sandbox.SceneObject.ClipPlaneEnabled">
      <summary>
            Whether or not to use the clipping plane defined in <see cref="F:Sandbox.SceneObject.ClipPlane" />.
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.Parent">
      <summary>
            Movement parent of this scene object, if any.
            </summary>
    </member>
    <member name="M:Sandbox.SceneObject.AddChild(System.String,Sandbox.SceneObject)">
      <summary>
            Add a named child scene object to this one. The child scene object will have its parent set.
            </summary>
      <remarks>
            The name can be used to look up children by name, but it is not bound. (SceneObject_FindChild)
            </remarks>
    </member>
    <member name="M:Sandbox.SceneObject.RemoveChild(Sandbox.SceneObject)">
      <summary>
            Unlink given scene object as a child from this one. The child scene object will have its parent set to null. It will not be deleted.
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.Model">
      <summary>
            The model this scene object will render.
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.MeshGroupMask">
      <summary>
            State of all bodygroups of this object's model. You might be looking for <see cref="M:Sandbox.SceneModel.SetBodyGroup(System.String,System.Int32)" />.
            </summary>
    </member>
    <member name="M:Sandbox.SceneObject.SetMaterialOverride(Sandbox.Material)">
      <summary>
            Override all materials on this object's <see cref="P:Sandbox.SceneObject.Model" />.
            </summary>
    </member>
    <member name="M:Sandbox.SceneObject.ClearMaterialOverride">
      <summary>
            Clear all material replacements.
            </summary>
    </member>
    <member name="M:Sandbox.SceneObject.SetMaterialOverride(Sandbox.Material,System.String,System.Int32)">
      <summary>
             Replaces all materials of the model that have the given <b>User Material Attribute</b> set to <b>"1"</b>, with given material.
            
             <para>The system checks both the models' default material group materials and the materials of the active material group.</para></summary>
      <param name="material">Material to replace with.</param>
      <param name="attributeName">Name of the <b>User Material Attribute</b> to test on each material of the model. They are set in the Material Editor's <b>Attributes</b> tab.</param>
      <param name="attributeValue">Value of the attribute to test for.</param>
    </member>
    <member name="M:Sandbox.SceneObject.SetMaterialGroup(System.String)">
      <summary>
            Set material group to replace materials of the model as set up in ModelDoc.
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.Batchable">
      <summary>
            This object is not batchable by material for some reason ( example: has dynamic attributes that affect rendering )
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.GameObject">
      <summary>
            For storing and retrieving the GameObject this SceneObject belongs to
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.Component">
      <summary>
            For storing and retrieving the Component this SceneObject beloings to 
            </summary>
    </member>
    <member name="M:Sandbox.SceneObject.UpdateFlagsBasedOnMaterial">
      <summary>
            Updates flags like transparent/opaque based on object's material, this is usually called automatically.
            But some procedural workflows (mesh editor) may want to call this manually.
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.Flags">
      <summary>
            Access to various advanced scene object flags.
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.CastShadows">
      <summary>
            Whether this scene object should cast shadows.
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.ExcludeGameLayer">
      <summary>
            Don't render in the opaque/translucent game passes. This is useful when you
            want to only render in the Bloom layer, rather than additionally to it.
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.NeedsEnvironmentMap">
      <summary>
            True if this object needs cubemap information
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.WantsFrameBufferCopy">
      <summary>
            Automatically sets the "FrameBufferCopyTexture" attribute within the material.
            This does the same thing as Render.CopyFrameBuffer(); except automatically if
            the pass allows for it.
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.IncludeInCubemap">
      <summary>
            Draw this in cubemaps
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.RenderLayer">
      <summary>
            For a layer to draw this object, the target layer must match (or be unset)
            and the flags must match
            </summary>
    </member>
    <member name="P:Sandbox.SceneObject.Tags">
      <summary>
            List of tags for this scene object.
            </summary>
    </member>
    <member name="T:Sandbox.SceneRenderLayer">
      <summary>
            SceneObjects can be rendered on layers other than the main game layer.
            This is useful if, for example, you want to render on top of everything without
            applying post processing.
            </summary>
    </member>
    <member name="F:Sandbox.SceneRenderLayer.Default">
      <summary>
            Draw wherever makes sense based on the flags, default behaviour
            </summary>
    </member>
    <member name="F:Sandbox.SceneRenderLayer.ViewModel">
      <summary>
            Layer drawn on top of everything else - with altered depth
            </summary>
    </member>
    <member name="F:Sandbox.SceneRenderLayer.OverlayWithDepth">
      <summary>
            Overlay - after post processing - but still with the scene's depth
            </summary>
    </member>
    <member name="F:Sandbox.SceneRenderLayer.OverlayWithoutDepth">
      <summary>
            Overlay - after post processing - without depth (draw over)
            </summary>
    </member>
    <member name="F:Sandbox.SceneRenderLayerHelper.Names">
      <summary>
            Internally we don't pass these enums, they're just string tokens.
            No need to expose the actual string tokens to people unless we expose the render pipeline fully to them.
            </summary>
    </member>
    <member name="T:Sandbox.SceneOrthoLight">
      <summary>
            Keep this internal for now
            </summary>
    </member>
    <member name="T:Sandbox.SceneParticles">
      <summary>
            A SceneObject used to render particles.
            We need to be careful with what we do here, because this object is created for in-engine particles
            as well as custom scene object particles.
            With custom particles there's no automatic Simulate, or deletion.. You're completely on your own. This
            is perhaps a good thing though, it's maybe what you want to happen. To be completely isolated and completely
            in control. But at the same time maybe it's not and it's something we need to sort out.
            </summary>
    </member>
    <member name="P:Sandbox.SceneParticles.particleCollection">
      <summary>
            TODO: Lets find a way to expose the IParticleCollection a bit raw'er
            </summary>
    </member>
    <member name="M:Sandbox.SceneParticles.#ctor(Sandbox.SceneWorld,System.String)">
      <summary>
            Create scene particles.
            </summary>
      <param name="world">The scene world to create the particles in.</param>
      <param name="particleSystem">Path to the particle system file.</param>
    </member>
    <member name="M:Sandbox.SceneParticles.#ctor(Sandbox.SceneWorld,Sandbox.ParticleSystem)">
      <summary>
            Create scene particles.
            </summary>
      <param name="world">The scene world to create the particles in.</param>
      <param name="particleSystem">Particle system resource.</param>
    </member>
    <member name="P:Sandbox.SceneParticles.RenderParticles">
      <summary>
            Whether to render the particles or not.
            </summary>
    </member>
    <member name="P:Sandbox.SceneParticles.EmissionStopped">
      <summary>
            Stop (or start) the particle system emission.
            </summary>
    </member>
    <member name="P:Sandbox.SceneParticles.PhysicsWorld">
      <summary>
            Particle collisions use this physics world to perform traces.
            </summary>
    </member>
    <member name="M:Sandbox.SceneParticles.IsControlPointSet(System.Int32)">
      <summary>
            Whether given control point has any data set.
            </summary>
      <param name="index">The control point index. Range is 0-63.</param>
    </member>
    <member name="M:Sandbox.SceneParticles.GetControlPointPosition(System.Int32)">
      <summary>
            Returns the position set on a given control point.
            </summary>
      <param name="index">The control point index. Range is 0-63.</param>
    </member>
    <member name="M:Sandbox.SceneParticles.SetControlPoint(System.Int32,Vector3)">
      <summary>
            Set position on given control point.
            </summary>
      <param name="i">The control point index. Range is 0-63.</param>
      <param name="position">The position to set.</param>
    </member>
    <member name="M:Sandbox.SceneParticles.SetControlPoint(System.Int32,Rotation)">
      <summary>
            Set rotation on given control point.
            </summary>
      <param name="i">The control point index. Range is 0-63.</param>
      <param name="rotation">The rotation to set.</param>
    </member>
    <member name="M:Sandbox.SceneParticles.SetControlPoint(System.Int32,Transform)">
      <summary>
            Set transform on given control point.
            </summary>
      <param name="i">The control point index. Range is 0-63.</param>
      <param name="transform">The transform to set.</param>
    </member>
    <member name="M:Sandbox.SceneParticles.SetControlPoint(System.Int32,Sandbox.ParticleSnapshot)">
      <summary>
            Set snapshot on given control point.
            </summary>
      <param name="i">The control point index. Range is 0-63.</param>
      <param name="snapshot">The snapshot to set.</param>
    </member>
    <member name="M:Sandbox.SceneParticles.SetControlPoint(System.Int32,Sandbox.Model)">
      <summary>
            Set model on given control point.
            </summary>
      <param name="i">The control point index. Range is 0-63.</param>
      <param name="model">The model to set.</param>
    </member>
    <member name="M:Sandbox.SceneParticles.SetNamedValue(System.String,Vector3)">
      <summary>
            Set vector on given named value.
            </summary>
      <param name="name">The name of the key.</param>
      <param name="value">The value to set.</param>
    </member>
    <member name="M:Sandbox.SceneParticles.Simulate(System.Single)">
      <summary>
            Simulate the particles for given amount of time.
            </summary>
      <param name="f">Amount of time has passed since last simulation.</param>
    </member>
    <member name="P:Sandbox.SceneParticles.ActiveParticlesSelf">
      <summary>
            The amount of particles 
            </summary>
    </member>
    <member name="P:Sandbox.SceneParticles.ActiveParticlesTotal">
      <summary>
            The amount of particles including child systems
            </summary>
    </member>
    <member name="P:Sandbox.SceneParticles.MaximumParticles">
      <summary>
            The total allowed particle count
            </summary>
    </member>
    <member name="M:Sandbox.SceneParticles.Emit(System.Int32)">
      <summary>
            Manually emit a bunch of particles
            </summary>
    </member>
    <member name="P:Sandbox.SceneParticles.Finished">
      <summary>
            True if particle system has reached the end
            </summary>
    </member>
    <member name="P:Sandbox.SceneParticles.SimulationTime">
      <summary>
            Get or set the simulation time
            </summary>
    </member>
    <member name="T:Sandbox.SceneSkyBox">
      <summary>
            Renders a skybox within a <see cref="T:Sandbox.SceneWorld" />.
            </summary>
    </member>
    <member name="P:Sandbox.SceneSkyBox.SkyMaterial">
      <summary>
            The skybox material. Typically it should use the "Sky" shader.
            </summary>
    </member>
    <member name="P:Sandbox.SceneSkyBox.SkyTint">
      <summary>
            Skybox color tint.
            </summary>
    </member>
    <member name="P:Sandbox.SceneSkyBox.FogParams">
      <summary>
            Controls the skybox specific fog.
            </summary>
    </member>
    <member name="M:Sandbox.SceneSkybox3D.Delete">
      <summary>
            Delete this fog volume. You shouldn't access it anymore.
            </summary>
    </member>
    <member name="T:Sandbox.SceneSpotLight">
      <summary>
            A simple spot light scene object for use in a <see cref="T:Sandbox.SceneWorld" />.
            </summary>
    </member>
    <member name="P:Sandbox.SceneSpotLight.ConeInner">
      <summary>
            The inner cone of the spotlight, in half angle degrees.
            </summary>
    </member>
    <member name="P:Sandbox.SceneSpotLight.ConeOuter">
      <summary>
            The outer cone of the spotlight, in half angle degrees
            </summary>
    </member>
    <member name="T:Sandbox.SceneTrailObject">
      <summary>
            I don't want to expose SceneObjects to people anymore. They should be using the scene system.
            It's better if we can keep things internal so we don't have the burden of supporting api layout.
            </summary>
    </member>
    <member name="P:Sandbox.SceneTrailObject.MaxPoints">
      <summary>
            Total maximum points we're allowing
            </summary>
    </member>
    <member name="P:Sandbox.SceneTrailObject.PointDistance">
      <summary>
            Wait until we're this far away before adding a new point
            </summary>
    </member>
    <member name="P:Sandbox.SceneTrailObject.Texturing">
      <summary>
            Texture details, in a nice stuct to hide the bs
            </summary>
    </member>
    <member name="P:Sandbox.SceneTrailObject.LifeTime">
      <summary>
            How long the trail lasts - or 0 for infinite
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrailObject.TryAddPosition(Vector3)">
      <summary>
            Try to add a position to this trail. Returns true on success.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrailObject.TryAddPosition(Vector3,Vector3)">
      <summary>
            Try to add a position to this trail. Returns true on success.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrailObject.AdvanceTime(System.Single)">
      <summary>
            Advance the time for this trail. Will fade out points and scoll the texture.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrailObject.Build">
      <summary>
            Build the vertices for this object.
            TODO: We can move this to build automatically in a thread
            </summary>
    </member>
    <member name="T:Sandbox.TrailTextureConfig">
      <summary>
            Defines how a trail is going to be textured. Used by TrailRenderer.
            </summary>
    </member>
    <member name="T:Sandbox.SceneWorld">
      <summary>
             A scene world that contains <see cref="T:Sandbox.SceneObject" />s. See <a href="https://sbox.game/api/Tools.Utility.CreateSceneWorld()">Utility.CreateSceneWorld</a>.
            
             <para>You may also want a <see cref="T:Sandbox.SceneCamera" /> to manually render the scene world.</para></summary>
    </member>
    <member name="P:Sandbox.SceneWorld.SceneObjects">
      <summary>
            List of scene objects belonging to this scene world.
            </summary>
    </member>
    <member name="F:Sandbox.SceneWorld.GradientFog">
      <summary>
            Controls gradient fog settings.
            </summary>
    </member>
    <member name="F:Sandbox.SceneWorld.AmbientLightColor">
      <summary>
            Sets the ambient lighting color
            </summary>
    </member>
    <member name="F:Sandbox.SceneWorld.ClearColor">
      <summary>
            Sets the clear color, if nothing else is drawn, this is the color you will see
            </summary>
    </member>
    <member name="P:Sandbox.SceneWorld.IsTransient">
      <summary>
            If a world is transient, it means it was created by game code, and should
            be deleted at the end of the game session. If they're non transient then
            they were created in the menu, or by the engine code and will be released
            properly by that code.
            </summary>
    </member>
    <member name="M:Sandbox.SceneWorld.Delete">
      <summary>
            Delete this scene world. You shouldn't access it anymore.
            </summary>
    </member>
    <member name="M:Sandbox.SceneWorld.SetWorldAttributes(Sandbox.RenderAttributes)">
      <summary>
            Any components we add to the sceneworld will want to install attributes
            into the RenderAttributes for the pipeline to find. This should be called
            right before rendering to allow that to happen.
            </summary>
    </member>
    <member name="M:Sandbox.SceneWorld.DeletePendingObjects">
      <summary>
            Deleted objects are actually deleted at the end of each frame. Call this
            to actually delete pending deletes right now instead of waiting. 
            </summary>
    </member>
    <member name="M:Sandbox.SceneWorld.UpdateObjectsForRendering(Vector3,System.Single)">
      <summary>
            This finishes any loads and actually spawns the world sceneobjects
            </summary>
    </member>
    <member name="M:Sandbox.SceneWorld.AddSceneMap(Sandbox.SceneMap)">
      <summary>
            Add a scenemap to this world
            </summary>
    </member>
    <member name="P:Sandbox.SceneWorld.Trace">
      <summary>
            Trace against all scene objects in this scene world
            </summary>
    </member>
    <member name="F:Sandbox.StereoTargetEye.None">
      <summary>
            Don't render in stereo
            </summary>
    </member>
    <member name="F:Sandbox.StereoTargetEye.LeftEye">
      <summary>
            Only render the left eye
            </summary>
    </member>
    <member name="F:Sandbox.StereoTargetEye.RightEye">
      <summary>
            Only render the right eye
            </summary>
    </member>
    <member name="F:Sandbox.StereoTargetEye.Both">
      <summary>
            Render both eyes in stereo
            </summary>
    </member>
    <member name="P:Sandbox.EditorContext.Target">
      <summary>
            The current entity we're rendering gizmos for
            </summary>
    </member>
    <member name="P:Sandbox.EditorContext.IsSelected">
      <summary>
            If the current entity we're drawing selected
            </summary>
    </member>
    <member name="P:Sandbox.EditorContext.Selection">
      <summary>
            All selected entities
            </summary>
    </member>
    <member name="M:Sandbox.EditorContext.FindTarget(System.String)">
      <summary>
            Given a string name return the first found target
            </summary>
    </member>
    <member name="M:Sandbox.EditorContext.FindTargets(System.String)">
      <summary>
            Given a string name return all found targets
            </summary>
    </member>
    <member name="P:Sandbox.Standalone.Manifest">
      <summary>
            If running in standalone, contains the properties of the standalone game
            </summary>
    </member>
    <member name="P:Sandbox.Standalone.BuildDate">
      <summary>
            The date and time at which the current standalone game was built
            </summary>
    </member>
    <member name="P:Sandbox.Standalone.IsDevelopmentBuild">
      <summary>
            Is the current standalone game running in development mode?
            </summary>
    </member>
    <member name="P:Sandbox.Standalone.VersionDate">
      <summary>
            The date and time at which the current standalone game was built
            </summary>
    </member>
    <member name="P:Sandbox.Standalone.Version">
      <summary>
            Represents the current standalone game's version, specified by the developer
            </summary>
    </member>
    <member name="P:Sandbox.StandaloneManifest.Name">
      <summary>
            What is the game's name?
            </summary>
    </member>
    <member name="P:Sandbox.StandaloneManifest.Ident">
      <summary>
            What ident are we running under?
            </summary>
    </member>
    <member name="P:Sandbox.StandaloneManifest.ExecutableName">
      <summary>
            Game's executable name (e.g. game.exe)
            </summary>
    </member>
    <member name="P:Sandbox.StandaloneManifest.AppId">
      <summary>
            The Steam App ID of the game
            </summary>
    </member>
    <member name="P:Sandbox.StandaloneManifest.BuildDate">
      <summary>
            Game's build date, automatically set when the game was exported.
            </summary>
    </member>
    <member name="P:Sandbox.StandaloneManifest.IsVRProject">
      <summary>
            Should we automatically launch this project in VR?
            </summary>
    </member>
    <member name="P:Sandbox.Streamer.Username">
      <summary>
            Your own username
            </summary>
    </member>
    <member name="P:Sandbox.Streamer.UserId">
      <summary>
            Your own user id
            </summary>
    </member>
    <member name="P:Sandbox.Streamer.Service">
      <summary>
            The service type (ie "Twitch")
            </summary>
    </member>
    <member name="P:Sandbox.Streamer.IsActive">
      <summary>
            Are we connected to a service
            </summary>
    </member>
    <member name="M:Sandbox.Streamer.GetUser(System.String)">
      <summary>
            Get user information. If no username is specified, the user returned is ourself
            </summary>
    </member>
    <member name="M:Sandbox.Streamer.GetUserFollowing(System.String)">
      <summary>
            Get user following "Who is X following"
            </summary>
    </member>
    <member name="M:Sandbox.Streamer.GetUserFollowers(System.String)">
      <summary>
            Get user followers "Who is following X"
            </summary>
    </member>
    <member name="M:Sandbox.Streamer.CreatePoll(System.String,System.String,System.Int32,System.String[])">
      <summary>
            Start a poll with choices, save the poll id so you can end it later on
            </summary>
    </member>
    <member name="M:Sandbox.Streamer.EndPoll(System.String,System.String,System.Boolean)">
      <summary>
            End a poll using a saved poll id, you can optionally archive the poll or just terminate it
            </summary>
    </member>
    <member name="M:Sandbox.Streamer.CreatePrediction(System.String,System.String,System.Int32,System.String,System.String)">
      <summary>
            Create a prediction to bet with channel points
            </summary>
    </member>
    <member name="M:Sandbox.Streamer.LockPrediction(System.String,System.String)">
      <summary>
            Lock a current prediction with prediction id
            </summary>
    </member>
    <member name="M:Sandbox.Streamer.CancelPrediction(System.String,System.String)">
      <summary>
            Cancel a current prediction with prediction id
            </summary>
    </member>
    <member name="M:Sandbox.Streamer.ResolvePrediction(System.String,System.String,System.String)">
      <summary>
            Resolve a current prediction with prediction id and choose winning outcome to pay out channel points
            </summary>
    </member>
    <member name="M:Sandbox.Streamer.SendMessage(System.String)">
      <summary>
            Send a message to chat, optionally specify channel you want to send the message, otherwise it is sent to your own chat
            </summary>
    </member>
    <member name="M:Sandbox.Streamer.ClearChat">
      <summary>
            Clear your own chat
            </summary>
    </member>
    <member name="M:Sandbox.Streamer.BanUser(System.String,System.String,System.Int32)">
      <summary>
            Ban user from your chat by username, the user will no longer be able to chat.
            Optionally specify the duration, a duration of zero means perm ban
            (Note: You have to be in your chat for this to work)
            </summary>
    </member>
    <member name="M:Sandbox.Streamer.UnbanUser(System.String)">
      <summary>
            Unban user from your chat by username
            (Note: You have to be in your chat for this to work)
            </summary>
    </member>
    <member name="P:Sandbox.Streamer.Game">
      <summary>
            Set the game you're playing by game id
            </summary>
    </member>
    <member name="P:Sandbox.Streamer.Language">
      <summary>
            Set the language of your stream
            </summary>
    </member>
    <member name="P:Sandbox.Streamer.Title">
      <summary>
            Set the title of your stream
            </summary>
    </member>
    <member name="P:Sandbox.Streamer.Delay">
      <summary>
            Set the delay of your stream
            </summary>
    </member>
    <member name="P:Sandbox.Streamer.ViewerCount">
      <summary>
            Amount of concurrent viewer your stream has.
            </summary>
    </member>
    <member name="M:Sandbox.StreamPoll.End(System.Boolean)">
      <summary>
            End this poll, you can optionally archive the poll, otherwise just terminate it
            </summary>
    </member>
    <member name="M:Sandbox.StreamPrediction.Lock">
      <summary>
            Lock this prediction
            </summary>
    </member>
    <member name="M:Sandbox.StreamPrediction.Cancel">
      <summary>
            Cancel this prediction
            </summary>
    </member>
    <member name="M:Sandbox.StreamPrediction.Resolve">
      <summary>
            Resolve this prediction and choose winning outcome to pay out channel points
            </summary>
    </member>
    <member name="T:Sandbox.StreamService">
      <summary>
            Streamer integration services
            </summary>
    </member>
    <member name="P:Sandbox.StreamUser.Following">
      <summary>
            Get following "Who is following us"
            </summary>
    </member>
    <member name="P:Sandbox.StreamUser.Followers">
      <summary>
            Get followers "Who are we following"
            </summary>
    </member>
    <member name="M:Sandbox.StreamUser.Ban(System.String,System.Int32)">
      <summary>
            Ban user from your chat, the user will no longer be able to chat.
            Optionally specify the duration, a duration of zero means perm ban
            (Note: You have to be in your chat for this to work)
            </summary>
    </member>
    <member name="M:Sandbox.StreamUser.Unban">
      <summary>
            Unban user from your chat, this allows them to chat again
            (Note: You have to be in your chat for this to work)
            </summary>
    </member>
    <member name="M:Sandbox.StreamUser.CreateClip(System.Boolean)">
      <summary>
            Create a clip of our stream, if we're streaming
            </summary>
    </member>
    <member name="M:Sandbox.StreamUser.CreatePoll(System.String,System.Int32,System.String[])">
      <summary>
            Start a poll on our channel with multiple choices, save the poll so you can end it later on
            </summary>
    </member>
    <member name="M:Sandbox.StreamUser.CreatePrediction(System.String,System.Int32,System.String,System.String)">
      <summary>
            Create a prediction on our channel to bet with channel points
            </summary>
    </member>
    <member name="P:Sandbox.Twitch.IRCMessage.Channel">
      <summary>
            The channel the message was sent in
            </summary>
    </member>
    <member name="P:Sandbox.Twitch.IRCMessage.Message">
      <summary>
            Message itself
            </summary>
    </member>
    <member name="F:Sandbox.Twitch.IRCMessage._parameters">
      <summary>
            Command parameters
            </summary>
    </member>
    <member name="F:Sandbox.Twitch.IRCMessage.User">
      <summary>
            The user whose message it is
            </summary>
    </member>
    <member name="F:Sandbox.Twitch.IRCMessage.Hostmask">
      <summary>
            Hostmask of the user
            </summary>
    </member>
    <member name="F:Sandbox.Twitch.IRCMessage.Command">
      <summary>
            Raw Command
            </summary>
    </member>
    <member name="F:Sandbox.Twitch.IRCMessage.Tags">
      <summary>
            IRCv3 tags
            </summary>
    </member>
    <member name="M:Sandbox.Twitch.IRCMessage.#ctor(System.String)">
      <summary>
            Create an INCOMPLETE IrcMessage only carrying username
            </summary>
      <param name="user" />
    </member>
    <member name="M:Sandbox.Twitch.IRCMessage.#ctor(Sandbox.Twitch.IRCCommand,System.String[],System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Create an IrcMessage
            </summary>
      <param name="command">IRC Command</param>
      <param name="parameters">Command params</param>
      <param name="hostmask">User</param>
      <param name="tags">IRCv3 tags</param>
    </member>
    <member name="M:Sandbox.Twitch.IRCParser.Parse(System.String)">
      <summary>
            Parses a raw IRC message into a IRCMessage.
            </summary>
    </member>
    <member name="P:Sandbox.Tasks.ExpirableSynchronizationContext.HasExpired">
      <summary>
            When true, any continuations that attempt to run on this instance will
            log an exception, unless whitelisted by <see cref="M:Sandbox.Tasks.ExpirableSynchronizationContext.AllowPersistentTaskMethods(System.Reflection.Assembly)" />.
            </summary>
    </member>
    <member name="M:Sandbox.Tasks.ExpirableSynchronizationContext.#ctor(System.Boolean)">
      <param name="warnNonYieldingTasks">If true, warn when tasks don't yield after <see cref="F:Sandbox.Tasks.ExpirableSynchronizationContext.MaxTimeBetweenYieldsMillis" />.</param>
    </member>
    <member name="M:Sandbox.Tasks.ExpirableSynchronizationContext.WatchDogAsync">
      <summary>
            Logs a warning if any actions posted to this sync context take
            too long before returning.
            </summary>
    </member>
    <member name="M:Sandbox.Tasks.ExpirableSynchronizationContext.CheckValid(System.Object,System.Boolean@)">
      <summary>
            Returns true if <see cref="P:Sandbox.Tasks.ExpirableSynchronizationContext.HasExpired" /> is false, or if <paramref name="state" /> represents
            a task method that is allowed to persist after context expiry. Logs an error otherwise.
            </summary>
    </member>
    <member name="P:Sandbox.Tasks.SyncContext.MainThread">
      <summary>
            Current sync context for the main thread. This will be null until <see cref="M:Sandbox.Tasks.SyncContext.Init" /> has been
            called for the first time.
            </summary>
    </member>
    <member name="P:Sandbox.Tasks.SyncContext.WorkerThread">
      <summary>
            Current sync context for worker threads. This will be null until <see cref="M:Sandbox.Tasks.SyncContext.Init" /> has been
            called for the first time.
            </summary>
    </member>
    <member name="M:Sandbox.Tasks.SyncContext.Init">
      <summary>
            Sets both <see cref="P:Sandbox.Tasks.SyncContext.MainThread" /> and <see cref="P:System.Threading.SynchronizationContext.Current" /> to be a new
            instance of <see cref="T:Sandbox.Tasks.ExpirableSynchronizationContext" />. Only has an effect the first time it's called.
            </summary>
    </member>
    <member name="M:Sandbox.Tasks.SyncContext.Reset">
      <summary>
            Invalidates <see cref="P:Sandbox.Tasks.SyncContext.MainThread" /> and <see cref="P:Sandbox.Tasks.SyncContext.WorkerThread" />, and replaces
            them with a new instance.
            Any tasks that try to continue on the old instances will log an error, unless they
            are whitelisted with <see cref="M:Sandbox.Tasks.ExpirableSynchronizationContext.AllowPersistentTaskMethods(System.Reflection.Assembly)" />.
            </summary>
    </member>
    <member name="M:Sandbox.Tasks.SyncContext.RunBlocking(System.Threading.Tasks.Task)">
      <summary>
            Run an async task in a synchronous blocking manner.
            </summary>
    </member>
    <member name="M:Sandbox.Tasks.SyncContext.RunBlocking``1(System.Threading.Tasks.Task{``0})">
      <summary>
            Run an async task in a synchronous blocking manner and returns the result.
            </summary>
    </member>
    <member name="M:Sandbox.Tasks.WorkerThread.Start">
      <summary>
            Starts a bunch of long-running tasks in the worker thread pool that
            keep calling <see cref="M:Sandbox.Tasks.ExpirableSynchronizationContext.ProcessQueue" /> on
            <see cref="P:Sandbox.Tasks.SyncContext.WorkerThread" />.
            </summary>
      <exception cref="T:System.InvalidOperationException">Thrown if tasks are already running.</exception>
    </member>
    <member name="M:Sandbox.Tasks.WorkerThread.Stop(System.Int32)">
      <summary>
            Forces the tasks created by <see cref="M:Sandbox.Tasks.WorkerThread.Start" /> to cancel, to be restarted later.
            This doesn't cancel tasks created with Sandbox.TaskSource.RunInThreadAsync, they
            just get suspended until <see cref="M:Sandbox.Tasks.WorkerThread.Start" /> is called again.
            </summary>
      <param name="millisecondsTimeout">
            Log an error if any tasks take longer than this to return.
            </param>
    </member>
    <member name="T:Sandbox.MainThread">
      <summary>
            Utility functions that revolve around the main thread
            </summary>
    </member>
    <member name="M:Sandbox.MainThread.Wait">
      <summary>
            Wait to execute on the main thread
            </summary>
    </member>
    <member name="M:Sandbox.MainThread.Run``1(System.Int32,System.Func{``0})">
      <summary>
            Run a function on the main thread and wait for the result.
            </summary>
    </member>
    <member name="M:Sandbox.MainThread.Queue(System.Action)">
      <summary>
            When running in another thread you can queue a method to run in the main thread.
            If you are on the main thread we will execute the method immediately and return.
            </summary>
    </member>
    <member name="M:Sandbox.MainThread.RunMainThreadQueues">
      <summary>
            Run queued actions on the main thread
            </summary>
    </member>
    <member name="F:Sandbox.UI.InputData.Mouse0">
      <summary>
            Left Mouse Button
            </summary>
    </member>
    <member name="F:Sandbox.UI.InputData.Mouse1">
      <summary>
            Muddle Mouse Button
            </summary>
    </member>
    <member name="F:Sandbox.UI.InputData.Mouse2">
      <summary>
            Right Mouse Button
            </summary>
    </member>
    <member name="F:Sandbox.UI.InputData.Mouse3">
      <summary>
            Back Button
            </summary>
    </member>
    <member name="F:Sandbox.UI.InputData.Mouse4">
      <summary>
            Forward Button
            </summary>
    </member>
    <member name="F:Sandbox.UI.PanelInputType.UI">
      <summary>
            Regular expected behaviour.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PanelInputType.Game">
      <summary>
            Redirect to the game's Input system
            </summary>
    </member>
    <member name="T:Sandbox.UI.TransitionDesc">
      <summary>
            Describes transition of a single CSS property, a.k.a. the values of a <c>transition</c> CSS property.
            <para>Utility to create a transition by comparing the
            panel style before and after the scope.</para></summary>
    </member>
    <member name="F:Sandbox.UI.TransitionDesc.Property">
      <summary>
            The CSS property to transition.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TransitionDesc.Duration">
      <summary>
            Duration of the transition between old value and new value.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TransitionDesc.Delay">
      <summary>
            If set, delay before starting the transition after the property was changed.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TransitionDesc.TimingFunction">
      <summary>
            The timing or "easing" function. <c>transition-timing-function</c> CSS property.
            Example values would be <c>ease</c>,  <c>ease-in</c>,  <c>ease-out</c> and  <c>ease-in-out</c>.
            </summary>
    </member>
    <member name="T:Sandbox.UI.TransitionList">
      <summary>
             A list of CSS properties that should transition when changed.
            
             Utility to create a transition by comparing the
             panel style before and after the scope.
             </summary>
    </member>
    <member name="F:Sandbox.UI.TransitionList.List">
      <summary>
            The actual list of CSS properties that should be transitioned.
            </summary>
    </member>
    <member name="M:Sandbox.UI.TransitionList.Clear">
      <summary>
            Clear the list of CSS transitions.
            </summary>
    </member>
    <member name="T:Sandbox.UI.BaseStyles">
      <summary>
            Auto generated container class for majority of CSS properties available.
            </summary>
    </member>
    <member name="M:Sandbox.UI.BaseStyles.Dirty">
      <summary>
            Called when any CSS properties are changed.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.Overflow">
      <summary>
            Represents the <c>overflow</c> CSS property.
            </summary>
    </member>
    <member name="M:Sandbox.UI.BaseStyles.Add(Sandbox.UI.BaseStyles)">
      <summary>
            Copy over only the styles that are set.
            </summary>
    </member>
    <member name="M:Sandbox.UI.BaseStyles.From(Sandbox.UI.BaseStyles)">
      <summary>
            Copy all styles from given style set.
            </summary>
    </member>
    <member name="M:Sandbox.UI.BaseStyles.Set(System.String,System.String)">
      <summary>
            Copy all styles from given style set.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.Content">
      <summary>
            Represents the <c>content</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.Width">
      <summary>
            Represents the <c>width</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.MinWidth">
      <summary>
            Represents the <c>min-width</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.MaxWidth">
      <summary>
            Represents the <c>max-width</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.Height">
      <summary>
            Represents the <c>height</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.MinHeight">
      <summary>
            Represents the <c>min-height</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.MaxHeight">
      <summary>
            Represents the <c>max-height</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.Left">
      <summary>
            Represents the <c>left</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.Top">
      <summary>
            Represents the <c>top</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.Right">
      <summary>
            Represents the <c>right</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.Bottom">
      <summary>
            Represents the <c>bottom</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.Opacity">
      <summary>
            Represents the <c>opacity</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BackgroundColor">
      <summary>
            Represents the <c>background-color</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.PaddingLeft">
      <summary>
            Represents the <c>padding-left</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.PaddingTop">
      <summary>
            Represents the <c>padding-top</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.PaddingRight">
      <summary>
            Represents the <c>padding-right</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.PaddingBottom">
      <summary>
            Represents the <c>padding-bottom</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.MarginLeft">
      <summary>
            Represents the <c>margin-left</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.MarginTop">
      <summary>
            Represents the <c>margin-top</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.MarginRight">
      <summary>
            Represents the <c>margin-right</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.MarginBottom">
      <summary>
            Represents the <c>margin-bottom</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderTopLeftRadius">
      <summary>
            Represents the <c>border-top-left-radius</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderTopRightRadius">
      <summary>
            Represents the <c>border-top-right-radius</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderBottomRightRadius">
      <summary>
            Represents the <c>border-bottom-right-radius</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderBottomLeftRadius">
      <summary>
            Represents the <c>border-bottom-left-radius</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderLeftWidth">
      <summary>
            Represents the <c>border-left-width</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderTopWidth">
      <summary>
            Represents the <c>border-top-width</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderRightWidth">
      <summary>
            Represents the <c>border-right-width</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderBottomWidth">
      <summary>
            Represents the <c>border-bottom-width</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderLeftColor">
      <summary>
            Represents the <c>border-left-color</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderTopColor">
      <summary>
            Represents the <c>border-top-color</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderRightColor">
      <summary>
            Represents the <c>border-right-color</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderBottomColor">
      <summary>
            Represents the <c>border-bottom-color</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FontSize">
      <summary>
            Represents the <c>font-size</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FontColor">
      <summary>
            Represents the <c>font-color</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FontWeight">
      <summary>
            Represents the <c>font-weight</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FontFamily">
      <summary>
            Represents the <c>font-family</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.CaretColor">
      <summary>
            Represents the <c>caret-color</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.Cursor">
      <summary>
            Represents the <c>cursor</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.PointerEvents">
      <summary>
            Represents the <c>pointer-events</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.MixBlendMode">
      <summary>
            Represents the <c>mix-blend-mode</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.Position">
      <summary>
            Represents the <c>position</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.OverflowX">
      <summary>
            Represents the <c>overflow-x</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.OverflowY">
      <summary>
            Represents the <c>overflow-y</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FlexDirection">
      <summary>
            Represents the <c>flex-direction</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.JustifyContent">
      <summary>
            Represents the <c>justify-content</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.Display">
      <summary>
            Represents the <c>display</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FlexWrap">
      <summary>
            Represents the <c>flex-wrap</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.AlignContent">
      <summary>
            Represents the <c>align-content</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.AlignSelf">
      <summary>
            Represents the <c>align-self</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.AlignItems">
      <summary>
            Represents the <c>align-items</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FlexBasis">
      <summary>
            Represents the <c>flex-basis</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FlexGrow">
      <summary>
            Represents the <c>flex-grow</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FlexShrink">
      <summary>
            Represents the <c>flex-shrink</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.RowGap">
      <summary>
            Represents the <c>row-gap</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.ColumnGap">
      <summary>
            Represents the <c>column-gap</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.AspectRatio">
      <summary>
            Represents the <c>aspect-ratio</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.TextAlign">
      <summary>
            Represents the <c>text-align</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.TextOverflow">
      <summary>
            Represents the <c>text-overflow</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.WordBreak">
      <summary>
            Represents the <c>word-break</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.TextDecorationLine">
      <summary>
            Represents the <c>text-decoration-line</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.TextDecorationColor">
      <summary>
            Represents the <c>text-decoration-color</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.TextDecorationThickness">
      <summary>
            Represents the <c>text-decoration-thickness</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.TextDecorationSkipInk">
      <summary>
            Represents the <c>text-decoration-skip-ink</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.TextDecorationStyle">
      <summary>
            Represents the <c>text-decoration-style</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.TextUnderlineOffset">
      <summary>
            Represents the <c>text-underline-offset</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.TextOverlineOffset">
      <summary>
            Represents the <c>text-overline-offset</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.TextLineThroughOffset">
      <summary>
            Represents the <c>text-line-through-offset</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FontStyle">
      <summary>
            Represents the <c>font-style</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.Transform">
      <summary>
            Represents the <c>transform</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.TextTransform">
      <summary>
            Represents the <c>text-transform</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.TransformOriginX">
      <summary>
            Represents the <c>transform-origin-x</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.TransformOriginY">
      <summary>
            Represents the <c>transform-origin-y</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.LetterSpacing">
      <summary>
            Represents the <c>letter-spacing</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.LineHeight">
      <summary>
            Represents the <c>line-height</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.WordSpacing">
      <summary>
            Represents the <c>word-spacing</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.WhiteSpace">
      <summary>
            Represents the <c>white-space</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.ZIndex">
      <summary>
            Represents the <c>z-index</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.Order">
      <summary>
            Represents the <c>order</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.SoundIn">
      <summary>
            Represents the <c>sound-in</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.SoundOut">
      <summary>
            Represents the <c>sound-out</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BackdropFilterBlur">
      <summary>
            Represents the <c>backdrop-filter-blur</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BackdropFilterBrightness">
      <summary>
            Represents the <c>backdrop-filter-brightness</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BackdropFilterContrast">
      <summary>
            Represents the <c>backdrop-filter-contrast</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BackdropFilterSaturate">
      <summary>
            Represents the <c>backdrop-filter-saturate</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BackdropFilterSepia">
      <summary>
            Represents the <c>backdrop-filter-sepia</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BackdropFilterInvert">
      <summary>
            Represents the <c>backdrop-filter-invert</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BackdropFilterHueRotate">
      <summary>
            Represents the <c>backdrop-filter-hue-rotate</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FilterBlur">
      <summary>
            Represents the <c>filter-blur</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FilterSaturate">
      <summary>
            Represents the <c>filter-saturate</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FilterSepia">
      <summary>
            Represents the <c>filter-sepia</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FilterBrightness">
      <summary>
            Represents the <c>filter-brightness</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FilterHueRotate">
      <summary>
            Represents the <c>filter-hue-rotate</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FilterInvert">
      <summary>
            Represents the <c>filter-invert</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FilterContrast">
      <summary>
            Represents the <c>filter-contrast</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FilterTint">
      <summary>
            Represents the <c>filter-tint</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FilterBorderWidth">
      <summary>
            Represents the <c>filter-border-width</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FilterBorderColor">
      <summary>
            Represents the <c>filter-border-color</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.MaskMode">
      <summary>
            Represents the <c>mask-mode</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.MaskRepeat">
      <summary>
            Represents the <c>mask-repeat</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.MaskSizeX">
      <summary>
            Represents the <c>mask-size-x</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.MaskSizeY">
      <summary>
            Represents the <c>mask-size-y</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.MaskPositionX">
      <summary>
            Represents the <c>mask-position-x</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.MaskPositionY">
      <summary>
            Represents the <c>mask-position-y</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.MaskAngle">
      <summary>
            Represents the <c>mask-angle</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.MaskScope">
      <summary>
            Represents the <c>mask-scope</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BackgroundSizeX">
      <summary>
            Represents the <c>background-size-x</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BackgroundSizeY">
      <summary>
            Represents the <c>background-size-y</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BackgroundPositionX">
      <summary>
            Represents the <c>background-position-x</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BackgroundPositionY">
      <summary>
            Represents the <c>background-position-y</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BackgroundRepeat">
      <summary>
            Represents the <c>background-repeat</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderImageWidthLeft">
      <summary>
            Represents the <c>border-image-width-left</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderImageWidthRight">
      <summary>
            Represents the <c>border-image-width-right</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderImageWidthTop">
      <summary>
            Represents the <c>border-image-width-top</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderImageWidthBottom">
      <summary>
            Represents the <c>border-image-width-bottom</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderImageFill">
      <summary>
            Represents the <c>border-image-fill</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderImageRepeat">
      <summary>
            Represents the <c>border-image-repeat</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BorderImageTint">
      <summary>
            Represents the <c>border-image-tint</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BackgroundBlendMode">
      <summary>
            Represents the <c>background-blend-mode</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BackgroundTint">
      <summary>
            Represents the <c>background-tint</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.BackgroundAngle">
      <summary>
            Represents the <c>background-angle</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.TextBackgroundAngle">
      <summary>
            Represents the <c>text-background-angle</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.PerspectiveOriginX">
      <summary>
            Represents the <c>perspective-origin-x</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.PerspectiveOriginY">
      <summary>
            Represents the <c>perspective-origin-y</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.TextStrokeColor">
      <summary>
            Represents the <c>text-stroke-color</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.TextStrokeWidth">
      <summary>
            Represents the <c>text-stroke-width</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.ImageRendering">
      <summary>
            Represents the <c>image-rendering</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.AnimationDelay">
      <summary>
            Represents the <c>animation-delay</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.AnimationDirection">
      <summary>
            Represents the <c>animation-direction</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.AnimationDuration">
      <summary>
            Represents the <c>animation-duration</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.AnimationFillMode">
      <summary>
            Represents the <c>animation-fill-mode</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.AnimationIterationCount">
      <summary>
            Represents the <c>animation-iteration-count</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.AnimationName">
      <summary>
            Represents the <c>animation-name</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.AnimationPlayState">
      <summary>
            Represents the <c>animation-play-state</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.AnimationTimingFunction">
      <summary>
            Represents the <c>animation-timing-function</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.FontSmooth">
      <summary>
            Represents the <c>font-smooth</c> CSS property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.ObjectFit">
      <summary>
            Represents the <c>object-fit</c> CSS property.
            </summary>
    </member>
    <member name="M:Sandbox.UI.BaseStyles.AddGenerated(Sandbox.UI.BaseStyles)">
      <summary>
            Copy over only the styles that are set.
            </summary>
    </member>
    <member name="M:Sandbox.UI.BaseStyles.FromGenerated(Sandbox.UI.BaseStyles)">
      <summary>
            Copy all styles from given style set.
            </summary>
    </member>
    <member name="M:Sandbox.UI.BaseStyles.SetGenerated(System.String,System.String)">
      <summary>
            Set a CSS property via its string name.
            </summary>
    </member>
    <member name="M:Sandbox.UI.BaseStyles.FromLerp(Sandbox.UI.BaseStyles,Sandbox.UI.BaseStyles,System.Single)">
      <summary>
            Lerp every property in this stylesheet
            </summary>
    </member>
    <member name="M:Sandbox.UI.BaseStyles.LerpProperty(System.String,Sandbox.UI.BaseStyles,Sandbox.UI.BaseStyles,System.Single)">
      <summary>
            Lerp a specific property by name
            </summary>
    </member>
    <member name="M:Sandbox.UI.BaseStyles.Clone">
      <summary>
            Perform a deep copy of this stylesheet
            </summary>
    </member>
    <member name="P:Sandbox.UI.BaseStyles.HasAnimation">
      <summary>
            Whether there is an active CSS animation.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Clipboard.SetText(System.String)">
      <summary>
            Sets the clipboard text
            </summary>
    </member>
    <member name="T:Sandbox.UI.Emoji">
      <summary>
            Helper class for working with Unicode emoji.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Emoji.FindEmoji(System.String)">
      <summary>
            Find a Unicode emoji from a <c>:emoji_name:</c> format.
            </summary>
      <param name="lookup">Input emoji text in <c>:emoji_name:</c> format.</param>
      <returns>The emoji or <see langword="null" />.</returns>
    </member>
    <member name="T:Sandbox.UI.ImageRect">
      <summary>
            We share a lot of code between mask-image and background-image - so this handles all image rect calculations.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxEngineExtensions.AsFloatSpan(System.Span{System.Single})">
      <summary>
            Convert to a FloatSpan, which allows easy SIMD/AVX2 instructions
            </summary>
    </member>
    <member name="F:Sandbox.FixedUpdate.Frequency">
      <summary>
            How many times a second FixedUpdate runs
            </summary>
    </member>
    <member name="F:Sandbox.FixedUpdate.step">
      <summary>
            Accumulate frame time up until a maximum amount (maxSteps). While this value
            is above the <see cref="P:Sandbox.FixedUpdate.Delta" /> time we will invoke a fixed update.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Parallel">
      <summary>
            Wrappers of the parallel class.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Steam.CategorizeSteamId(Sandbox.SteamId)">
      <summary>
            Return what type os SteamId this is
            </summary>
    </member>
    <member name="P:Sandbox.Utility.Steam.SteamId">
      <summary>
            The current user's SteamId
            </summary>
    </member>
    <member name="P:Sandbox.Utility.Steam.PersonaName">
      <summary>
            The current user's persona name (Steam name)
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Steam.IsFriend(Sandbox.SteamId)">
      <summary>
            Return true if this is a friend
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Steam.IsOnline(Sandbox.SteamId)">
      <summary>
            Return true if this person is online
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Web.DownloadFile(System.String,System.String,System.Threading.CancellationToken,Sandbox.Utility.DataProgress.Callback)">
      <summary>
            Download a file to a target filename (todo - progress)
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Web.GrabFile(System.String,System.Threading.CancellationToken,System.Action{System.Int32})">
      <summary>
            Download a file to a byte array
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Web.DownloadString(System.String,System.Threading.CancellationToken)">
      <summary>
            Download a url to a string
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Web.DownloadJson``1(System.String,System.Threading.CancellationToken)">
      <summary>
            Download a url to a string
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Web.PutAsync(System.IO.Stream,System.String,System.Threading.CancellationToken,Sandbox.Utility.DataProgress.Callback)">
      <summary>
            Download a file to a target filename (todo - progress)
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Svg.PathFillType">
      <summary>
            How to determine which sections of the path are filled.
            </summary>
    </member>
    <member name="F:Sandbox.Utility.Svg.PathFillType.Winding">
      <summary>
            Clockwise paths are filled, counter-clockwise are empty.
            </summary>
    </member>
    <member name="F:Sandbox.Utility.Svg.PathFillType.EvenOdd">
      <summary>
            Regions that are enclosed by an odd number of paths are filled, other regions are empty.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Svg.PathArcSize">
      <summary>
            Controls arc size in <see cref="T:Sandbox.Utility.Svg.ArcToPathCommand" />.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Svg.PathDirection">
      <summary>
            Controls arc direction in <see cref="T:Sandbox.Utility.Svg.ArcToPathCommand" />.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Svg.PathCommand">
      <summary>
            Base class for SVG path commands.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Svg.AddCirclePathCommand">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle" />.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Svg.AddCirclePathCommand.#ctor(System.Single,System.Single,System.Single)">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle" />.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Svg.AddOvalPathCommand">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/ellipse" />.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Svg.AddOvalPathCommand.#ctor(Sandbox.Rect)">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/ellipse" />.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Svg.AddPolyPathCommand">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polyline" />, <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polygon" />.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Svg.AddPolyPathCommand.#ctor(System.Collections.Generic.IReadOnlyList{Vector2},System.Boolean)">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polyline" />, <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polygon" />.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Svg.AddRectPathCommand">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect" />.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Svg.AddRectPathCommand.#ctor(Sandbox.Rect)">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect" />.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Svg.AddRoundRectPathCommand">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect" />.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Svg.AddRoundRectPathCommand.#ctor(Sandbox.Rect,System.Single,System.Single)">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect" />.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Svg.ArcToPathCommand">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#arcs" />.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Svg.ArcToPathCommand.#ctor(System.Single,System.Single,System.Single,Sandbox.Utility.Svg.PathArcSize,Sandbox.Utility.Svg.PathDirection,System.Single,System.Single)">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#arcs" />.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Svg.ClosePathCommand">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#line_commands" />.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Svg.CubicToPathCommand">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#b%C3%A9zier_curves" />.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Svg.CubicToPathCommand.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#b%C3%A9zier_curves" />.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Svg.LineToPathCommand">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#line_commands" />.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Svg.LineToPathCommand.#ctor(System.Single,System.Single)">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#line_commands" />.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Svg.MoveToPathCommand">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#line_commands" />.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Svg.MoveToPathCommand.#ctor(System.Single,System.Single)">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#line_commands" />.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Svg.QuadToPathCommand">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#b%C3%A9zier_curves" />.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Svg.QuadToPathCommand.#ctor(System.Single,System.Single,System.Single,System.Single)">
      <summary>
            See <see href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#b%C3%A9zier_curves" />.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Svg.SvgPath">
      <summary>
            A shape in a <see cref="T:Sandbox.Utility.Svg.SvgDocument" />, described as a vector path.
            </summary>
    </member>
    <member name="P:Sandbox.Utility.Svg.SvgPath.FillType">
      <summary>
            How to determine which sections of the path are filled.
            </summary>
    </member>
    <member name="P:Sandbox.Utility.Svg.SvgPath.Commands">
      <summary>
            Description of how the path is constructed out of basic elements.
            </summary>
    </member>
    <member name="P:Sandbox.Utility.Svg.SvgPath.IsEmpty">
      <summary>
            If true, this path has no commands.
            </summary>
    </member>
    <member name="P:Sandbox.Utility.Svg.SvgPath.Bounds">
      <summary>
            Enclosing bounding box for this path.
            </summary>
    </member>
    <member name="P:Sandbox.Utility.Svg.SvgPath.StrokeColor">
      <summary>
            Optional outline color for this path.
            </summary>
    </member>
    <member name="P:Sandbox.Utility.Svg.SvgPath.FillColor">
      <summary>
            Optional fill color for this path.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Svg.SvgDocument">
      <summary>
            Helper class for reading Scalable Vector Graphics files.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Svg.SvgDocument.FromString(System.String)">
      <summary>
            Reads an SVG document from the given string, returning a list of path elements
            describing the shapes in the image.
            </summary>
      <param name="contents">SVG document contents.</param>
    </member>
    <member name="P:Sandbox.Utility.Svg.SvgDocument.Paths">
      <summary>
            List of all shapes in the document.
            </summary>
    </member>
    <member name="M:Sandbox.ITagSet.RemoveAll">
      <summary>
            Remove all tags from the set.
            </summary>
    </member>
    <member name="M:Sandbox.ITagSet.Has(System.String)">
      <summary>
            Does this set have the specified tag?
            </summary>
      <param name="tag" />
    </member>
    <member name="M:Sandbox.ITagSet.Add(System.String)">
      <summary>
            Add a tag to the set.
            </summary>
      <param name="tag" />
    </member>
    <member name="M:Sandbox.ITagSet.Remove(System.String)">
      <summary>
            Remove a tag from the set.
            </summary>
      <param name="tag" />
    </member>
    <member name="M:Sandbox.ITagSet.Set(System.String,System.Boolean)">
      <summary>
            Add or remove this tag, based on state
            </summary>
    </member>
    <member name="M:Sandbox.ITagSet.TryGetAll">
      <summary>
            Try to get all tags in the set.
            </summary>
    </member>
    <member name="M:Sandbox.ITagSet.GetTokens">
      <summary>
            Try to get all tags in the set.
            </summary>
    </member>
    <member name="M:Sandbox.ITagSet.SetFrom(Sandbox.ITagSet)">
      <summary>
            Set the tags to match this other tag set
            </summary>
    </member>
    <member name="M:Sandbox.ITagSet.Add(Sandbox.ITagSet)">
      <summary>
            Add the tags from another set, to this set
            </summary>
    </member>
    <member name="M:Sandbox.ITagSet.Toggle(System.String)">
      <summary>
            If this tag is already here, remove it, else add it.
            </summary>
    </member>
    <member name="M:Sandbox.ITagSet.HasAny(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Does this set have any of the specified tag?
            </summary>
    </member>
    <member name="M:Sandbox.ITagSet.HasAny(Sandbox.ITagSet)">
      <inheritdoc cref="M:Sandbox.ITagSet.HasAny(System.Collections.Generic.IEnumerable{System.String})" />
    </member>
    <member name="M:Sandbox.ITagSet.HasAny(System.String[])">
      <inheritdoc cref="M:Sandbox.ITagSet.HasAny(System.Collections.Generic.IEnumerable{System.String})" />
    </member>
    <member name="M:Sandbox.ITagSet.HasAll(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Does this set have all of the specified tags?
            </summary>
    </member>
    <member name="M:Sandbox.ITagSet.HasAll(Sandbox.ITagSet)">
      <inheritdoc cref="M:Sandbox.ITagSet.HasAll(System.Collections.Generic.IEnumerable{System.String})" />
    </member>
    <member name="M:Sandbox.ITagSet.HasAll(System.String[])">
      <inheritdoc cref="M:Sandbox.ITagSet.HasAll(Sandbox.ITagSet)" />
    </member>
    <member name="M:Sandbox.ITagSet.GetEnumerator">
      <inheritdoc />
    </member>
    <member name="M:Sandbox.ITagSet.System#Collections#IEnumerable#GetEnumerator">
      <inheritdoc />
    </member>
    <member name="T:Sandbox.IJsonConvert">
      <summary>
            Allows writing JsonConverter in a more compact way, without having to pre-register them.
            </summary>
    </member>
    <member name="T:Sandbox.Json">
      <summary>
            A convenience JSON helper that handles <see cref="T:Sandbox.Resource" /> types for you.
            </summary>
    </member>
    <member name="M:Sandbox.Json.Initialize(Sandbox.Internal.TypeLibrary)">
      <summary>
            Should be called on startup and when hotloading. 
            The reason for doing on hotloading is to clear all the types in JsonSerializableFactory
            </summary>
    </member>
    <member name="M:Sandbox.Json.Deserialize(System.String,System.Type)">
      <summary>
            Try to deserialize given source to given type.
            </summary>
    </member>
    <member name="M:Sandbox.Json.Deserialize``1(System.String)">
      <summary>
            Try to deserialize given source to given type.
            </summary>
    </member>
    <member name="M:Sandbox.Json.TryDeserialize(System.String,System.Type,System.Object@)">
      <summary>
            Try to deserialize given source to given type. Return true if it was a success
            </summary>
    </member>
    <member name="M:Sandbox.Json.TryDeserialize``1(System.String,``0@)">
      <summary>
            Try to deserialize given source to given type. Return true if it was a success
            </summary>
    </member>
    <member name="M:Sandbox.Json.Serialize(System.Object)">
      <summary>
            Serialize an object.
            </summary>
    </member>
    <member name="M:Sandbox.Json.ParseToJsonObject(System.String)">
      <summary>
            Parse some Json to a JsonObject
            </summary>
    </member>
    <member name="M:Sandbox.Json.ParseToJsonNode(System.String)">
      <summary>
            Parse some Json to a JsonNode
            </summary>
    </member>
    <member name="M:Sandbox.Json.ParseToJsonObject(System.Text.Json.Utf8JsonReader@)">
      <summary>
            Parse some Json to a JsonNode
            </summary>
    </member>
    <member name="M:Sandbox.Json.DeserializeToObject(System.Object,System.String)">
      <summary>
            Deserialize to this existing object
            </summary>
    </member>
    <member name="M:Sandbox.Json.ToNode(System.Object)">
      <summary>
            Serialize a single object to a JsonNode
            </summary>
    </member>
    <member name="M:Sandbox.Json.ToNode(System.Object,System.Type)">
      <summary>
            Serialize a single object to a JsonNode with the given expected type
            </summary>
    </member>
    <member name="M:Sandbox.Json.FromNode(System.Text.Json.Nodes.JsonNode,System.Type)">
      <summary>
            Deserialize a single object to a type
            </summary>
    </member>
    <member name="M:Sandbox.Json.FromNode``1(System.Text.Json.Nodes.JsonNode)">
      <summary>
            Deserialize a single object to a type
            </summary>
    </member>
    <member name="M:Sandbox.Json.SerializeAsObject(System.Object)">
      <summary>
            Serialize this object property by property - even if JsonConvert has other plans
            </summary>
    </member>
    <member name="M:Sandbox.Json.WalkJsonTree(System.Text.Json.Nodes.JsonNode,System.Func{System.String,System.Text.Json.Nodes.JsonValue,System.Text.Json.Nodes.JsonNode},System.Func{System.String,System.Text.Json.Nodes.JsonObject,System.Text.Json.Nodes.JsonObject})">
      <summary>
            Deep walk though an entire Json tree, optionally changing values of nodes.
            </summary>
    </member>
    <member name="T:Sandbox.Json.ObjectIdentifier">
      <summary>
            Uniquely identifies a tracked object by its type and identifier value.
            </summary>
    </member>
    <member name="T:Sandbox.Json.PropertyOverride">
      <summary>
            Represents a property change to apply during patching.
            </summary>
    </member>
    <member name="F:Sandbox.Json.PropertyOverride.Target">
      <summary>The object whose property should be modified</summary>
    </member>
    <member name="F:Sandbox.Json.PropertyOverride.Property">
      <summary>The name of the property to modify</summary>
    </member>
    <member name="F:Sandbox.Json.PropertyOverride.Value">
      <summary>The new value to assign to the property</summary>
    </member>
    <member name="T:Sandbox.Json.AddedObject">
      <summary>
            Represents an object that needs to be added during patching.
            </summary>
    </member>
    <member name="F:Sandbox.Json.AddedObject.Id">
      <summary>The identifier for the new object</summary>
    </member>
    <member name="F:Sandbox.Json.AddedObject.Parent">
      <summary>The parent object that will contain this object</summary>
    </member>
    <member name="F:Sandbox.Json.AddedObject.PreviousElement">
      <summary>The previous sibling when adding to an array (null if first or not in array)</summary>
    </member>
    <member name="F:Sandbox.Json.AddedObject.ContainerProperty">
      <summary>The property name in the parent that will contain this object</summary>
    </member>
    <member name="F:Sandbox.Json.AddedObject.IsContainerArray">
      <summary>Whether this object is being added to an array (true) or as a direct property (false)</summary>
    </member>
    <member name="F:Sandbox.Json.AddedObject.Data">
      <summary>The data for the new object</summary>
    </member>
    <member name="T:Sandbox.Json.RemovedObject">
      <summary>
            Represents an object that should be removed during patching.
            </summary>
    </member>
    <member name="F:Sandbox.Json.RemovedObject.Id">
      <summary>The identifier of the object to remove</summary>
    </member>
    <member name="T:Sandbox.Json.MovedObject">
      <summary>
            Represents an object that should be moved to a new location during patching.
            </summary>
    </member>
    <member name="F:Sandbox.Json.MovedObject.Id">
      <summary>The identifier of the object to move</summary>
    </member>
    <member name="F:Sandbox.Json.MovedObject.NewParent">
      <summary>The new parent object</summary>
    </member>
    <member name="F:Sandbox.Json.MovedObject.NewContainerProperty">
      <summary>The property name in the new parent that will contain this object</summary>
    </member>
    <member name="F:Sandbox.Json.MovedObject.IsNewContainerArray">
      <summary>Whether the object is being moved to an array (true) or as a direct property (false)</summary>
    </member>
    <member name="F:Sandbox.Json.MovedObject.NewPreviousElement">
      <summary>The previous sibling in the new location (null if first or not in array)</summary>
    </member>
    <member name="T:Sandbox.Json.TrackedObjectDefinition">
      <summary>
            Defines characteristics of an object type that should be tracked within a JSON tree structure.
            These definitions are used to identify, track, and manage specific types of objects during JSON diffing and patching operations.
            </summary>
    </member>
    <member name="F:Sandbox.Json.TrackedObjectDefinition.Type">
      <summary>
            A unique identifier for this object type. This is used to categorize objects.
            </summary>
    </member>
    <member name="F:Sandbox.Json.TrackedObjectDefinition.MatchScore">
      <summary>
            Determines whether a JSON object should be considered an instance of this tracked object type.
            </summary>
      <remarks>
            The function returns a float value indicating how well the JSON object matches this definition.
            A return value of 0 indicates no match, while higher values indicate stronger matches.
            This allows for heuristic-based matching when exact matches aren't possible.
            </remarks>
    </member>
    <member name="F:Sandbox.Json.TrackedObjectDefinition.ToId">
      <summary>
            Maps a JSON object to a unique identifier string.
            </summary>
      <remarks>
            The identifier could be derived from a specific property, a combination of properties, or a computed hash.
            It's critical that this function:
            1. Produces a truly unique value for each distinct object of this type
            2. Never maps two different objects to the same ID
            3. Is deterministic - always returns the same ID when applied to the same object
            
            If you can just use a UUID or other guaranteed unique identifier.
            </remarks>
    </member>
    <member name="F:Sandbox.Json.TrackedObjectDefinition.ParentType">
      <summary>
            Specifies the required type of the parent object. If null, AllowedAsRoot must be true.
            </summary>
      <remarks>
            This enforces type hierarchy constraints within the JSON structure.
            </remarks>
    </member>
    <member name="F:Sandbox.Json.TrackedObjectDefinition.AllowedAsRoot">
      <summary>
            If true, objects of this type can be the root of the object tree.
            </summary>
      <remarks>
            Root objects don't require a parent, and they don't need an ID since there can only be one root.
            If AllowedAsRoot is false, ParentType must be specified.
            </remarks>
    </member>
    <member name="M:Sandbox.Json.TrackedObjectDefinition.CreatePresenceBasedDefinition(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.Boolean)">
      <summary>
            Creates a TrackedObjectDefinition that identifies objects based on the presence of specific fields.
            </summary>
    </member>
    <member name="T:Sandbox.Json.TrackedObject">
      <summary>
            Represents a tracked object in a JSON tree with metadata for diffing and patching operations.
            </summary>
    </member>
    <member name="F:Sandbox.Json.TrackedObject.Id">
      <summary>The unique identifier for this object</summary>
    </member>
    <member name="F:Sandbox.Json.TrackedObject.Data">
      <summary>The object's JSON data without its children</summary>
    </member>
    <member name="F:Sandbox.Json.TrackedObject.Parent">
      <summary>Reference to this object's parent (null for root objects)</summary>
    </member>
    <member name="F:Sandbox.Json.TrackedObject.ContainerProperty">
      <summary>The property name in parent that contains this object</summary>
    </member>
    <member name="F:Sandbox.Json.TrackedObject.IsContainedInArray">
      <summary>Whether this object is contained in an array (true) or as a direct property (false)</summary>
    </member>
    <member name="F:Sandbox.Json.TrackedObject.PreviousElement">
      <summary>The previous sibling element when contained in an array (null if first or not in array)</summary>
    </member>
    <member name="F:Sandbox.Json.TrackedObject.Path">
      <summary>The path to this object in the JSON structure</summary>
    </member>
    <member name="F:Sandbox.Json.TrackedObject.Children">
      <summary>Child objects belonging to this object</summary>
    </member>
    <member name="M:Sandbox.Json.TrackedObject.ToJson">
      <summary>
            Reconstructs a complete JSON tree from this object and all its children.
            </summary>
    </member>
    <member name="T:Sandbox.Json.Patch">
      <summary>
            Represents a complete set of changes to be applied to a JSON structure.
            </summary>
      <remarks>
            A patch contains all the operations needed to transform one JSON structure into another
            while preserving object identity and relationships.
            </remarks>
    </member>
    <member name="P:Sandbox.Json.Patch.AddedObjects">
      <summary>
            Objects that need to be added to the target structure.
            </summary>
    </member>
    <member name="P:Sandbox.Json.Patch.RemovedObjects">
      <summary>
            Objects that need to be removed from the target structure.
            </summary>
    </member>
    <member name="P:Sandbox.Json.Patch.PropertyOverrides">
      <summary>
            Property values that need to be changed on existing objects.
            </summary>
    </member>
    <member name="P:Sandbox.Json.Patch.MovedObjects">
      <summary>
            Objects that need to be moved to a different location in the structure.
            </summary>
    </member>
    <member name="M:Sandbox.Json.CalculateDifferences(System.Text.Json.Nodes.JsonObject,System.Text.Json.Nodes.JsonObject,System.Collections.Generic.HashSet{Sandbox.Json.TrackedObjectDefinition})">
      <summary>
            Compares two JSON object trees and calculates the differences between them.
            </summary>
      <param name="oldRoot">The original JSON object tree</param>
      <param name="newRoot">The updated JSON object tree</param>
      <param name="definitions">Set of definitions for tracked object types in the JSON structure</param>
      <returns>A Patch object containing all changes needed to transform oldRoot into newRoot</returns>
    </member>
    <member name="M:Sandbox.Json.ApplyPatch(System.Text.Json.Nodes.JsonObject,Sandbox.Json.Patch,System.Collections.Generic.HashSet{Sandbox.Json.TrackedObjectDefinition})">
      <summary>
            Applies a patch to transform a JSON object tree, with support for partial patch application
            when the source tree has been modified after the patch was created.
            </summary>
      <param name="sourceRoot">The JSON object tree to modify</param>
      <param name="patch">The patch containing all changes to apply</param>
      <param name="definitions">Set of definitions for tracked object types</param>
      <returns>A new JSON object tree with all applicable changes applied</returns>
      <remarks>
            Partial patch application semantics:
            
            Object Removal:
            - Skipped if object doesn't exist in source
            - Proceeds if object exists even if parent has changed
            
            Object Addition:
            - Only added if parent exists in source
            - Skipped if parent is missing
            
            Object Moves:
            - Requires both object and target parent to exist
            - Object is removed if target parent doesn't exist
            
            Property Overrides:
            - Only applied if target object exists
            
            Array Ordering:
            - Best effort based on neighbourhood information (previous element)
            - Objects without previous elements are placed at start
            
            Operations are processed in this order: removals, additions, moves,
            reordering, and finally property overrides.
            </remarks>
    </member>
    <member name="T:Sandbox.Json.Pointer">
      <summary>
            Represents a JSON Pointer as defined in RFC 6901.
            </summary>
    </member>
    <member name="P:Sandbox.Json.Pointer.ReferenceTokens">
      <summary>
            The reference tokens that make up the JSON Pointer.
            </summary>
    </member>
    <member name="F:Sandbox.Json.Pointer.Root">
      <summary>
            A static instance representing the root JSON Pointer (i.e., "/").
            </summary>
    </member>
    <member name="M:Sandbox.Json.Pointer.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Sandbox.Json.Pointer" /> class with the specified string.
            </summary>
      <param name="value">The string value of the JSON Pointer.</param>
    </member>
    <member name="M:Sandbox.Json.Pointer.#ctor(System.Collections.Immutable.ImmutableArray{System.String})">
      <summary>
            Initializes a new instance of the <see cref="T:Sandbox.Json.Pointer" /> class with the specified tokens.
            </summary>
      <param name="tokens">The tokens that make up the JSON Pointer.</param>
    </member>
    <member name="M:Sandbox.Json.Pointer.Append(System.String)">
      <summary>
            Appends a token to the JSON Pointer and returns a new <see cref="T:Sandbox.Json.Pointer" />.
            </summary>
      <param name="token">The token to append.</param>
      <returns>A new <see cref="T:Sandbox.Json.Pointer" /> with the appended token.</returns>
    </member>
    <member name="M:Sandbox.Json.Pointer.Append(System.Int32)">
      <summary>
            Appends an integer index as a token to the JSON Pointer and returns a new <see cref="T:Sandbox.Json.Pointer" />.
            </summary>
      <param name="index">The integer index to append.</param>
      <returns>A new <see cref="T:Sandbox.Json.Pointer" /> with the appended index.</returns>
    </member>
    <member name="M:Sandbox.Json.Pointer.GetParent">
      <summary>
            Returns a new <see cref="T:Sandbox.Json.Pointer" /> representing the parent of the current pointer.
            </summary>
      <returns>A new <see cref="T:Sandbox.Json.Pointer" /> for the parent path.</returns>
    </member>
    <member name="T:Sandbox.Json.PointerJsonConverter">
      <summary>
            Custom JSON converter for the Pointer class that serializes a Pointer as a string
            and deserializes a string back into a Pointer using the Parse method.
            </summary>
    </member>
    <member name="M:Sandbox.Json.PopulateReflectionCache(Sandbox.Internal.TypeLibrary)">
      <summary>
            Try to do any reflection / code gen immediately, so we don't do anything too slow during gameplay.
            </summary>
    </member>
    <member name="T:Sandbox.IJsonPopulator">
      <summary>
            Objects that need to be deserialized into can implement this interface
            which allows them to be populated from a JSON object.
            </summary>
    </member>
    <member name="M:Sandbox.JsonUpgrader.Upgrade(System.Int32,System.Text.Json.Nodes.JsonObject,System.Type)">
      <summary>
            Runs through all upgraders that match its class where our version is lower than the specified version.
            </summary>
      <param name="version">The current version that's serialized in the json object</param>
      <param name="json" />
      <param name="targetType" />
    </member>
    <member name="T:Sandbox.FloatSpan">
      <summary>
            Allows easy SIMD/AVX2 fast math on a span of floats
            </summary>
    </member>
    <member name="M:Sandbox.FloatSpan.Max">
      <summary>
            Uses SIMD/AVX2 to find the maximum value in a span of floats.
            </summary>
    </member>
    <member name="M:Sandbox.FloatSpan.Min">
      <summary>
            Uses SIMD/AVX2 to find the minimum value in a span of floats.
            </summary>
    </member>
    <member name="T:Sandbox.Metadata">
      <summary>
            A simple class for storing and retrieving metadata values.
            </summary>
    </member>
    <member name="M:Sandbox.Metadata.Deserialize(System.String)">
      <summary>
            Deserialize metadata from a JSON string.
            </summary>
    </member>
    <member name="M:Sandbox.Metadata.Serialize">
      <summary>
            Serialize the metadata to a JSON string.
            </summary>
    </member>
    <member name="M:Sandbox.Metadata.SetValue(System.String,System.Object)">
      <summary>
            Set a value with the specified key.
            </summary>
    </member>
    <member name="M:Sandbox.Metadata.TryGetValue``1(System.String,``0@)">
      <summary>
            Try to get a value of the specified type.
            </summary>
    </member>
    <member name="M:Sandbox.Metadata.GetValueOrDefault``1(System.String,``0)">
      <summary>
            Get the a value. If it's missing or the wrong type then use the default value.
            </summary>
    </member>
    <member name="T:Sandbox.Screen">
      <summary>
            Access screen dimension etc.
            </summary>
    </member>
    <member name="P:Sandbox.Screen.Size">
      <summary>
            The total size of the game screen
            </summary>
    </member>
    <member name="P:Sandbox.Screen.Width">
      <summary>
            The width of the game screen. Equal to Screen.x
            </summary>
    </member>
    <member name="P:Sandbox.Screen.Height">
      <summary>
            The height of the game screen. Equal to Screen.y
            </summary>
    </member>
    <member name="P:Sandbox.Screen.Aspect">
      <summary>
            The aspect ratio of the screen. Equal to Width/Height
            </summary>
    </member>
    <member name="P:Sandbox.Screen.DesktopScale">
      <summary>
            The desktop's dpi scale on the current monitor.
            </summary>
    </member>
    <member name="M:Sandbox.Screen.CreateVerticalFieldOfView(System.Single)">
      <summary>
            Converts a vertical field of view to a horizontal field of view based on the screen aspect ratio.
            </summary>
    </member>
    <member name="M:Sandbox.Screen.CreateVerticalFieldOfView(System.Single,System.Single)">
      <summary>
            Converts a vertical field of view to a horizontal field of view based on the given aspect ratio.
            </summary>
    </member>
    <member name="M:Sandbox.TagSet.GetTokens">
      <summary>
            Returns a list of ints, representing the tags. These are used internally by the engine.
            </summary>
    </member>
    <member name="P:Sandbox.Time.Now">
      <summary>
            The time since game startup
            </summary>
    </member>
    <member name="P:Sandbox.Time.Delta">
      <summary>
            The delta between the last frame and the current (for all intents and purposes)
            </summary>
    </member>
    <member name="T:Sandbox.TimeSince">
      <summary>
            A convenience struct to easily measure time since an event last happened, based on <see cref="P:Sandbox.Time.Now" />.<br /><br />
            Typical usage would see you assigning 0 to a variable of this type to reset the timer.
            Then the struct would return time since the last reset. i.e.:
            <code>
            TimeSince lastUsed = 0;
            if ( lastUsed &gt; 10 ) { /*Do something*/ }
            </code></summary>
    </member>
    <member name="P:Sandbox.TimeSince.Absolute">
      <summary>
            Time at which the timer reset happened, based on <see cref="P:Sandbox.Time.Now" />.
            </summary>
    </member>
    <member name="P:Sandbox.TimeSince.Relative">
      <summary>
            Time passed since last reset, in seconds.
            </summary>
    </member>
    <member name="T:Sandbox.TimeUntil">
      <summary>
            A convenience struct to easily manage a time countdown, based on <see cref="P:Sandbox.Time.Now" />.<br /><br />
            Typical usage would see you assigning to a variable of this type a necessary amount of seconds.
            Then the struct would return the time countdown, or can be used as a bool i.e.:
            <code>
            TimeUntil nextAttack = 10;
            if ( nextAttack ) { /*Do something*/ }
            </code></summary>
    </member>
    <member name="P:Sandbox.TimeUntil.Absolute">
      <summary>
            Time to which we are counting down to, based on <see cref="P:Sandbox.Time.Now" />.
            </summary>
    </member>
    <member name="P:Sandbox.TimeUntil.Relative">
      <summary>
            The actual countdown, in seconds.
            </summary>
    </member>
    <member name="P:Sandbox.TimeUntil.Passed">
      <summary>
            Amount of seconds passed since the countdown started.
            </summary>
    </member>
    <member name="P:Sandbox.TimeUntil.Fraction">
      <summary>
            The countdown, but as a fraction, i.e. a value from 0 (start of countdown) to 1 (end of countdown)
            </summary>
    </member>
    <member name="M:Sandbox.TokenBasedTagSet.GetTokens">
      <summary>
            Try to get all tags in the set.
            </summary>
    </member>
    <member name="M:Sandbox.VoiceManager.Uncompress(System.Byte[],System.Action{System.Memory{System.Int16}})">
      <summary>
            Uncompress a voice buffer and call ondata with the result
            </summary>
    </member>
    <member name="T:Sandbox.WebSurface">
      <summary>
            Enables rendering and interacting with a webpage
            </summary>
    </member>
    <member name="P:Sandbox.WebSurface.OnTexture">
      <summary>
            Called when the texture has changed and should be updated
            </summary>
    </member>
    <member name="P:Sandbox.WebSurface.Url">
      <summary>
            The current Url
            </summary>
    </member>
    <member name="M:Sandbox.WebSurface.CheckUrlIsAllowed(System.Uri)">
      <summary>
            Is this URL allowed
            </summary>
    </member>
    <member name="P:Sandbox.WebSurface.Size">
      <summary>
            The size of the browser
            </summary>
    </member>
    <member name="M:Sandbox.WebSurface.OnNeedsRepaint(Steamworks.Data.HTML_NeedsPaint_t)">
      <summary>
            Invoked when the browser needs to be repainted
            </summary>
    </member>
    <member name="M:Sandbox.WebSurface.OnStartRequest(Steamworks.Data.HTML_StartRequest_t)">
      <summary>
            A navigation has happened, allow or deny it
            </summary>
      <param name="r" />
    </member>
    <member name="M:Sandbox.WebSurface.OnURLChanged(Steamworks.Data.HTML_URLChanged_t)">
      <summary>
            Invoked when the browser is navigating to a new url
            </summary>
      <param name="x" />
    </member>
    <member name="M:Sandbox.WebSurface.TellMouseMove(Vector2)">
      <summary>
            Tell the browser the mouse has moved
            </summary>
    </member>
    <member name="M:Sandbox.WebSurface.TellMouseWheel(System.Int32)">
      <summary>
            Tell the browser the mouse wheel has moved
            </summary>
      <param name="delta" />
    </member>
    <member name="M:Sandbox.WebSurface.TellMouseButton(Sandbox.MouseButtons,System.Boolean)">
      <summary>
            Tell the browser a mouse button has been pressed
            </summary>
    </member>
    <member name="M:Sandbox.WebSurface.TellChar(System.UInt32,Sandbox.KeyboardModifiers)">
      <summary>
            Tell the browser a unicode key has been pressed
            </summary>
    </member>
    <member name="M:Sandbox.WebSurface.TellKey(System.UInt32,Sandbox.KeyboardModifiers,System.Boolean)">
      <summary>
            Tell the browser a key has been pressed or released
            </summary>
    </member>
    <member name="P:Sandbox.WebSurface.HasKeyFocus">
      <summary>
            Tell the html control if it has key focus currently, controls showing the I-beam cursor in text controls amongst other things
            </summary>
    </member>
    <member name="P:Sandbox.WebSurface.ScaleFactor">
      <summary>
            DPI Scaling factor
            </summary>
    </member>
    <member name="P:Sandbox.WebSurface.InBackgroundMode">
      <summary>
            Enable/disable low-resource background mode, where javascript and repaint timers are throttled, resources are
            more aggressively purged from memory, and audio/video elements are paused. When background mode is enabled,
            all HTML5 video and audio objects will execute ".pause()" and gain the property "._steam_background_paused = 1".
            When background mode is disabled, any video or audio objects with that property will resume with ".play()".
            </summary>
    </member>
    <member name="T:Sandbox.Http">
      <summary>
            Lets your game make async HTTP requests.
            </summary>
    </member>
    <member name="P:Sandbox.Http.IsLocalAllowed">
      <summary>
            We shouldn't blindly let users opt into local http.
            But it's okay for editor, dedicated servers and standalone.
            </summary>
    </member>
    <member name="M:Sandbox.Http.IsAllowed(System.Uri)">
      <summary>
            Check if the given Uri matches the following requirements:
            1. Scheme is https/http or wss/ws
            2. If it's localhost, only allow ports 80/443/8080/8443
            3. Not an ip address
            </summary>
      <param name="uri">The Uri to check.</param>
      <returns>True if the Uri can be accessed, false if the Uri will be blocked.</returns>
    </member>
    <member name="M:Sandbox.Http.IsHeaderAllowed(System.String)">
      <summary>
            Checks if a given header is allowed to be set.
            </summary>
      <param name="header">The header name to check.</param>
      <returns>True if the header is allowed to be set.</returns>
    </member>
    <member name="M:Sandbox.Http.RequestStringAsync(System.String,System.String,System.Net.Http.HttpContent,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
      <summary>
            Send a HTTP request to the specified URI and return the response body as a string in an asynchronous operation.
            </summary>
      <param name="requestUri">The URI to request.</param>
      <param name="method">The HTTP verb for the request (eg. GET, POST, etc.).</param>
      <param name="content">The content to include within the request, or null if none should be sent.</param>
      <param name="headers">Headers to add to the request, or null if none should be added.</param>
      <param name="cancellationToken">An optional cancellation token for canceling this request.</param>
      <returns>An asynchronous task which resolves to the response body as a string.</returns>
      <exception cref="T:System.Net.Http.HttpRequestException">The request responded with a non-2xx HTTP status code.</exception>
      <exception cref="T:System.InvalidOperationException">The request was not allowed, either an unallowed URI or header.</exception>
    </member>
    <member name="M:Sandbox.Http.RequestBytesAsync(System.String,System.String,System.Net.Http.HttpContent,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
      <summary>
            Send a HTTP request to the specified URI and return the response body as a byte array in an asynchronous operation.
            </summary>
      <param name="requestUri">The URI to request.</param>
      <param name="method">The HTTP verb for the request (eg. GET, POST, etc.).</param>
      <param name="content">The content to include within the request, or null if none should be sent.</param>
      <param name="headers">Headers to add to the request, or null if none should be added.</param>
      <param name="cancellationToken">An optional cancellation token for canceling this request.</param>
      <returns>An asynchronous task which resolves to the response body as a byte array.</returns>
      <exception cref="T:System.Net.Http.HttpRequestException">The request responded with a non-2xx HTTP status code.</exception>
      <exception cref="T:System.InvalidOperationException">The request was not allowed, either an unallowed URI or header.</exception>
    </member>
    <member name="M:Sandbox.Http.RequestStreamAsync(System.String,System.String,System.Net.Http.HttpContent,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
      <summary>
            Send a HTTP request to the specified URI and return the response body as a stream in an asynchronous operation.
            </summary>
      <param name="requestUri">The URI to request.</param>
      <param name="method">The HTTP verb for the request (eg. GET, POST, etc.).</param>
      <param name="content">The content to include within the request, or null if none should be sent.</param>
      <param name="headers">Headers to add to the request, or null if none should be added.</param>
      <param name="cancellationToken">An optional cancellation token for canceling this request.</param>
      <returns>An asynchronous task which resolves to the response body as a <see cref="T:System.IO.Stream" />.</returns>
      <exception cref="T:System.Net.Http.HttpRequestException">The request responded with a non-2xx HTTP status code.</exception>
      <exception cref="T:System.InvalidOperationException">The request was not allowed, either an unallowed URI or header.</exception>
    </member>
    <member name="M:Sandbox.Http.RequestJsonAsync``1(System.String,System.String,System.Net.Http.HttpContent,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
      <summary>
            Sends a HTTP request to the specified URI and return the response body as a JSON deserialized object in an asynchronous operation.
            </summary>
      <param name="requestUri">The URI to request.</param>
      <param name="method">The HTTP verb for the request (eg. GET, POST, etc.).</param>
      <param name="content">The content to include within the request, or null if none should be sent.</param>
      <param name="headers">Headers to add to the request, or null if none should be added.</param>
      <param name="cancellationToken">An optional cancellation token for canceling this request.</param>
      <returns>An asynchronous task which resolves to the response body deserialized from JSON.</returns>
      <exception cref="T:System.Net.Http.HttpRequestException">The request responded with a non-2xx HTTP status code.</exception>
      <exception cref="T:System.InvalidOperationException">The request was not allowed, either an unallowed URI or header.</exception>
    </member>
    <member name="M:Sandbox.Http.RequestAsync(System.String,System.String,System.Net.Http.HttpContent,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
      <summary>
            Sends a HTTP request to the specified URI and returns the response in an asynchronous operation. 
            </summary>
      <param name="requestUri">The URI to request.</param>
      <param name="method">The HTTP verb for the request (eg. GET, POST, etc.).</param>
      <param name="content">The content to include within the request, or null if none should be sent.</param>
      <param name="headers">Headers to add to the request, or null if none should be added.</param>
      <param name="cancellationToken">An optional cancellation token for canceling this request.</param>
      <returns>An asynchronous task which resolves to a <see cref="T:System.Net.Http.HttpResponseMessage" /> containing the response for the request.</returns>
      <exception cref="T:System.Net.Http.HttpRequestException">The request responded with a non-2xx HTTP status code.</exception>
      <exception cref="T:System.InvalidOperationException">The request was not allowed, either an unallowed URI or header.</exception>
    </member>
    <member name="M:Sandbox.Http.CreateJsonContent``1(``0)">
      <summary>
            Creates a new <see cref="T:System.Net.Http.HttpContent" /> instance containing the specified object serialized to JSON.
            </summary>
    </member>
    <member name="T:NativeEngine.HMaterial">
      <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
    </member>
    <member name="T:NativeEngine.IndexBufferHandle_t">
      <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
    </member>
    <member name="T:NativeEngine.RenderBufferHandle_t">
      <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
    </member>
    <member name="T:NativeEngine.RenderInputLayout_t">
      <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
    </member>
    <member name="T:NativeEngine.RenderShaderHandle_t">
      <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
    </member>
    <member name="T:NativeEngine.VertexBufferHandle_t">
      <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
    </member>
    <member name="T:NativeEngine.CreateInterface">
      <summary>
            Mimmicks the engine internal CreateInterface system, allowing us to 
            get the interfaces without asking native.
            </summary>
    </member>
    <member name="P:NativeEngine.InputEvent.IsButtonPress">
      <summary>
            True if this is as a result of a button being pressed
            </summary>
    </member>
    <member name="P:NativeEngine.InputEvent.IsGameButton">
      <summary>
            We let some button presses skip the UI completely. These can then be used as key binds that
            can always run. We mainly do this with the F keys.
            </summary>
    </member>
    <member name="F:NativeEngine.ESceneObjectTypeFlags.SHOULD_BE_DELETED_BEFORE_WORLD">
            For objects that can't be considered to be "owned" by the world they are in because they
            are owned by a manager. All this flag does is cause a warning when such an object is still
            in the world at world deletion time (a leak).
        </member>
    <member name="F:NativeEngine.ESceneObjectTypeFlags.OWNED_BY_ANOTHER_SCENEOBJECT">
            if this flag is set, then the object will not be deleted when deleting the world, and will not be queued for delete. It's assumed that this object is going to be deleted inside of the destructor of another sceneobject
        </member>
    <member name="F:NativeEngine.ESceneObjectTypeFlags.PARTIALLY_ALPHA_BLENDED">
            We have a mixture of alpha-blended and non-alpha blended draws
        </member>
    <member name="F:NativeEngine.ESceneObjectTypeFlags.UNIQUE_BATCH_GROUP">
            A unique batch flag that allows objects to draw in a separate batch from their original group
        </member>
    <member name="F:NativeEngine.SceneSystemWellKnownRenderTargetID.SCENE_RTGT_SCRATCH_TEXTURE_8888">
      <summary>
            a scratch render target texture for use for monitor rendering and other temp storage
            </summary>
    </member>
    <member name="T:DotRecast.Detour.Crowd.DtCrowd">
            
            	@defgroup crowd Crowd
            
            	Members in this module implement local steering and dynamic avoidance features.
            
            	The crowd is the big beast of the navigation features. It not only handles a
            	lot of the path management for you, but also local steering and dynamic
            	avoidance between members of the crowd. I.e. It can keep your agents from
            	running into each other.
            
            	Main class: #dtCrowd
            
            	The #dtNavMeshQuery and #dtPathCorridor classes provide perfectly good, easy
            	to use path planning features. But in the end they only give you points that
            	your navigation client should be moving toward. When it comes to deciding things
            	like agent velocity and steering to avoid other agents, that is up to you to
            	implement. Unless, of course, you decide to use #dtCrowd.
            
            	Basically, you add an agent to the crowd, providing various configuration
            	settings such as maximum speed and acceleration. You also provide a local
            	target to more toward. The crowd manager then provides, with every update, the
            	new agent position and velocity for the frame. The movement will be
            	constrained to the navigation mesh, and steering will be applied to ensure
            	agents managed by the crowd do not collide with each other.
            
            	This is very powerful feature set. But it comes with limitations.
            
            	The biggest limitation is that you must give control of the agent's position
            	completely over to the crowd manager. You can update things like maximum speed
            	and acceleration. But in order for the crowd manager to do its thing, it can't
            	allow you to constantly be giving it overrides to position and velocity. So
            	you give up direct control of the agent's movement. It belongs to the crowd.
            
            	The second biggest limitation revolves around the fact that the crowd manager
            	deals with local planning. So the agent's target should never be more than
            	256 polygons aways from its current position. If it is, you risk
            	your agent failing to reach its target. So you may still need to do long
            	distance planning and provide the crowd manager with intermediate targets.
            
            	Other significant limitations:
            
            	- All agents using the crowd manager will use the same #dtQueryFilter.
            	- Crowd management is relatively expensive. The maximum agents under crowd
            	  management at any one time is between 20 and 30.  A good place to start
            	  is a maximum of 25 agents for 0.5ms per frame.
            
            	@note This is a summary list of members.  Use the index or search
            	feature to find minor members.
            
            	@struct dtCrowdAgentParams
            	@see dtCrowdAgent, dtCrowd::addAgent(), dtCrowd::updateAgentParameters()
            
            	@var dtCrowdAgentParams::obstacleAvoidanceType
            	@par
            
            	#dtCrowd permits agents to use different avoidance configurations.  This value
            	is the index of the #dtObstacleAvoidanceParams within the crowd.
            
            	@see dtObstacleAvoidanceParams, dtCrowd::setObstacleAvoidanceParams(),
            		 dtCrowd::getObstacleAvoidanceParams()
            
            	@var dtCrowdAgentParams::collisionQueryRange
            	@par
            
            	Collision elements include other agents and navigation mesh boundaries.
            
            	This value is often based on the agent radius and/or maximum speed. E.g. radius * 8
            
            	@var dtCrowdAgentParams::pathOptimizationRange
            	@par
            
            	Only applicable if #updateFlags includes the #DT_CROWD_OPTIMIZE_VIS flag.
            
            	This value is often based on the agent radius. E.g. radius * 30
            
            	@see dtPathCorridor::optimizePathVisibility()
            
            	@var dtCrowdAgentParams::separationWeight
            	@par
            
            	A higher value will result in agents trying to stay farther away from each other at
            	the cost of more difficult steering in tight spaces.
            Provides local steering behaviors for a group of agents. 
            @ingroup crowd
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtCrowd.SetObstacleAvoidanceParams(System.Int32,DotRecast.Detour.Crowd.DtObstacleAvoidanceParams)">
            Sets the shared avoidance configuration for the specified index.
            @param[in] idx The index. [Limits: 0 &lt;= value &lt; #DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS]
            @param[in] option The new configuration.
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtCrowd.GetObstacleAvoidanceParams(System.Int32)">
            Gets the shared avoidance configuration for the specified index.
            @param[in] idx The index of the configuration to retreive.
            [Limits: 0 &lt;= value &lt; #DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS]
            @return The requested configuration.
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtCrowd.UpdateAgentParameters(DotRecast.Detour.Crowd.DtCrowdAgent,DotRecast.Detour.Crowd.DtCrowdAgentParams)">
            Updates the specified agent's configuration.
            @param[in] idx The agent index. [Limits: 0 &lt;= value &lt; #GetAgentCount()]
            @param[in] params The new agent configuration.
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtCrowd.AddAgent(Vector3,DotRecast.Detour.Crowd.DtCrowdAgentParams)">
             @par
            
             The agent's position will be constrained to the surface of the navigation mesh.
             Adds a new agent to the crowd.
              @param[in]		pos		The requested position of the agent. [(x, y, z)]
              @param[in]		params	The configuration of the agent.
             @return The index of the agent in the agent pool. Or -1 if the agent could not be added.
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtCrowd.RequestMoveTarget(DotRecast.Detour.Crowd.DtCrowdAgent,System.Int64,Vector3)">
             Submits a new move request for the specified agent.
             @param[in] idx The agent index. [Limits: 0 &lt;= value &lt; #GetAgentCount()]
             @param[in] ref The position's polygon reference.
             @param[in] pos The position within the polygon. [(x, y, z)]
             @return True if the request was successfully submitted.
            
             This method is used when a new target is set.
            
             The position will be constrained to the surface of the navigation mesh.
            
             The request will be processed during the next #Update().
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtCrowd.RequestMoveVelocity(DotRecast.Detour.Crowd.DtCrowdAgent,Vector3)">
            Submits a new move request for the specified agent.
            @param[in] idx The agent index. [Limits: 0 &lt;= value &lt; #GetAgentCount()]
            @param[in] vel The movement velocity. [(x, y, z)]
            @return True if the request was successfully submitted.
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtCrowd.ResetMoveTarget(DotRecast.Detour.Crowd.DtCrowdAgent)">
            Resets any request for the specified agent.
            @param[in] idx The agent index. [Limits: 0 &lt;= value &lt; #GetAgentCount()]
            @return True if the request was successfully reseted.
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtCrowd.GetActiveAgents">
             Gets the active agents int the agent pool.
            
             @return List of active agents
        </member>
    <member name="T:DotRecast.Detour.Crowd.DtCrowdAgent">
            Represents an agent managed by a #dtCrowd object.
            @ingroup crowd
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.state">
            The type of mesh polygon the agent is traversing. (See: #CrowdAgentState)
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.partial">
            True if the agent has valid path (targetState == DT_CROWDAGENT_TARGET_VALID) and the path does not lead to the requested position, else false.
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.corridor">
            The path corridor the agent is using.
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.boundary">
            The local boundary data for the agent.
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.topologyOptTime">
            Time since the agent's path corridor was optimized.
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.neis">
            The known neighbors of the agent.
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.nneis">
            The number of neighbors.
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.desiredSpeed">
            The desired speed.
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.option">
            The agent's configuration parameters.
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.corners">
            The local path corridor corners for the agent.
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdAgent.ncorners">
            The number of corners.
        </member>
    <member name="T:DotRecast.Detour.Crowd.DtCrowdAgentParams">
            Configuration parameters for a crowd agent.
            @ingroup crowd
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdAgentParams.collisionQueryRange">
            Defines how close a collision element must be before it is considered for steering behaviors. [Limits: &gt; 0]
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdAgentParams.separationWeight">
            How aggresive the agent manager should be at avoiding collisions with this agent. [Limit: &gt;= 0]
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdAgentParams.updateFlags">
            the agent path.
            Flags that impact steering behavior. (See: #UpdateFlags)
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdAgentParams.obstacleAvoidanceType">
            The index of the avoidance configuration to use for the agent.
            [Limits: 0 &lt;= value &lt; #DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS]
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdAgentParams.queryFilterType">
            The index of the query filter used by this agent.
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdAgentParams.userData">
            User defined data attached to the agent.
        </member>
    <member name="T:DotRecast.Detour.Crowd.DtCrowdAgentState">
            The type of navigation mesh polygon the agent is currently traversing.
            @ingroup crowd
        </member>
    <member name="T:DotRecast.Detour.Crowd.DtCrowdAgentUpdateFlags">
            Crowd agent update flags.
            @ingroup crowd
            @see dtCrowdAgentParams::updateFlags
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdConst.DT_CROWDAGENT_MAX_NEIGHBOURS">
            The maximum number of neighbors that a crowd agent can take into account
            for steering decisions.
            @ingroup crowd
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdConst.DT_CROWDAGENT_MAX_CORNERS">
            The maximum number of corners a crowd agent will look ahead in the path.
            This value is used for sizing the crowd agent corner buffers.
            Due to the behavior of the crowd manager, the actual number of useful
            corners will be one less than this number.
            @ingroup crowd
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdConst.DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS">
            The maximum number of crowd avoidance configurations supported by the
            crowd manager.
            @ingroup crowd
            @see dtObstacleAvoidanceParams, dtCrowd::SetObstacleAvoidanceParams(), dtCrowd::GetObstacleAvoidanceParams(),
            dtCrowdAgentParams::obstacleAvoidanceType
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtCrowdConst.DT_CROWD_MAX_QUERY_FILTER_TYPE">
            The maximum number of query filter types supported by the crowd manager.
            @ingroup crowd
            @see dtQueryFilter, dtCrowd::GetFilter() dtCrowd::GetEditableFilter(),
            dtCrowdAgentParams::queryFilterType
        </member>
    <member name="T:DotRecast.Detour.Crowd.DtCrowdNeighbour">
            Provides neighbor data for agents managed by the crowd.
            @ingroup crowd
            @see dtCrowdAgent::neis, dtCrowd
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtObstacleAvoidanceQuery.ProcessSample(Vector3,System.Single,Vector3,System.Single,Vector3,Vector3,System.Single)">
             Calculate the collision penalty for a given velocity vector
            
             @param vcand
                        sampled velocity
             @param dvel
                        desired velocity
             @param minPenalty
                        threshold penalty for early out
        </member>
    <member name="T:DotRecast.Detour.Crowd.DtObstacleCircle">
            &lt; Max number of adaptive rings.
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtObstacleCircle.p">
            Position of the obstacle 
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtObstacleCircle.vel">
            Velocity of the obstacle 
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtObstacleCircle.dvel">
            Velocity of the obstacle 
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtObstacleCircle.rad">
            Radius of the obstacle 
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtObstacleCircle.dp">
            Use for side selection during sampling. 
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtObstacleCircle.np">
            Use for side selection during sampling. 
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtObstacleSegment.p">
            End points of the obstacle segment 
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtObstacleSegment.q">
            End points of the obstacle segment 
        </member>
    <member name="T:DotRecast.Detour.Crowd.DtPathCorridor">
            Represents a dynamic polygon corridor used to plan agent movement.
            @ingroup crowd, detour
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.#ctor">
            		@class dtPathCorridor
            		@par
            
            		The corridor is loaded with a path, usually obtained from a #dtNavMeshQuery::findPath() query. The corridor
            		is then used to plan local movement, with the corridor automatically updating as needed to deal with inaccurate
            		agent locomotion.
            
            		Example of a common use case:
            
            		-# Construct the corridor object and call #init() to allocate its path buffer.
            		-# Obtain a path from a #dtNavMeshQuery object.
            		-# Use #reset() to set the agent's current position. (At the beginning of the path.)
            		-# Use #setCorridor() to load the path and target.
            		-# Use #findCorners() to plan movement. (This handles dynamic path straightening.)
            		-# Use #movePosition() to feed agent movement back into the corridor. (The corridor will automatically adjust as needed.)
            		-# If the target is moving, use #moveTargetPosition() to update the end of the corridor.
            		   (The corridor will automatically adjust as needed.)
            		-# Repeat the previous 3 steps to continue to move the agent.
            
            		The corridor position and target are always constrained to the navigation mesh.
            
            		One of the difficulties in maintaining a path is that floating point errors, locomotion inaccuracies, and/or local
            		steering can result in the agent crossing the boundary of the path corridor, temporarily invalidating the path.
            		This class uses local mesh queries to detect and update the corridor as needed to handle these types of issues.
            
            		The fact that local mesh queries are used to move the position and target locations results in two beahviors that
            		need to be considered:
            
            		Every time a move function is used there is a chance that the path will become non-optimial. Basically, the further
            		the target is moved from its original location, and the further the position is moved outside the original corridor,
            		the more likely the path will become non-optimal. This issue can be addressed by periodically running the
            		#optimizePathTopology() and #optimizePathVisibility() methods.
            
            		All local mesh queries have distance limitations. (Review the #dtNavMeshQuery methods for details.) So the most accurate
            		use case is to move the position and target in small increments. If a large increment is used, then the corridor
            		may not be able to accurately find the new location.  Because of this limiation, if a position is moved in a large
            		increment, then compare the desired and resulting polygon references. If the two do not match, then path replanning
            		may be needed.  E.g. If you move the target, check #getLastPoly() to see if it is the expected polygon.
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.Init(System.Int32)">
             @par
            
             @warning Cannot be called more than once.
             Allocates the corridor's path buffer. 
              @param[in]		maxPath		The maximum path size the corridor can handle.
             @return True if the initialization succeeded.
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.Reset(System.Int64,Vector3)">
             @par
            
             Essentially, the corridor is set of one polygon in size with the target
             equal to the position.
             
             Resets the path corridor to the specified position.
              @param[in]		ref		The polygon reference containing the position.
              @param[in]		pos		The new position in the corridor. [(x, y, z)]
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.FindCorners(System.Span{DotRecast.Detour.DtStraightPath},System.Int32,DotRecast.Detour.DtNavMeshQuery,DotRecast.Detour.IDtQueryFilter)">
            		@par
            
            		This is the function used to plan local movement within the corridor. One or more corners can be
            		detected in order to plan movement. It performs essentially the same function as #dtNavMeshQuery::findStraightPath.
            
            		Due to internal optimizations, the maximum number of corners returned will be (@p maxCorners - 1)
            		For example: If the buffers are sized to hold 10 corners, the function will never return more than 9 corners.
            		So if 10 corners are needed, the buffers should be sized for 11 corners.
            
            		If the target is within range, it will be the last corner and have a polygon reference id of zero.
            Finds the corners in the corridor from the position toward the target. (The straightened path.)
             @param[out]	cornerVerts		The corner vertices. [(x, y, z) * cornerCount] [Size: &lt;= maxCorners]
             @param[out]	cornerFlags		The flag for each corner. [(flag) * cornerCount] [Size: &lt;= maxCorners]
             @param[out]	cornerPolys		The polygon reference for each corner. [(polyRef) * cornerCount] 
             								[Size: &lt;= @p maxCorners]
             @param[in]		maxCorners		The maximum number of corners the buffers can hold.
             @param[in]		navquery		The query object used to build the corridor.
             @param[in]		filter			The filter to apply to the operation.
            @return The number of corners returned in the corner buffers. [0 &lt;= value &lt;= @p maxCorners]
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.OptimizePathVisibility(Vector3,System.Single,DotRecast.Detour.DtNavMeshQuery,DotRecast.Detour.IDtQueryFilter)">
            		@par
            
            		Inaccurate locomotion or dynamic obstacle avoidance can force the argent position significantly outside the
            		original corridor. Over time this can result in the formation of a non-optimal corridor. Non-optimal paths can
            		also form near the corners of tiles.
            
            		This function uses an efficient local visibility search to try to optimize the corridor
            		between the current position and @p next.
            
            		The corridor will change only if @p next is visible from the current position and moving directly toward the point
            		is better than following the existing path.
            
            		The more inaccurate the agent movement, the more beneficial this function becomes. Simply adjust the frequency
            		of the call to match the needs to the agent.
            
            		This function is not suitable for long distance searches.
            Attempts to optimize the path if the specified point is visible from the current position.
             @param[in]		next					The point to search toward. [(x, y, z])
             @param[in]		pathOptimizationRange	The maximum range to search. [Limit: &gt; 0]
             @param[in]		navquery				The query object used to build the corridor.
             @param[in]		filter					The filter to apply to the operation.	
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.OptimizePathTopology(DotRecast.Detour.DtNavMeshQuery,DotRecast.Detour.IDtQueryFilter,System.Int32)">
            		@par
            
            		Inaccurate locomotion or dynamic obstacle avoidance can force the agent position significantly outside the
            		original corridor. Over time this can result in the formation of a non-optimal corridor. This function will use a
            		local area path search to try to re-optimize the corridor.
            
            		The more inaccurate the agent movement, the more beneficial this function becomes. Simply adjust the frequency of
            		the call to match the needs to the agent.
            Attempts to optimize the path using a local area search. (Partial replanning.) 
             @param[in]		navquery	The query object used to build the corridor.
             @param[in]		filter		The filter to apply to the operation.	
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.MovePosition(Vector3,DotRecast.Detour.DtNavMeshQuery,DotRecast.Detour.IDtQueryFilter)">
            		@par
            
            		Behavior:
            
            		- The movement is constrained to the surface of the navigation mesh.
            		- The corridor is automatically adjusted (shorted or lengthened) in order to remain valid.
            		- The new position will be located in the adjusted corridor's first polygon.
            
            		The expected use case is that the desired position will be 'near' the current corridor. What is considered 'near'
            		depends on local polygon density, query search half extents, etc.
            
            		The resulting position will differ from the desired position if the desired position is not on the navigation mesh,
            		or it can't be reached using a local search.
            Moves the position from the current location to the desired location, adjusting the corridor 
            as needed to reflect the change.
             @param[in]		npos		The desired new position. [(x, y, z)]
             @param[in]		navquery	The query object used to build the corridor.
             @param[in]		filter		The filter to apply to the operation.
            @return Returns true if move succeeded.
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.MoveTargetPosition(Vector3,DotRecast.Detour.DtNavMeshQuery,DotRecast.Detour.IDtQueryFilter)">
            		@par
            
            		Behavior:
            
            		- The movement is constrained to the surface of the navigation mesh.
            		- The corridor is automatically adjusted (shorted or lengthened) in order to remain valid.
            		- The new target will be located in the adjusted corridor's last polygon.
            
            		The expected use case is that the desired target will be 'near' the current corridor. What is considered 'near' depends on local polygon density, query search half extents, etc.
            
            		The resulting target will differ from the desired target if the desired target is not on the navigation mesh, or it can't be reached using a local search.
            Moves the target from the curent location to the desired location, adjusting the corridor
            as needed to reflect the change. 
             @param[in]		npos		The desired new target position. [(x, y, z)]
             @param[in]		navquery	The query object used to build the corridor.
             @param[in]		filter		The filter to apply to the operation.
            @return Returns true if move succeeded.
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.SetCorridor(Vector3,System.Collections.Generic.List{System.Int64})">
             @par
            
             The current corridor position is expected to be within the first polygon in the path. The target 
             is expected to be in the last polygon. 
             
             @warning The size of the path must not exceed the size of corridor's path buffer set during #init().
             Loads a new path and target into the corridor.
              @param[in]		target		The target location within the last polygon of the path. [(x, y, z)]
              @param[in]		path		The path corridor. [(polyRef) * @p npolys]
              @param[in]		npath		The number of polygons in the path.
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.IsValid(System.Int32,DotRecast.Detour.DtNavMeshQuery,DotRecast.Detour.IDtQueryFilter)">
             @par
            
             The path can be invalidated if there are structural changes to the underlying navigation mesh, or the state of 
             a polygon within the path changes resulting in it being filtered out. (E.g. An exclusion or inclusion flag changes.)
             Checks the current corridor path to see if its polygon references remain valid.
             
              @param[in]		maxLookAhead	The number of polygons from the beginning of the corridor to search.
              @param[in]		navquery		The query object used to build the corridor.
              @param[in]		filter			The filter to apply to the operation.	
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.GetPos">
            Gets the current position within the corridor. (In the first polygon.)
            @return The current position within the corridor.
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.GetTarget">
            Gets the current target within the corridor. (In the last polygon.)
            @return The current target within the corridor.
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.GetFirstPoly">
            The polygon reference id of the first polygon in the corridor, the polygon containing the position.
            @return The polygon reference id of the first polygon in the corridor. (Or zero if there is no path.)
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.GetLastPoly">
            The polygon reference id of the last polygon in the corridor, the polygon containing the target.
            @return The polygon reference id of the last polygon in the corridor. (Or zero if there is no path.)
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.GetPath">
            The corridor's path.
            @return The corridor's path. [(polyRef) * #getPathCount()]
        </member>
    <member name="M:DotRecast.Detour.Crowd.DtPathCorridor.GetPathCount">
            The number of polygons in the current corridor path.
            @return The number of polygons in the current corridor path.
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtPathQuery.startPos">
            Path find start and end location.
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtSegment.s">
            Segment start/end 
        </member>
    <member name="F:DotRecast.Detour.Crowd.DtSegment.d">
            Distance for pruning. 
        </member>
    <member name="T:DotRecast.Detour.DtBVNode">
            Bounding volume node.
            @note This structure is rarely if ever used by the end user.
            @see dtMeshTile
        </member>
    <member name="F:DotRecast.Detour.DtDetour.DT_VERTS_PER_POLYGON">
            The maximum number of vertices per navigation polygon.
            @ingroup detour
        </member>
    <member name="F:DotRecast.Detour.DtDetour.DT_NAVMESH_MAGIC">
            A magic number used to detect compatibility of navigation tile data. 
        </member>
    <member name="F:DotRecast.Detour.DtDetour.DT_NAVMESH_VERSION">
            A version number used to detect compatibility of navigation tile data. 
        </member>
    <member name="F:DotRecast.Detour.DtDetour.DT_NAVMESH_STATE_MAGIC">
            A magic number used to detect the compatibility of navigation tile states. 
        </member>
    <member name="F:DotRecast.Detour.DtDetour.DT_NAVMESH_STATE_VERSION">
            A version number used to detect compatibility of navigation tile states. 
        </member>
    <member name="F:DotRecast.Detour.DtDetour.DT_EXT_LINK">
            A flag that indicates that an entity links to an external entity.
            (E.g. A polygon edge is a portal that links to another polygon.)
        </member>
    <member name="F:DotRecast.Detour.DtDetour.DT_NULL_LINK">
            A value that indicates the entity does not link to anything.
        </member>
    <member name="F:DotRecast.Detour.DtDetour.DT_MAX_AREAS">
            The maximum number of user defined area ids.
        </member>
    <member name="F:DotRecast.Detour.DtDetour.DT_RAY_CAST_LIMIT_PROPORTIONS">
            Limit raycasting during any angle pahfinding
            The limit is given as a multiple of the character radius
        </member>
    <member name="M:DotRecast.Detour.DtDetour.EncodePolyId(System.Int32,System.Int32,System.Int32)">
            @{
            @name Encoding and Decoding
            These functions are generally meant for internal use only.
            Derives a standard polygon reference.
             @note This function is generally meant for internal use only.
             @param[in]	salt	The tile's salt value.
             @param[in]	it		The index of the tile.
             @param[in]	ip		The index of the polygon within the tile.
        </member>
    <member name="M:DotRecast.Detour.DtDetour.DecodePolyId(System.Int64,System.Int32@,System.Int32@,System.Int32@)">
            Decodes a standard polygon reference.
            @note This function is generally meant for internal use only.
            @param[in] ref The polygon reference to decode.
            @param[out] salt The tile's salt value.
            @param[out] it The index of the tile.
            @param[out] ip The index of the polygon within the tile.
            @see #encodePolyId
        </member>
    <member name="M:DotRecast.Detour.DtDetour.DecodePolyIdSalt(System.Int64)">
            Extracts a tile's salt value from the specified polygon reference.
            @note This function is generally meant for internal use only.
            @param[in] ref The polygon reference.
            @see #encodePolyId
        </member>
    <member name="M:DotRecast.Detour.DtDetour.DecodePolyIdTile(System.Int64)">
            Extracts the tile's index from the specified polygon reference.
            @note This function is generally meant for internal use only.
            @param[in] ref The polygon reference.
            @see #encodePolyId
        </member>
    <member name="M:DotRecast.Detour.DtDetour.DecodePolyIdPoly(System.Int64)">
            Extracts the polygon's index (within its tile) from the specified
            polygon reference.
            @note This function is generally meant for internal use only.
            @param[in] ref The polygon reference.
            @see #encodePolyId
        </member>
    <member name="M:DotRecast.Detour.DtDetour.GetDetailTriEdgeFlags(System.Int32,System.Int32)">
            Get flags for edge in detail triangle.
            @param[in]	triFlags		The flags for the triangle (last component of detail vertices above).
            @param[in]	edgeIndex		The index of the first vertex of the edge. For instance, if 0,
            							returns flags for edge AB.
        </member>
    <member name="T:DotRecast.Detour.DtFindPathOptions">
            Options for dtNavMeshQuery::initSlicedFindPath and updateSlicedFindPath
        </member>
    <member name="T:DotRecast.Detour.DtLink">
            Defines a link between polygons.
            @note This structure is rarely if ever used by the end user.
            @see dtMeshTile
        </member>
    <member name="F:DotRecast.Detour.DtMeshData.detailVerts">
            The detail mesh's unique vertices. [(x, y, z) * dtMeshHeader::detailVertCount]
        </member>
    <member name="F:DotRecast.Detour.DtMeshData.detailTris">
            The detail mesh's triangles. [(vertA, vertB, vertC, triFlags) * dtMeshHeader::detailTriCount].
            See dtDetailTriEdgeFlags and dtGetDetailTriEdgeFlags.
        </member>
    <member name="F:DotRecast.Detour.DtMeshData.bvTree">
            The tile bounding volume nodes. [Size: dtMeshHeader::bvNodeCount]
            (Will be null if bounding volumes are disabled.)
        </member>
    <member name="T:DotRecast.Detour.DtMeshHeader">
            Provides high level information related to a dtMeshTile object. 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.magic">
            Tile magic number. (Used to identify the data format.) 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.version">
            Tile data format version number. 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.x">
            The x-position of the tile within the dtNavMesh tile grid. (x, y, layer) 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.y">
            The y-position of the tile within the dtNavMesh tile grid. (x, y, layer) 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.layer">
            The layer of the tile within the dtNavMesh tile grid. (x, y, layer) 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.userId">
            The user defined id of the tile. 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.polyCount">
            The number of polygons in the tile. 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.vertCount">
            The number of vertices in the tile. 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.maxLinkCount">
            The number of allocated links. 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.detailMeshCount">
            The number of sub-meshes in the detail mesh. 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.detailVertCount">
            The number of unique vertices in the detail mesh. (In addition to the polygon vertices.) 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.detailTriCount">
            The number of triangles in the detail mesh. 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.bvNodeCount">
            The number of bounding volume nodes. (Zero if bounding volumes are disabled.) 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.offMeshConCount">
            The number of off-mesh connections. 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.offMeshBase">
            The index of the first polygon which is an off-mesh connection. 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.walkableHeight">
            The height of the agents using the tile. 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.walkableRadius">
            The radius of the agents using the tile. 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.walkableClimb">
            The maximum climb height of the agents using the tile. 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.bmin">
            The minimum bounds of the tile's AABB. [(x, y, z)] 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.bmax">
            The maximum bounds of the tile's AABB. [(x, y, z)] 
        </member>
    <member name="F:DotRecast.Detour.DtMeshHeader.bvQuantFactor">
            The bounding volume quantization factor. 
        </member>
    <member name="T:DotRecast.Detour.DtMeshTile">
            Defines a navigation mesh tile.
            @ingroup detour
        </member>
    <member name="T:DotRecast.Detour.DtNavMesh">
            A navigation mesh based on tiles of convex polygons.
            @ingroup detour
        </member>
    <member name="F:DotRecast.Detour.DtNavMesh.m_maxVertPerPoly">
            The maximum number of vertices per navigation polygon. 
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.GetMaxTiles">
            The maximum number of tiles supported by the navigation mesh.
            @return The maximum number of tiles supported by the navigation mesh.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.GetTile(System.Int32)">
            Returns pointer to tile in the tile array.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.GetPolyRefBase(DotRecast.Detour.DtMeshTile)">
            Gets the polygon reference for the tile's base polygon.
             @param[in]	tile		The tile.
            @return The polygon reference for the base polygon in the specified tile.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.CalcTileLoc(Vector3,System.Int32@,System.Int32@)">
            Calculates the tile grid location for the specified world position.
             @param[in]	pos  The world position for the query. [(x, y, z)]
             @param[out]	tx		The tile's x-location. (x, y)
             @param[out]	ty		The tile's y-location. (x, y)
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.GetTileAndPolyByRef(System.Int64,DotRecast.Detour.DtMeshTile@,DotRecast.Detour.DtPoly@)">
            Gets the tile and polygon for the specified polygon reference.
             @param[in]		ref		The reference for the a polygon.
             @param[out]	tile	The tile containing the polygon.
             @param[out]	poly	The polygon.
            @return The status flags for the operation.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.GetTileAndPolyByRefUnsafe(System.Int64,DotRecast.Detour.DtMeshTile@,DotRecast.Detour.DtPoly@)">
             @par
            
             @warning Only use this function if it is known that the provided polygon
             reference is valid. This function is faster than #getTileAndPolyByRef,
             but
             it does not validate the reference.
             Returns the tile and polygon for the specified polygon reference.
              @param[in]		ref		A known valid reference for a polygon.
              @param[out]	tile	The tile containing the polygon.
              @param[out]	poly	The polygon.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.IsValidPolyRef(System.Int64)">
            Checks the validity of a polygon reference.
             @param[in]	ref		The polygon reference to check.
            @return True if polygon reference is valid for the navigation mesh.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.QueryPolygonsInTile(DotRecast.Detour.DtMeshTile,Vector3,Vector3)">
            Queries polygons within a tile.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.AddTile(DotRecast.Detour.DtMeshData,System.Int32,System.Int64,System.Int64@)">
             @par
            
             The add operation will fail if the data is in the wrong format, the allocated tile
             space is full, or there is a tile already at the specified reference.
            
             The lastRef parameter is used to restore a tile with the same tile
             reference it had previously used.  In this case the #dtPolyRef's for the
             tile will be restored to the same values they were before the tile was 
             removed.
            
             The nav mesh assumes exclusive access to the data passed and will make
             changes to the dynamic portion of the data. For that reason the data
             should not be reused in other nav meshes until the tile has been successfully
             removed from this nav mesh.
            
             @see dtCreateNavMeshData, #removeTile
             Adds a tile to the navigation mesh.
              @param[in]		data		Data for the new tile mesh. (See: #dtCreateNavMeshData)
              @param[in]		dataSize	Data size of the new tile mesh.
              @param[in]		flags		Tile flags. (See: #dtTileFlags)
              @param[in]		lastRef		The desired reference for the tile. (When reloading a tile.) [opt] [Default: 0]
              @param[out]	result		The tile reference. (If the tile was succesfully added.) [opt]
             @return The status flags for the operation. 
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.RemoveTile(System.Int64)">
             Removes the specified tile from the navigation mesh.
             @param[in] ref The reference of the tile to remove.
             @param[out] data Data associated with deleted tile.
             @param[out] dataSize Size of the data associated with deleted tile.
            
             This function returns the data for the tile so that, if desired,
             it can be added back to the navigation mesh at a later point.
            
             @see #addTile
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.ConnectIntLinks(DotRecast.Detour.DtMeshTile)">
            Builds internal polygons links for a tile.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.UnconnectLinks(DotRecast.Detour.DtMeshTile,DotRecast.Detour.DtMeshTile)">
            Removes external links at specified side.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.ConnectExtLinks(DotRecast.Detour.DtMeshTile,DotRecast.Detour.DtMeshTile,System.Int32)">
            Builds external polygon links for a tile.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.ConnectExtOffMeshLinks(DotRecast.Detour.DtMeshTile,DotRecast.Detour.DtMeshTile,System.Int32)">
            Builds external polygon links for a tile.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.FindConnectingPolys(Vector3,Vector3,DotRecast.Detour.DtMeshTile,System.Int32,System.Collections.Generic.List{DotRecast.Detour.DtConnectPoly}@)">
            Returns all polygons in neighbour tile based on portal defined by the segment.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.BaseOffMeshLinks(DotRecast.Detour.DtMeshTile)">
            Builds internal polygons links for a tile.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.ClosestPointOnDetailEdges(DotRecast.Detour.DtMeshTile,DotRecast.Detour.DtPoly,Vector3,System.Boolean)">
             Returns closest point on polygon.
            
             @param ref
             @param pos
             @return
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.FindNearestPolyInTile(DotRecast.Detour.DtMeshTile,Vector3,Vector3,Vector3@)">
            Find nearest polygon within a tile.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.GetNeighbourTilesAt(System.Int32,System.Int32,System.Int32,DotRecast.Detour.DtMeshTile[],System.Int32)">
            Returns neighbour tile based on side.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.GetTilesAt(System.Int32,System.Int32,DotRecast.Detour.DtMeshTile[],System.Int32)">
            Returns neighbour tile based on side.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.GetOffMeshConnectionPolyEndPoints(System.Int64,System.Int64,Vector3@,Vector3@)">
             Gets the endpoints for an off-mesh connection, ordered by "direction of travel".
              @param[in]		prevRef		The reference of the polygon before the connection.
              @param[in]		polyRef		The reference of the off-mesh connection polygon.
              @param[out]	startPos	The start position of the off-mesh connection. [(x, y, z)]
              @param[out]	endPos		The end position of the off-mesh connection. [(x, y, z)]
             @return The status flags for the operation.
             
             @par
            
             Off-mesh connections are stored in the navigation mesh as special 2-vertex 
             polygons with a single edge. At least one of the vertices is expected to be 
             inside a normal polygon. So an off-mesh connection is "entered" from a 
             normal polygon at one of its endpoints. This is the polygon identified by 
             the prevRef parameter.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.SetPolyFlags(System.Int64,System.Int32)">
            @{
            @name State Management
            These functions do not effect #dtTileRef or #dtPolyRef's. 
            Sets the user defined flags for the specified polygon.
             @param[in]	ref		The polygon reference.
             @param[in]	flags	The new flags for the polygon.
            @return The status flags for the operation.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.GetPolyFlags(System.Int64,System.Int32@)">
            Gets the user defined flags for the specified polygon.
             @param[in]		ref				The polygon reference.
             @param[out]	resultFlags		The polygon flags.
            @return The status flags for the operation.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.SetPolyArea(System.Int64,System.Char)">
            Sets the user defined area for the specified polygon.
             @param[in]	ref		The polygon reference.
             @param[in]	area	The new area id for the polygon. [Limit: DT_MAX_AREAS]
            @return The status flags for the operation.
        </member>
    <member name="M:DotRecast.Detour.DtNavMesh.GetPolyArea(System.Int64,System.Int32@)">
            Gets the user defined area for the specified polygon.
             @param[in]		ref			The polygon reference.
             @param[out]	resultArea	The area id for the polygon.
            @return The status flags for the operation.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshBuilder.CreateNavMeshData(DotRecast.Detour.DtNavMeshCreateParams)">
             @par
             
             The output data array is allocated using the detour allocator (dtAlloc()).  The method
             used to free the memory will be determined by how the tile is added to the navigation
             mesh.
            
             @see dtNavMesh, dtNavMesh::addTile()
        </member>
    <member name="T:DotRecast.Detour.DtNavMeshCreateParams">
            Represents the source data used to build an navigation mesh tile.
            @ingroup detour
        </member>
    <member name="F:DotRecast.Detour.DtNavMeshCreateParams.verts">
            @name Polygon Mesh Attributes
            Used to create the base navigation graph.
            See #rcPolyMesh for details related to these attributes.
            @{
        </member>
    <member name="F:DotRecast.Detour.DtNavMeshCreateParams.detailMeshes">
            @}
            @name Height Detail Attributes (Optional)
            See #rcPolyMeshDetail for details related to these attributes.
            @{
            
        </member>
    <member name="F:DotRecast.Detour.DtNavMeshCreateParams.offMeshConVerts">
            @}
            @name Off-Mesh Connections Attributes (Optional)
            Used to define a custom point-to-point edge within the navigation graph, an
            off-mesh connection is a user defined traversable connection made up to two vertices,
            at least one of which resides within a navigation mesh polygon.
            @{
            Off-mesh connection vertices. [(ax, ay, az, bx, by, bz) * #offMeshConCount] [Unit: wu]
        </member>
    <member name="F:DotRecast.Detour.DtNavMeshCreateParams.offMeshConRad">
            Off-mesh connection radii. [Size: #offMeshConCount] [Unit: wu]
        </member>
    <member name="F:DotRecast.Detour.DtNavMeshCreateParams.offMeshConFlags">
            User defined flags assigned to the off-mesh connections. [Size: #offMeshConCount]
        </member>
    <member name="F:DotRecast.Detour.DtNavMeshCreateParams.offMeshConAreas">
            User defined area ids assigned to the off-mesh connections. [Size: #offMeshConCount]
        </member>
    <member name="F:DotRecast.Detour.DtNavMeshCreateParams.offMeshConBidirectional">
            The permitted travel direction of the off-mesh connections. [Size: #offMeshConCount]
        </member>
    <member name="F:DotRecast.Detour.DtNavMeshCreateParams.offMeshConUserData">
            The user defined ids of the off-mesh connection. [Size: #offMeshConCount]
        </member>
    <member name="F:DotRecast.Detour.DtNavMeshCreateParams.offMeshConCount">
            The number of off-mesh connections. [Limit: &gt;= 0]
        </member>
    <member name="F:DotRecast.Detour.DtNavMeshCreateParams.userId">
            @}
            @name Tile Attributes
            @note The tile grid/layer data can be left at zero if the destination is a single tile mesh.
            @{
        </member>
    <member name="F:DotRecast.Detour.DtNavMeshCreateParams.walkableHeight">
            @}
            @name General Configuration Attributes
            @{
        </member>
    <member name="F:DotRecast.Detour.DtNavMeshCreateParams.buildBvTree">
            True if a bounding volume tree should be built for the tile.
            @note The BVTree is not normally needed for layered navigation meshes.
        </member>
    <member name="T:DotRecast.Detour.DtNavMeshParams">
            Configuration parameters used to define multi-tile navigation meshes.
            The values are used to allocate space during the initialization of a navigation mesh.
            @see dtNavMesh::init()
            @ingroup detour
        </member>
    <member name="T:DotRecast.Detour.DtNavMeshQuery">
            Provides the ability to perform pathfinding related queries against
            a navigation mesh.
            @ingroup detour
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.#ctor(DotRecast.Detour.DtNavMesh)">
             @class dtNavMeshQuery
            
             For methods that support undersized buffers, if the buffer is too small 
             to hold the entire result set the return status of the method will include 
             the #DT_BUFFER_TOO_SMALL flag.
            
             Constant member functions can be used by multiple clients without side
             effects. (E.g. No change to the closed list. No impact on an in-progress
             sliced path query. Etc.)
             
             Walls and portals: A @e wall is a polygon segment that is 
             considered impassable. A @e portal is a passable segment between polygons.
             A portal may be treated as a wall based on the dtQueryFilter used for a query.
            
             @see dtNavMesh, dtQueryFilter, #dtAllocNavMeshQuery(), #dtAllocNavMeshQuery()
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.FindRandomPoint(DotRecast.Detour.IDtQueryFilter,System.Random,System.Int64@,Vector3@)">
            Returns random location on navmesh.
            Polygons are chosen weighted by area. The search runs in linear related to number of polygon.
             @param[in]		filter			The polygon filter to apply to the query.
             @param[in]		frand			Function returning a random number [0..1).
             @param[out]	randomRef		The reference id of the random location.
             @param[out]	randomPt		The random location. 
            @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.FindRandomPointAroundCircle(System.Int64,Vector3,System.Single,DotRecast.Detour.IDtQueryFilter,System.Random,System.Int64@,Vector3@)">
            Returns random location on navmesh within the reach of specified location.
            Polygons are chosen weighted by area. The search runs in linear related to number of polygon.
            The location is not exactly constrained by the circle, but it limits the visited polygons.
             @param[in]		startRef		The reference id of the polygon where the search starts.
             @param[in]		centerPos		The center of the search circle. [(x, y, z)]
             @param[in]		maxRadius		The radius of the search circle. [Units: wu]
             @param[in]		filter			The polygon filter to apply to the query.
             @param[in]		frand			Function returning a random number [0..1).
             @param[out]	randomRef		The reference id of the random location.
             @param[out]	randomPt		The random location. [(x, y, z)]
            @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.FindRandomPointWithinCircle(System.Int64,Vector3,System.Single,DotRecast.Detour.IDtQueryFilter,System.Random,System.Int64@,Vector3@)">
             Returns random location on navmesh within the reach of specified location. Polygons are chosen weighted by area.
             The search runs in linear related to number of polygon. The location is strictly constrained by the circle.
            
             @param startRef
                        The reference id of the polygon where the search starts.
             @param centerPos
                        The center of the search circle. [(x, y, z)]
             @param maxRadius
             @param filter
                        The polygon filter to apply to the query.
             @param frand
                        Function returning a random number [0..1).
             @return Random location
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.FindRandomPointAroundCircle(System.Int64,Vector3,System.Single,DotRecast.Detour.IDtQueryFilter,System.Random,DotRecast.Detour.IDtPolygonByCircleConstraint,System.Int64@,Vector3@)">
            Returns random location on navmesh within the reach of specified location.
            Polygons are chosen weighted by area. The search runs in linear related to number of polygon.
            The location is not exactly constrained by the circle, but it limits the visited polygons.
             @param[in]		startRef		The reference id of the polygon where the search starts.
             @param[in]		centerPos		The center of the search circle. [(x, y, z)]
             @param[in]		maxRadius		The radius of the search circle. [Units: wu]
             @param[in]		filter			The polygon filter to apply to the query.
             @param[in]		frand			Function returning a random number [0..1).
             @param[in]		constraint      
             @param[out]	randomRef		The reference id of the random location.
             @param[out]	randomPt		The random location. [(x, y, z)]
            @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.ClosestPointOnPoly(System.Int64,Vector3,Vector3@,System.Boolean@)">
             @par
            
             Uses the detail polygons to find the surface height. (Most accurate.)
            
             @p pos does not have to be within the bounds of the polygon or navigation mesh.
            
             See closestPointOnPolyBoundary() for a limited but faster option.
            
             Finds the closest point on the specified polygon.
              @param[in]		ref			The reference id of the polygon.
              @param[in]		pos			The position to check. [(x, y, z)]
              @param[out]	closest		The closest point on the polygon. [(x, y, z)]
              @param[out]	posOverPoly	True of the position is over the polygon.
             @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.ClosestPointOnPolyBoundary(System.Int64,Vector3,Vector3@)">
             @par
            
             Much faster than ClosestPointOnPoly().
            
             If the provided position lies within the polygon's xz-bounds (above or below), 
             then @p pos and @p closest will be equal.
            
             The height of @p closest will be the polygon boundary.  The height detail is not used.
             
             @p pos does not have to be within the bounds of the polybon or the navigation mesh.
             
             Returns a point on the boundary closest to the source point if the source point is outside the 
             polygon's xz-bounds.
              @param[in]		ref			The reference id to the polygon.
              @param[in]		pos			The position to check. [(x, y, z)]
              @param[out]	closest		The closest point. [(x, y, z)]
             @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.GetPolyHeight(System.Int64,Vector3,System.Single@)">
             @par
            
             Will return #DT_FAILURE if the provided position is outside the xz-bounds
             of the polygon.
            
             Gets the height of the polygon at the provided position using the height detail. (Most accurate.)
             @param[in] ref The reference id of the polygon.
             @param[in] pos A position within the xz-bounds of the polygon. [(x, y, z)]
             @param[out] height The height at the surface of the polygon.
             @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.FindNearestPoly(Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,System.Int64@,Vector3@,System.Boolean@)">
            Finds the polygon nearest to the specified center point.
            [opt] means the specified parameter can be a null pointer, in that case the output parameter will not be set.
            
             @param[in]		center		The center of the search box. [(x, y, z)]
             @param[in]		halfExtents	The search distance along each axis. [(x, y, z)]
             @param[in]		filter		The polygon filter to apply to the query.
             @param[out]	nearestRef	The reference id of the nearest polygon. Will be set to 0 if no polygon is found.
             @param[out]	nearestPt	The nearest point on the polygon. Unchanged if no polygon is found. [opt] [(x, y, z)]
             @param[out]	isOverPoly 	Set to true if the point's X/Z coordinate lies inside the polygon, false otherwise. Unchanged if no polygon is found. [opt]
            @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.QueryPolygonsInTile(DotRecast.Detour.DtMeshTile,Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,DotRecast.Detour.IDtPolyQuery)">
            Queries polygons within a tile.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.QueryPolygons(Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,System.Int64[],System.Int32@,System.Int32)">
             @par 
            
             If no polygons are found, the function will return #DT_SUCCESS with a
             @p polyCount of zero.
            
             If @p polys is too small to hold the entire result set, then the array will 
             be filled to capacity. The method of choosing which polygons from the 
             full set are included in the partial result set is undefined.
            
             Finds polygons that overlap the search box.
              @param[in]		center		The center of the search box. [(x, y, z)]
              @param[in]		halfExtents		The search distance along each axis. [(x, y, z)]
              @param[in]		filter		The polygon filter to apply to the query.
              @param[out]	polys		The reference ids of the polygons that overlap the query box.
              @param[out]	polyCount	The number of polygons in the search result.
              @param[in]		maxPolys	The maximum number of polygons the search result can hold.
             @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.QueryPolygons(Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,DotRecast.Detour.IDtPolyQuery)">
             @par 
            
             The query will be invoked with batches of polygons. Polygons passed
             to the query have bounding boxes that overlap with the center and halfExtents
             passed to this function. The dtPolyQuery::process function is invoked multiple
             times until all overlapping polygons have been processed.
            
             Finds polygons that overlap the search box.
              @param[in]		center		The center of the search box. [(x, y, z)]
              @param[in]		halfExtents		The search distance along each axis. [(x, y, z)]
              @param[in]		filter		The polygon filter to apply to the query.
              @param[in]		query		The query. Polygons found will be batched together and passed to this query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.FindPath(System.Int64,System.Int64,Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,System.Collections.Generic.List{System.Int64}@,DotRecast.Detour.DtFindPathOption)">
             @par
            
             If the end polygon cannot be reached through the navigation graph,
             the last polygon in the path will be the nearest the end polygon.
            
             If the path array is to small to hold the full result, it will be filled as 
             far as possible from the start polygon toward the end polygon.
            
             The start and end positions are used to calculate traversal costs. 
             (The y-values impact the result.)
            
             @name Standard Pathfinding Functions
             @{
             Finds a path from the start polygon to the end polygon.
              @param[in]		startRef	The reference id of the start polygon.
              @param[in]		endRef		The reference id of the end polygon.
              @param[in]		startPos	A position within the start polygon. [(x, y, z)]
              @param[in]		endPos		A position within the end polygon. [(x, y, z)]
              @param[in]		filter		The polygon filter to apply to the query.
              @param[out]	path		An ordered list of polygon references representing the path. (Start to end.) 
              							[(polyRef) * @p pathCount]
              @param[out]	pathCount	The number of polygons returned in the @p path array.
              @param[in]		maxPath		The maximum number of polygons the @p path array can hold. [Limit: &gt;= 1]
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.InitSlicedFindPath(System.Int64,System.Int64,Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,System.Int32)">
            @}
             @name Sliced Pathfinding Functions
             Common use case:
            	-# Call initSlicedFindPath() to initialize the sliced path query.
            	-# Call updateSlicedFindPath() until it returns complete.
            	-# Call finalizeSlicedFindPath() to get the path.
            @{ 
             Initializes a sliced path query.
              @param[in]		startRef	The reference id of the start polygon.
              @param[in]		endRef		The reference id of the end polygon.
              @param[in]		startPos	A position within the start polygon. [(x, y, z)]
              @param[in]		endPos		A position within the end polygon. [(x, y, z)]
              @param[in]		filter		The polygon filter to apply to the query.
              @param[in]		options		query options (see: #dtFindPathOptions)
             @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.UpdateSlicedFindPath(System.Int32,System.Int32@)">
            Updates an in-progress sliced path query.
             @param[in]		maxIter		The maximum number of iterations to perform.
             @param[out]	doneIters	The actual number of iterations completed. [opt]
            @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.FinalizeSlicedFindPath(System.Collections.Generic.List{System.Int64}@)">
            Finalizes and returns the results of a sliced path query.
             @param[out]	path		An ordered list of polygon references representing the path. (Start to end.) 
             							[(polyRef) * @p pathCount]
             @param[out]	pathCount	The number of polygons returned in the @p path array.
             @param[in]		maxPath		The max number of polygons the path array can hold. [Limit: &gt;= 1]
            @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.FinalizeSlicedFindPathPartial(System.Collections.Generic.List{System.Int64},System.Int32,System.Collections.Generic.List{System.Int64}@)">
            Finalizes and returns the results of an incomplete sliced path query, returning the path to the furthest
            polygon on the existing path that was visited during the search.
             @param[in]		existing		An array of polygon references for the existing path.
             @param[in]		existingSize	The number of polygon in the @p existing array.
             @param[out]	path			An ordered list of polygon references representing the path. (Start to end.) 
             								[(polyRef) * @p pathCount]
             @param[out]	pathCount		The number of polygons returned in the @p path array.
             @param[in]		maxPath			The max number of polygons the @p path array can hold. [Limit: &gt;= 1]
            @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.FindStraightPath(Vector3,Vector3,System.Collections.Generic.List{System.Int64},System.Int32,System.Span{DotRecast.Detour.DtStraightPath},System.Int32@,System.Int32,System.Int32)">
             @par
             
             This method peforms what is often called 'string pulling'.
            
             The start position is clamped to the first polygon in the path, and the 
             end position is clamped to the last. So the start and end positions should 
             normally be within or very near the first and last polygons respectively.
            
             The returned polygon references represent the reference id of the polygon 
             that is entered at the associated path position. The reference id associated 
             with the end point will always be zero.  This allows, for example, matching 
             off-mesh link points to their representative polygons.
            
             If the provided result buffers are too small for the entire result set, 
             they will be filled as far as possible from the start toward the end 
             position.
            
             Finds the straight path from the start to the end position within the polygon corridor.
              @param[in]		startPos			Path start position. [(x, y, z)]
              @param[in]		endPos				Path end position. [(x, y, z)]
              @param[in]		path				An array of polygon references that represent the path corridor.
              @param[in]		pathSize			The number of polygons in the @p path array.
              @param[out]	straightPath		Points describing the straight path. [(x, y, z) * @p straightPathCount].
              @param[in]		maxStraightPath		The maximum number of points the straight path arrays can hold.  [Limit: &gt; 0]
              @param[in]		options				Query options. (see: #dtStraightPathOptions)
             @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.MoveAlongSurface(System.Int64,Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,Vector3@,System.Span{System.Int64},System.Int32@,System.Int32)">
             @par
            
             This method is optimized for small delta movement and a small number of 
             polygons. If used for too great a distance, the result set will form an 
             incomplete path.
            
             @p resultPos will equal the @p endPos if the end is reached. 
             Otherwise the closest reachable position will be returned.
             
             @p resultPos is not projected onto the surface of the navigation 
             mesh. Use #getPolyHeight if this is needed.
            
             This method treats the end position in the same manner as 
             the #raycast method. (As a 2D point.) See that method's documentation 
             for details.
             
             If the @p visited array is too small to hold the entire result set, it will 
             be filled as far as possible from the start position toward the end 
             position.
            
             Moves from the start to the end position constrained to the navigation mesh.
              @param[in]		startRef		The reference id of the start polygon.
              @param[in]		startPos		A position of the mover within the start polygon. [(x, y, x)]
              @param[in]		endPos			The desired end position of the mover. [(x, y, z)]
              @param[in]		filter			The polygon filter to apply to the query.
              @param[out]	resultPos		The result position of the mover. [(x, y, z)]
              @param[out]	visited			The reference ids of the polygons visited during the move.
              @param[out]	visitedCount	The number of polygons visited during the move.
              @param[in]		maxVisitedSize	The maximum number of polygons the @p visited array can hold.
             @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.Raycast(System.Int64,Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,System.Single@,Vector3@,System.Collections.Generic.List{System.Int64}@)">
             @par
            
             This method is meant to be used for quick, short distance checks.
            
             If the path array is too small to hold the result, it will be filled as 
             far as possible from the start postion toward the end position.
            
             <b>Using the Hit Parameter (t)</b>
             
             If the hit parameter is a very high value (FLT_MAX), then the ray has hit 
             the end position. In this case the path represents a valid corridor to the 
             end position and the value of @p hitNormal is undefined.
            
             If the hit parameter is zero, then the start position is on the wall that 
             was hit and the value of @p hitNormal is undefined.
            
             If 0 &lt; t &lt; 1.0 then the following applies:
            
             @code
             distanceToHitBorder = distanceToEndPosition * t
             hitPoint = startPos + (endPos - startPos) * t
             @endcode
            
             <b>Use Case Restriction</b>
            
             The raycast ignores the y-value of the end position. (2D check.) This 
             places significant limits on how it can be used. For example:
            
             Consider a scene where there is a main floor with a second floor balcony 
             that hangs over the main floor. So the first floor mesh extends below the 
             balcony mesh. The start position is somewhere on the first floor. The end 
             position is on the balcony.
            
             The raycast will search toward the end position along the first floor mesh. 
             If it reaches the end position's xz-coordinates it will indicate FLT_MAX
             (no wall hit), meaning it reached the end position. This is one example of why
             this method is meant for short distance checks.
            
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.Raycast(System.Int64,Vector3,Vector3,DotRecast.Detour.IDtQueryFilter,System.Int32,DotRecast.Detour.DtRaycastHit@,System.Int64)">
             @par
            
             This method is meant to be used for quick, short distance checks.
            
             If the path array is too small to hold the result, it will be filled as 
             far as possible from the start postion toward the end position.
            
             <b>Using the Hit Parameter t of RaycastHit</b>
             
             If the hit parameter is a very high value (FLT_MAX), then the ray has hit 
             the end position. In this case the path represents a valid corridor to the 
             end position and the value of @p hitNormal is undefined.
            
             If the hit parameter is zero, then the start position is on the wall that 
             was hit and the value of @p hitNormal is undefined.
            
             If 0 &lt; t &lt; 1.0 then the following applies:
            
             @code
             distanceToHitBorder = distanceToEndPosition * t
             hitPoint = startPos + (endPos - startPos) * t
             @endcode
            
             <b>Use Case Restriction</b>
            
             The raycast ignores the y-value of the end position. (2D check.) This 
             places significant limits on how it can be used. For example:
            
             Consider a scene where there is a main floor with a second floor balcony 
             that hangs over the main floor. So the first floor mesh extends below the 
             balcony mesh. The start position is somewhere on the first floor. The end 
             position is on the balcony.
            
             The raycast will search toward the end position along the first floor mesh. 
             If it reaches the end position's xz-coordinates it will indicate FLT_MAX
             (no wall hit), meaning it reached the end position. This is one example of why
             this method is meant for short distance checks.
            
             Casts a 'walkability' ray along the surface of the navigation mesh from 
             the start position toward the end position.
              @param[in]		startRef	The reference id of the start polygon.
              @param[in]		startPos	A position within the start polygon representing 
              							the start of the ray. [(x, y, z)]
              @param[in]		endPos		The position to cast the ray toward. [(x, y, z)]
              @param[in]		filter		The polygon filter to apply to the query.
              @param[in]		options		govern how the raycast behaves. See dtRaycastOptions
              @param[out]	hit			Pointer to a raycast hit structure which will be filled by the results.
              @param[in]		prevRef		parent of start ref. Used during for cost calculation [opt]
             @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.FindPolysAroundCircle(System.Int64,Vector3,System.Single,DotRecast.Detour.IDtQueryFilter,System.Collections.Generic.List{System.Int64}@,System.Collections.Generic.List{System.Int64}@,System.Collections.Generic.List{System.Single}@)">
             @par
            
             At least one result array must be provided.
            
             The order of the result set is from least to highest cost to reach the polygon.
            
             A common use case for this method is to perform Dijkstra searches.
             Candidate polygons are found by searching the graph beginning at the start polygon.
            
             If a polygon is not found via the graph search, even if it intersects the
             search circle, it will not be included in the result set. For example:
            
             polyA is the start polygon.
             polyB shares an edge with polyA. (Is adjacent.)
             polyC shares an edge with polyB, but not with polyA
             Even if the search circle overlaps polyC, it will not be included in the
             result set unless polyB is also in the set.
            
             The value of the center point is used as the start position for cost
             calculations. It is not projected onto the surface of the mesh, so its
             y-value will effect the costs.
            
             Intersection tests occur in 2D. All polygons and the search circle are
             projected onto the xz-plane. So the y-value of the center point does not
             effect intersection tests.
            
             If the result arrays are to small to hold the entire result set, they will be
             filled to capacity.
            
            @}
             @name Dijkstra Search Functions
             @{ 
             Finds the polygons along the navigation graph that touch the specified circle.
              @param[in]		startRef		The reference id of the polygon where the search starts.
              @param[in]		centerPos		The center of the search circle. [(x, y, z)]
              @param[in]		radius			The radius of the search circle.
              @param[in]		filter			The polygon filter to apply to the query.
              @param[out]	resultRef		The reference ids of the polygons touched by the circle. [opt]
              @param[out]	resultParent	The reference ids of the parent polygons for each result. 
              								Zero if a result polygon has no parent. [opt]
              @param[out]	resultCost		The search cost from @p centerPos to the polygon. [opt]
              @param[out]	resultCount		The number of polygons found. [opt]
              @param[in]		maxResult		The maximum number of polygons the result arrays can hold.
             @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.FindPolysAroundShape(System.Int64,Vector3[],DotRecast.Detour.IDtQueryFilter,System.Collections.Generic.List{System.Int64}@,System.Collections.Generic.List{System.Int64}@,System.Collections.Generic.List{System.Single}@)">
             @par
            
             The order of the result set is from least to highest cost.
             
             At least one result array must be provided.
            
             A common use case for this method is to perform Dijkstra searches. 
             Candidate polygons are found by searching the graph beginning at the start 
             polygon.
             
             The same intersection test restrictions that apply to findPolysAroundCircle()
             method apply to this method.
             
             The 3D centroid of the search polygon is used as the start position for cost 
             calculations.
             
             Intersection tests occur in 2D. All polygons are projected onto the 
             xz-plane. So the y-values of the vertices do not effect intersection tests.
             
             If the result arrays are is too small to hold the entire result set, they will 
             be filled to capacity.
            
             Finds the polygons along the naviation graph that touch the specified convex polygon.
              @param[in]		startRef		The reference id of the polygon where the search starts.
              @param[in]		verts			The vertices describing the convex polygon. (CCW) 
              								[(x, y, z) * @p nverts]
              @param[in]		nverts			The number of vertices in the polygon.
              @param[in]		filter			The polygon filter to apply to the query.
              @param[out]	resultRef		The reference ids of the polygons touched by the search polygon. [opt]
              @param[out]	resultParent	The reference ids of the parent polygons for each result. Zero if a 
              								result polygon has no parent. [opt]
              @param[out]	resultCost		The search cost from the centroid point to the polygon. [opt]
              @param[out]	resultCount		The number of polygons found.
              @param[in]		maxResult		The maximum number of polygons the result arrays can hold.
             @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.FindLocalNeighbourhood(System.Int64,Vector3,System.Single,DotRecast.Detour.IDtQueryFilter,System.Collections.Generic.List{System.Int64}@,System.Collections.Generic.List{System.Int64}@)">
             @par
            
             This method is optimized for a small search radius and small number of result 
             polygons.
            
             Candidate polygons are found by searching the navigation graph beginning at 
             the start polygon.
            
             The same intersection test restrictions that apply to the findPolysAroundCircle 
             mehtod applies to this method.
            
             The value of the center point is used as the start point for cost calculations. 
             It is not projected onto the surface of the mesh, so its y-value will effect 
             the costs.
             
             Intersection tests occur in 2D. All polygons and the search circle are 
             projected onto the xz-plane. So the y-value of the center point does not 
             effect intersection tests.
             
             If the result arrays are is too small to hold the entire result set, they will 
             be filled to capacity.
             
             Finds the non-overlapping navigation polygons in the local neighbourhood around the center position.
              @param[in]		startRef		The reference id of the polygon where the search starts.
              @param[in]		centerPos		The center of the query circle. [(x, y, z)]
              @param[in]		radius			The radius of the query circle.
              @param[in]		filter			The polygon filter to apply to the query.
              @param[out]	resultRef		The reference ids of the polygons touched by the circle.
              @param[out]	resultParent	The reference ids of the parent polygons for each result. 
             @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.GetPolyWallSegments(System.Int64,DotRecast.Detour.IDtQueryFilter,System.Span{DotRecast.Detour.RcSegmentVert},System.Span{System.Int64},System.Int32@,System.Int32)">
             @par
            
             If the @p segmentRefs parameter is provided, then all polygon segments will be returned. 
             Otherwise only the wall segments are returned.
             
             A segment that is normally a portal will be included in the result set as a 
             wall if the @p filter results in the neighbor polygon becoomming impassable.
             
             The @p segmentVerts and @p segmentRefs buffers should normally be sized for the 
             maximum segments per polygon of the source navigation mesh.
             
             Returns the segments for the specified polygon, optionally including portals.
              @param[in]		ref				The reference id of the polygon.
              @param[in]		filter			The polygon filter to apply to the query.
              @param[out]	segmentVerts	The segments. [(ax, ay, az, bx, by, bz) * segmentCount]
              @param[out]	segmentRefs		The reference ids of each segment's neighbor polygon. 
              								Or zero if the segment is a wall. [opt] [(parentRef) * @p segmentCount] 
              @param[out]	segmentCount	The number of segments returned.
              @param[in]		maxSegments		The maximum number of segments the result arrays can hold.
             @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.FindDistanceToWall(System.Int64,Vector3,System.Single,DotRecast.Detour.IDtQueryFilter,System.Single@,Vector3@,Vector3@)">
             @par
            
             @p hitPos is not adjusted using the height detail data.
            
             @p hitDist will equal the search radius if there is no wall within the
             radius. In this case the values of @p hitPos and @p hitNormal are
             undefined.
            
             The normal will become unpredicable if @p hitDist is a very small number.
            
             Finds the distance from the specified position to the nearest polygon wall.
              @param[in]		startRef		The reference id of the polygon containing @p centerPos.
              @param[in]		centerPos		The center of the search circle. [(x, y, z)]
              @param[in]		maxRadius		The radius of the search circle.
              @param[in]		filter			The polygon filter to apply to the query.
              @param[out]	hitDist			The distance to the nearest wall from @p centerPos.
              @param[out]	hitPos			The nearest position on the wall that was hit. [(x, y, z)]
              @param[out]	hitNormal		The normalized ray formed from the wall point to the 
              								source point. [(x, y, z)]
             @returns The status flags for the query.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.IsValidPolyRef(System.Int64,DotRecast.Detour.IDtQueryFilter)">
            Returns true if the polygon reference is valid and passes the filter restrictions.
            @param[in] ref The polygon reference to check.
            @param[in] filter The filter to apply.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.GetAttachedNavMesh">
            Gets the navigation mesh the query object is using.
            @return The navigation mesh the query object is using.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.GetPathFromDijkstraSearch(System.Int64,System.Collections.Generic.List{System.Int64}@)">
            Gets a path from the explored nodes in the previous search.
             @param[in]		endRef		The reference id of the end polygon.
             @param[out]	path		An ordered list of polygon references representing the path. (Start to end.)
             							[(polyRef) * @p pathCount]
             @param[out]	pathCount	The number of polygons returned in the @p path array.
             @param[in]		maxPath		The maximum number of polygons the @p path array can hold. [Limit: &gt;= 0]
             @returns		The status flags. Returns DT_FAILURE | DT_INVALID_PARAM if any parameter is wrong, or if
             				@p endRef was not explored in the previous search. Returns DT_SUCCESS | DT_BUFFER_TOO_SMALL
             				if @p path cannot contain the entire path. In this case it is filled to capacity with a partial path.
             				Otherwise returns DT_SUCCESS.
             @remarks		The result of this function depends on the state of the query object. For that reason it should only
             				be used immediately after one of the two Dijkstra searches, findPolysAroundCircle or findPolysAroundShape.
        </member>
    <member name="M:DotRecast.Detour.DtNavMeshQuery.IsInClosedList(System.Int64)">
             @par
            
             The closed list is the list of polygons that were fully evaluated during 
             the last navigation graph search. (A* or Dijkstra)
             
        </member>
    <member name="T:DotRecast.Detour.DtNavMeshRaycast">
            Simple helper to find an intersection between a ray and a nav mesh
        </member>
    <member name="T:DotRecast.Detour.DtOffMeshConnection">
            Defines an navigation mesh off-mesh connection within a dtMeshTile object.
            An off-mesh connection is a user defined traversable connection made up to two vertices.
        </member>
    <member name="F:DotRecast.Detour.DtOffMeshConnection.rad">
            The radius of the endpoints. [Limit: &gt;= 0]
        </member>
    <member name="F:DotRecast.Detour.DtOffMeshConnection.poly">
            The polygon reference of the connection within the tile.
        </member>
    <member name="F:DotRecast.Detour.DtOffMeshConnection.side">
            End point side.
        </member>
    <member name="F:DotRecast.Detour.DtOffMeshConnection.userData">
            The id of the offmesh connection. (User assigned when the navigation mesh is built.)
        </member>
    <member name="T:DotRecast.Detour.DtPoly">
            Defines a polygon within a dtMeshTile object.
            @ingroup detour
        </member>
    <member name="F:DotRecast.Detour.DtPoly.firstLink">
            Index to first link in linked list. (Or #DT_NULL_LINK if there is no link.)
        </member>
    <member name="F:DotRecast.Detour.DtPoly.verts">
            The indices of the polygon's vertices.
            The actual vertices are located in dtMeshTile::verts.
        </member>
    <member name="F:DotRecast.Detour.DtPoly.neis">
            Packed data representing neighbor polygons references and flags for each edge.
        </member>
    <member name="F:DotRecast.Detour.DtPoly.flags">
            The user defined polygon flags.
        </member>
    <member name="F:DotRecast.Detour.DtPoly.vertCount">
            The number of vertices in the polygon.
        </member>
    <member name="F:DotRecast.Detour.DtPoly.areaAndtype">
            The bit packed area id and polygon type.
            @note Use the structure's set and get methods to access this value.
        </member>
    <member name="M:DotRecast.Detour.DtPoly.SetArea(System.Int32)">
            Sets the user defined area id. [Limit: &lt; #DT_MAX_AREAS]
        </member>
    <member name="M:DotRecast.Detour.DtPoly.SetPolyType(System.Int32)">
            Sets the polygon type. (See: #dtPolyTypes.)
        </member>
    <member name="M:DotRecast.Detour.DtPoly.GetArea">
            Gets the user defined area id.
        </member>
    <member name="M:DotRecast.Detour.DtPoly.GetPolyType">
            Gets the polygon type. (See: #dtPolyTypes)
        </member>
    <member name="T:DotRecast.Detour.DtPolyDetail">
            Defines the location of detail sub-mesh data within a dtMeshTile.
        </member>
    <member name="T:DotRecast.Detour.DtPolyTypes">
            Flags representing the type of a navigation mesh polygon.
        </member>
    <member name="T:DotRecast.Detour.DtQueryDefaultFilter">
      <b>The Default Implementation</b>
            
             At construction: All area costs default to 1.0. All flags are included and none are excluded.
            
             If a polygon has both an include and an exclude flag, it will be excluded.
            
             The way filtering works, a navigation mesh polygon must have at least one flag set to ever be considered by a query.
             So a polygon with no flags will never be considered.
            
             Setting the include flags to 0 will result in all polygons being excluded.
            
             <b>Custom Implementations</b>
            
             Implement a custom query filter by overriding the virtual PassFilter() and GetCost() functions. If this is done, both
             functions should be as fast as possible. Use cached local copies of data rather than accessing your own objects where
             possible.
            
             Custom implementations do not need to adhere to the flags or cost logic used by the default implementation.
            
             In order for A* searches to work properly, the cost should be proportional to the travel distance. Implementing a
             cost modifier less than 1.0 is likely to lead to problems during pathfinding.
            
             @see NavMeshQuery
        </member>
    <member name="T:DotRecast.Detour.DtRaycastHit">
            Provides information about raycast hit
            filled by dtNavMeshQuery::raycast
            @ingroup detour
        </member>
    <member name="F:DotRecast.Detour.DtRaycastHit.t">
            The hit parameter. (FLT_MAX if no wall hit.)
        </member>
    <member name="F:DotRecast.Detour.DtRaycastHit.hitNormal">
            hitNormal	The normal of the nearest wall hit. [(x, y, z)]
        </member>
    <member name="F:DotRecast.Detour.DtRaycastHit.hitEdgeIndex">
            The index of the edge on the final polygon where the wall was hit.
        </member>
    <member name="F:DotRecast.Detour.DtRaycastHit.path">
            Pointer to an array of reference ids of the visited polygons. [opt]
        </member>
    <member name="F:DotRecast.Detour.DtRaycastHit.pathCost">
             The cost of the path until hit.
        </member>
    <member name="T:DotRecast.Detour.DtRaycastOptions">
            Options for dtNavMeshQuery::raycast
        </member>
    <member name="F:DotRecast.Detour.DtStraightPath.pos">
            The local path corridor corners for the agent. (Staight path.) [(x, y, z) * #ncorners]
        </member>
    <member name="F:DotRecast.Detour.DtStraightPath.flags">
            The local path corridor corner flags. (See: #dtStraightPathFlags) [(flags) * #ncorners]
        </member>
    <member name="F:DotRecast.Detour.DtStraightPath.refs">
            The reference id of the polygon being entered at the corner. [(polyRef) * #ncorners]
        </member>
    <member name="T:DotRecast.Detour.DtStraightPathFlags">
            Vertex flags returned by dtNavMeshQuery::findStraightPath.
        </member>
    <member name="T:DotRecast.Detour.DtStraightPathOptions">
            Options for dtNavMeshQuery::findStraightPath.
        </member>
    <member name="M:DotRecast.Detour.DtUtils.OverlapQuantBounds(Vector3Int@,Vector3Int@,Vector3Int@,Vector3Int@)">
            Determines if two axis-aligned bounding boxes overlap.
            @param[in] amin Minimum bounds of box A. [(x, y, z)]
            @param[in] amax Maximum bounds of box A. [(x, y, z)]
            @param[in] bmin Minimum bounds of box B. [(x, y, z)]
            @param[in] bmax Maximum bounds of box B. [(x, y, z)]
            @return True if the two AABB's overlap.
            @see dtOverlapBounds
        </member>
    <member name="M:DotRecast.Detour.DtUtils.OverlapBounds(Vector3,Vector3,Vector3,Vector3)">
            Determines if two axis-aligned bounding boxes overlap.
            @param[in] amin Minimum bounds of box A. [(x, y, z)]
            @param[in] amax Maximum bounds of box A. [(x, y, z)]
            @param[in] bmin Minimum bounds of box B. [(x, y, z)]
            @param[in] bmax Maximum bounds of box B. [(x, y, z)]
            @return True if the two AABB's overlap.
            @see dtOverlapQuantBounds
        </member>
    <member name="M:DotRecast.Detour.DtUtils.OverlapPolyPoly2D(System.Span{Vector3},System.Span{Vector3})">
             @par
            
             All vertices are projected onto the xz-plane, so the y-values are ignored.
        </member>
    <member name="M:DotRecast.Detour.DtUtils.TriArea2D(Vector3,Vector3,Vector3)">
            @}
            @name Computational geometry helper functions.
            @{
            Derives the signed xz-plane area of the triangle ABC, or the
            relationship of line AB to point C.
            @param[in] a Vertex A. [(x, y, z)]
            @param[in] b Vertex B. [(x, y, z)]
            @param[in] c Vertex C. [(x, y, z)]
            @return The signed xz-plane area of the triangle.
        </member>
    <member name="M:DotRecast.Detour.DtUtils.PointInPolygon(Vector3,System.Span{Vector3})">
             @par
            
             All points are projected onto the xz-plane, so the y-values are ignored.
        </member>
    <member name="M:DotRecast.Detour.DtUtils.Perp2D(Vector3,Vector3)">
             Derives the xz-plane 2D perp product of the two vectors. (uz*vx - ux*vz)
             @param[in] u The LHV vector [(x, y, z)]
             @param[in] v The RHV vector [(x, y, z)]
             @return The dot product on the xz-plane.
            
             The vectors are projected onto the xz-plane, so the y-values are
             ignored.
             TODO should be called DOT2D
        </member>
    <member name="T:DotRecast.Detour.IDtPolyQuery">
            Provides custom polygon query behavior.
            Used by dtNavMeshQuery::queryPolygons.
            @ingroup detour
        </member>
    <member name="M:DotRecast.Detour.IDtPolyQuery.Process(DotRecast.Detour.DtMeshTile,DotRecast.Detour.DtPoly[],System.Span{System.Int64},System.Int32)">
            Called for each batch of unique polygons touched by the search area in dtNavMeshQuery::queryPolygons.
            This can be called multiple times for a single query.
        </member>
    <member name="F:NavMeshParams_t.tileSizeXY">
      <summary>
            The size of the tiles on the xz-plane. [Limit: &gt;= 0]
            </summary>
    </member>
    <member name="F:NavMeshParams_t.maxTiles">
      <summary>
            The number of tiles along the xy axis.
            </summary>
    </member>
    <member name="F:NavMeshParams_t.origin">
      <summary>
            The world space origin of the navigation mesh's tile space. [(x, y, z)]
            </summary>
    </member>
    <member name="F:NavMeshParams_t.maxAgentRadius">
      <summary>
            The maximum radius of any agent that will be added to the crowd. [Limit: &gt; 0]
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.tileX">
      <summary>
            The tiles x position in tile coordinates.
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.tileY">
      <summary>
            The tiles y position in tile coordinates.
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.tileSizeXY">
      <summary>
            The width/height size of tile's on the xy-plane. [Limit: &gt;= 0] [Units: vx]
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.borderSize">
      <summary>
            The size of the non-navigable border around the heightfield. [Limit: &gt;=0] [Units: vx]
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.cellSize">
      <summary>
            The xz-plane cell size to use for fields. [Limit: &gt; 0] [Units: wu]
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.cellHeight">
      <summary>
            The y-axis cell size to use for fields. [Limit: &gt; 0] [Units: wu]
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.bounds">
      <summary>
            The bounds of the field's AABB. [Units: wu]
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.walkableSlopeAngle">
      <summary>
            The maximum slope that is considered walkable. [Limits: 0 &lt;= value &lt; 90] [Units: Degrees]
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.walkableHeight">
      <summary>
            Minimum floor to 'ceiling' height that will still allow the floor area to 
            be considered walkable. [Limit: &gt;= 3] [Units: vx]
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.walkableClimb">
      <summary>
            Maximum ledge height that is considered to still be traversable. [Limit: &gt;=0] [Units: vx]
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.walkableRadius">
      <summary>
            The distance to erode/shrink the walkable area of the heightfield away from 
            obstructions.  [Limit: &gt;=0] [Units: vx]
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.maxEdgeLen">
      <summary>
            The maximum allowed length for contour edges along the border of the mesh. [Limit: &gt;=0] [Units: vx]
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.maxSimplificationError">
      <summary>
            The maximum distance a simplified contour's border edges should deviate 
            the original raw contour. [Limit: &gt;=0] [Units: vx]
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.minRegionArea">
      <summary>
            The minimum number of cells allowed to form isolated island areas. [Limit: &gt;=0] [Units: vx]
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.mergeRegionArea">
      <summary>
            Any regions with a span count smaller than this value will, if possible, 
            be merged with larger regions. [Limit: &gt;=0] [Units: vx]
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.maxVertsPerPoly">
      <summary>
            The maximum number of vertices allowed for polygons generated during the 
            contour to polygon conversion process. [Limit: &gt;= 3] 
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.detailSampleDist">
      <summary>
            Sets the sampling distance to use when generating the detail mesh.
            (For height detail only.) [Limits: 0 or &gt;= 0.9] [Units: wu]
            </summary>
    </member>
    <member name="F:NavTileGenConfig_t.detailSampleMaxError">
      <summary>
            The maximum distance the detail mesh surface should deviate from heightfield
            data. (For height detail only.) [Limit: &gt;=0] [Units: wu]
            </summary>
    </member>
    <member name="T:ConditionalVisibilityAttribute">
      <summary>
            Hide a property if a condition matches.
            </summary>
    </member>
    <member name="M:ConditionalVisibilityAttribute.TestCondition(System.Object,Sandbox.TypeDescription)">
      <summary>
            The test condition.
            </summary>
      <param name="targetObject">The class instance of the property this attribute is attached to.</param>
      <param name="td">Description of the <paramref name="targetObject" />'s type.</param>
      <returns>Return true if the property should be visible.</returns>
    </member>
    <member name="T:HideIfAttribute">
      <summary>
            Hide this property if a given property within the same class has the given value. Used typically in the Editor Inspector.
            </summary>
    </member>
    <member name="P:HideIfAttribute.PropertyName">
      <summary>
            Property name to test.
            </summary>
    </member>
    <member name="P:HideIfAttribute.Value">
      <summary>
            Property value to test against.
            </summary>
    </member>
    <member name="T:ShowIfAttribute">
      <summary>
            Show this property if a given property within the same class has the given value. Used typically in the Editor Inspector.
            </summary>
    </member>
    <member name="T:Editor.MetaDataAttribute">
      <summary>
            Base attribute which allows adding FGD metadata to classes.
            </summary>
    </member>
    <member name="T:Editor.FieldMetaDataAttribute">
      <summary>
            Base attribute which allows adding metadata to properties.
            </summary>
    </member>
    <member name="T:Editor.HidePropertyAttribute">
      <summary>
            A way to hide properties from parent classes in tools.
            </summary>
    </member>
    <member name="M:Editor.HidePropertyAttribute.#ctor(System.String)">
      <param name="internal_name">The internal/fgd name to skip. Usually all lowercase and with underscores (_) instead of spaces.</param>
    </member>
    <member name="T:Editor.EnableColorAlphaAttribute">
      <summary>
            If used on a Color or Color32 property, enables alpha modification in editors.
            </summary>
    </member>
    <member name="T:Editor.HammerEntityAttribute">
      <summary>
            This is an entity that can be placed in Hammer.
            </summary>
    </member>
    <member name="T:Editor.SolidAttribute">
      <summary>
            This is a brush based entity class. It can only be a mesh tied to an entity.
            </summary>
    </member>
    <member name="T:Editor.SupportsSolidAttribute">
      <summary>
            This is a point class entity, but does support being a brush entity (a mesh tied to an entity).
            </summary>
    </member>
    <member name="T:Editor.PhysicsConstraintAttribute">
      <summary>
            Marks this entity as a physics constraint.
            This disables pre-settle for all <see cref="T:Editor.PhysicsSimulatedAttribute">PhysicsSimulated</see> entities this entity's keyvalues reference in Hammer.
            </summary>
    </member>
    <member name="T:Editor.PathAttribute">
      <summary>
            This is a path class, used with Hammer's Path Tool.
            </summary>
    </member>
    <member name="M:Editor.PathAttribute.#ctor(System.String,System.Boolean)">
      <param name="nodeClassName">Class name of the node entity.</param>
      <param name="spawnEnts">If set to true, will actually create node entities. If set to false, node data will be serialized to a JSON key-value.</param>
    </member>
    <member name="T:Editor.PathNodeAttribute">
      <summary>
            This is a path node class. May not necessarily be an entity.
            </summary>
    </member>
    <member name="T:Editor.AutoApplyMaterialAttribute">
      <summary>
            Apply this material to the mesh when tying one to this class. Typically used for triggers.
            </summary>
    </member>
    <member name="T:Editor.ModelAttribute">
      <summary>
            This makes it so the model, skin and bodygroups can be set and changed in Hammer.
            </summary>
    </member>
    <member name="P:Editor.ModelAttribute.Model">
      <summary>
            The default model to be set to.
            </summary>
    </member>
    <member name="P:Editor.ModelAttribute.BodyGroup">
      <summary>
            The default body group to be set to.
            </summary>
    </member>
    <member name="P:Editor.ModelAttribute.MaterialGroup">
      <summary>
            The default material group to be set to.
            </summary>
    </member>
    <member name="P:Editor.ModelAttribute.Archetypes">
      <summary>
            Marks this entity as a representative of a certain model archetype.
            This makes this entity class appear in ModelDoc under given archetype(s), which will be used to decide which entity class to use when dragging models from Hammer's Asset browser.
            </summary>
    </member>
    <member name="T:Editor.EditorSpriteAttribute">
      <summary>
            Declare a sprite to represent this entity in Hammer.
            </summary>
      <example>
            [EditorSprite( "editor/ai_goal_follow.vmat" )]
            </example>
    </member>
    <member name="T:Editor.ParticleAttribute">
      <summary>
            Tells Hammer that this entity has a particle effect keyvalue that needs to be visualized.
            </summary>
    </member>
    <member name="T:Editor.PhysicsTypeOverrideMeshAttribute">
      <summary>
            Indicate to the map builder that any meshes associated with the entity should have a mesh physics type.
            </summary>
    </member>
    <member name="T:Editor.PhysicsSimulatedAttribute">
      <summary>
            Indicate if the entity is simulated in game and should participate in the pre-settle simulation during map compile.
            Adds a pre-settle keyvalue to this entity class.
            </summary>
    </member>
    <member name="T:Editor.SkyboxAttribute">
      <summary>
            Helper to render skybox in hammer
            </summary>
    </member>
    <member name="T:Editor.VisGroup">
      <summary>
            Used to tell Hammer which automatic Visibility Groups an entity should belong to. See <see cref="T:Editor.VisGroupAttribute">VisGroupAttribute</see>.
            </summary>
    </member>
    <member name="F:Editor.VisGroup.Lighting">
      <summary>
            Entities that are primarily lights and that sort of thing.
            </summary>
    </member>
    <member name="F:Editor.VisGroup.Sound">
      <summary>
            The purpose of these entities is to emit light and not much else.
            </summary>
    </member>
    <member name="F:Editor.VisGroup.Logic">
      <summary>
            Pure logic entities, typically not shown in-game.
            </summary>
    </member>
    <member name="F:Editor.VisGroup.Trigger">
      <summary>
            Any sort of trigger volume, these usually don't show up in-game.
            </summary>
    </member>
    <member name="F:Editor.VisGroup.Navigation">
      <summary>
            Entities that are related to nav meshes.
            </summary>
    </member>
    <member name="F:Editor.VisGroup.Particles">
      <summary>
            The main reason these exist is to create particle systems.
            </summary>
    </member>
    <member name="F:Editor.VisGroup.Physics">
      <summary>
            Physics enabled entities.
            </summary>
    </member>
    <member name="F:Editor.VisGroup.Dynamic">
      <summary>
            Entities that do not move via physics but are still intractable with or otherwise non static.
            </summary>
    </member>
    <member name="T:Editor.VisGroupAttribute">
      <summary>
            Makes the entity show up under given automatic visibility group in Hammer.
            </summary>
    </member>
    <member name="T:Editor.DrawAnglesAttribute">
      <summary>
            Draws the movement direction in Hammer.
            </summary>
      <example>
            [DrawAngles( "movedir", "movedir_islocal" )]
            </example>
    </member>
    <member name="T:Editor.DoorHelperAttribute">
      <summary>
            Draws the door movement and the final open position in Hammer.
            </summary>
    </member>
    <member name="T:Editor.RenderFieldsAttribute">
      <summary>
            Adds the render color and other related options to the entity class in Hammer.
            </summary>
      <example>
            [RenderFields]
            </example>
    </member>
    <member name="T:Editor.FrustumBoundlessAttribute">
      <summary>
            Draws a frustum that doesn't contribute to bounds calculations.
            </summary>
    </member>
    <member name="T:Editor.SphereAttribute">
      <summary>
            Displays a sphere in Hammer with a radius tied to given property and with given color.
            The sphere's radius can be manipulated in Hammer's 2D views. You can have multiple of these.
            </summary>
    </member>
    <member name="P:Editor.SphereAttribute.IsLean">
      <summary>
            If set to true, the sphere will appear as 3 circles in 3D view, rather than a wireframe sphere.
            </summary>
    </member>
    <member name="M:Editor.SphereAttribute.#ctor(System.String,System.UInt32,System.Boolean)">
      <param name="variableName">Name of the variable to use as sphere radius.</param>
      <param name="color">Color as an unsigned integer. For example 0xFF99CC, where 0xBBGGRR.</param>
      <param name="singleSelect">If this helper should show up when only 1 object is selected in Hammer.</param>
    </member>
    <member name="M:Editor.SphereAttribute.#ctor(System.String,System.String,System.Boolean)">
      <param name="variableName">Name of the variable to use as sphere radius.</param>
      <param name="color">Color as an unsigned integer. For example 0xFF99CC, where 0xBBGGRR.</param>
      <param name="singleSelect">If this helper should show up when only 1 object is selected in Hammer.</param>
    </member>
    <member name="M:Editor.SphereAttribute.#ctor(System.String,System.Byte,System.Byte,System.Byte,System.Boolean)">
      <param name="variableName">Name of the variable to use as sphere radius.</param>
      <param name="red">Red component of the sphere's color.</param>
      <param name="green">Green component of the sphere's color.</param>
      <param name="blue">Blue component of the sphere's color.</param>
      <param name="singleSelect">If this helper should show up when only 1 object is selected in Hammer.</param>
    </member>
    <member name="M:Editor.SphereAttribute.#ctor(System.Single,System.Byte,System.Byte,System.Byte,System.Boolean)">
      <param name="radius">Range of the sphere to show.</param>
      <param name="red">Red component of the sphere's color.</param>
      <param name="green">Green component of the sphere's color.</param>
      <param name="blue">Blue component of the sphere's color.</param>
      <param name="singleSelect">If this helper should show up when only 1 object is selected in Hammer.</param>
    </member>
    <member name="T:Editor.TextAttribute">
      <summary>
            Displays text in Hammer on the entity.
            </summary>
    </member>
    <member name="M:Editor.TextAttribute.#ctor(System.String,System.String,System.Boolean)">
      <param name="text">The text to display.</param>
      <param name="offsetVariable">The name of the property that will act as the position of the text.</param>
      <param name="worldspace">Whether the position from the variable should be interpreted in world space (true) or in local space (false).</param>
    </member>
    <member name="T:Editor.LineAttribute">
      <summary>
            Draws a line in Hammer. You can have multiple of this attribute.
            </summary>
    </member>
    <member name="M:Editor.LineAttribute.#ctor(System.String,System.String,System.Boolean)">
      <summary>
            Draws lines between this entity and all entities which have a key named '<paramref name="startKey">startKey</paramref>' and its value matches
            the value of our '<paramref name="startKeyValue">startKeyValue</paramref>'.
            </summary>
      <param name="startKey">Name of the key to search on other entities. This typically will be 'targetname'.</param>
      <param name="startKeyValue">Name of our key whose value will be used to match other entities.</param>
      <param name="onlySelected">Only draw the line when the entity is selected.</param>
    </member>
    <member name="M:Editor.LineAttribute.#ctor(System.String,System.String,System.String,System.String,System.Boolean)">
      <summary>
            Draws lines between all entities, starting from each entity that has a key named '<paramref name="startKey">startKey</paramref>' and its value matches
            the value of our '<paramref name="startKeyValue">startKeyValue</paramref>' and going to each entity that has a key named <paramref name="endKey">endKey</paramref>
            with a value of '<paramref name="endKeyValue">endKeyValue</paramref>'s value.
            </summary>
      <param name="startKey">Name of the key to search on other entities. This typically will be 'targetname'.</param>
      <param name="startKeyValue">Name of our key whose value will be used to match other entities.</param>
      <param name="endKey">Name of the key to search on other entities.</param>
      <param name="endKeyValue">Name of our key whose value will be used to match other entities.</param>
      <param name="onlySelected">Only draw the line when the entity is selected.</param>
    </member>
    <member name="T:Editor.PointLineAttribute">
      <summary>
            Draws a line in Hammer from the entity's origin to a point that can be moved with a gizmo and is stored in this property.
            </summary>
    </member>
    <member name="P:Editor.PointLineAttribute.Local">
      <summary>
            Write local to entity coordinates to the provided key. Default is to write in world space.
            </summary>
    </member>
    <member name="T:Editor.BoxSizeAttribute">
      <summary>
            For point entities without visualization (model/sprite), sets the size of the box the entity will appear as in Hammer.
            </summary>
    </member>
    <member name="T:Editor.BoundsHelperAttribute">
      <summary>
            Creates a resizable box helper in Hammer which outputs the size of the bounding box defined by the level designer into given keys/properties.
            You can have multiple of this attribute.
            </summary>
    </member>
    <member name="P:Editor.BoundsHelperAttribute.MinsKey">
      <summary>
            Key (classname) of the entity to store the "Mins" of the bounding box.
            </summary>
    </member>
    <member name="P:Editor.BoundsHelperAttribute.MaxsKey">
      <summary>
            Key (classname) of the entity to store the "Maxs" of the bounding box.
            </summary>
    </member>
    <member name="P:Editor.BoundsHelperAttribute.ExtentsKey">
      <summary>
            Key (classname) of the entity to store the bounding box as an "extents".
            This replaces <see cref="P:Editor.BoundsHelperAttribute.MinsKey" /> and <see cref="P:Editor.BoundsHelperAttribute.MaxsKey" /> and assumes the entity is in the middle of the bounds.
            The output value will be the total size of the bounds on each axis.
            </summary>
    </member>
    <member name="P:Editor.BoundsHelperAttribute.AutoCenter">
      <summary>
            Always move the entity to the center of the bounds.
            </summary>
    </member>
    <member name="P:Editor.BoundsHelperAttribute.IsWorldAligned">
      <summary>
            Make the bounds AABB (true), not OBB (false). Basically ignores rotation.
            </summary>
    </member>
    <member name="M:Editor.BoundsHelperAttribute.#ctor(System.String,System.String,System.Boolean,System.Boolean)">
      <summary>
            Creates a box helper that outputs the size of the bounding box defined by the level designer as mins and maxs
            </summary>
      <param name="minsKey">The internal key name to output "mins" size to.</param>
      <param name="maxsKey">The internal key name to output "maxs" size to.</param>
      <param name="autoCenter">If set to true, editing this box in Hammer will automatically move the entity to the center of the box.</param>
      <param name="worldAliged">If set, the helper box will ignore entity rotation.</param>
    </member>
    <member name="M:Editor.BoundsHelperAttribute.#ctor(System.String,System.Boolean)">
      <summary>
            Creates a box helper that outputs the size of the bounding box defined by the level designer as extents (maxs - mins).
            This assumes the entity is in the center of the box.
            </summary>
      <param name="extentsKey">The internal key name to output "extents" size to. This is the result of (maxs - mins).</param>
      <param name="worldAliged">If set, the helper box will ignore entity rotation.</param>
    </member>
    <member name="T:Editor.OrthoBoundsHelperAttribute">
      <summary>
            Creates a resizable box helper that represents an orthographic projection from the entity's origin in Hammer.
            The size of the bounding box as defined by the level designer is put into given keys/properties.
            </summary>
    </member>
    <member name="T:Editor.CanBeClientsideOnlyAttribute">
      <summary>
            Adds a property in Hammer that dictates whether the entity will be spawned on server or client.
            </summary>
    </member>
    <member name="T:Editor.EntityReportSourceAttribute">
      <summary>
            Makes value of this property appear in the Source File column of the Entity Report dialog in Hammer.
            There can be only one of such properties.
            </summary>
    </member>
    <member name="T:Editor.PostProcessingVolumeAttribute">
      <summary>
            Internally marks this class in Hammer as a post processing entity for preview purposes.
            </summary>
    </member>
    <member name="T:Editor.ToneMapAttribute">
      <summary>
            Internally marks this class in Hammer as a tonemap entity for preview purposes.
            </summary>
    </member>
    <member name="T:Editor.LightAttribute">
      <summary>
            Internally marks this class in Hammer as a light.
            </summary>
    </member>
    <member name="T:Editor.LightConeAttribute">
      <summary>
            The light_spot visualizer.
            </summary>
    </member>
    <member name="T:Editor.GlobalAttribute">
      <summary>
            Marks this entity as global, there should only be one entity with this global name in the map.
            Used internally for Preview purposes.
            </summary>
    </member>
    <member name="T:Editor.SimpleHelperAttribute">
      <summary>
            Adds a simple parameterless helper to the entity class.
            </summary>
    </member>
    <member name="T:Editor.BakeAmbientLightAttribute">
      <summary>
            Used by light_environment entity internally.
            </summary>
    </member>
    <member name="T:Editor.BakeAmbientOcclusionAttribute">
      <summary>
            Used by light_environment entity internally.
            </summary>
    </member>
    <member name="T:Editor.BakeSkyLightAttribute">
      <summary>
            Used by light_environment entity internally.
            </summary>
    </member>
    <member name="T:Editor.BakeResourceAttribute">
      <summary>
            Allows hammer to bake resources, mostly used for cubemaps and light probes
            </summary>
    </member>
    <member name="T:SwapChainHandle_t">
      <summary>
            This is a pointer but native pretends like it's a handle/struct using DECLARE_POINTER_HANDLE. We just treat it like a pointer.
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_ConVarSystem_RegisterNativeVar(System.IntPtr)">
      <summary>
            Sandbox.ConVarSystem.RegisterNativeVar( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_ConVarSystem_RegisterNativeCommand(System.IntPtr)">
      <summary>
            Sandbox.ConVarSystem.RegisterNativeCommand( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_ConVarSystem_OnConVarChanged(System.IntPtr,System.IntPtr,System.IntPtr)">
      <summary>
            Sandbox.ConVarSystem.OnConVarChanged( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SndbxDgnstcs_Logging_RegisterEngineLogger(System.Int32,System.IntPtr)">
      <summary>
            Sandbox.Diagnostics.Logging.RegisterEngineLogger( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_Bootstrap_EnvironmentExit(System.Int32)">
      <summary>
            Sandbox.Engine.Bootstrap.EnvironmentExit( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnMouseMotion(System.Int32,System.Int32)">
      <summary>
            Sandbox.Engine.InputRouter.OnMouseMotion( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnMousePositionChange(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Sandbox.Engine.InputRouter.OnMousePositionChange( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnMouseButton(System.Int64,System.Int32,System.Int32)">
      <summary>
            Sandbox.Engine.InputRouter.OnMouseButton( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnKey(System.Int64,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Sandbox.Engine.InputRouter.OnKey( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnText(System.UInt32)">
      <summary>
            Sandbox.Engine.InputRouter.OnText( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnWindowActive(System.Int32)">
      <summary>
            Sandbox.Engine.InputRouter.OnWindowActive( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnMouseWheel(System.Int32,System.Int32,System.Int32)">
      <summary>
            Sandbox.Engine.InputRouter.OnMouseWheel( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnImeStart">
      <summary>
            Sandbox.Engine.InputRouter.OnImeStart( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnImeComposition(System.IntPtr,System.Int32)">
      <summary>
            Sandbox.Engine.InputRouter.OnImeComposition( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnImeEnd">
      <summary>
            Sandbox.Engine.InputRouter.OnImeEnd( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnGameControllerButton(System.Int32,System.Int64,System.Int32)">
      <summary>
            Sandbox.Engine.InputRouter.OnGameControllerButton( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnGameControllerAxis(System.Int32,System.Int64,System.Int32)">
      <summary>
            Sandbox.Engine.InputRouter.OnGameControllerAxis( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnGameControllerConnected(System.Int32,System.Int32)">
      <summary>
            Sandbox.Engine.InputRouter.OnGameControllerConnected( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnGameControllerDisconnected(System.Int32)">
      <summary>
            Sandbox.Engine.InputRouter.OnGameControllerDisconnected( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_OnConsoleCommand(System.IntPtr)">
      <summary>
            Sandbox.Engine.InputRouter.OnConsoleCommand( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_InputRouter_CloseApplication">
      <summary>
            Sandbox.Engine.InputRouter.CloseApplication( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_SystemInfo_Set(System.IntPtr,System.UInt16,System.UInt64,System.UInt64)">
      <summary>
            Sandbox.Engine.SystemInfo.Set( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_SystemInfo_SetGpu(System.IntPtr,System.IntPtr,System.UInt64)">
      <summary>
            Sandbox.Engine.SystemInfo.SetGpu( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_Print(System.Int32,System.IntPtr,System.IntPtr)">
      <summary>
            Sandbox.EngineLoop.Print( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_DispatchConsoleCommand(System.IntPtr,System.IntPtr,System.Int64)">
      <summary>
            Sandbox.EngineLoop.DispatchConsoleCommand( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_OnClientOutput">
      <summary>
            Sandbox.EngineLoop.OnClientOutput( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_OnPresent">
      <summary>
            Sandbox.EngineLoop.OnPresent( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_Graphics_OnLayer(System.Int32,ManagedRenderSetup_t)">
      <summary>
            Sandbox.Graphics.OnLayer( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_HandleIndex_RegisterHandle(System.IntPtr,System.UInt32)">
      <summary>
            Sandbox.HandleIndex.RegisterHandle( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_HandleIndex_FreeHandle(System.Int32)">
      <summary>
            Sandbox.HandleIndex.FreeHandle( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnLobbyInvite(System.UInt64,System.UInt64)">
      <summary>
            Sandbox.LobbyManager.OnLobbyInvite( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnMemberEntered(System.UInt64,System.UInt64)">
      <summary>
            Sandbox.LobbyManager.OnMemberEntered( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnMemberLeave(System.UInt64,System.UInt64)">
      <summary>
            Sandbox.LobbyManager.OnMemberLeave( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnEntered(System.UInt64)">
      <summary>
            Sandbox.LobbyManager.OnEntered( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnCreated(System.UInt64)">
      <summary>
            Sandbox.LobbyManager.OnCreated( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnDataUpdate(System.UInt64,System.UInt64)">
      <summary>
            Sandbox.LobbyManager.OnDataUpdate( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_LobbyManager_OnChatMessage(System.UInt64,System.UInt64,System.IntPtr,System.Int32)">
      <summary>
            Sandbox.LobbyManager.OnChatMessage( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_MusicPlayer_OnInitAudioInternal(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Sandbox.MusicPlayer.OnInitAudioInternal( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_MusicPlayer_OnFinishedInternal(System.UInt32)">
      <summary>
            Sandbox.MusicPlayer.OnFinishedInternal( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_MusicPlayer_OnRepeatInternal(System.UInt32)">
      <summary>
            Sandbox.MusicPlayer.OnRepeatInternal( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxNetwork_SteamNetwork_OnSocketConnection(Sandbox.Network.HSteamListenSocket,Sandbox.Network.HSteamNetConnection)">
      <summary>
            Sandbox.Network.SteamNetwork.OnSocketConnection( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxNetwork_SteamNetwork_OnSocketDisconnection(Sandbox.Network.HSteamListenSocket,Sandbox.Network.HSteamNetConnection)">
      <summary>
            Sandbox.Network.SteamNetwork.OnSocketDisconnection( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxNetwork_SteamNetwork_ShouldAcceptConnection(Sandbox.Network.HSteamListenSocket,Sandbox.Network.HSteamNetConnection)">
      <summary>
            Sandbox.Network.SteamNetwork.ShouldAcceptConnection( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxNetwork_SteamNetwork_OnDisconnection(Sandbox.Network.HSteamNetConnection,System.Int32,System.IntPtr)">
      <summary>
            Sandbox.Network.SteamNetwork.OnDisconnection( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxNetwork_SteamNetwork_OnSessionEstablished(System.UInt64)">
      <summary>
            Sandbox.Network.SteamNetwork.OnSessionEstablished( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxNetwork_SteamNetwork_OnSessionFailed(Sandbox.Network.HSteamListenSocket,System.UInt64)">
      <summary>
            Sandbox.Network.SteamNetwork.OnSessionFailed( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxPhysics_PhysicsEngine_OnPhysicsJointBreak(System.Int32)">
      <summary>
            Sandbox.Physics.PhysicsEngine.OnPhysicsJointBreak( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxPhysics_PhysicsEngine_OnActive(System.Int32,Transform,Vector3,Vector3)">
      <summary>
            Sandbox.Physics.PhysicsEngine.OnActive( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxPhysics_PhysicsEngine_DebugDrawLine(Vector3,Vector3,Color32)">
      <summary>
            Sandbox.Physics.PhysicsEngine.DebugDrawLine( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_RealTime_Update(System.Single)">
      <summary>
            Sandbox.RealTime.Update( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SndbxRndrng_RenderPipeline_AddLayersToView(System.IntPtr,NativeEngine.RenderViewport,System.IntPtr,System.IntPtr,System.Int64,System.IntPtr,NativeEngine.RenderViewport)">
      <summary>
            Sandbox.Rendering.RenderPipeline.AddLayersToView( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SndbxRndrng_RenderPipeline_OnStage(System.Int64,System.IntPtr,NativeEngine.RenderViewport)">
      <summary>
            Sandbox.Rendering.RenderPipeline.OnStage( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_RenderTarget_Flush">
      <summary>
            Sandbox.RenderTarget.Flush( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_Resource_OnResourceReloaded(System.IntPtr,System.IntPtr)">
      <summary>
            Sandbox.Resource.OnResourceReloaded( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_ScnCstmbjctRndr_RenderObject(ManagedRenderSetup_t,System.Int32)">
      <summary>
            Sandbox.SceneCustomObjectRender.RenderObject( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SndbxSrvcs_Inventory_OnDefinitionUpdate">
      <summary>
            Sandbox.Services.Inventory.OnDefinitionUpdate( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SndbxSrvcs_Inventory_OnPricesUpdate(System.Int32,System.IntPtr)">
      <summary>
            Sandbox.Services.Inventory.OnPricesUpdate( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SndbxSrvcs_Inventory_OnPurchaseResult(System.Int32,System.UInt64,System.UInt64)">
      <summary>
            Sandbox.Services.Inventory.OnPurchaseResult( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SndbxSrvcs_ServerList_OnStarted(System.UInt32)">
      <summary>
            Sandbox.Services.ServerList.OnStarted( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SndbxSrvcs_ServerList_OnServerResponded(System.UInt32,System.IntPtr,System.UInt64)">
      <summary>
            Sandbox.Services.ServerList.OnServerResponded( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SndbxSrvcs_ServerList_OnFinished(System.UInt32)">
      <summary>
            Sandbox.Services.ServerList.OnFinished( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_OnTextureCreatedInternal(System.UInt32)">
      <summary>
            Sandbox.VideoPlayer.OnTextureCreatedInternal( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_OnInitAudioInternal(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Sandbox.VideoPlayer.OnInitAudioInternal( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_OnFreeAudioInternal(System.UInt32)">
      <summary>
            Sandbox.VideoPlayer.OnFreeAudioInternal( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_OnTextureDataInternal(System.UInt32,System.IntPtr,System.Int32,System.Int32)">
      <summary>
            Sandbox.VideoPlayer.OnTextureDataInternal( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_OnLoadedInternal(System.UInt32)">
      <summary>
            Sandbox.VideoPlayer.OnLoadedInternal( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Sandbox_VideoPlayer_WantsTextureData(System.UInt32)">
      <summary>
            Sandbox.VideoPlayer.WantsTextureData( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_InternalIsActive">
      <summary>
            Sandbox.VR.VRSystem.InternalIsActive( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_InternalWantsInit">
      <summary>
            Sandbox.VR.VRSystem.InternalWantsInit( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_BeginFrame">
      <summary>
            Sandbox.VR.VRSystem.BeginFrame( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_EndFrame">
      <summary>
            Sandbox.VR.VRSystem.EndFrame( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_Submit(System.IntPtr,System.IntPtr)">
      <summary>
            Sandbox.VR.VRSystem.Submit( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_GetVulkanInstanceExtensionsRequired">
      <summary>
            Sandbox.VR.VRSystem.GetVulkanInstanceExtensionsRequired( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_GetVulkanDeviceExtensionsRequired">
      <summary>
            Sandbox.VR.VRSystem.GetVulkanDeviceExtensionsRequired( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.SandboxVR_VRSystem_RenderOverlays">
      <summary>
            Sandbox.VR.VRSystem.RenderOverlays( ... )
            </summary>
    </member>
    <member name="M:Managed.SandboxEngine.Exports.Steamworks_Dispatch_OnClientCallback(System.Int32,System.IntPtr,System.Int32,System.Int32)">
      <summary>
            Steamworks.Dispatch.OnClientCallback( ... )
            </summary>
    </member>
    <member name="M:NetCore.InitializeInterop(System.String)">
      <summary>
            From here we'll open the native dlls and inject our function pointers into them,
            and retrieve function pointers from them.
            </summary>
    </member>
    <member name="T:FBMGammaType_t">
      <summary>
            from FloatBitmap 
            </summary>
    </member>
    <member name="M:SandboxSystemExtensions.HasRenderMeshes(Sandbox.Model)">
      <summary>
            Returns false if model has no valid render meshes, or is null.
            </summary>
    </member>
    <member name="T:NativeResourceCache">
      <summary>
            We only want 1 instance of a Resource class in C# and we want that to have 1 strong handle to native.
            So we need a WeakReference lookup everytime we get a Resource from native to match that class.
            This way GC can work for us and free anything we're no longer using anywhere, fantastic!
            
            However sometimes GC is very good at it's job and will free Resources we don't keep a strong reference to
            in generation 0 or 1 immediately after usage. This can cause the resource to need to be loaded every frame.
            Or worse be finalized at unpredictable times.
            
            So we keep a sliding memory cache of the Resources - realistically these only need to live for an extra frame.
            But it's probably nice to keep around for longer if they're going to be used on and off.
            </summary>
    </member>
    <member name="F:NativeResourceCache.WeakTable">
      <summary>
            We still want a WeakReference cache because we might have a strong reference somewhere to a resource
            that has been expired from the cache. And we absolutely only want 1 instance of the resource.
            </summary>
    </member>
    <member name="M:NativeResourceCache.Tick">
      <summary>
            Ticks the underlying MemoryCache to clear expired entries
            </summary>
    </member>
    <member name="M:NativeResourceCache.Clear">
      <summary>
            Clear the cache when games are closed etc. ready for a <see cref="M:System.GC.Collect" /></summary>
    </member>
    <member name="T:SceneObjectAnimationSequence">
      <summary>
            Hidden class. addon code should only ever access AnimationSequence.
            </summary>
    </member>
    <member name="T:SceneObjectDirectPlayback">
      <summary>
            Hidden class. addon code should only ever access DirectPlayback.
            </summary>
    </member>
    <member name="T:SceneObjectMorphCollection">
      <summary>
            Hidden class. addon code should only ever access MorphCollection.
            </summary>
    </member>
    <member name="T:Steamworks.CallResult`1">
      <summary>
            An awaitable version of a SteamAPICall_t.
            </summary>
    </member>
    <member name="M:Steamworks.CallResult`1.OnCompleted(System.Action)">
      <summary>
            This gets called if IsComplete returned false on the first call.
            The Action "continues" the async call. We pass it to the Dispatch
            to be called when the callback returns.
            </summary>
    </member>
    <member name="M:Steamworks.CallResult`1.GetResult">
      <summary>
            Gets the result. This is called internally by the async shit.
            </summary>
    </member>
    <member name="P:Steamworks.CallResult`1.IsCompleted">
      <summary>
            Return true if complete or failed
            </summary>
    </member>
    <member name="M:Steamworks.CallResult`1.GetAwaiter">
      <summary>
            This is what makes this struct awaitable
            </summary>
    </member>
    <member name="T:Steamworks.ICallbackData">
      <summary>
            Gives us a generic way to get the CallbackId of structs
            </summary>
    </member>
    <member name="T:Steamworks.Dispatch">
      <summary>
            Responsible for all callback/call result handling. This manually pumps Steam's message queue
            and dispatches those events to any waiting callbacks/call results.
            </summary>
    </member>
    <member name="M:Steamworks.Dispatch.OnClientCallback(System.Int32,System.IntPtr,System.Int32,System.Boolean)">
      <summary>
            Called if an exception happens during a callback/call result. This is needed because the
            exception isn't always accessible when running async.. and can fail silently. With
            this hooked you won't be stuck wondering what happened.
            </summary>
    </member>
    <member name="F:Steamworks.Dispatch.actionsToCall">
      <summary>
            To be safe we don't call the continuation functions while iterating
            the Callback list. This is maybe overly safe because the only way this
            could be an issue is if the callback list is modified in the continuation
            which would only happen if starting or shutting down in the callback.
            </summary>
    </member>
    <member name="M:Steamworks.Dispatch.ProcessCallback(Steamworks.CallbackType,System.IntPtr,System.Int32,System.Boolean)">
      <summary>
            A callback is a general global message.
            </summary>
    </member>
    <member name="M:Steamworks.Dispatch.CallbackToString(Steamworks.CallbackType,System.IntPtr,System.Int32)">
      <summary>
            Given a callback, try to turn it into a string
            </summary>
    </member>
    <member name="M:Steamworks.Dispatch.ProcessResult(Steamworks.CallbackType,System.IntPtr,System.Int32)">
      <summary>
            A result is a reply to a specific command
            </summary>
    </member>
    <member name="M:Steamworks.Dispatch.OnCallComplete``1(Steamworks.Data.SteamAPICall_t,System.Action,System.Boolean)">
      <summary>
            Watch for a Steam API call.
            </summary>
    </member>
    <member name="M:Steamworks.Dispatch.Install``1(System.Action{``0},System.Boolean)">
      <summary>
            Install a global callback. The passed function will get called if it's all good.
            </summary>
    </member>
    <member name="M:Steamworks.Data.Lobby.Join">
      <summary>
            Try to join this room. Will return RoomEnter.Success on success,
            and anything else is a failure
            </summary>
    </member>
    <member name="M:Steamworks.Data.Lobby.Leave">
      <summary>
            Leave a lobby; this will take effect immediately on the client side
            other users in the lobby will be notified by a LobbyChatUpdate_t callback
            </summary>
    </member>
    <member name="M:Steamworks.Data.Lobby.InviteFriend(Steamworks.SteamId)">
      <summary>
            Invite another user to the lobby
            will return true if the invite is successfully sent, whether or not the target responds
            returns false if the local user is not connected to the Steam servers
            </summary>
    </member>
    <member name="M:Steamworks.Data.Lobby.InviteOverlay">
      <summary>
            Invite another user to the lobby
            </summary>
    </member>
    <member name="P:Steamworks.Data.Lobby.MemberCount">
      <summary>
            Get current lobby's member count
            </summary>
    </member>
    <member name="P:Steamworks.Data.Lobby.Members">
      <summary>
            Returns current members. Need to be in the lobby to see the users.
            </summary>
    </member>
    <member name="M:Steamworks.Data.Lobby.GetData(System.String)">
      <summary>
            Get data associated with this lobby
            </summary>
    </member>
    <member name="M:Steamworks.Data.Lobby.SetData(System.String,System.String)">
      <summary>
            Get data associated with this lobby
            </summary>
    </member>
    <member name="M:Steamworks.Data.Lobby.DeleteData(System.String)">
      <summary>
            Removes a metadata key from the lobby
            </summary>
    </member>
    <member name="P:Steamworks.Data.Lobby.Data">
      <summary>
            Get all data for this lobby
            </summary>
    </member>
    <member name="M:Steamworks.Data.Lobby.GetMemberData(Steamworks.Friend,System.String)">
      <summary>
            Gets per-user metadata for someone in this lobby
            </summary>
    </member>
    <member name="M:Steamworks.Data.Lobby.SetMemberData(System.String,System.String)">
      <summary>
            Sets per-user metadata (for the local user implicitly)
            </summary>
    </member>
    <member name="M:Steamworks.Data.Lobby.RefreshData">
      <summary>
            Refreshes metadata for a lobby you're not necessarily in right now
            you never do this for lobbies you're a member of, only if your
            this will send down all the metadata associated with a lobby
            this is an asynchronous call
            returns false if the local user is not connected to the Steam servers
            results will be returned by a LobbyDataUpdate_t callback
            if the specified lobby doesn't exist, LobbyDataUpdate_t::m_bSuccess will be set to false
            </summary>
    </member>
    <member name="P:Steamworks.Data.Lobby.MaxMembers">
      <summary>
            Max members able to join this lobby. Cannot be over 250.
            Can only be set by the owner
            </summary>
    </member>
    <member name="P:Steamworks.Data.Lobby.Owner">
      <summary>
            You must be the lobby owner to set the owner
            </summary>
    </member>
    <member name="M:Steamworks.Data.Lobby.IsOwnedBy(Steamworks.SteamId)">
      <summary>
            Check if the specified SteamId owns the lobby
            </summary>
    </member>
    <member name="M:Steamworks.Data.LobbyQuery.FilterDistanceClose">
      <summary>
            only lobbies in the same immediate region will be returned
            </summary>
    </member>
    <member name="M:Steamworks.Data.LobbyQuery.FilterDistanceFar">
      <summary>
            only lobbies in the same immediate region will be returned
            </summary>
    </member>
    <member name="M:Steamworks.Data.LobbyQuery.FilterDistanceWorldwide">
      <summary>
            only lobbies in the same immediate region will be returned
            </summary>
    </member>
    <member name="M:Steamworks.Data.LobbyQuery.WithKeyValue(System.String,System.String)">
      <summary>
            Filter by specified key/value pair; string parameters
            </summary>
    </member>
    <member name="M:Steamworks.Data.LobbyQuery.WithLower(System.String,System.Int32)">
      <summary>
            Numerical filter where value is less than the value provided
            </summary>
    </member>
    <member name="M:Steamworks.Data.LobbyQuery.WithHigher(System.String,System.Int32)">
      <summary>
            Numerical filter where value is greater than the value provided
            </summary>
    </member>
    <member name="M:Steamworks.Data.LobbyQuery.WithEqual(System.String,System.Int32)">
      <summary>
            Numerical filter where value must be equal to the value provided
            </summary>
    </member>
    <member name="M:Steamworks.Data.LobbyQuery.WithNotEqual(System.String,System.Int32)">
      <summary>
            Numerical filter where value must not equal the value provided
            </summary>
    </member>
    <member name="M:Steamworks.Data.LobbyQuery.AddNumericalFilter(System.String,System.Int32,Steamworks.LobbyComparison)">
      <summary>
            Test key, initialize numerical filter list if necessary, then add new numerical filter
            </summary>
    </member>
    <member name="M:Steamworks.Data.LobbyQuery.OrderByNear(System.String,System.Int32)">
      <summary>
            Order filtered results according to key/values nearest the provided key/value pair.
            Can specify multiple near value filters; each successive filter is lower priority than the previous.
            </summary>
    </member>
    <member name="M:Steamworks.Data.LobbyQuery.WithSlotsAvailable(System.Int32)">
      <summary>
            returns only lobbies with the specified number of slots available
            </summary>
    </member>
    <member name="M:Steamworks.Data.LobbyQuery.WithMaxResults(System.Int32)">
      <summary>
            sets how many results to return, the lower the count the faster it is to download the lobby results
            </summary>
    </member>
    <member name="M:Steamworks.Data.LobbyQuery.RequestAsync">
      <summary>
            Run the query, get the matching lobbies
            </summary>
    </member>
    <member name="M:Steamworks.SteamClient.Init(System.Int32)">
      <summary>
            Initialize the steam client.
            </summary>
    </member>
    <member name="P:Steamworks.SteamClient.IsValid">
      <summary>
            Check if Steam is loaded and accessible.
            </summary>
    </member>
    <member name="F:Steamworks.SteamClient.SteamId">
      <summary>
            Gets the Steam ID of the account currently logged into the Steam client. This is 
            commonly called the 'current user', or 'local user'.
            A Steam ID is a unique identifier for a Steam accounts, Steam groups, Lobbies and Chat 
            rooms, and used to differentiate users in all parts of the Steamworks API.
            </summary>
    </member>
    <member name="F:Steamworks.SteamClient.Name">
      <summary>
            returns the local players name - guaranteed to not be NULL.
            this is the same name as on the users community profile page
            </summary>
    </member>
    <member name="F:Steamworks.SteamClient.AppId">
      <summary>
            returns the appID of the current process
            </summary>
    </member>
    <member name="T:Steamworks.SteamFriends">
      <summary>
            Functions for clients to access data about Steam friends
            </summary>
    </member>
    <member name="P:Steamworks.SteamFriends.OnPersonaStateChange">
      <summary>
            Called when a friends' status changes
            </summary>
    </member>
    <member name="P:Steamworks.SteamFriends.OnGameRichPresenceJoinRequested">
      <summary>
            Called when the user tries to join a game from their friends list
            rich presence will have been set with the "connect" key which is set here
            </summary>
    </member>
    <member name="P:Steamworks.SteamFriends.OnFriendRichPresenceUpdate">
      <summary>
            Callback indicating updated data about friends rich presence information
            </summary>
    </member>
    <member name="P:Steamworks.SteamFriends.OnGameLobbyJoinRequested">
      <summary>
            Called when the user tries to join a game from their friends list
            in a lobby
            </summary>
    </member>
    <member name="M:Steamworks.SteamFriends.OpenUserOverlay(Steamworks.SteamId,System.String)">
      <summary>
            "steamid" - Opens the overlay web browser to the specified user or groups profile.
            "chat" - Opens a chat window to the specified user, or joins the group chat.
            "jointrade" - Opens a window to a Steam Trading session that was started with the ISteamEconomy/StartTrade Web API.
            "stats" - Opens the overlay web browser to the specified user's stats.
            "achievements" - Opens the overlay web browser to the specified user's achievements.
            "friendadd" - Opens the overlay in minimal mode prompting the user to add the target user as a friend.
            "friendremove" - Opens the overlay in minimal mode prompting the user to remove the target friend.
            "friendrequestaccept" - Opens the overlay in minimal mode prompting the user to accept an incoming friend invite.
            "friendrequestignore" - Opens the overlay in minimal mode prompting the user to ignore an incoming friend invite.
            </summary>
    </member>
    <member name="M:Steamworks.SteamFriends.OpenGameInviteOverlay(Steamworks.SteamId)">
      <summary>
            Activates the Steam Overlay to open the invite dialog. Invitations sent from this dialog will be for the provided lobby.
            </summary>
    </member>
    <member name="M:Steamworks.SteamFriends.RequestUserInformation(Steamworks.SteamId,System.Boolean)">
      <summary>
            Requests the persona name and optionally the avatar of a specified user.
            NOTE: It's a lot slower to download avatars and churns the local cache, so if you don't need avatars, don't request them.
            returns true if we're fetching the data, false if we already have it
            </summary>
    </member>
    <member name="T:Steamworks.SteamMatchmaking">
      <summary>
            Functions for clients to access matchmaking services, favorites, and to operate on game lobbies
            </summary>
    </member>
    <member name="P:Steamworks.SteamMatchmaking.MaxLobbyKeyLength">
      <summary>
            Maximum number of characters a lobby metadata key can be
            </summary>
    </member>
    <member name="M:Steamworks.SteamMatchmaking.CreateLobbyAsync(System.Int32)">
      <summary>
            Creates a new invisible lobby. Call lobby.SetPublic to take it online.
            </summary>
    </member>
    <member name="M:Steamworks.SteamMatchmaking.JoinLobbyAsync(Steamworks.SteamId)">
      <summary>
            Attempts to directly join the specified lobby
            </summary>
    </member>
    <member name="T:Steamworks.SteamUtils">
      <summary>
            Interface which provides access to a range of miscellaneous utility functions
            </summary>
    </member>
    <member name="M:Steamworks.SteamUtils.GetImageSize(System.Int32,System.UInt32@,System.UInt32@)">
      <summary>
            returns true if the image exists, and the buffer was successfully filled out
            results are returned in RGBA format
            the destination buffer size should be 4 * height * width * sizeof(char)
            </summary>
    </member>
    <member name="M:Steamworks.SteamUtils.GetImage(System.Int32)">
      <summary>
            returns the image in RGBA format
            </summary>
    </member>
    <member name="P:Steamworks.SteamUtils.IsRunningOnSteamDeck">
      <summary>
            returns true if Steam itself is running on the Steam Deck
            </summary>
    </member>
    <member name="P:Steamworks.Friend.IsMe">
      <summary>
            Returns true if this is the local user
            </summary>
    </member>
    <member name="P:Steamworks.Friend.IsFriend">
      <summary>
            Return true if this is a friend
            </summary>
    </member>
    <member name="P:Steamworks.Friend.IsBlocked">
      <summary>
            Returns true if you have this user blocked
            </summary>
    </member>
    <member name="P:Steamworks.Friend.IsPlayingThisGame">
      <summary>
            Return true if this user is playing the game we're running
            </summary>
    </member>
    <member name="P:Steamworks.Friend.IsPlaying">
      <summary>
            Return true if this user is playing another game
            </summary>
    </member>
    <member name="P:Steamworks.Friend.IsOnline">
      <summary>
            Returns true if this friend is online
            </summary>
    </member>
    <member name="M:Steamworks.Friend.RequestInfoAsync">
      <summary>
            Sometimes we don't know the user's name. This will wait until we have
            downloaded the information on this user.
            </summary>
    </member>
    <member name="P:Steamworks.Friend.IsAway">
      <summary>
            Returns true if this friend is marked as away
            </summary>
    </member>
    <member name="P:Steamworks.Friend.IsBusy">
      <summary>
            Returns true if this friend is marked as busy
            </summary>
    </member>
    <member name="P:Steamworks.Friend.IsSnoozing">
      <summary>
            Returns true if this friend is marked as snoozing
            </summary>
    </member>
    <member name="M:Steamworks.Friend.InviteToGame(System.String)">
      <summary>
            Invite this friend to the game that we are playing
            </summary>
    </member>
    <member name="M:Steamworks.Friend.OpenInOverlay(System.String)">
      <summary>
            Activates the Steam Overlay to a specific dialog
            </summary>
      <param name="type">
            "steamid" - Opens the overlay web browser to the specified user or groups profile.
            "chat" - Opens a chat window to the specified user, or joins the group chat.
            "jointrade" - Opens a window to a Steam Trading session that was started with the ISteamEconomy/StartTrade Web API.
            "stats" - Opens the overlay web browser to the specified user's stats.
            "achievements" - Opens the overlay web browser to the specified user's achievements.
            "friendadd" - Opens the overlay in minimal mode prompting the user to add the target user as a friend.
            "friendremove" - Opens the overlay in minimal mode prompting the user to remove the target friend.
            "friendrequestaccept" - Opens the overlay in minimal mode prompting the user to accept an incoming friend invite.
            "friendrequestignore" - Opens the overlay in minimal mode prompting the user to ignore an incoming friend invite.
            </param>
    </member>
    <member name="M:Steamworks.Friend.SendMessage(System.String)">
      <summary>
            Sends a message to a Steam friend. Returns true if success
            </summary>
    </member>
    <member name="M:Steamworks.Helpers.TakeBuffer(System.Int32)">
      <summary>
            Returns a buffer. This will get returned and reused later on.
            We shouldn't really be using this anymore. 
            </summary>
    </member>
  </members>
  <assembly>
    <name>Sandbox.Event</name>
  </assembly>
  <members>
    <member name="T:Sandbox.Internal.EventSystem.EventClass">
      <summary>
            A Type with events on it
            </summary>
    </member>
    <member name="T:Sandbox.Internal.EventSystem.EventAction">
      <summary>
            A method on a type
            </summary>
    </member>
    <member name="M:Sandbox.Internal.EventSystem.EventAction.Run(System.String,System.Object[])">
      <summary>
            Run this event action, aggregating any exceptions.
            </summary>
    </member>
    <member name="T:Sandbox.Internal.EventSystem.EventList">
      <summary>
            A list of events, usually indexed by the event name
            </summary>
    </member>
    <member name="M:Sandbox.Internal.EventSystem.EventList.Run(System.String,System.Object[])">
      <summary>
            Run this event list, aggregating any exceptions.
            </summary>
    </member>
    <member name="F:Sandbox.Internal.EventSystem.OrphanedInstances">
      <summary>
            Instances that have had their assembly removed. We keep them around becuase the
            assembly might be re-registered.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.EventSystem.UnregisterAssembly(System.Reflection.Assembly)">
      <summary>
            Register an assembly. If old assembly is valid, we try to remove all of the old event hooks
            from this assembly, while retaining a list of objects.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.EventSystem.RegisterAssembly(System.Reflection.Assembly)">
      <summary>
            Register an assembly. If old assembly is valid, we try to remove all of the old event hooks
            from this assembly, while retaining a list of objects.
            </summary>
    </member>
  </members>
  <assembly>
    <name>Sandbox.Filesystem</name>
  </assembly>
  <members>
    <member name="T:Sandbox.AggregateFileSystem">
      <summary>
            A filesystem that merges a bunch of other filesystems. This is read only.
            </summary>
    </member>
    <member name="T:Sandbox.BaseFileSystem">
      <summary>
            A filesystem. Could be on disk, or in memory, or in the cloud. Could be writable or read only.
            Or it could be an aggregation of all those things, merged together and read only.
            </summary>
    </member>
    <member name="P:Sandbox.BaseFileSystem.IsValid">
      <inheritdoc cref="P:Sandbox.IValid.IsValid" />
    </member>
    <member name="M:Sandbox.BaseFileSystem.FindDirectory(System.String,System.String,System.Boolean)">
      <summary>
            Get a list of directories
            </summary>
    </member>
    <member name="P:Sandbox.BaseFileSystem.FileCount">
      <summary>
            Unoptimal, for debugging purposes - don't expose
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.FindFile(System.String,System.String,System.Boolean)">
      <summary>
            Get a list of files
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.DeleteDirectory(System.String,System.Boolean)">
      <summary>
            Delete a folder and optionally all of its contents
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.DeleteFile(System.String)">
      <summary>
            Delete a file
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.CreateDirectory(System.String)">
      <summary>
            Create a directory - or a tree of directories.
            Returns silently if the directory already exists.
            </summary>
      <param name="folder" />
    </member>
    <member name="M:Sandbox.BaseFileSystem.FileExists(System.String)">
      <summary>
            Returns true if the file exists on this filesystem
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.DirectoryExists(System.String)">
      <summary>
             Returns true if the directory exists on this filesystem
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.GetFullPath(System.String)">
      <summary>
            Returns the full physical path to a file or folder on disk,
            or null if it isn't on disk.
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.GetRelativePath(System.String)">
      <summary>
            Returns the relative path
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.WriteAllText(System.String,System.String)">
      <summary>
            Write the contents to the path. The file will be over-written if the file exists
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.WriteAllBytes(System.String,System.Byte[])">
      <summary>
            Write the contents to the path. The file will be over-written if the file exists
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.ReadAllText(System.String)">
      <summary>
            Read the contents of path and return it as a string.
            Returns null if file not found.
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.ReadAllBytes(System.String)">
      <summary>
            Read the contents of path and return it as a string
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.ReadAllBytesAsync(System.String)">
      <summary>
            Read the contents of path and return it as a string
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.ReadAllTextAsync(System.String)">
      <summary>
            Read the contents of path and return it as a string
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.CreateSubSystem(System.String)">
      <summary>
            Create a sub-filesystem at the specified path
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.OpenWrite(System.String,System.IO.FileMode)">
      <summary>
            Open a file for write. If the file exists we'll overwrite it (by default)
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.OpenRead(System.String,System.IO.FileMode)">
      <summary>
            Open a file for read. Will throw an exception if it doesn't exist.
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.ReadJson``1(System.String,``0)">
      <summary>
            Read Json from a file using System.Text.Json.JsonSerializer. This will throw exceptions
            if not valid json.
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.ReadJsonOrDefault``1(System.String,``0)">
      <summary>
            The same as ReadJson except will return a default value on missing/error.
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.WriteJson``1(System.String,``0)">
      <summary>
            Convert object to json and write it to the specified file
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.DirectorySize(System.String,System.Boolean)">
      <summary>
            Gets the size in bytes of all the files in a directory
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.GetCrcAsync(System.String)">
      <summary>
            Returns CRC64 of the file contents.
            </summary>
      <param name="filepath">File path to the file to get CRC of.</param>
      <returns>The CRC64, or 0 if file is not found.</returns>
    </member>
    <member name="M:Sandbox.BaseFileSystem.GetCrc(System.String)">
      <summary>
            Returns CRC64 of the file contents.
            </summary>
      <param name="filepath">File path to the file to get CRC of.</param>
      <returns>The CRC64, or 0 if file is not found.</returns>
    </member>
    <member name="M:Sandbox.BaseFileSystem.FileSize(System.String)">
      <summary>
            Returns file size of given file.
            </summary>
      <param name="filepath">File path to the file to look up size of.</param>
      <returns>File size, in bytes.</returns>
    </member>
    <member name="M:Sandbox.BaseFileSystem.CreateAndMount(Sandbox.BaseFileSystem,System.String)">
      <summary>
            Mount this path on the filesystem, so it's accessible in Mount
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.CreateAndMount(System.String)">
      <summary>
            Mount this path on the filesystem, so it's accessible in Mount
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.FixPath(System.String)">
      <summary>
            Zio wants good paths to start with '/' - so we add it here if it isn't already on
            </summary>
    </member>
    <member name="M:Sandbox.BaseFileSystem.NormalizeFilename(System.String)">
      <summary>
            Lowercase the filename and replace \ with /
            </summary>
    </member>
    <member name="T:Sandbox.FileWatch">
      <summary>
            Watch folders, dispatch events on changed files
            </summary>
    </member>
    <member name="P:Sandbox.FileWatch.SuppressWatchers">
      <summary>
            Bit of a hack until we can do better. Don't trigger any watchers until this time.
            </summary>
    </member>
    <member name="E:Sandbox.FileWatch.OnChanges">
      <summary>
            Called once per batch of files changed
            </summary>
    </member>
    <member name="E:Sandbox.FileWatch.OnChangedFile">
      <summary>
            Called for each file changed
            </summary>
    </member>
    <member name="M:Sandbox.FileWatch.TickUntilFileChanged(System.String)">
      <summary>
            This is used for unit tests, to assure that a change is detected
            </summary>
    </member>
    <member name="T:Sandbox.LocalFileSystem">
      <summary>
            A directory on a disk
            </summary>
    </member>
    <member name="T:Sandbox.MemoryFileSystem">
      <summary>
            A filesystem that only exists in memory
            </summary>
    </member>
    <member name="T:Sandbox.Internal.RedirectFileSystem">
      <summary>
            A readonly filesystem that has a list of files, and a list of redirects. When accessing a file, it'll access the redirect file invisibly.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.RedirectFileSystem.AddFile(System.String,System.String)">
      <summary>
            Add a redirect path
            </summary>
      <param name="localPath">The path you want to pretend to be (local)</param>
      <param name="targetPath">The path you want to redirect to (relative to our root filesystem)</param>
    </member>
  </members>
  <assembly>
    <name>Sandbox.Game</name>
  </assembly>
  <members>
    <member name="T:Sandbox.ActionGraphs.ActionsInvoker">
      <summary>
            A component which allows you to use action in all the usual functions.
            </summary>
    </member>
    <member name="T:Sandbox.ActionGraphs.IActionComponent">
      <summary>
            A component that only provides actions to implement with an Action Graph.
            </summary>
    </member>
    <member name="T:Sandbox.ActionGraphs.SimpleActionComponent">
      <summary>
            These should not exist
            </summary>
    </member>
    <member name="P:Sandbox.ActionGraphs.SimpleActionComponent.Action">
      <summary>
            ActionGraph to run when the relevant event occurs.
            </summary>
    </member>
    <member name="T:Sandbox.ActionGraphs.AwakeActionComponent">
      <inheritdoc cref="M:Sandbox.Component.OnAwake" />
    </member>
    <member name="T:Sandbox.ActionGraphs.StartActionComponent">
      <inheritdoc cref="M:Sandbox.Component.OnStart" />
    </member>
    <member name="T:Sandbox.ActionGraphs.EnabledActionComponent">
      <inheritdoc cref="M:Sandbox.Component.OnEnabled" />
    </member>
    <member name="T:Sandbox.ActionGraphs.DisabledActionComponent">
      <inheritdoc cref="M:Sandbox.Component.OnDisabled" />
    </member>
    <member name="T:Sandbox.ActionGraphs.UpdateActionComponent">
      <inheritdoc cref="M:Sandbox.Component.OnUpdate" />
    </member>
    <member name="T:Sandbox.ActionGraphs.FixedUpdateActionComponent">
      <inheritdoc cref="M:Sandbox.Component.OnFixedUpdate" />
    </member>
    <member name="T:Sandbox.ActionGraphs.DestroyActionComponent">
      <inheritdoc cref="M:Sandbox.Component.OnDestroy" />
    </member>
    <member name="T:Sandbox.ActionGraphs.CollisionActionComponent">
      <summary>
            Reacts to collisions.
            </summary>
    </member>
    <member name="P:Sandbox.ActionGraphs.CollisionActionComponent.CollisionStart">
      <inheritdoc cref="M:Sandbox.Component.ICollisionListener.OnCollisionStart(Sandbox.Collision)" />
    </member>
    <member name="P:Sandbox.ActionGraphs.CollisionActionComponent.CollisionUpdate">
      <inheritdoc cref="M:Sandbox.Component.ICollisionListener.OnCollisionUpdate(Sandbox.Collision)" />
    </member>
    <member name="P:Sandbox.ActionGraphs.CollisionActionComponent.CollisionStop">
      <inheritdoc cref="M:Sandbox.Component.ICollisionListener.OnCollisionStop(Sandbox.CollisionStop)" />
    </member>
    <member name="T:Sandbox.ActionGraphs.TriggerActionComponent">
      <summary>
            Reacts to collider triggers.
            </summary>
    </member>
    <member name="P:Sandbox.ActionGraphs.TriggerActionComponent.TriggerEnter">
      <inheritdoc cref="M:Sandbox.Component.ITriggerListener.OnTriggerEnter(Sandbox.Collider)" />
    </member>
    <member name="P:Sandbox.ActionGraphs.TriggerActionComponent.TriggerExit">
      <inheritdoc cref="M:Sandbox.Component.ITriggerListener.OnTriggerExit(Sandbox.Collider)" />
    </member>
    <member name="M:Sandbox.ActionGraphs.ResourceNodes.SoundFile(Sandbox.SoundFile)">
      <summary>
            A sound resource.
            </summary>
    </member>
    <member name="M:Sandbox.ActionGraphs.ResourceNodes.SoundEvent(Sandbox.SoundEvent)">
      <summary>
            A sound event. It can play a set of random sounds with optionally random settings such as volume and pitch.
            </summary>
    </member>
    <member name="M:Sandbox.ActionGraphs.ResourceNodes.Model(Sandbox.Model)">
      <summary>
            A model.
            </summary>
    </member>
    <member name="M:Sandbox.ActionGraphs.ResourceNodes.Material(Sandbox.Material)">
      <summary>
            A material. Uses several Textures and a Shader with specific settings for more interesting visual effects.
            </summary>
    </member>
    <member name="M:Sandbox.ActionGraphs.ResourceNodes.Prefab(Sandbox.PrefabFile)">
      <summary>
            A prefab.
            </summary>
    </member>
    <member name="M:Sandbox.ActionGraphs.ResourceNodes.GameResource``1(``0)">
      <summary>
            An asset defined in C# and created through tools.
            </summary>
    </member>
    <member name="P:Sandbox.ActionGraphs.RunSceneEventNodeDefinition.TargetInput">
      <summary>
            Optional target <see cref="T:Sandbox.GameObject" /> to post this event to.
            Only components within this target and its descendants will receive the event.
            If not provided, the whole <see cref="T:Sandbox.Scene" /> will be used.
            </summary>
    </member>
    <member name="M:Sandbox.ActionGraphs.SceneNodes.PlaySound(Sandbox.GameObject,Sandbox.SoundEvent)">
      <summary>
            Plays a sound at the position of the target object.
            </summary>
    </member>
    <member name="P:Sandbox.ActionGraphs.SceneNodes.Trace">
      <inheritdoc cref="P:Sandbox.Scene.Trace" />
    </member>
    <member name="M:Sandbox.ActionGraphs.SceneNodes.NetworkSpawn(Sandbox.GameObject,Sandbox.Connection)">
      <inheritdoc cref="M:Sandbox.GameObject.NetworkSpawn(Sandbox.Connection)" />
    </member>
    <member name="M:Sandbox.ActionGraphs.SceneNodes.IsOwner(Sandbox.GameObject)">
      <summary>
            True if we are the owner of the GameObject
            </summary>
    </member>
    <member name="T:Sandbox.ActionGraphs.SceneRefGizmo">
      <summary>
            Handles drawing lines representing ActionGraph references between objects / components in the scene.
            </summary>
    </member>
    <member name="M:Sandbox.ActionGraphs.TimeNodes.Delay(System.Single,System.Nullable{System.Threading.CancellationToken})">
      <summary>
            A task that does nothing for a given amount of time in seconds. This will continue even if the
            object containing this graph is destroyed, you probably want <see cref="T:Sandbox.GameObject" /> → Time → Delay instead.
            </summary>
      <param name="seconds">Time to wait in seconds.</param>
      <param name="ct">Token for cancelling the delay.</param>
    </member>
    <member name="M:Sandbox.ActionGraphs.TimeNodes.Delay(Sandbox.GameObject,System.Single,System.Nullable{System.Threading.CancellationToken})">
      <summary>
            A task that does nothing for a given amount of time in seconds, and cancels automatically if the target <see cref="T:Sandbox.GameObject" />
            is destroyed.
            </summary>
      <param name="target">Cancel the delay if this object is destroyed.</param>
      <param name="seconds">Time to wait in seconds.</param>
      <param name="ct">Token for cancelling the delay.</param>
    </member>
    <member name="M:Sandbox.ActionGraphs.TimeNodes.Delta">
      <inheritdoc cref="P:Sandbox.Time.Delta" />
    </member>
    <member name="M:Sandbox.ActionGraphs.TimeNodes.Now">
      <inheritdoc cref="P:Sandbox.Time.Now" />
    </member>
    <member name="T:Sandbox.ConsoleSystem">
      <summary>
            A library to interact with the Console System.
            </summary>
    </member>
    <member name="M:Sandbox.ConsoleSystem.SetValue(System.String,System.Object)">
      <summary>
            Try to set a console variable. You will only be able to set variables that you have permission to set.
            </summary>
    </member>
    <member name="M:Sandbox.ConsoleSystem.GetValue(System.String,System.String)">
      <summary>
            Get a console variable's value as a string.
            </summary>
    </member>
    <member name="M:Sandbox.ConsoleSystem.OnChangePropertySet``1(Sandbox.WrappedPropertySet{``0}@)">
      <summary>
            Invoke a method when a property with [Change] is changed.
            </summary>
    </member>
    <member name="M:Sandbox.ConsoleSystem.OnWrappedSet``1(Sandbox.WrappedPropertySet{``0}@)">
      <summary>
            When we update a ConVar in code, call the ConsoleSystem.
            </summary>
    </member>
    <member name="M:Sandbox.ConsoleSystem.OnWrappedGet``1(Sandbox.WrappedPropertyGet{``0}@)">
      <summary>
            When we query a convar property
            </summary>
    </member>
    <member name="M:Sandbox.ConsoleSystem.Run(System.String)">
      <summary>
            Run this command. This should be a single command.
            </summary>
    </member>
    <member name="M:Sandbox.ConsoleSystem.Run(System.String,System.Object[])">
      <summary>
            Run this command, along with the arguments. We'll automatically convert them to strings and handle quoting.
            </summary>
    </member>
    <member name="M:Sandbox.ConsoleSystem.RunInternal(Sandbox.ConsoleSystem.ConsoleCommand)">
      <summary>
            Actually do the business of trying to run a command. Will return (not throw) an exception
            object if an exception is thrown of command isn't found.
            </summary>
    </member>
    <member name="M:Sandbox.ContextInterface.OwnsAssembly(System.Reflection.Assembly)">
      <summary>
            Return true if this assembly is a part of this context
            </summary>
    </member>
    <member name="T:Sandbox.Event">
      <summary>
            The event system.
            </summary>
    </member>
    <member name="M:Sandbox.Event.UnregisterAssembly(System.Reflection.Assembly)">
      <summary>
            Register an assembly. If old assembly is valid, we try to remove all of the old event hooks
            from this assembly, while retaining a list of objects.
            </summary>
    </member>
    <member name="M:Sandbox.Event.RegisterAssembly(System.Reflection.Assembly)">
      <summary>
            Register an assembly. If old assembly is valid, we try to remove all of the old event hooks
            from this assembly, while retaining a list of objects.
            </summary>
    </member>
    <member name="M:Sandbox.Event.Register(System.Object)">
      <summary>
            Register an object to start receiving events
            </summary>
    </member>
    <member name="M:Sandbox.Event.Unregister(System.Object)">
      <summary>
            Unregister an object, stop reviving events
            </summary>
    </member>
    <member name="M:Sandbox.Event.Run(System.String)">
      <summary>
            Run an event.
            </summary>
    </member>
    <member name="M:Sandbox.Event.Run``1(System.String,``0)">
      <summary>
            Run an event with an argument of arbitrary type.
            </summary>
      <typeparam name="T">Arbitrary type for the argument.</typeparam>
      <param name="name">Name of the event to run.</param>
      <param name="arg0">Argument to pass down to event handlers.</param>
    </member>
    <member name="M:Sandbox.Event.Run``2(System.String,``0,``1)">
      <summary>
            Run an event with 2 arguments of arbitrary type.
            </summary>
      <typeparam name="T">Arbitrary type for the first argument.</typeparam>
      <typeparam name="U">Arbitrary type for the second argument.</typeparam>
      <param name="name">Name of the event to run.</param>
      <param name="arg0">First argument to pass down to event handlers.</param>
      <param name="arg1">Second argument to pass down to event handlers.</param>
    </member>
    <member name="M:Sandbox.Event.Run``3(System.String,``0,``1,``2)">
      <summary>
            Run an event with 3 arguments of arbitrary type.
            </summary>
      <typeparam name="T">Arbitrary type for the first argument.</typeparam>
      <typeparam name="U">Arbitrary type for the second argument.</typeparam>
      <typeparam name="V">Arbitrary type for the third argument.</typeparam>
      <param name="name">Name of the event to run.</param>
      <param name="arg0">First argument to pass down to event handlers.</param>
      <param name="arg1">Second argument to pass down to event handlers.</param>
      <param name="arg2">Third argument to pass down to event handlers.</param>
    </member>
    <member name="T:Sandbox.Event.Streamer">
      <summary>
            Stream API related events. See Sandbox.Streamer.
            </summary>
    </member>
    <member name="T:Sandbox.Event.Streamer.JoinChatAttribute">
      <summary>
            Event called when joined a chat
            </summary>
    </member>
    <member name="T:Sandbox.Event.Streamer.LeaveChatAttribute">
      <summary>
            Event called when left a chat
            </summary>
    </member>
    <member name="T:Sandbox.Event.Streamer.ChatMessageAttribute">
      <summary>
            Event called when chat message comes in
            </summary>
    </member>
    <member name="M:Sandbox.SandboxGameExtensions.Reset(Sandbox.ClothingContainer,Sandbox.SkinnedModelRenderer)">
      <summary>
            Clear the outfit from this model, make it named
            </summary>
    </member>
    <member name="M:Sandbox.SandboxGameExtensions.Apply(Sandbox.ClothingContainer,Sandbox.SkinnedModelRenderer)">
      <summary>
            Dress a skinned model renderer with an outfit
            </summary>
    </member>
    <member name="M:Sandbox.SandboxGameExtensions.MountAsync(Sandbox.Package)">
      <summary>
            Download and mount this package. If withCode is true we'll try to load the assembly if it exists.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxGameExtensions.IsMounted(Sandbox.Package)">
      <summary>
            Check if the package is installed and mounted
            </summary>
    </member>
    <member name="M:Sandbox.SandboxGameExtensions.PlayCollisionSound(Sandbox.Surface,Vector3,System.Single)">
      <summary>
            Play a collision sound based on this shape's surface. Can return null if sound is invalid, or too quiet to play.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxGameExtensions.ToScreen(Vector3)">
      <summary>
            Clientside, returns position of this 3D vector on local clients' screen in 2D coordinates based on the Camera
            </summary>
      <param name="self">The vector to transform/project.</param>
      <returns>
            The position of this vector3 on the local clients' screen.<br />
            X and Y components are in range of 0 (left, top) to 1 (right, bottom).<br />
            The Z component stores whether this vector is behind the screen (&lt;0) or in front of it (&gt;0).
            </returns>
    </member>
    <member name="M:Sandbox.SandboxGameExtensions.ToScreen(Vector3,Vector2)">
      <summary>
            Same as <see cref="M:Sandbox.SandboxGameExtensions.ToScreen(Vector3)" />, but return value is in absolute coordinates.
            </summary>
      <param name="self">The vector to transform/project.</param>
      <param name="screenSize">Screen size. You probably want to use <see cref="P:Sandbox.Screen.Size" />.</param>
      <returns>Will return null if this vector is behind the screen, otherwise returns position of it on the local clients' screen.</returns>
    </member>
    <member name="M:Sandbox.SandboxGameExtensions.Draw(Sandbox.VertexBuffer,Sandbox.Material,Sandbox.RenderAttributes)">
      <summary>
            Draw this mesh using Material
            </summary>
    </member>
    <member name="M:Sandbox.SoundHandleExtensions.SetParent(Sandbox.SoundHandle,Sandbox.GameObject)">
      <summary>
            Tell the SoundHandle to follow this GameObject's position
            </summary>
    </member>
    <member name="T:Sandbox.FileSystem">
      <summary>
            A filesystem that can be accessed by the game.
            </summary>
    </member>
    <member name="M:Sandbox.FileSystem.NormalizeFilename(System.String)">
      <summary>
            Normalizes given file path so the game's filesystem can understand it. Fixes slashes and lowercases the file path.
            </summary>
      <param name="filepath">The file path to normalize</param>
      <returns>The normalized file path</returns>
    </member>
    <member name="P:Sandbox.FileSystem.Mounted">
      <summary>
            All mounted content.
            </summary>
    </member>
    <member name="P:Sandbox.FileSystem.Data">
      <summary>
            A subset of <see cref="P:Sandbox.FileSystem.OrganizationData" /> for custom gamemode data.
            </summary>
    </member>
    <member name="P:Sandbox.FileSystem.OrganizationData">
      <summary>
            A filesystem for custom data, per gamemode's organization.
            </summary>
    </member>
    <member name="P:Sandbox.FileSystem.Localization">
      <summary>
            A filesystem for localization
            </summary>
    </member>
    <member name="P:Sandbox.FileSystem.ProjectSettings">
      <summary>
            Internal until we have a reason for it not to be
            </summary>
    </member>
    <member name="P:Sandbox.Game.InputContext">
      <summary>
            The input context for this context (menu, gamemenu, client)
            </summary>
    </member>
    <member name="P:Sandbox.Game.AppId">
      <summary>
            Steam AppId of S&amp;box.
            </summary>
    </member>
    <member name="P:Sandbox.Game.InGame">
      <summary>
            Return true if we're in a game (ie, not in the main menu)
            </summary>
    </member>
    <member name="P:Sandbox.Game.IsEditor">
      <summary>
            Returns true if the game is running with the editor enabled
            </summary>
    </member>
    <member name="P:Sandbox.Game.Ident">
      <summary>
            Returns the current game's ident - ie facepunch.sandbox
            </summary>
    </member>
    <member name="P:Sandbox.Game.IsMainMenuVisible">
      <summary>
            Returns true if the main menu is visible. Note that this will work serverside too but will only
            return the state of the host.
            </summary>
    </member>
    <member name="P:Sandbox.Game.IsRecordingVideo">
      <summary>
            True if we're currently recording a video (using the video command, or F6)
            </summary>
    </member>
    <member name="P:Sandbox.Game.IsClosing">
      <summary>
            Set to true when the game is closing
            </summary>
    </member>
    <member name="P:Sandbox.Game.IsRunningInVR">
      <summary>
            Return true if we're running in VR
            </summary>
    </member>
    <member name="P:Sandbox.Game.IsRunningOnHandheld">
      <summary>
            Return true if we're running on a handheld device (the deck). Will always be false serverside.
            </summary>
    </member>
    <member name="P:Sandbox.Game.Random">
      <summary>
            A shared random that is automatically seeded on tick
            </summary>
    </member>
    <member name="M:Sandbox.Game.SetRandomSeed(System.Int32)">
      <summary>
            Set the seed for Game.Random
            </summary>
    </member>
    <member name="P:Sandbox.Game.SteamId">
      <summary>
            Your SteamId
            </summary>
    </member>
    <member name="M:Sandbox.Game.CreateWebSurface">
      <summary>
            Create a limited web surface
            </summary>
    </member>
    <member name="M:Sandbox.Game.Disconnect">
      <summary>
            Disconnect from the current game session
            </summary>
    </member>
    <member name="P:Sandbox.Game.PhysicsTrace">
      <summary>
            Trace against the physics in the current scene
            </summary>
    </member>
    <member name="P:Sandbox.Game.SceneTrace">
      <summary>
            Trace against the physics and hitboxes in the current scene
            </summary>
    </member>
    <member name="M:Sandbox.Game.Close">
      <summary>
            Close the current game.
            </summary>
    </member>
    <member name="M:Sandbox.Game.Load(System.String,System.Boolean)">
      <summary>
            Load a game. You can configure the new game with LaunchArguments before calling this.
            </summary>
    </member>
    <member name="M:Sandbox.Game.TakeScreenshot">
      <summary>
            Capture a screenshot. Saves it in Steam.
            </summary>
    </member>
    <member name="P:Sandbox.Game.CheatsEnabled">
      <summary>
            This has to be in Game.dll so the codegen will get generated for it
            </summary>
    </member>
    <member name="M:Sandbox.Game.InitUnitTest``1">
      <summary>
            Initialize for a unit test
            </summary>
    </member>
    <member name="P:Sandbox.Game.IsMenu">
      <summary>
            Returns true only when current code is running in the menu.
            </summary>
    </member>
    <member name="M:Sandbox.Game.AssertMenu(System.String)">
      <summary>
            Throws an exception when called from client or server.
            </summary>
    </member>
    <member name="M:Sandbox.Game.Overlay.ShowGameModal(System.String)">
      <summary>
            Opens a modal for the specified game package
            </summary>
      <param name="packageIdent" />
    </member>
    <member name="M:Sandbox.Game.Overlay.ShowMapModal(System.String)">
      <summary>
            Opens a modal for the specified map package
            </summary>
      <param name="packageIdent" />
    </member>
    <member name="M:Sandbox.Game.Overlay.ShowPackageModal(System.String)">
      <summary>
            Opens a modal for the specified package
            </summary>
      <param name="ident" />
    </member>
    <member name="M:Sandbox.Game.Overlay.ShowPackageModal(System.String,System.String)">
      <summary>
            Opens a modal for the specified package on the specified page
            </summary>
      <param name="ident" />
      <param name="page" />
    </member>
    <member name="M:Sandbox.Game.Overlay.ShowNewsModal(Sandbox.Services.News)">
      <summary>
            Opens a modal for the news item
            </summary>
    </member>
    <member name="M:Sandbox.Game.Overlay.ShowOrganizationModal(Sandbox.Package.Organization)">
      <summary>
            Opens a modal for the specified organization. 
            This is most likely called from a Package - so get the organization from there.
            </summary>
      <param name="org" />
    </member>
    <member name="M:Sandbox.Game.Overlay.ShowReviewModal(Sandbox.Package)">
      <summary>
            Opens a modal to review the specified package
            </summary>
      <param name="package" />
    </member>
    <member name="M:Sandbox.Game.Overlay.ShowPackageSelector(System.String,System.Action{Sandbox.Package},System.Action{System.String})">
      <summary>
            Opens a modal for selecting a package
            </summary>
    </member>
    <member name="M:Sandbox.Game.Overlay.ShowFriendsList(Sandbox.Modals.FriendsListModalOptions)">
      <summary>
            Opens a modal that shows the user's friends list
            </summary>
      <param name="options" />
    </member>
    <member name="M:Sandbox.Game.Overlay.ShowServerList(Sandbox.Modals.ServerListConfig@)">
      <summary>
            Opens a modal that shows a list of active servers
            </summary>
    </member>
    <member name="M:Sandbox.Game.Overlay.ShowSettingsModal">
      <summary>
            Opens a modal that lets you modify your settings
            </summary>
    </member>
    <member name="M:Sandbox.Game.Overlay.ShowBinds">
      <summary>
            Opens a modal that lets you view and rebind game input actions.
            </summary>
    </member>
    <member name="M:Sandbox.Game.Overlay.CreateGame(Sandbox.Modals.CreateGameOptions@)">
      <summary>
            Opens a modal to create a multiplayer game. We use this in the menu when you click "Create Game"
            and the game has options.
            </summary>
    </member>
    <member name="M:Sandbox.Game.Overlay.ShowPlayer(Sandbox.SteamId,System.String)">
      <summary>
            View a selected user's profile
            </summary>
    </member>
    <member name="P:Sandbox.Game.Overlay.IsOpen">
      <summary>
            Returns true if any overlay is open
            </summary>
    </member>
    <member name="P:Sandbox.Game.Overlay.IsPauseMenuOpen">
      <summary>
            Returns true if the pause menu overlay is open
            </summary>
    </member>
    <member name="P:Sandbox.Internal.GlobalGameNamespace.Log">
      <summary>
            Log information to console for debugging purposes.
            </summary>
    </member>
    <member name="P:Sandbox.Internal.GlobalGameNamespace.Cookie">
      <summary>
            Data storage that persists across sessions.
            </summary>
    </member>
    <member name="P:Sandbox.Internal.GlobalGameNamespace.TypeLibrary">
      <summary>
            Allows access to all available types, reflection style.
            </summary>
    </member>
    <member name="P:Sandbox.Internal.GlobalGameNamespace.NodeLibrary">
      <summary>
            A library of node definitions for action graphs.
            </summary>
    </member>
    <member name="T:Sandbox.ColorGradient">
      <summary>
            A color gradient for use as entity and asset properties
            TODO: Gradient property editor
            </summary>
    </member>
    <member name="P:Sandbox.ColorGradient.IsValid">
      <summary>
            Whether the curve was loaded correctly or not
            </summary>
    </member>
    <member name="T:Sandbox.FGDCurve">
      <summary>
            A helper class to handle 'curve' FGD type.
            TOOD: Get rid of in favor of new curve stuff.
            </summary>
    </member>
    <member name="M:Sandbox.FGDCurve.Get(System.Single,System.Boolean)">
      <summary>
            The cubic spline function in ranges as defined in Hammer/Asset editor.
            </summary>
    </member>
    <member name="M:Sandbox.FGDCurve.GetNormalized(System.Single,System.Boolean)">
      <summary>
            The cubic spline function normalized to ranges [0,1] on both input and output.
            </summary>
    </member>
    <member name="P:Sandbox.FGDCurve.Mins">
      <summary>
            The bottom left corner of the curve. Mins and Maxs represent the range of inputs and outputs of the curve function.
            </summary>
    </member>
    <member name="P:Sandbox.FGDCurve.Maxs">
      <summary>
            The top right corner of the curve. Mins and Maxs represent the range of inputs and outputs of the curve function.
            </summary>
    </member>
    <member name="P:Sandbox.FGDCurve.IsValid">
      <summary>
            Whether the curve was loaded correctly or not
            </summary>
    </member>
    <member name="T:Sandbox.EditorHandleAttribute">
      <summary>
            When applied to a component, the editor will draw a selectable handle sprite for the gameobject in scene
            </summary>
    </member>
    <member name="T:Sandbox.AudioListener">
      <summary>
            If this exists and is enabled in a scene, then the client will hear from this point rather than
            from the cameras point of view.
            </summary>
    </member>
    <member name="P:Sandbox.AudioListener.UseCameraDirection">
      <summary>
            If true, while the audio listener position will be used, the rotation element will come from the camera.
            </summary>
    </member>
    <member name="P:Sandbox.BaseSoundComponent.TargetMixer">
      <summary>
            The mixer we want this sound to play through
            </summary>
    </member>
    <member name="T:Sandbox.DspVolumeGameSystem">
      <summary>
            Apply DSP to mixer when listener is inside a DspVolume
            </summary>
    </member>
    <member name="T:Sandbox.LipSync">
      <summary>
            Drive morphs with lipsync from sounds.
            </summary>
    </member>
    <member name="T:Sandbox.SoundBoxComponent">
      <summary>
            Plays a sound within a box.
            </summary>
    </member>
    <member name="T:Sandbox.SoundPointComponent">
      <summary>
            Plays a sound at a point in the world.
            </summary>
    </member>
    <member name="P:Sandbox.SoundPointComponent.Sandbox#Component#ITemporaryEffect#IsActive">
      <summary>
            Return true if the sound is playing
            </summary>
    </member>
    <member name="T:Sandbox.SoundscapeTrigger">
      <summary>
            Plays a soundscape when the listener enters the trigger area.
            </summary>
    </member>
    <member name="F:Sandbox.SoundscapeTrigger.TriggerType.Point">
      <summary>
            Can be heard from anywhere.
            </summary>
    </member>
    <member name="F:Sandbox.SoundscapeTrigger.TriggerType.Sphere">
      <summary>
            Can be heard within a radius.
            </summary>
    </member>
    <member name="F:Sandbox.SoundscapeTrigger.TriggerType.Box">
      <summary>
            Can be heard within the bounds of a box.
            </summary>
    </member>
    <member name="P:Sandbox.SoundscapeTrigger.Type">
      <summary>
            Determines when/where the soundscape can be heard.
            </summary>
    </member>
    <member name="P:Sandbox.SoundscapeTrigger.TargetMixer">
      <summary>
            Ths mixer that the soundscape will play on.
            </summary>
    </member>
    <member name="P:Sandbox.SoundscapeTrigger.StayActiveOnExit">
      <summary>
            When true the soundscape will keep playing after exiting the area, and will
            only stop playing once another soundscape takes over.
            </summary>
    </member>
    <member name="P:Sandbox.SoundscapeTrigger.Radius">
      <summary>
            The radius of the Soundscape when <see cref="P:Sandbox.SoundscapeTrigger.Type" /> is set to <see cref="F:Sandbox.SoundscapeTrigger.TriggerType.Sphere" />.
            </summary>
    </member>
    <member name="P:Sandbox.SoundscapeTrigger.BoxSize">
      <summary>
            The size of the Soundscape when <see cref="P:Sandbox.SoundscapeTrigger.Type" /> is set to <see cref="F:Sandbox.SoundscapeTrigger.TriggerType.Box" />.
            </summary>
    </member>
    <member name="M:Sandbox.SoundscapeTrigger.TestListenerPosition(Vector3)">
      <summary>
            Return true if they should hear this soundscape when in this position
            </summary>
    </member>
    <member name="M:Sandbox.SoundscapeTrigger.StartSoundscape(Sandbox.Soundscape)">
      <summary>
            Load and start this soundscape..
            </summary>
    </member>
    <member name="P:Sandbox.SoundscapeTrigger.PlayingSound.IsDead">
      <summary>
            True if this sound has finished, can be removed
            </summary>
    </member>
    <member name="P:Sandbox.SoundscapeTrigger.PlayingSound.Finished">
      <summary>
            Gets set when it's time to fade this out
            </summary>
    </member>
    <member name="F:Sandbox.SoundscapeTrigger.LoopedSoundEntry.currentVolume">
      <summary>
            We store the current volume so we can seamlessly fade in and out
            </summary>
    </member>
    <member name="P:Sandbox.SoundscapeTrigger.LoopedSoundEntry.IsDead">
      <summary>
            Consider us dead if the soundscape system thinks we're finished and our volume is low
            </summary>
    </member>
    <member name="M:Sandbox.SoundscapeTrigger.LoopedSoundEntry.TryUpdateFrom(Sandbox.Soundscape.LoopedSound,System.Single,System.Single)">
      <summary>
            If we're using the same sound file as this incoming sound, and we're on our way out.. then
            let it replace us instead. This is much nicer.
            </summary>
    </member>
    <member name="T:Sandbox.Voice">
      <summary>
            Records and transmits voice/microphone input to other players.
            </summary>
    </member>
    <member name="P:Sandbox.Voice.LastPlayed">
      <summary>
            How long has it been since this sound played?
            </summary>
    </member>
    <member name="P:Sandbox.Voice.LaughterScore">
      <summary>
            Laughter score for the current audio frame, between 0 and 1
            </summary>
    </member>
    <member name="P:Sandbox.Voice.VoiceMixer">
      <inheritdoc cref="P:Sandbox.SoundHandle.TargetMixer" />
    </member>
    <member name="P:Sandbox.Voice.Distance">
      <inheritdoc cref="P:Sandbox.SoundHandle.Distance" />
    </member>
    <member name="P:Sandbox.Voice.Falloff">
      <inheritdoc cref="P:Sandbox.SoundHandle.Falloff" />
    </member>
    <member name="P:Sandbox.Voice.Visemes">
      <summary>
            A list of 15 lipsync viseme weights. Requires <see cref="T:Sandbox.LipSync" /> to be enabled.
            </summary>
    </member>
    <member name="P:Sandbox.Voice.IsListening">
      <summary>
            Returns true if the mic is listening. Even if it's listening, it might
            not be playing - because it will only record and transmit if it can hear sound.
            </summary>
    </member>
    <member name="P:Sandbox.Voice.Amplitude">
      <summary>
            Measure of audio loudness.
            </summary>
    </member>
    <member name="M:Sandbox.Voice.ExcludeFilter">
      <summary>
            Exclude these connection from hearing our voice.
            </summary>
    </member>
    <member name="M:Sandbox.Voice.ShouldHearVoice(Sandbox.Connection)">
      <summary>
            Whether we want to hear voice from a particular connection.
            </summary>
    </member>
    <member name="T:Sandbox.CameraComponent">
      <summary>
            Every scene should have at least one Camera.
            </summary>
    </member>
    <member name="M:Sandbox.CameraComponent.AddCommandList(Sandbox.Rendering.CommandList,Sandbox.Rendering.Stage,System.Int32)">
      <summary>
            Add a command list to the render
            </summary>
    </member>
    <member name="M:Sandbox.CameraComponent.RemoveCommandList(Sandbox.Rendering.CommandList,Sandbox.Rendering.Stage)">
      <summary>
            Remove an entry 
            </summary>
    </member>
    <member name="M:Sandbox.CameraComponent.RemoveCommandList(Sandbox.Rendering.CommandList)">
      <summary>
            Remove an entry 
            </summary>
    </member>
    <member name="M:Sandbox.CameraComponent.ClearCommandLists(Sandbox.Rendering.Stage)">
      <summary>
            Remove all entries in this stage
            </summary>
    </member>
    <member name="M:Sandbox.CameraComponent.ClearCommandLists">
      <summary>
            Remove all entries in this stage
            </summary>
    </member>
    <member name="M:Sandbox.CameraComponent.ExecuteCommandLists(Sandbox.Rendering.Stage)">
      <summary>
            Called during the render pipeline. Currently this is rendered on the main thread, but ideally, one day, this will all be threaded.
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.ClearFlags">
      <summary>
            The clear flags for this camera.
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.BackgroundColor">
      <summary>
            The background color of this camera's view if there's no 2D Sky in the scene.
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.IsMainCamera">
      <summary>
            Returns true if this is the main game camera.
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.FovAxis">
      <summary>
            The axis to use for the field of view.
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.FieldOfView">
      <summary>
            The field of view of this camera.
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.ZNear">
      <summary>
            The camera's near clip plane distance. This is the closest distance this camera will be able to render.
            A good value for this is about 5. Below 5 and particularly below 1 you're going to start to see
            a lot of artifacts like z-fighting.
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.ZFar">
      <summary>
            The camera's far clip plane distance. This is the furthest distance this camera will be able to render.
            This value totally depends on the game you're making. Shorter the better, sensible ranges would be
            between about 1000 and 30000, but if you want it to be further out you can balance that out by making
            ZNear larger.
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.Priority">
      <summary>
            The priority of this camera. Dictates which camera gets rendered on top of another. Higher means it'll be rendered on top.
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.Orthographic">
      <summary>
            Whether or not to use orthographic projection instead of perspective.
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.OrthographicHeight">
      <summary>
            The orthographic size for this camera while <see cref="P:Sandbox.CameraComponent.Orthographic" /> is set to true.
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.TargetEye">
      <inheritdoc cref="P:Sandbox.SceneCamera.TargetEye" />
    </member>
    <member name="P:Sandbox.CameraComponent.RenderTags">
      <summary>
            A list of tags that will be checked to include specific game objects when rendering this camera.
            If none are set, it will include everything.
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.RenderExcludeTags">
      <summary>
            A list of tags that will be checked to exclude specific game objects when rendering this camera.
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.Viewport">
      <summary>
            The size of the camera represented on the screen. Normalized between 0 and 1.
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.RenderTarget">
      <summary>
            The texture to draw this camera to.
            Requires <see cref="M:Sandbox.Texture.CreateRenderTarget" /></summary>
    </member>
    <member name="P:Sandbox.CameraComponent.SceneCamera">
      <summary>
            Accessor for getting this Camera Component's SceneCamera
            </summary>
    </member>
    <member name="M:Sandbox.CameraComponent.UpdateSceneCamera(Sandbox.SceneCamera,System.Boolean)">
      <summary>
            Update a SceneCamera with the settings from this component
            </summary>
    </member>
    <member name="M:Sandbox.CameraComponent.AddToRenderList(SwapChainHandle_t,System.Nullable{Vector2})">
      <summary>
            This should only be called when creating render lists!!
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.ScreenRect">
      <summary>
            The size of the viewport, in screen coordinates
            </summary>
    </member>
    <member name="M:Sandbox.CameraComponent.ScreenToWorld(Vector2)">
      <inheritdoc cref="M:Sandbox.SceneCamera.ToWorld(Vector2)" />
    </member>
    <member name="M:Sandbox.CameraComponent.GetFrustum(Sandbox.Rect)">
      <inheritdoc cref="M:Sandbox.SceneCamera.GetFrustum(Sandbox.Rect)" />
    </member>
    <member name="M:Sandbox.CameraComponent.GetFrustum(Sandbox.Rect,Vector3)">
      <inheritdoc cref="M:Sandbox.SceneCamera.GetFrustum(Sandbox.Rect,Vector3)" />
    </member>
    <member name="M:Sandbox.CameraComponent.RenderToTexture(Sandbox.Texture)">
      <inheritdoc cref="M:Sandbox.Graphics.RenderToTexture(Sandbox.SceneCamera,Sandbox.Texture)" />
    </member>
    <member name="P:Sandbox.CameraComponent.CustomProjectionMatrix">
      <summary>
            Allows specifying a custom projection matrix for this camera
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.CustomSize">
      <summary>
            Allows specifying a custom aspect ratio for this camera.
            By default the camera size is screen size or render target size.
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.ProjectionMatrix">
      <summary>
            Get frustum projection matrix.
            </summary>
    </member>
    <member name="M:Sandbox.CameraComponent.CalculateObliqueMatrix(Sandbox.Plane)">
      <summary>
            Calculates a projection matrix with an oblique clip-plane defined in world space.
            </summary>
    </member>
    <member name="F:Sandbox.CameraComponent.Axis.Horizontal">
      <summary>
            Fits the view within the x-axis.
            </summary>
    </member>
    <member name="F:Sandbox.CameraComponent.Axis.Vertical">
      <summary>
            Fits the view within the y-axis.
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.Hud">
      <summary>
            Allows drawing on the camera. This is drawn before the post processing.
            </summary>
    </member>
    <member name="P:Sandbox.CameraComponent.Overlay">
      <summary>
            Used to draw to the screen. This is drawn on top of everything, so is good for debug overlays etc.
            </summary>
    </member>
    <member name="T:Sandbox.CubemapFog">
      <summary>
            Applies a cubemap fog effect to the camera
            </summary>
    </member>
    <member name="T:Sandbox.Tonemapping">
      <summary>
            Applies a tonemapping effect to the camera.
            </summary>
    </member>
    <member name="T:Sandbox.Tonemapping.TonemappingMode">
      <summary>
            Options to select a tonemapping algorithm to use for color grading.
            </summary>
    </member>
    <member name="F:Sandbox.Tonemapping.TonemappingMode.HableFilmic">
      <summary>
            John Hable's filmic tonemapping algorithm.
            Matches the default curve Source 2 uses based on Uncharted 2.
            </summary>
    </member>
    <member name="F:Sandbox.Tonemapping.TonemappingMode.ACES">
      <summary>
            The most realistic tonemapper at handling bright light, desaturating light as it becomes brighter.
            This is slightly more expensive than other options.
            </summary>
    </member>
    <member name="F:Sandbox.Tonemapping.TonemappingMode.ReinhardJodie">
      <summary>
            Reinhard's tonemapper, which is a simple and fast tonemapper.
            </summary>
    </member>
    <member name="F:Sandbox.Tonemapping.TonemappingMode.Linear">
      <summary>
            Linear tonemapper, only applies autoexposure.
            </summary>
    </member>
    <member name="P:Sandbox.Tonemapping.Mode">
      <summary>
            Which tonemapping algorithm to use for color grading.
            </summary>
    </member>
    <member name="M:Sandbox.Tonemapping.Upgrader_v3(System.Text.Json.Nodes.JsonObject)">
      <summary>
            Remove Exposure Bias
            this doesn't make much sense since it's tied to only HableFilmic and does the same thing as ExposureCompensation
            </summary>
    </member>
    <member name="M:Sandbox.Tonemapping.Upgrader_v2(System.Text.Json.Nodes.JsonObject)">
      <summary>
            Remap the old "Legacy" mode to HableFilmic 
            </summary>
    </member>
    <member name="T:Sandbox.CharacterController">
      <summary>
            Allows collision contrained movement without the need for a rigidbody. This is not affected by forces and will only move when you call the Move() method.
            </summary>
    </member>
    <member name="P:Sandbox.CharacterController.Bounciness">
      <summary>
            When jumping into walls, should we bounce off or just stop dead?
            </summary>
    </member>
    <member name="P:Sandbox.CharacterController.UseCollisionRules">
      <summary>
            If enabled, determine what to collide with using current project's collision rules for the <see cref="P:Sandbox.GameObject.Tags" />
            of the containing <see cref="T:Sandbox.GameObject" />.
            </summary>
    </member>
    <member name="M:Sandbox.CharacterController.Accelerate(Vector3)">
      <summary>
            Add acceleration to the current velocity. 
            No need to scale by time delta - it will be done inside.
            </summary>
    </member>
    <member name="M:Sandbox.CharacterController.ApplyFriction(System.Single,System.Single)">
      <summary>
            Apply an amount of friction to the current velocity.
            No need to scale by time delta - it will be done inside.
            </summary>
    </member>
    <member name="M:Sandbox.CharacterController.TraceDirection(Vector3)">
      <summary>
            Trace the controller's current position to the specified delta
            </summary>
    </member>
    <member name="M:Sandbox.CharacterController.Punch(Vector3@)">
      <summary>
            Disconnect from ground and punch our velocity. This is useful if you want the player to jump or something.
            </summary>
    </member>
    <member name="M:Sandbox.CharacterController.Move">
      <summary>
            Move a character, with this velocity
            </summary>
    </member>
    <member name="M:Sandbox.CharacterController.MoveTo(Vector3,System.Boolean)">
      <summary>
            Move from our current position to this target position, but using tracing an sliding.
            This is good for different control modes like ladders and stuff.
            </summary>
    </member>
    <member name="M:Sandbox.CharacterControllerHelper.TraceFromTo(Vector3,Vector3)">
      <summary>
            Trace this from one position to another
            </summary>
    </member>
    <member name="M:Sandbox.CharacterControllerHelper.TryMove(System.Single)">
      <summary>
            Try to move to the position. Will return the fraction of the desired velocity that we traveled.
            Position and Velocity will be what we recommend using.
            </summary>
    </member>
    <member name="M:Sandbox.CharacterControllerHelper.TraceMove(Vector3)">
      <summary>
            Move our position by this delta using trace. If we hit something we'll stop,
            we won't slide across it nicely like TryMove does.
            </summary>
    </member>
    <member name="M:Sandbox.CharacterControllerHelper.TryMoveWithStep(System.Single,System.Single)">
      <summary>
            Like TryMove but will also try to step up if it hits a wall
            </summary>
    </member>
    <member name="T:Sandbox.VelocityClipPlanes">
      <summary>
            Used to store a list of planes that an object is going to hit, and then
            remove velocity from them so the object can slide over the surface without
            going through any of the planes.
            </summary>
    </member>
    <member name="P:Sandbox.VelocityClipPlanes.Max">
      <summary>
            Maximum number of planes that can be hit
            </summary>
    </member>
    <member name="P:Sandbox.VelocityClipPlanes.Count">
      <summary>
            Number of planes we're currently holding
            </summary>
    </member>
    <member name="M:Sandbox.VelocityClipPlanes.TryAdd(Vector3,Vector3@,System.Single)">
      <summary>
            Try to add this plane and restrain velocity to it (and its brothers)
            </summary>
      <returns>False if we ran out of room and should stop adding planes</returns>
    </member>
    <member name="M:Sandbox.VelocityClipPlanes.TryClip(Vector3@)">
      <summary>
            Try to clip our velocity to all the planes, so we're not travelling into them
            Returns true if we clipped properly
            </summary>
    </member>
    <member name="M:Sandbox.VelocityClipPlanes.MovingTowardsAnyPlane(Vector3,System.Int32)">
      <summary>
            Returns true if we're moving towards any of our planes (except for skip)
            </summary>
    </member>
    <member name="M:Sandbox.VelocityClipPlanes.StartBump(Vector3)">
      <summary>
            Start a new bump. Clears planes and resets BumpVelocity
            </summary>
    </member>
    <member name="M:Sandbox.VelocityClipPlanes.ClipVelocity(Vector3,Vector3,System.Single)">
      <summary>
            Clip the velocity to the normal
            </summary>
    </member>
    <member name="T:Sandbox.BoxCollider">
      <summary>
            Defines a box collider.
            </summary>
    </member>
    <member name="P:Sandbox.BoxCollider.Scale">
      <summary>
            The size of the box, from corner to corner.
            </summary>
    </member>
    <member name="P:Sandbox.BoxCollider.Center">
      <summary>
            The center of the box relative to this GameObject
            </summary>
    </member>
    <member name="T:Sandbox.CapsuleCollider">
      <summary>
            Defines a capsule collider.
            </summary>
    </member>
    <member name="P:Sandbox.CapsuleCollider.Start">
      <summary>
            Bottom point of the capsule
            </summary>
    </member>
    <member name="P:Sandbox.CapsuleCollider.End">
      <summary>
            Top point of the capsule
            </summary>
    </member>
    <member name="P:Sandbox.CapsuleCollider.Radius">
      <summary>
            Radius of the capsule
            </summary>
    </member>
    <member name="P:Sandbox.Collider.IsDynamic">
      <summary>
            Return true if this collider is using dynamic physics.
            Returns false if this is a keyframe body, or a static physics body.
            </summary>
    </member>
    <member name="P:Sandbox.Collider.Rigidbody">
      <summary>
            If this collider is part of a Rigidbody then this will return the component
            that it's attached to. If this is null it's usually a good indication that this
            collider is either static, world geometry, or a keyframe.
            </summary>
    </member>
    <member name="P:Sandbox.Collider.Friction">
      <summary>
            Allows overriding the friction for this collider. This value 
            can exceed 1 to to give crazy grippy friction if you want it to, 
            but the normal value is between 0 and 1.
            </summary>
    </member>
    <member name="P:Sandbox.Collider.SurfaceVelocity">
      <summary>
            Set the local velocity of the surface so things can slide along it, like a conveyor belt
            </summary>
    </member>
    <member name="P:Sandbox.Collider.LocalBounds">
      <summary>
            Calculated local bounds of all physics shapes in this collider.
            </summary>
    </member>
    <member name="M:Sandbox.Collider.CreatePhysicsShapes(Sandbox.PhysicsBody)">
      <summary>
            Overridable in derived component to create shapes
            </summary>
    </member>
    <member name="P:Sandbox.Collider.OnTriggerEnter">
      <summary>
            Called when a collider enters this trigger
            </summary>
    </member>
    <member name="P:Sandbox.Collider.OnTriggerExit">
      <summary>
            Called when a collider exits this trigger
            </summary>
    </member>
    <member name="P:Sandbox.Collider.OnObjectTriggerEnter">
      <summary>
            Called when a gameobject enters this trigger
            </summary>
    </member>
    <member name="P:Sandbox.Collider.OnObjectTriggerExit">
      <summary>
            Called when a gameobject exits this trigger
            </summary>
    </member>
    <member name="P:Sandbox.Collider.Touching">
      <summary>
            If we're a trigger, this will list all of the colliders that are touching us.
            If we're not a trigger, this will list all of the triggers that we are touching.
            </summary>
    </member>
    <member name="M:Sandbox.Collider.ConfigureShapes">
      <summary>
            Apply any things that we an apply after they're created
            </summary>
    </member>
    <member name="M:Sandbox.Collider.UpdateKeyframeTransform">
      <summary>
            Called right before physics simulation to move the keyframebody to its new transform.
            </summary>
    </member>
    <member name="M:Sandbox.Collider.GetVelocityAtPoint(Vector3)">
      <summary>
            Get the velocity of this collider at the specific point in word coordinates.
            </summary>
    </member>
    <member name="M:Sandbox.Collider.FindClosestPoint(Vector3)">
      <summary>
            Returns the closest point to the given one between all convex shapes of this body.
            </summary>
    </member>
    <member name="T:Sandbox.CollisionEventSystem">
      <summary>
            Used to abstract the listening of collision events
            </summary>
    </member>
    <member name="T:Sandbox.HullCollider">
      <summary>
            Defines a box, cone, or cylinder hull collider.
            </summary>
    </member>
    <member name="P:Sandbox.HullCollider.Type">
      <summary>
            The type of primitive.
            </summary>
    </member>
    <member name="P:Sandbox.HullCollider.Center">
      <summary>
            The center of the primitive relative to this GameObject.
            </summary>
    </member>
    <member name="P:Sandbox.HullCollider.BoxSize">
      <summary>
            The size of the box, from corner to corner.
            </summary>
    </member>
    <member name="T:Sandbox.ModelCollider">
      <summary>
            Defines a collider based on a model.
            </summary>
    </member>
    <member name="T:Sandbox.ModelPhysics">
      <summary>
            Physics for a model. This is primarily used for ragdolls and other physics driven models, otherwise you should be using a Rigidbody.
            </summary>
    </member>
    <member name="P:Sandbox.ModelPhysics.MotionEnabled">
      <summary>
            Enable to drive renderer from physics, disable to drive physics from renderer.
            </summary>
    </member>
    <member name="M:Sandbox.ModelPhysics.OnTagsChanged">
      <summary>
            The gameobject tags have changed, update collision tags on the target objects
            </summary>
    </member>
    <member name="M:Sandbox.ModelPhysics.CopyBonesFrom(Sandbox.SkinnedModelRenderer,System.Boolean)">
      <summary>
            Copy the bone positions and velocities from a different SkinnedModelRenderer
            </summary>
    </member>
    <member name="T:Sandbox.PlaneCollider">
      <summary>
            Defines a plane collider.
            </summary>
    </member>
    <member name="P:Sandbox.PlaneCollider.Scale">
      <summary>
            The size of the plane, from corner to corner.
            </summary>
    </member>
    <member name="P:Sandbox.PlaneCollider.Center">
      <summary>
            The center of the plane relative to this GameObject
            </summary>
    </member>
    <member name="T:Sandbox.Rigidbody">
      <summary>
            Adds physics properties to an object. Requires a collider to be attached to the same object.
            </summary>
    </member>
    <member name="P:Sandbox.Rigidbody.Gravity">
      <summary>
            Is gravity enabled or not.
            </summary>
    </member>
    <member name="P:Sandbox.Rigidbody.MassOverride">
      <summary>
            Override mass for this body, only when value is more than zero
            </summary>
    </member>
    <member name="P:Sandbox.Rigidbody.MassCenter">
      <summary>
            Center of mass for this rigidbody in local space coordinates.
            </summary>
    </member>
    <member name="P:Sandbox.Rigidbody.CollisionEventsEnabled">
      <summary>
            Enable or disable touch events. If you disable the events then ICollisionListener won't get any touch events
            and you won't get things like collision sounds.
            </summary>
    </member>
    <member name="P:Sandbox.Rigidbody.CollisionUpdateEventsEnabled">
      <summary>
            Like CollisionEventsEnabled but means the OnCollisionUpdate gets called when the collision persists
            </summary>
    </member>
    <member name="P:Sandbox.Rigidbody.Sleeping">
      <inheritdoc cref="P:Sandbox.PhysicsBody.Sleeping" />
    </member>
    <member name="P:Sandbox.Rigidbody.TargetTransform">
      <summary>
            Used for transforming a selected rigidbody in editor, if useful for gameplay this could be made public.
            </summary>
    </member>
    <member name="P:Sandbox.Rigidbody.PhysicsBody">
      <summary>
            Get the actual physics body that was created by this component. You should be careful, this
            can of course be null when the object is not enabled or the physics world is not available.
            It might also get deleted and re-created, so best use this to access, but don't store it.
            </summary>
    </member>
    <member name="M:Sandbox.Rigidbody.FindClosestPoint(Vector3@)">
      <summary>
            Returns the closest point to the given one between all convex shapes of this body.
            </summary>
    </member>
    <member name="M:Sandbox.Rigidbody.GetVelocityAtPoint(Vector3@)">
      <summary>
            Returns the world space velocity of a point of the object. This is useful for objects rotating around their own axis/origin.
            </summary>
    </member>
    <member name="M:Sandbox.Rigidbody.ApplyForceAt(Vector3@,Vector3@)">
      <summary>
            Applies force to this body at given position.
            </summary>
    </member>
    <member name="M:Sandbox.Rigidbody.ApplyForce(Vector3@)">
      <summary>
            Applies linear force to this body
            </summary>
    </member>
    <member name="M:Sandbox.Rigidbody.ApplyTorque(Vector3@)">
      <summary>
            Applies angular velocity to this body.
            </summary>
    </member>
    <member name="M:Sandbox.Rigidbody.ApplyImpulseAt(Vector3@,Vector3@)">
      <summary>
            Applies instant linear impulse (i.e. a bullet impact) to this body at given position
            </summary>
    </member>
    <member name="M:Sandbox.Rigidbody.ApplyImpulse(Vector3@)">
      <summary>
            Applies instant linear impulse (i.e. a bullet impact) to this body
            </summary>
    </member>
    <member name="M:Sandbox.Rigidbody.ClearForces">
      <summary>
            Clear accumulated linear forces (<see cref="M:Sandbox.Rigidbody.ApplyForce(Vector3@)" /> and <see cref="M:Sandbox.Rigidbody.ApplyForceAt(Vector3@,Vector3@)" />) during this physics frame that were not yet applied to the physics body.
            </summary>
    </member>
    <member name="M:Sandbox.Rigidbody.SmoothMove(Transform@,System.Single,System.Single)">
      <inheritdoc cref="M:Sandbox.PhysicsBody.SmoothMove(Transform@,System.Single,System.Single)" />
    </member>
    <member name="M:Sandbox.Rigidbody.SmoothMove(Vector3@,System.Single,System.Single)">
      <inheritdoc cref="M:Sandbox.PhysicsBody.SmoothMove(Vector3@,System.Single,System.Single)" />
    </member>
    <member name="M:Sandbox.Rigidbody.SmoothRotate(Rotation@,System.Single,System.Single)">
      <inheritdoc cref="M:Sandbox.PhysicsBody.SmoothRotate(Rotation@,System.Single,System.Single)" />
    </member>
    <member name="P:Sandbox.Rigidbody.Touching">
      <summary>
            This is a list of all of the triggers that we are touching.
            </summary>
    </member>
    <member name="T:Sandbox.SphereCollider">
      <summary>
            Defines a sphere collider.
            </summary>
    </member>
    <member name="T:Sandbox.Component">
      <summary>
            A GameObject can have many components, which are the building blocks of the game.
            </summary>
    </member>
    <member name="M:Sandbox.Component.InitClone(Sandbox.Component,System.Collections.Generic.Dictionary{System.Object,System.Object})">
      <summary>
            Runs after this clone has been created by a cloned GameObject.
            </summary>
      <param name="original">The original component that was cloned.</param>
      <param name="originalToClonedObject">During the cloning processe, we build a mapping from original objects to their clone, so we will need to add ourselves to it.</param>
    </member>
    <member name="M:Sandbox.Component.PostClone(System.Collections.Generic.Dictionary{System.Object,System.Object},System.Collections.Generic.Dictionary{System.Guid,System.Guid})">
      <summary>
            Runs after all objects of the original hierarchy have been cloned/created.
            Here we initialize the clones properties and fields with the values from the original object.
            <param name="originalToClonedObject">A mapping of original objects to their clones, used for all reference types.</param><param name="originalIdToCloneId">A mapping of original GUIDs to cloned GUIDs, used for GameObject and Component references in JSON.</param></summary>
    </member>
    <member name="P:Sandbox.Component.Scene">
      <summary>
            The scene this Component is in. This is a shortcut for `GameObject.Scene`.
            </summary>
    </member>
    <member name="P:Sandbox.Component.Transform">
      <summary>
            The transform of the GameObject this component belongs to. Components don't have their own transforms
            but they can access the transform of the GameObject they belong to. This is a shortcut for `GameObject.Transform`.
            </summary>
    </member>
    <member name="P:Sandbox.Component.GameObject">
      <summary>
            The GameObject this component belongs to.
            </summary>
    </member>
    <member name="P:Sandbox.Component.Task">
      <summary>
            Allow creating tasks that are automatically cancelled when the GameObject is destroyed.
            </summary>
    </member>
    <member name="P:Sandbox.Component.Components">
      <summary>
            Access components on this component's GameObject
            </summary>
    </member>
    <member name="M:Sandbox.Component.InitializeComponent">
      <summary>
            Called to call Awake, once, at startup.
            </summary>
    </member>
    <member name="P:Sandbox.Component.Enabled">
      <summary>
        <para>
            The enable state of this <see cref="T:Sandbox.Component" />.
            </para>
        <para>
            This doesn't tell you whether the component is actually active because its parent
            <see cref="T:Sandbox.GameObject" /> might be disabled. This merely tells you what the
            component wants to be. You should use <see cref="P:Sandbox.Component.Active" /> to determine whether the
            object is truly active in the scene.
            </para>
      </summary>
    </member>
    <member name="P:Sandbox.Component.Active">
      <summary>
            True if this Component is enabled, and all of its ancestor GameObjects are enabled
            </summary>
    </member>
    <member name="P:Sandbox.Component.ShouldExecute">
      <summary>
            Should this component execute? Should OnUpdate, OnEnabled get called?
            </summary>
    </member>
    <member name="M:Sandbox.Component.OnAwake">
      <summary>
            Called once per component
            </summary>
    </member>
    <member name="M:Sandbox.Component.OnEnabled">
      <summary>
            Called after Awake or whenever the component switches to being enabled (because a gameobject heirachy active change, or the component changed)
            </summary>
    </member>
    <member name="M:Sandbox.Component.OnDestroy">
      <summary>
            Called once, when the component or gameobject is destroyed
            </summary>
    </member>
    <member name="M:Sandbox.Component.OnPreRender">
      <summary>
            When enabled, called every frame, does not get called on a dedicated server
            </summary>
    </member>
    <member name="M:Sandbox.Component.SetUpdateAction``1(System.Action@,System.Action,Sandbox.Utility.HashSetEx{Sandbox.Component})">
      <summary>
            Replaces <paramref name="currentAction" /> with <paramref name="newAction" />, and adds / removes this component
            from the given <paramref name="updateSet" />, depending on whether the new action is null, and this type implements
            the given <typeparamref name="TSubscriber" /> interface.
            </summary>
    </member>
    <member name="M:Sandbox.Component.Destroy">
      <summary>
            Destroy this component, if it isn't already destroyed. The component will be removed from its
            GameObject and will stop existing. You should avoid interating with the component after calling this.
            </summary>
    </member>
    <member name="M:Sandbox.Component.DestroyGameObject">
      <summary>
            Destroy the parent GameObject. This really only exists so when you're typing Destroy you realise
            that calling Destroy only destroys the Component - not the whole GameObject.
            </summary>
    </member>
    <member name="M:Sandbox.Component.OnValidate">
      <summary>
            Called immediately after deserializing, and when a property is changed in the editor.
            </summary>
    </member>
    <member name="M:Sandbox.Component.OnRefresh">
      <summary>
            Called immediately after being refreshed from a network snapshot.
            </summary>
    </member>
    <member name="M:Sandbox.Component.EditLog(System.String,System.Object)">
      <summary>
            Called when something on the component has been edited
            </summary>
    </member>
    <member name="P:Sandbox.Component.Tags">
      <inheritdoc cref="P:Sandbox.GameObject.Tags" />
    </member>
    <member name="M:Sandbox.Component.OnTagsChanged">
      <summary>
            When tags have been updated
            </summary>
    </member>
    <member name="M:Sandbox.Component.OnParentChanged(Sandbox.GameObject,Sandbox.GameObject)">
      <summary>
            The parent has changed from one parent to another
            </summary>
    </member>
    <member name="M:Sandbox.Component.Invoke(System.Single,System.Action,System.Threading.CancellationToken)">
      <summary>
            Invoke a method in x seconds. Won't be invoked if the component is no longer active.
            </summary>
    </member>
    <member name="P:Sandbox.Component.DebugOverlay">
      <summary>
            Allows drawing of temporary debug shapes and text in the scene
            </summary>
    </member>
    <member name="M:Sandbox.Component.OnPropertyDirty``1(Sandbox.WrappedPropertySet{``0}@)">
      <summary>
            Called when a property is set, which will run a callback
            </summary>
    </member>
    <member name="M:Sandbox.Component.OnDirty">
      <summary>
            Called when the component has become dirty
            </summary>
    </member>
    <member name="M:Sandbox.Component.AddComponent``1(System.Boolean)">
      <summary>
            Add a component to this GameObject
            </summary>
    </member>
    <member name="M:Sandbox.Component.GetOrAddComponent``1(System.Boolean)">
      <summary>
            Add a component to this GameObject
            </summary>
    </member>
    <member name="M:Sandbox.Component.GetComponent``1(System.Boolean)">
      <summary>
            Get a component on this GameObject
            </summary>
    </member>
    <member name="M:Sandbox.Component.GetComponents``1(System.Boolean)">
      <summary>
            Get components on this GameObject
            </summary>
    </member>
    <member name="M:Sandbox.Component.GetComponentsInChildren``1(System.Boolean,System.Boolean)">
      <summary>
            Get components on this GameObject and on descendant GameObjects
            </summary>
    </member>
    <member name="M:Sandbox.Component.GetComponentInChildren``1(System.Boolean,System.Boolean)">
      <summary>
            Get component on this GameObject or on descendant GameObjects
            </summary>
    </member>
    <member name="M:Sandbox.Component.GetComponentsInParent``1(System.Boolean,System.Boolean)">
      <summary>
            Get components on this GameObject and on ancestor GameObjects
            </summary>
    </member>
    <member name="M:Sandbox.Component.GetComponentInParent``1(System.Boolean,System.Boolean)">
      <summary>
            Get component on this GameObject and on ancestor GameObjects
            </summary>
    </member>
    <member name="M:Sandbox.Component.DrawGizmos">
      <summary>
            Called in the editor to draw things like bounding boxes etc
            </summary>
    </member>
    <member name="M:Sandbox.Component.ForceChangeId(System.Guid)">
      <summary>
            Should only be called by <see cref="M:Sandbox.GameObjectDirectory.Add(Sandbox.Component)" />.
            </summary>
    </member>
    <member name="P:Sandbox.Component.LocalTransform">
      <summary>
            The local transform of the game object.
            </summary>
    </member>
    <member name="P:Sandbox.Component.LocalPosition">
      <summary>
            The local position of the game object.
            </summary>
    </member>
    <member name="P:Sandbox.Component.LocalRotation">
      <summary>
            The local rotation of the game object.
            </summary>
    </member>
    <member name="P:Sandbox.Component.LocalScale">
      <summary>
            The local scale of the game object.
            </summary>
    </member>
    <member name="P:Sandbox.Component.IsProxy">
      <summary>
            True if this is a networked object and is owned by another client. This means that we're
            not controlling this object, so shouldn't try to move it or anything.
            </summary>
    </member>
    <member name="M:Sandbox.Component.GetOrCreateInterpolatedVar``1(``0,System.String)">
      <summary>
            Get or create a new interpolated variable. This will set the current interpolated value to the
            provided one if it hasn't been created yet.
            </summary>
    </member>
    <member name="M:Sandbox.Component.CheckRequireComponent">
      <summary>
            Check all of our properties for a [RequireComponent] attribute. 
            If we find one, and the property is null, try to find one or create one.
            Runs in the editor as well as in game.
            </summary>
    </member>
    <member name="M:Sandbox.Component.DeserializeImmediately(System.Text.Json.Nodes.JsonObject)">
      <summary>
            Deserialize this component as per <see cref="M:Sandbox.Component.Deserialize(System.Text.Json.Nodes.JsonObject)" /> but update <see cref="P:Sandbox.Component.GameObject" /> and <see cref="T:Sandbox.Component" /> property
            references immediately instead of having them deferred.
            </summary>
    </member>
    <member name="M:Sandbox.Component.OnStart">
      <summary>
            Called once before the first Update - when enabled.
            </summary>
    </member>
    <member name="M:Sandbox.Component.OnUpdate">
      <summary>
            When enabled, called every frame
            </summary>
    </member>
    <member name="M:Sandbox.Component.OnFixedUpdate">
      <summary>
            When enabled, called on a fixed interval that is determined by the Scene. This
            is also the fixed interval in which the physics are ticked. Time.Delta is that
            fixed interval.
            </summary>
    </member>
    <member name="P:Sandbox.Component.ComponentVersion">
      <summary>
            The version of the component. Used by <see cref="T:Sandbox.JsonUpgrader" />.
            </summary>
    </member>
    <member name="P:Sandbox.Component.WorldTransform">
      <summary>
            The world transform of the game object.
            </summary>
    </member>
    <member name="P:Sandbox.Component.WorldPosition">
      <summary>
            The world position of the game object.
            </summary>
    </member>
    <member name="P:Sandbox.Component.WorldRotation">
      <summary>
            The world rotation of the game object.
            </summary>
    </member>
    <member name="P:Sandbox.Component.WorldScale">
      <summary>
            The world scale of the game object.
            </summary>
    </member>
    <member name="T:Sandbox.Component.ExecuteInEditor">
      <summary>
            A component with this interface will run in the editor.
            </summary>
    </member>
    <member name="T:Sandbox.Component.ICollisionListener">
      <summary>
            A <see cref="T:Sandbox.Component" /> with this interface can react to collisions.
            </summary>
    </member>
    <member name="M:Sandbox.Component.ICollisionListener.OnCollisionStart(Sandbox.Collision)">
      <summary>
            Called when this collider/rigidbody starts touching another collider.
            </summary>
    </member>
    <member name="M:Sandbox.Component.ICollisionListener.OnCollisionUpdate(Sandbox.Collision)">
      <summary>
            Called once per physics step for every collider being touched.
            </summary>
    </member>
    <member name="M:Sandbox.Component.ICollisionListener.OnCollisionStop(Sandbox.CollisionStop)">
      <summary>
            Called when this collider/rigidbody stops touching another collider.
            </summary>
    </member>
    <member name="T:Sandbox.Component.IColorProvider">
      <summary>
            When applied to a <see cref="T:Sandbox.Component" />, the component will be able to provide the color to use for certain UI editor elements.
            </summary>
    </member>
    <member name="T:Sandbox.Component.IDamageable">
      <summary>
            A component that can be damaged by something.
            </summary>
    </member>
    <member name="T:Sandbox.Component.IHasBounds">
      <summary>
            A component that has bounds
            </summary>
    </member>
    <member name="P:Sandbox.Component.IHasBounds.LocalBounds">
      <summary>
            Returns bounds, in local space
            </summary>
    </member>
    <member name="T:Sandbox.Component.INetworkListener">
      <summary>
            A <see cref="T:Sandbox.Component" /> with this interface can react to network events.
            </summary>
    </member>
    <member name="M:Sandbox.Component.INetworkListener.AcceptConnection(Sandbox.Connection,System.String@)">
      <summary>
            Called on the host to decide whether to accept a <see cref="T:Sandbox.Connection" />. If any <see cref="T:Sandbox.Component" />
            that implements this returns false, the connection will be denied.
            </summary>
      <param name="channel" />
      <param name="reason">The reason to display to the client.</param>
    </member>
    <member name="M:Sandbox.Component.INetworkListener.OnConnected(Sandbox.Connection)">
      <summary>
            Called when someone joins the server. This will only be called for the host.
            </summary>
    </member>
    <member name="M:Sandbox.Component.INetworkListener.OnDisconnected(Sandbox.Connection)">
      <summary>
            Called when someone leaves the server. This will only be called for the host.
            </summary>
    </member>
    <member name="M:Sandbox.Component.INetworkListener.OnActive(Sandbox.Connection)">
      <summary>
            Called when someone is all loaded and entered the game. This will only be called for the host.
            </summary>
    </member>
    <member name="M:Sandbox.Component.INetworkListener.OnBecameHost(Sandbox.Connection)">
      <summary>
            Called when the host of the game has left - and you are now the new host.
            </summary>
    </member>
    <member name="T:Sandbox.Component.INetworkSnapshot">
      <summary>
            When implemented on a <see cref="T:Sandbox.Component" /> it can read and write data to and from a network snapshot.
            </summary>
    </member>
    <member name="M:Sandbox.Component.INetworkSnapshot.ReadSnapshot(Sandbox.ByteStream@)">
      <summary>
            Read data from the snapshot.
            </summary>
    </member>
    <member name="M:Sandbox.Component.INetworkSnapshot.WriteSnapshot(Sandbox.ByteStream@)">
      <summary>
            Write data to the snapshot.
            </summary>
    </member>
    <member name="T:Sandbox.Component.INetworkSpawn">
      <summary>
            A <see cref="T:Sandbox.Component" /> with this interface can listen for when a GameObject
            in its ancestors has been network spawned.
            </summary>
    </member>
    <member name="M:Sandbox.Component.INetworkSpawn.OnNetworkSpawn(Sandbox.Connection)">
      <summary>
            Called when this object is spawned on the network.
            </summary>
    </member>
    <member name="T:Sandbox.Component.IPressable">
      <summary>
            A component that can be pressed. Like a button. This could be by 
            a player USE'ing it, or by a player walking on it, or by an NPC.
            A call to Press should ALWAYS call release afterwards. Generally
            this is done by the player, where holding E presses the button, and
            releasing E stops pressing it. You need to handle edge cases where
            the player dies while holding etc.
            </summary>
    </member>
    <member name="T:Sandbox.Component.IPressable.Event">
      <summary>
            Describes who pressed it.
            </summary>
    </member>
    <member name="M:Sandbox.Component.IPressable.Event.#ctor(Sandbox.Component,System.Nullable{Ray})">
      <summary>
            Describes who pressed it.
            </summary>
    </member>
    <member name="M:Sandbox.Component.IPressable.Hover(Sandbox.Component.IPressable.Event)">
      <summary>
            A player has started looking at this
            </summary>
    </member>
    <member name="M:Sandbox.Component.IPressable.Look(Sandbox.Component.IPressable.Event)">
      <summary>
            A player is still looking at this. Called every frame.
            </summary>
    </member>
    <member name="M:Sandbox.Component.IPressable.Blur(Sandbox.Component.IPressable.Event)">
      <summary>
            A player has stopped looking at this
            </summary>
    </member>
    <member name="M:Sandbox.Component.IPressable.Press(Sandbox.Component.IPressable.Event)">
      <summary>
            Pressed. Returns true on success, else false.
            If it returns true then you should call Release when the
            press finishes. Not everything expects it, but some stuff will.
            </summary>
    </member>
    <member name="M:Sandbox.Component.IPressable.Pressing(Sandbox.Component.IPressable.Event)">
      <summary>
            Still being pressed. Return true to allow the press to continue, false cancel the press
            </summary>
    </member>
    <member name="M:Sandbox.Component.IPressable.Release(Sandbox.Component.IPressable.Event)">
      <summary>
            To be called when the press finishes. You should only call this
            after a successful press - ie when Press hass returned true.
            </summary>
    </member>
    <member name="M:Sandbox.Component.IPressable.CanPress(Sandbox.Component.IPressable.Event)">
      <summary>
            Return true if the press is possible right now
            </summary>
    </member>
    <member name="T:Sandbox.Component.ISceneStage">
      <summary>
            Called on update start. This is the very first thing called.
            </summary>
    </member>
    <member name="T:Sandbox.Component.ITemporaryEffect">
      <summary>
            Allows components to indicate their state in a generic way. This is useful if you have a temporary effect system in which
            you want to remove GameObjects when their effects have all finished.
            </summary>
    </member>
    <member name="P:Sandbox.Component.ITemporaryEffect.IsActive">
      <summary>
            Should return true if the effect is active in a visible way
            </summary>
    </member>
    <member name="M:Sandbox.Component.ITemporaryEffect.DisableLooping">
      <summary>
            Indicates to the target object that we want it to die. If it's looping then
            it should stop now and put itself in a state where it will eventually die.
            </summary>
    </member>
    <member name="M:Sandbox.Component.ITemporaryEffect.DisableLoopingEffects(Sandbox.GameObject)">
      <summary>
            Disable the any looping effects. This indicates to the target object that we want it to die soon.
            </summary>
    </member>
    <member name="T:Sandbox.Component.ITintable">
      <summary>
            A <see cref="T:Sandbox.Component" /> that lets you change its color.
            </summary>
    </member>
    <member name="T:Sandbox.Component.ITriggerListener">
      <summary>
            A <see cref="T:Sandbox.Component" /> with this interface can react to interactions with triggers.
            </summary>
    </member>
    <member name="M:Sandbox.Component.ITriggerListener.OnTriggerEnter(Sandbox.Collider)">
      <summary>
            Called when a collider enters the trigger.
            </summary>
    </member>
    <member name="M:Sandbox.Component.ITriggerListener.OnTriggerExit(Sandbox.Collider)">
      <summary>
            Called when a collider stops touching the trigger.
            </summary>
    </member>
    <member name="M:Sandbox.Component.ITriggerListener.OnTriggerEnter(Sandbox.GameObject)">
      <summary>
            Called when a gameobject enters the trigger.
            </summary>
    </member>
    <member name="M:Sandbox.Component.ITriggerListener.OnTriggerExit(Sandbox.GameObject)">
      <summary>
            Called when a gameobject stops touching the trigger.
            </summary>
    </member>
    <member name="T:Sandbox.CloneHelpers">
      <summary>
            Provides helper methods for cloning objects and their members.
            We use a heuristic <see cref="M:Sandbox.ReflectionQueryCache.IsTypeCloneableByCopy(System.Type)" /> to determine if a type can be cloned by copy to speed up cloning.
            If we cannot copy something and we have to "clone" we do so by serializing to and deserializing from JSON.
            However, our goal is to copy as much as possible to avoid the serialization overhead.
            </summary>
    </member>
    <member name="M:Sandbox.CloneHelpers.UpdateClonedIdsInJson(System.Text.Json.Nodes.JsonNode@,System.Collections.Generic.Dictionary{System.Guid,System.Guid})">
      <summary>
            We want GUIDS that reference something within the original hierachy to reference the corresponding clone in the new hierachy.
            </summary>
    </member>
    <member name="F:Sandbox.ComponentFlags.Hidden">
      <summary>
            Hide this component in component inspector
            </summary>
    </member>
    <member name="F:Sandbox.ComponentFlags.NotSaved">
      <summary>
            Don't save this component to disk
            </summary>
    </member>
    <member name="F:Sandbox.ComponentFlags.Error">
      <summary>
            There's something wrong with this
            </summary>
    </member>
    <member name="F:Sandbox.ComponentFlags.Loading">
      <summary>
            Loading something
            </summary>
    </member>
    <member name="F:Sandbox.ComponentFlags.Deserializing">
      <summary>
            Is in the process of deserializing
            </summary>
    </member>
    <member name="F:Sandbox.ComponentFlags.NotEditable">
      <summary>
            Cannot be edited in the component inspector
            </summary>
    </member>
    <member name="F:Sandbox.ComponentFlags.NotNetworked">
      <summary>
            Keep local - don't network this component as part of the scene snapshot
            </summary>
    </member>
    <member name="F:Sandbox.ComponentFlags.Refreshing">
      <summary>
            In the process of refreshing from the network
            </summary>
    </member>
    <member name="F:Sandbox.ComponentFlags.NotCloned">
      <summary>
            Don't serialize this component when cloning
            </summary>
    </member>
    <member name="T:Sandbox.ComponentReference">
      <summary>
            A serialized reference to a <see cref="T:Sandbox.Component" /> that can be resolved at runtime.
            Components are referenced by their <see cref="P:Sandbox.Component.Id" />, their containing object's
            <see cref="P:Sandbox.GameObject.Id" />, and their <see cref="P:Sandbox.TypeDescription.ClassName" /> if available.
            </summary>
    </member>
    <member name="M:Sandbox.ComponentReference.FromInstance(Sandbox.Component)">
      <summary>
            Reference a given <see cref="T:Sandbox.Component" />.
            </summary>
    </member>
    <member name="M:Sandbox.ComponentReference.op_Explicit(Sandbox.ComponentReference)~Sandbox.GameObjectReference">
      <summary>
            Converts a <see cref="T:Sandbox.ComponentReference" /> into a <see cref="T:Sandbox.GameObjectReference" />, referencing the object
            that contains the component.
            </summary>
    </member>
    <member name="P:Sandbox.ComponentReference.ReferenceType">
      <summary>
            Expected to be <c>"component"</c> for a component reference.
            </summary>
    </member>
    <member name="P:Sandbox.ComponentReference.ComponentId">
      <summary>
            The <see cref="P:Sandbox.Component.Id" /> of the referenced component.
            </summary>
    </member>
    <member name="P:Sandbox.ComponentReference.GameObjectId">
      <summary>
            The <see cref="P:Sandbox.GameObject.Id" /> of the object containing the referenced component.
            </summary>
    </member>
    <member name="P:Sandbox.ComponentReference.ComponentTypeName">
      <summary>
            If available, the <see cref="P:Sandbox.TypeDescription.ClassName" /> of the referenced component.
            </summary>
    </member>
    <member name="M:Sandbox.ComponentReference.ResolveComponentType(System.Type)">
      <summary>
            Attempt to resolve <see cref="P:Sandbox.ComponentReference.ComponentTypeName" /> into a <see cref="T:System.Type" />. Returns <see langword="null" /> if not resolved.
            </summary>
      <param name="targetType">Optional base type / interface that the resolved type must derive from / implement. Defaults to <see cref="T:Sandbox.Component" />.</param>
    </member>
    <member name="M:Sandbox.ComponentReference.Resolve">
      <summary>
            Attempt to resolve this reference in the current <see cref="P:Sandbox.Game.ActiveScene" />. Returns <see langword="null" /> if
            the reference couldn't be resolved, and logs a warning.
            </summary>
    </member>
    <member name="M:Sandbox.ComponentReference.Resolve(Sandbox.Scene,System.Type,System.Boolean)">
      <summary>
            Attempt to resolve this reference in the given <paramref name="scene" />. Returns <see langword="null" /> if
            the reference couldn't be resolved.
            </summary>
      <param name="scene">Scene to attempt to resolve the reference in.</param>
      <param name="targetType">Optional base type / interface that the resolved instance must derive from / implement. Defaults to <see cref="T:Sandbox.Component" />.</param>
      <param name="warn">If true, log a warning to the console if the reference couldn't be resolved.</param>
    </member>
    <member name="T:Sandbox.LegacyParticleSystem">
      <summary>
            Support's Source Engine's vpcf particles
            </summary>
    </member>
    <member name="T:Sandbox.Gib">
      <summary>
            A gib is a prop that is treated slightly different. It will fade out after a certain amount of time.
            </summary>
    </member>
    <member name="T:Sandbox.ManualHitbox">
      <summary>
            A hitbox that can be placed manually on a GameObject, instead of coming from a model
            </summary>
    </member>
    <member name="P:Sandbox.ManualHitbox.Target">
      <summary>
            The target GameObject to report in trace hits. If this is unset we'll default to the gameobject on which this component is.
            </summary>
    </member>
    <member name="M:Sandbox.ManualHitbox.OnTagsChanged">
      <summary>
            Tags have been updated
            </summary>
    </member>
    <member name="T:Sandbox.ModelHitboxes">
      <summary>
            Hitboxes from a model
            </summary>
    </member>
    <member name="P:Sandbox.ModelHitboxes.Renderer">
      <summary>
            The target SkinnedModelRenderer that holds the model/skeleton you want to 
            take the hitboxes from.
            </summary>
    </member>
    <member name="P:Sandbox.ModelHitboxes.Target">
      <summary>
            The target GameObject to report in trace hits. If this is unset we'll defaault to the gameobject on which this component is.
            </summary>
    </member>
    <member name="M:Sandbox.ModelHitboxes.OnTagsChanged">
      <summary>
            The gameobject tags have changed, update collision tags on the target objects
            </summary>
    </member>
    <member name="T:Sandbox.Movement.MoveModeLadder">
      <summary>
            The character is climbing up a ladder
            </summary>
    </member>
    <member name="P:Sandbox.Movement.MoveModeLadder.ClimbableTags">
      <summary>
            A list of tags we can climb up - when they're on triggers
            </summary>
    </member>
    <member name="P:Sandbox.Movement.MoveModeLadder.ClimbingObject">
      <summary>
            The GameObject we're climbing. This will usually be a ladder trigger.
            </summary>
    </member>
    <member name="P:Sandbox.Movement.MoveModeLadder.ClimbingRotation">
      <summary>
            When climbing, this is the rotation of the wall/ladder you're climbing, where
            Forward is the direction to look at the ladder, and Up is the direction to climb.
            </summary>
    </member>
    <member name="T:Sandbox.Movement.MoveMode">
      <summary>
            A move mode for this character
            </summary>
    </member>
    <member name="M:Sandbox.Movement.MoveMode.UpdateAnimator(Sandbox.SkinnedModelRenderer)">
      <summary>
            Update the animator which is available at Controller.Renderer.
            </summary>
    </member>
    <member name="M:Sandbox.Movement.MoveMode.OnUpdateAnimatorVelocity(Sandbox.SkinnedModelRenderer)">
      <summary>
        <para>
            Sets animation parameters on <paramref name="renderer" /> based on the current
            <see cref="P:Sandbox.PlayerController.Velocity" /> and <see cref="P:Sandbox.PlayerController.WishVelocity" />.
            </para>
      </summary>
    </member>
    <member name="M:Sandbox.Movement.MoveMode.OnUpdateAnimatorState(Sandbox.SkinnedModelRenderer)">
      <summary>
            Sets animation parameters on <paramref name="renderer" /> describing the movement style, like
            swimming, falling, or ducking.
            </summary>
    </member>
    <member name="M:Sandbox.Movement.MoveMode.OnUpdateAnimatorLookDirection(Sandbox.SkinnedModelRenderer)">
      <summary>
            Set animation parameters on <paramref name="renderer" /> to look towards <see cref="P:Sandbox.PlayerController.EyeAngles" />.
            </summary>
    </member>
    <member name="M:Sandbox.Movement.MoveMode.OnRotateRenderBody(Sandbox.SkinnedModelRenderer)">
      <summary>
            Updates the <see cref="P:Sandbox.Component.WorldRotation" /> of <paramref name="renderer" />.
            </summary>
    </member>
    <member name="M:Sandbox.Movement.MoveMode.Score(Sandbox.PlayerController)">
      <summary>
            Highest number becomes the new control mode
            </summary>
    </member>
    <member name="M:Sandbox.Movement.MoveMode.PrePhysicsStep">
      <summary>
            Called before the physics step is run
            </summary>
    </member>
    <member name="M:Sandbox.Movement.MoveMode.PostPhysicsStep">
      <summary>
            Called after the physics step is run
            </summary>
    </member>
    <member name="M:Sandbox.Movement.MoveMode.OnModeBegin">
      <summary>
            This mode has just started
            </summary>
    </member>
    <member name="M:Sandbox.Movement.MoveMode.OnModeEnd(Sandbox.Movement.MoveMode)">
      <summary>
            This mode has stopped. We're swapping to another move mode.
            </summary>
    </member>
    <member name="M:Sandbox.Movement.MoveMode.TrySteppingUp(System.Single)">
      <summary>
            If we're approaching a step, step up if possible
            </summary>
    </member>
    <member name="M:Sandbox.Movement.MoveMode.StickToGround(System.Single)">
      <summary>
            If we're on the ground, make sure we stay there by falling to the ground
            </summary>
    </member>
    <member name="M:Sandbox.Movement.MoveMode.UpdateMove(Rotation,Vector3)">
      <summary>
            Read inputs, return WishVelocity
            </summary>
    </member>
    <member name="T:Sandbox.Movement.MoveModeSwim">
      <summary>
            The character is swimming
            </summary>
    </member>
    <member name="P:Sandbox.Movement.MoveModeSwim.WaterLevel">
      <summary>
            Will will update this based on how much you're in a "water" tagged trigger
            </summary>
    </member>
    <member name="T:Sandbox.Movement.MoveModeWalk">
      <summary>
            The character is walking
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.Renderer">
      <summary>
            The body will usually be a child object with SkinnedModelRenderer
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.ShowCreateBodyRenderer">
      <summary>
            If true we'll show the "create body" button
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.AimStrengthEyes">
      <summary>
            How strongly to look in the eye direction with our eyes
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.AimStrengthHead">
      <summary>
            How strongly to turn in the eye direction with our head
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.AimStrengthBody">
      <summary>
            How strongly to turn in the eye direction with our body
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.UpdateAnimation(Sandbox.SkinnedModelRenderer)">
      <summary>
            Update the animation for this renderer. This will update the body rotation etc too.
            </summary>
    </member>
    <member name="F:Sandbox.PlayerController._skin">
      <summary>
            This is used to keep a distance away from surfaces. For exmaple, when grounding, we'll
            be a skin distance away from the ground.
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.BrakePower">
      <summary>
            We will apply extra friction when we're on the ground and our desired velocity is
            lower than our current velocity, so we will slow down.
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.AirFriction">
      <summary>
            How much friction to add when we're in the air. This will slow you down unless you have a wish
            velocity.
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.Velocity">
      <summary>
            Our actual physical velocity minus our ground velocity
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.GroundVelocity">
      <summary>
            The velocity that the ground underneath us is moving
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.IsClimbing">
      <summary>
            Set to true when entering a climbing <see cref="T:Sandbox.Movement.MoveMode" />.
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.IsSwimming">
      <summary>
            Set to true when entering a swimming <see cref="T:Sandbox.Movement.MoveMode" />.
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.Jump(Vector3)">
      <summary>
            Adds velocity in a special way. First we subtract any opposite velocity (ie, falling) then 
            we add the velocity, but we clamp it to that direction. This means that if you jump when you're running
            up a platform, you don't get extra jump power.
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.EyeAngles">
      <summary>
            The direction we're looking.
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.EyePosition">
      <summary>
            The player's eye position, in first person mode
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.EyeTransform">
      <summary>
            The player's eye position, in first person mode
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.IsDucking">
      <summary>
            True if this player is ducking
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.Headroom">
      <summary>
            The distance from the top of the head to to closest ceiling
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.EnsureComponentsCreated">
      <summary>
            Make sure the body and our components are created
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.UpdateBody">
      <summary>
            Update the body dimensions, and change the physical properties based on the current state
            </summary>
    </member>
    <member name="T:Sandbox.PlayerController.IEvents">
      <summary>
            Events from the PlayerController
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.IEvents.OnEyeAngles(Angles@)">
      <summary>
            Our eye angles are changing. Allows you to change the sensitivity, or stomp all together.
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.IEvents.PostCameraSetup(Sandbox.CameraComponent)">
      <summary>
            Called after we've set the camera up
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.IEvents.OnJumped">
      <summary>
            The player has just jumped
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.IEvents.OnLanded(System.Single,Vector3)">
      <summary>
            The player has landed on the ground, after falling this distance.
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.IEvents.GetUsableComponent(Sandbox.GameObject)">
      <summary>
            Used by the Using system to find components we can interact with.
            By default we can only interact with IPressable components.
            Return a component if we can use it, or else return null.
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.IEvents.StartPressing(Sandbox.Component)">
      <summary>
            We have started using something (use was pressed)
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.IEvents.StopPressing(Sandbox.Component)">
      <summary>
            We have started using something (use was pressed)
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.IEvents.FailPressing">
      <summary>
            We pressed USE but it did nothing
            </summary>
    </member>
    <member name="F:Sandbox.PlayerController.DebugFootsteps">
      <summary>
            Draw debug overlay on footsteps
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.GroundObject">
      <summary>
            The object we're standing on. Null if we're standing on nothing.
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.GroundComponent">
      <summary>
            The collider component we're standing on. Null if we're standing nothing
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.GroundSurface">
      <summary>
            If we're stnding on a surface this is it
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.GroundFriction">
      <summary>
            The friction property of the ground we're standing on.
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.GroundIsDynamic">
      <summary>
            Are we standing on a surface that is physically dynamic
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.TimeSinceGrounded">
      <summary>
            Amount of time since this character was last on the ground
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.TimeSinceUngrounded">
      <summary>
            Amount of time since this character was last not on the ground
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.PreventGrounding(System.Single)">
      <summary>
            Prevent being grounded for a number of seconds
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.Reground(System.Single)">
      <summary>
            Lift player up and place a skin level above the ground
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.AccelerationTime">
      <summary>
            Amount of seconds it takes to get from your current speed to your requuested speed, if higher
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.DeaccelerationTime">
      <summary>
            Amount of seconds it takes to get from your current speed to your requuested speed, if lower
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.AltMoveButton">
      <summary>
            The button that the player will press to use to run
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.RunByDefault">
      <summary>
            If true then the player will run by default, and holding AltMoveButton will switch to walk
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.EnablePressing">
      <summary>
            Allows to player to interact with things by "use"ing them. 
            Usually by pressing the "use" button.
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.UseButton">
      <summary>
            The button that the player will press to use things
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.ReachLength">
      <summary>
            How far from the eye can the player reach to use things
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.UseLookControls">
      <summary>
            When true we'll move the camera around using the mouse
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.LookSensitivity">
      <summary>
            Allows modifying the eye angle sensitivity. Note that player preference sensitivity is already automatically applied, this is just extra.
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.UpdateDucking(System.Boolean)">
      <summary>
            Called during FixedUpdate when UseInputControls is enmabled. Will duck if requested.
            If not, and we're ducked, will unduck if there is room
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.Hovered">
      <summary>
            The object we're currently looking at
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.Pressed">
      <summary>
            The object we're currently using by holding down USE
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.UpdateLookAt">
      <summary>
            Called in Update when Using is enabled
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.UpdatePressed">
      <summary>
            Called every frame to update our pressed object
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.UpdateHovered">
      <summary>
            Called every frame to update our hovered status, unless it's being pressed
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.StopPressing">
      <summary>
            Stop pressing. Pressed will become null.
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.StartPressing(Sandbox.Component)">
      <summary>
            Start pressing a target component. This is called automatically when Use is pressed.
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.SwitchHovered(Sandbox.Component)">
      <summary>
            Called every frame with the component we're looking at - even if it's null
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.TryGetLookedAt">
      <summary>
            Get the best component we're looking at. We don't just return any old component, by default
            we only return components that implement IPressable. Components can implement GetUsableComponent
            to search and provide better alternatives.
            </summary>
    </member>
    <member name="P:Sandbox.PlayerController.StepDebug">
      <summary>
            Enable debug overlays for this character
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.TryStep(System.Single)">
      <summary>
            Try to step up. Will trace forward, then up, then across, then down.
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.RestoreStep">
      <summary>
            If we stepped up on the previous step, we suck our position back to the previous position after the physics step
            to avoid adding double velocity. This is technically wrong but doens't seem to cause any harm right now
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.BodyBox(System.Single,System.Single)">
      <summary>
            Return an aabb representing the body
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.TraceBody(Vector3,Vector3,System.Single,System.Single)">
      <summary>
            Trace the aabb body from one position to another and return the result
            </summary>
    </member>
    <member name="M:Sandbox.PlayerController.CreateRagdoll(System.String)">
      <summary>
            Create a ragdoll gameobject version of our render body.
            </summary>
    </member>
    <member name="T:Sandbox.Prop">
      <summary>
            A prop is defined by its model. The model can define its health and what happens when it breaks.
            This component is designed to be easy to use - since you only need to define the model. Although you can 
            access the procedural (hidden) components, they aren't saved, so it's a waste of time.
            </summary>
    </member>
    <member name="P:Sandbox.Prop.IsStatic">
      <summary>
            If the prop is static - it won't have dynamic physics. This is usually used for things that
            you want to be breakable but don't move. Like fences and stuff.
            </summary>
    </member>
    <member name="P:Sandbox.Prop.StartAsleep">
      <summary>
            Physics will be asleep until it's woken up.
            </summary>
    </member>
    <member name="M:Sandbox.Prop.Break">
      <summary>
            Delete this component and split into the procedural components that this prop created.
            </summary>
    </member>
    <member name="T:Sandbox.SpawnPoint">
      <summary>
            Dictates where players will spawn when they join the game when using a NetworkHelper.
            </summary>
    </member>
    <member name="T:Sandbox.BallJoint">
      <summary>
            Fix two objects together but can rotate - like a shoulder.
            </summary>
    </member>
    <member name="T:Sandbox.FixedJoint">
      <summary>
            Weld two physics objects together
            </summary>
    </member>
    <member name="T:Sandbox.HingeJoint">
      <summary>
            Create a hinged connection between two physics objects. Like a door hinge or a wheel.
            </summary>
    </member>
    <member name="P:Sandbox.HingeJoint.MinAngle">
      <summary>
            Minimum angle it should be allowed to go
            </summary>
    </member>
    <member name="P:Sandbox.HingeJoint.MaxAngle">
      <summary>
            Maximum angle it should be allowed to go
            </summary>
    </member>
    <member name="P:Sandbox.HingeJoint.Motor">
      <summary>
            Motor mode
            </summary>
    </member>
    <member name="P:Sandbox.HingeJoint.Friction">
      <summary>
            Hinge friction
            </summary>
    </member>
    <member name="P:Sandbox.HingeJoint.TargetAngle">
      <summary>
            Target angle of motor
            </summary>
    </member>
    <member name="P:Sandbox.HingeJoint.Frequency">
      <summary>
            Frequency of motor
            </summary>
    </member>
    <member name="P:Sandbox.HingeJoint.DampingRatio">
      <summary>
            Damping of motor
            </summary>
    </member>
    <member name="P:Sandbox.HingeJoint.TargetVelocity">
      <summary>
            Target velocity of motor
            </summary>
    </member>
    <member name="P:Sandbox.HingeJoint.MaxTorque">
      <summary>
            Max torque of motor
            </summary>
    </member>
    <member name="P:Sandbox.Joint.Body">
      <summary>
            Game object to find the body to attach this joint to.
            </summary>
    </member>
    <member name="P:Sandbox.Joint.EnableCollision">
      <summary>
            Enable or disable collision between the two bodies.
            </summary>
    </member>
    <member name="P:Sandbox.Joint.StartBroken">
      <summary>
            Is the joint broken on start.
            </summary>
    </member>
    <member name="P:Sandbox.Joint.BreakForce">
      <summary>
            Strength of the linear constraint. If it takes any more energy than this, it'll break.
            </summary>
    </member>
    <member name="P:Sandbox.Joint.BreakTorque">
      <summary>
            Strength of the angular constraint. If it takes any more energy than this, it'll break.
            </summary>
    </member>
    <member name="P:Sandbox.Joint.OnBreak">
      <summary>
            Called when the joint breaks.
            </summary>
    </member>
    <member name="P:Sandbox.Joint.LinearStress">
      <summary>
            Current linear stress applied to the joint.
            </summary>
    </member>
    <member name="P:Sandbox.Joint.AngularStress">
      <summary>
            Current angular stress applied to the joint.
            </summary>
    </member>
    <member name="P:Sandbox.Joint.IsBroken">
      <summary>
            Is the joint currently broken and inactive.
            </summary>
    </member>
    <member name="P:Sandbox.Joint.Body1">
      <summary>
            The source physics body this joint is attached to.
            </summary>
    </member>
    <member name="P:Sandbox.Joint.Body2">
      <summary>
            The target physics body this joint is constraining.
            </summary>
    </member>
    <member name="P:Sandbox.Joint.Point1">
      <summary>
            A specific point this joint is attached at on <see cref="P:Sandbox.Joint.Body1" /></summary>
    </member>
    <member name="P:Sandbox.Joint.Point2">
      <summary>
            A specific point this joint is attached at on <see cref="P:Sandbox.Joint.Body2" /></summary>
    </member>
    <member name="M:Sandbox.Joint.CreateJoint(Sandbox.Physics.PhysicsPoint,Sandbox.Physics.PhysicsPoint)">
      <summary>
            Joint type implementation.
            </summary>
    </member>
    <member name="T:Sandbox.SliderJoint">
      <summary>
            Restrict an object to one axis, relative to another object. Like a drawer opening.
            </summary>
    </member>
    <member name="P:Sandbox.SliderJoint.MaxLength">
      <summary>
            Maximum length it should be allowed to go
            </summary>
    </member>
    <member name="P:Sandbox.SliderJoint.MinLength">
      <summary>
            Minimum length it should be allowed to go
            </summary>
    </member>
    <member name="P:Sandbox.SliderJoint.Friction">
      <summary>
            Slider friction
            </summary>
    </member>
    <member name="T:Sandbox.SpringJoint">
      <summary>
            Try to keep an object a set distance away from another object. Like a spring connecting two objects.
            </summary>
    </member>
    <member name="P:Sandbox.SpringJoint.Frequency">
      <summary>
            The stiffness of the spring
            </summary>
    </member>
    <member name="P:Sandbox.SpringJoint.Damping">
      <summary>
            The damping ratio of the spring, usually between 0 and 1
            </summary>
    </member>
    <member name="P:Sandbox.SpringJoint.MinLength">
      <summary>
            Minimum length it should be allowed to go
            </summary>
    </member>
    <member name="P:Sandbox.SpringJoint.MaxLength">
      <summary>
            Maximum length it should be allowed to go
            </summary>
    </member>
    <member name="T:Sandbox.AmbientLight">
      <summary>
            Adds an ambient light to the scene, applied globally.
            </summary>
    </member>
    <member name="P:Sandbox.AmbientLight.Color">
      <summary>
            Ambient light color outside of all light probes.
            </summary>
    </member>
    <member name="T:Sandbox.DirectionalLight">
      <summary>
            A directional light that casts shadows, like the sun.
            </summary>
    </member>
    <member name="P:Sandbox.DirectionalLight.SkyColor">
      <summary>
            Color of the ambient sky color
            This is kept for long term support, the recommended way to do this is with an Ambient Light component.
            </summary>
    </member>
    <member name="T:Sandbox.EnvmapProbe">
      <summary>
            A cubemap probe that captures the environment around it.
            </summary>
    </member>
    <member name="P:Sandbox.EnvmapProbe.Texture">
      <summary>
            If this is set, the EnvmapProbe will use a custom cubemap texture instead of render dynamically
            </summary>
    </member>
    <member name="P:Sandbox.EnvmapProbe.NeedsInvertedAxis">
      <summary>
            Cubemaps in Source 2 have an inverted Y axis, for rendering them dynamically it uses correct axis
            We used to invert-Y but since we are rendering directly to cubemaps (and can't manipulate Y projection matrix
            without breaking culling ), we invert the matrix of the cubemap being drawn
            </summary>
    </member>
    <member name="M:Sandbox.EnvmapProbe.OnTagsChanged">
      <summary>
            Tags have been updated - lets update our tags
            </summary>
    </member>
    <member name="P:Sandbox.EnvmapProbe.Resolution">
      <summary>
            Resolution of the cubemap texture
            </summary>
    </member>
    <member name="P:Sandbox.EnvmapProbe.MaxDistance">
      <summary>
            Only update dynamically if we're this close to it
            </summary>
    </member>
    <member name="P:Sandbox.EnvmapProbe.MultiBounce">
      <summary>
            Minimum amount of reflection bounces to render when first enabled before settling, at cost of extra performance on load
            Often times you don't need this
            </summary>
    </member>
    <member name="F:Sandbox.EnvmapProbe.CubemapDynamicUpdate.OnEnabled">
      <summary>
            Update once, when the cubemap is enabled
            </summary>
    </member>
    <member name="F:Sandbox.EnvmapProbe.CubemapDynamicUpdate.EveryFrame">
      <summary>
            Update every frame (slow, not recommended)
            </summary>
    </member>
    <member name="F:Sandbox.EnvmapProbe.CubemapDynamicUpdate.FrameInterval">
      <summary>
            Update every x frames
            </summary>
    </member>
    <member name="F:Sandbox.EnvmapProbe.CubemapDynamicUpdate.TimeInterval">
      <summary>
            Update on a time based interval
            </summary>
    </member>
    <member name="P:Sandbox.Light.LightColor">
      <summary>
            The main color of the light
            </summary>
    </member>
    <member name="P:Sandbox.Light.Shadows">
      <summary>
            Should this light cast shadows?
            </summary>
    </member>
    <member name="M:Sandbox.Light.OnTagsChanged">
      <summary>
            Tags have been updated - lets update our light's tags
            </summary>
    </member>
    <member name="T:Sandbox.PointLight">
      <summary>
            Emits light in all directions from a point in space.
            </summary>
    </member>
    <member name="T:Sandbox.SpotLight">
      <summary>
            Emits light in a specific direction in a cone shape.
            </summary>
    </member>
    <member name="T:Sandbox.HammerMesh">
      <summary>
            Added automatically by Hammer to GameObjects that have a map mesh tied to them.
            When a map is compiled the Model property is populated by the generated model.
            </summary>
    </member>
    <member name="P:Sandbox.HammerMesh.Model">
      <summary>
            Gets populated at compile time, will be valid when loading from compiled map
            </summary>
    </member>
    <member name="P:Sandbox.HammerMesh.SurfaceVelocity">
      <summary>
            Set the local velocity of the surface so things can slide along it, like a conveyor belt
            </summary>
    </member>
    <member name="P:Sandbox.HammerMesh.OnTriggerEnter">
      <summary>
            Called when a collider enters this trigger
            </summary>
    </member>
    <member name="P:Sandbox.HammerMesh.OnTriggerExit">
      <summary>
            Called when a collider exits this trigger
            </summary>
    </member>
    <member name="T:Sandbox.MapInstance">
      <summary>
            Allows you to load a map into the Scene. This can be either a vpk or a scene map.
            </summary>
    </member>
    <member name="P:Sandbox.MapInstance.IsLoaded">
      <summary>
            True if the map is loaded
            </summary>
    </member>
    <member name="P:Sandbox.MapInstance.OnMapLoaded">
      <summary>
            Called when the map has successfully loaded
            </summary>
    </member>
    <member name="P:Sandbox.MapInstance.OnMapUnloaded">
      <summary>
            Called when the map has been unloaded
            </summary>
    </member>
    <member name="P:Sandbox.MapInstance.Bounds">
      <summary>
            Get the world bounds of the map
            </summary>
    </member>
    <member name="M:Sandbox.MapInstance.UnloadMap">
      <summary>
            Unload the current map.
            </summary>
    </member>
    <member name="M:Sandbox.MapInstance.UpdateDirtyReflections">
      <summary>
            Make sure all cubemaps placed on scene are up-to-date when we
            load/unload a map instance.
            </summary>
    </member>
    <member name="M:Sandbox.MapInstance.OnCreateObject(Sandbox.GameObject,Sandbox.MapLoader.ObjectEntry)">
      <summary>
            Override this to add components to a map object.
            Only called for map objects that are not implemented.
            </summary>
    </member>
    <member name="T:Sandbox.SkyboxMapLoader">
      <summary>
            Loader for a 3D skybox which updates the values on the parent sceneworld
            </summary>
    </member>
    <member name="T:Sandbox.MeshComponent">
      <summary>
            An editable polygon mesh with collision
            </summary>
    </member>
    <member name="T:Sandbox.PolygonMesh">
      <summary>
            An editable mesh made up of polygons, triangulated into a model
            </summary>
    </member>
    <member name="P:Sandbox.PolygonMesh.IsDirty">
      <summary>
            Has there been changes to the mesh that need rebuilding?
            </summary>
    </member>
    <member name="P:Sandbox.PolygonMesh.Transform">
      <summary>
            Where is the mesh in worldspace.
            </summary>
    </member>
    <member name="P:Sandbox.PolygonMesh.VertexHandles">
      <summary>
            All of the vertex handles being used
            </summary>
    </member>
    <member name="P:Sandbox.PolygonMesh.FaceHandles">
      <summary>
            All of the face handles being used
            </summary>
    </member>
    <member name="P:Sandbox.PolygonMesh.HalfEdgeHandles">
      <summary>
            All of the half edge handles being used
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.AddVertex(Vector3)">
      <summary>
            Add a vertex to the topology
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.AddVertices(Vector3[])">
      <summary>
            Add multiple vertices to the topology
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.AddFace(HalfEdgeMesh.VertexHandle[])">
      <summary>
            Connect these vertices to make a face
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.CalculateBounds">
      <summary>
            Calculate bounds of all vertices
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.CalculateBounds(Transform)">
      <summary>
            Calculate bounds of all transformed vertices
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.Scale(Vector3)">
      <summary>
            Scale all vertices
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.SetFaceMaterial(HalfEdgeMesh.FaceHandle,Sandbox.Material)">
      <summary>
            Assign a material to a face
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.SetFaceMaterial(HalfEdgeMesh.FaceHandle,System.String)">
      <summary>
            Assign a material to a face
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.GetFaceMaterial(HalfEdgeMesh.FaceHandle)">
      <summary>
            Get a material a face is using
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.GetEdgeSmoothing(HalfEdgeMesh.HalfEdgeHandle)">
      <summary>
            Get the smoothing of this edge
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.SetEdgeSmoothing(HalfEdgeMesh.HalfEdgeHandle,Sandbox.PolygonMesh.EdgeSmoothMode)">
      <summary>
            Set the smoothing of this edge
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.TriangleToFace(System.Int32)">
      <summary>
            Convert a triangle index to a face handle
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.ExtrudeFaces(HalfEdgeMesh.FaceHandle[],System.Collections.Generic.List{HalfEdgeMesh.FaceHandle}@,System.Collections.Generic.List{HalfEdgeMesh.FaceHandle}@,Vector3)">
      <summary>
            Extrude multiple faces along an offset
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.DetachFaces(HalfEdgeMesh.FaceHandle[],System.Collections.Generic.List{HalfEdgeMesh.FaceHandle}@)">
      <summary>
            Detatch multiple faces
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.CreateFaceInEdgeLoop(HalfEdgeMesh.HalfEdgeHandle,HalfEdgeMesh.FaceHandle@)">
      <summary>
            Add a face filling in the open edge loop specified by the provided edge
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.GetHalfEdgeFace(HalfEdgeMesh.HalfEdgeHandle)">
      <summary>
            Get the face connected to this half edge
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.IsEdgeOpen(HalfEdgeMesh.HalfEdgeHandle)">
      <summary>
            Determine if the specified edge is open (only has one connected face)
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.FindEdgeRing(HalfEdgeMesh.HalfEdgeHandle,System.Collections.Generic.List{HalfEdgeMesh.HalfEdgeHandle}@)">
      <summary>
            Find all of the edges in the ring with the specified edge. An edge ring is the set of edges that
            are connected by a loop of faces.
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.BridgeEdges(HalfEdgeMesh.HalfEdgeHandle,HalfEdgeMesh.HalfEdgeHandle,HalfEdgeMesh.FaceHandle@)">
      <summary>
            Bridge two edges (create a face connecting them). The edges must both be open and belong to
            different faces.
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.ConnectEdges(System.Collections.Generic.IReadOnlyList{HalfEdgeMesh.HalfEdgeHandle},System.Collections.Generic.List{HalfEdgeMesh.HalfEdgeHandle}@)">
      <summary>
            Connect the specified edges by adding a vertex to their mid point of each edge and then 
            connecting the vertices.
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.GetEdgeLine(HalfEdgeMesh.HalfEdgeHandle)">
      <summary>
            Get start and end points of an edge
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.GetEdgeVertices(HalfEdgeMesh.HalfEdgeHandle,HalfEdgeMesh.VertexHandle@,HalfEdgeMesh.VertexHandle@)">
      <summary>
            Get the two vertices of this half edge
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.SetVertexPosition(HalfEdgeMesh.VertexHandle,Vector3)">
      <summary>
            Set the position of a vertex
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.GetVertexPosition(HalfEdgeMesh.VertexHandle)">
      <summary>
            Get the position of a vertex
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.GetVertexPosition(HalfEdgeMesh.VertexHandle,Transform,Vector3@)">
      <summary>
            Get the position of a vertex
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.GetVertexPositions">
      <summary>
            Get the positions of all vertices
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.GetFaceCenter(HalfEdgeMesh.FaceHandle)">
      <summary>
            Calculate the center point of a face
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.GetEdges">
      <summary>
            Get the start and end points of all edges
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.ApplyTransform(Transform)">
      <summary>
            Transform all the vertices
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.GetFaceEdges(HalfEdgeMesh.FaceHandle)">
      <summary>
            Get all edge handles of a face
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.GetFaceVertices(HalfEdgeMesh.FaceHandle)">
      <summary>
            Get all vertex handles of a face
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.GetTextureOffset(HalfEdgeMesh.FaceHandle)">
      <summary>
            Get texture offset of a face
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.SetTextureOffset(HalfEdgeMesh.FaceHandle,Vector2)">
      <summary>
            Set texture offset of a face
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.GetTextureScale(HalfEdgeMesh.FaceHandle)">
      <summary>
            Get texture scale of a face
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.SetTextureScale(HalfEdgeMesh.FaceHandle,Vector2)">
      <summary>
            Set texture scale of a face
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.TextureAlignToGrid(Transform,HalfEdgeMesh.FaceHandle)">
      <summary>
            Align face texture properties to grid
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.TextureAlignToFace(Transform,HalfEdgeMesh.FaceHandle)">
      <summary>
            Align face texture properties to face
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.SetFaceTextureCoords(HalfEdgeMesh.FaceHandle,System.Collections.Generic.IReadOnlyList{Vector2})">
      <summary>
            Set face texture coords
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.SetFaceTextureParameters(HalfEdgeMesh.FaceHandle,Vector2,Vector3,Vector3)">
      <summary>
            Set face texture properties
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.TextureAlignToGrid(Transform)">
      <summary>
            Align all face texture properties to grid
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.RemoveFaces(System.Collections.Generic.IEnumerable{HalfEdgeMesh.FaceHandle})">
      <summary>
            Remove these faces
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.RemoveVertices(System.Collections.Generic.IEnumerable{HalfEdgeMesh.VertexHandle})">
      <summary>
            Remove these vertices
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.RemoveEdges(System.Collections.Generic.IEnumerable{HalfEdgeMesh.HalfEdgeHandle})">
      <summary>
            Remove these edges
            </summary>
    </member>
    <member name="M:Sandbox.PolygonMesh.Rebuild">
      <summary>
            Triangulate the polygons into a model
            </summary>
    </member>
    <member name="T:Sandbox.MissingComponent">
      <summary>
            This is added when a component is missing. It will store the json data of the missing component, so we don't lose any data.
            </summary>
    </member>
    <member name="M:Sandbox.MissingComponent.GetJson">
      <summary>
            Get the Json data that was deserialized
            </summary>
    </member>
    <member name="T:Sandbox.NavMeshAgent">
      <summary>
            An agent that can navigate the navmesh defined in the scene.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshAgent.Acceleration">
      <summary>
            The maximum acceleration a agent can have. This is how fast the agent can change its velocity.
            If you want snappy movement this should be as high or higher than <see cref="P:Sandbox.NavMeshAgent.MaxSpeed" />.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshAgent.UpdatePosition">
      <summary>
            Set the Position of the GameObject to the agent position every frame. You can turn this off and handle it yourself by using the AgentPosition property.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshAgent.UpdateRotation">
      <summary>
            This will simply face the direction it is moving. It is not configurable on purpose, so you should really turn this off and be doing this yourself if you need it to do anything specific.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshAgent.AgentPosition">
      <summary>
            Updated  with the agent's position, even if UpdatePosition is false
            </summary>
    </member>
    <member name="M:Sandbox.NavMeshAgent.SetAgentPosition(Vector3)">
      <summary>
            If you want to move the agent from one position to another
            </summary>
    </member>
    <member name="M:Sandbox.NavMeshAgent.MoveTo(Vector3)">
      <summary>
            Navigate to the position
            </summary>
    </member>
    <member name="M:Sandbox.NavMeshAgent.Stop">
      <summary>
            Stop moving, or whatever we're doing
            </summary>
    </member>
    <member name="M:Sandbox.NavMeshAgent.CompleteLinkTraversal">
      <summary>
            Finish link traversal, must be called after traversing a link if AutoTraverseLinks is false.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshAgent.LinkEnter">
      <summary>
            Emitted when the agent enters a link.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshAgent.LinkExit">
      <summary>
            Emitted when the agent exits a link.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshAgent.IsTraversingLink">
      <summary>
            Returns true if the agent is currently traversing a link.
            </summary>
    </member>
    <member name="T:Sandbox.NavMeshAgent.LinkTraversalData">
      <summary>
            Holds information about the current link the agent is traversing.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshAgent.LinkTraversalData.LinkEnterPosition">
      <summary>
            The start position of the traversal.
            Depending on the direction traversing,
            this is either LinkComponent.WorldStartPositionOnNavMesh or LinkComponent.WorldEndPositionOnNavMesh.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshAgent.LinkTraversalData.LinkExitPosition">
      <summary>
            The end position of the traversal. Where the agent should exit.
            Depending on the direction traversing,
            this is either LinkComponent.WorldStartPositionOnNavMesh or LinkComponent.WorldEndPositionOnNavMesh.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshAgent.LinkTraversalData.AgentInitialPosition">
      <summary>
            The position at which the agent entered the link.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshAgent.LinkTraversalData.LinkComponent">
      <summary>
            The Link component that the agent is traversing.
            May be null if the agent is traversing a link created without a NavMeshLink component.
            </summary>
    </member>
    <member name="F:Sandbox.NavMeshAgent.CurrentLinkTraversal">
      <summary>
            Information about the current link traversal.
            </summary>
    </member>
    <member name="M:Sandbox.NavMeshAgent.FindPhysicsGroundZ(Vector3)">
      <summary>
            We are tracing in the following interval (scale not accurate)
                x
                |
                |     We start a certain distance above the agents capsules center
                |
                | 
                |
             -------
             |  |  | 
             |  x  | -- Agent Capsule Center
             |  |  |
             -------
                |
                |
             ~~~~~~~ -- Potential ground
                |
                |
                |
                x      We trace down the same distance
                     
            In case of multiple hits we prefer the once closest to the agent's capsule center
            </summary>
    </member>
    <member name="M:Sandbox.NavMeshAgent.GetLookAhead(System.Single)">
      <summary>
            Get a point on the current path, distance away from here. This is a simplified path so 
            only includes the first few corners.
            </summary>
    </member>
    <member name="T:Sandbox.NavMeshArea">
      <summary>
            An area that influences the NavMesh generation.
            Areas can be used to block off parts of the NavMesh.
            Static areas have almost no performance overhead.
            Moving areas at runtime will have an impact on performance if done excessively.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshArea.LinkedCollider">
      <summary>
            The collider this area's shape is based on.
            In almost every case, you will want to use a trigger collider for this.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshArea.IsBlocker">
      <summary>
            Whether navmesh generation in this area will be completly disabled. 
            </summary>
    </member>
    <member name="T:Sandbox.NavMeshLink">
      <summary>
            NavigationLinks connect navigation mesh polygons for pathfinding and enable shortcuts like ladders, jumps, or teleports.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshLink.LocalStartPosition">
      <summary>
            Start position relative to the game object's position.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshLink.LocalEndPosition">
      <summary>
            End position relative to the game object's position.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshLink.WorldStartPositionOnNavmesh">
      <summary>
            Start position in world space snapped to the navmesh.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshLink.WorldEndPositionOnNavmesh">
      <summary>
            End position in world space snapped to the navmesh.
            </summary>
    </member>
    <member name="F:Sandbox.NavMeshLink.IsBiDirectional">
      <summary>
            Whether this link can be traverse bi-directional or only start towards end.
            </summary>
    </member>
    <member name="F:Sandbox.NavMeshLink.ConnectionRadius">
      <summary>
            Radius that will be searched at the start and end positions for a connection to the navmesh.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshLink.LinkEntered">
      <summary>
            Emitted when an agent enters the link.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshLink.LinkExited">
      <summary>
            Emitted when an agent exits the link.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshLink.WorldStartPosition">
      <summary>
            Start position in world space.
            </summary>
    </member>
    <member name="P:Sandbox.NavMeshLink.WorldEndPosition">
      <summary>
            End position in world space.
            </summary>
    </member>
    <member name="M:Sandbox.NavMeshLink.OnLinkEntered(Sandbox.NavMeshAgent)">
      <summary>
            Called when an agent enters the link.
            </summary>
    </member>
    <member name="M:Sandbox.NavMeshLink.OnLinkExited(Sandbox.NavMeshAgent)">
      <summary>
            Called when an agent exits the link.
            </summary>
    </member>
    <member name="T:Sandbox.ParticleAttractor">
      <summary>
            Attract particles to a GameObject in the scene
            </summary>
    </member>
    <member name="T:Sandbox.ParticleController">
      <summary>
            Particles can have extra controllers that can modify the particles every frame.
            </summary>
    </member>
    <member name="P:Sandbox.ParticleController.ParticleEffect">
      <summary>
            The particle we're controlling
            </summary>
    </member>
    <member name="M:Sandbox.ParticleController.OnBeforeStep(System.Single)">
      <summary>
            Called before the particle step
            </summary>
    </member>
    <member name="M:Sandbox.ParticleController.OnAfterStep(System.Single)">
      <summary>
            Called after the particle step
            </summary>
    </member>
    <member name="M:Sandbox.ParticleController.OnParticleStep(Sandbox.Particle,System.Single)">
      <summary>
            Called for each particle during the particle step. This is super threaded
            so you better watch out.
            </summary>
    </member>
    <member name="T:Sandbox.ParticleBoxEmitter">
      <summary>
            Emits particles within a box shape.
            </summary>
    </member>
    <member name="T:Sandbox.ParticleConeEmitter">
      <summary>
            Emits particles within/along a cone shape.
            </summary>
    </member>
    <member name="P:Sandbox.ParticleConeEmitter.VelocityRandom">
      <summary>
            Randomize the direction of the initial velocity. 0 = no randomization, 1 = full randomization.
            </summary>
    </member>
    <member name="P:Sandbox.ParticleConeEmitter.CenterBias">
      <summary>
            When distributing should we bias the center of the cone
            </summary>
    </member>
    <member name="P:Sandbox.ParticleConeEmitter.CenterBiasVelocity">
      <summary>
            Should particles near the center have more velocity
            </summary>
    </member>
    <member name="P:Sandbox.ParticleConeEmitter.VelocityMultiplier">
      <summary>
            Multiply velocity by this
            </summary>
    </member>
    <member name="T:Sandbox.ParticleEmitter">
      <summary>
            Creates particles. Should be attached to a <see cref="T:Sandbox.ParticleEffect" />.
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEmitter.Burst">
      <summary>
            How many particles to emit, in a burst
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEmitter.Rate">
      <summary>
            How many particles to emit over time
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEmitter.RateOverDistance">
      <summary>
            How many particles to emit per 100 units moved
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEmitter.Delta">
      <summary>
            0-1, the life time of the emitter
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEmitter.IsBursting">
      <summary>
            True if we're doing a burst
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEmitter.EmitRandom">
      <summary>
            0-1, a random number to be used for this loop of the emitter
            </summary>
    </member>
    <member name="M:Sandbox.ParticleEmitter.GetBurstCount">
      <summary>
            Allows child emitters to override how many particles are in a burst
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.ParticleEmitter.GetRateCount">
      <summary>
            Allows child emitters to override how many particles are in a rate
            </summary>
      <returns />
    </member>
    <member name="P:Sandbox.ParticleEmitter.Sandbox#Component#ITemporaryEffect#IsActive">
      <summary>
            Return true if we haven't finished emitting
            </summary>
    </member>
    <member name="T:Sandbox.ParticleModelEmitter">
      <summary>
            Emits particles in a model
            </summary>
    </member>
    <member name="T:Sandbox.ParticleRingEmitter">
      <summary>
            Emits particles in a ring. The ring can be flat or have a tube-like quality.
            
            Velocity can either be added from the center of the ring, or from the ring itself.
            </summary>
    </member>
    <member name="T:Sandbox.ParticleSphereEmitter">
      <summary>
            Emits particles within a sphere shape.
            </summary>
    </member>
    <member name="F:Sandbox.Particle.LifeDelta">
      <summary>
            A range from 0 to 1 descriving how long this particle has been alive
            </summary>
    </member>
    <member name="F:Sandbox.Particle.DeathTime">
      <summary>
            The time that this particle is scheduled to die
            </summary>
    </member>
    <member name="F:Sandbox.Particle.Follower">
      <summary>
            A GameObject that is following us. Might be emitting other particles or something.
            </summary>
    </member>
    <member name="M:Sandbox.Particle.Get``1(System.String)">
      <summary>
            Get an arbituary data value
            </summary>
    </member>
    <member name="M:Sandbox.Particle.Set``1(System.String,``0)">
      <summary>
            Set an arbituary data value
            </summary>
    </member>
    <member name="T:Sandbox.Particle.BaseListener">
      <summary>
            Allows creating a class that will exist for as long as a particle.
            The methods get called in the particle thread, which removes the need to run through
            the particle list again, but it has the danger and restrictions that come with threaded code.
            </summary>
    </member>
    <member name="P:Sandbox.Particle.BaseListener.Source">
      <summary>
            The component that created this listener. May be null.
            </summary>
    </member>
    <member name="M:Sandbox.Particle.BaseListener.OnEnabled(Sandbox.Particle)">
      <summary>
            Called in a thread. The particle is in its first position.
            </summary>
    </member>
    <member name="M:Sandbox.Particle.BaseListener.OnUpdate(Sandbox.Particle,System.Single)">
      <summary>
            Called in a thread, guarenteed to be called after OnEnabled
            </summary>
    </member>
    <member name="M:Sandbox.Particle.BaseListener.OnDisabled(Sandbox.Particle)">
      <summary>
            Called in a thread. OnUpdate won't be called again.
            </summary>
    </member>
    <member name="M:Sandbox.Particle.AddListener(Sandbox.Particle.BaseListener,Sandbox.Component)">
      <summary>
            Add a listener.
            </summary>
    </member>
    <member name="M:Sandbox.Particle.RemoveListener(Sandbox.Particle.BaseListener)">
      <summary>
            Remove a listener
            </summary>
    </member>
    <member name="M:Sandbox.Particle.DisableListenersForComponent(Sandbox.Component)">
      <summary>
            Remove all listeners with this component set as the source. This is most commonly called when
            the passed component is destroyed or disabled, to remove any effects created.
            </summary>
    </member>
    <member name="T:Sandbox.ParticleEffect">
      <summary>
            Defines and holds particles. This is the core of the particle system.
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.PreWarm">
      <summary>
            How many seconds to pre-warm this effect by when creating
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.StartDelay">
      <summary>
            The particle can wait until it properly spawns.
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.SequenceId">
      <summary>
            Which sequence to use
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.SequenceTime">
      <summary>
            Allows control of the sequence time, which spans from 0 to 1 for one loop
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.SequenceSpeed">
      <summary>
            Increment the sequence time by this much
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.FollowerPrefab">
      <summary>
            Will choose a random prefab to spawn from this list
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.FollowerPrefabChance">
      <summary>
            If 1 then we'll always spawn a prefab. If 0.5 then we'll spawn a prefab 50% of the time.
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.FollowerPrefabKill">
      <summary>
            When true the prefab will be destroyed at the end of the particle's life
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.CollisionPrefab">
      <summary>
            Will choose a random prefab to spawn from this list
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.CollisionPrefabAlign">
      <summary>
            Will choose a random prefab to spawn from this list
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.CollisionPrefabRotation">
      <summary>
            We will by default align to the particle's angle, but we can also randomize that.
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.CollisionPrefabChance">
      <summary>
            If 1 then we'll always spawn a prefab. If 0.5 then we'll spawn a prefab 50% of the time.
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.OnParticleDestroyed">
      <summary>
            Called any time a particle is destroyed
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.OnParticleCreated">
      <summary>
            Called any time a particle is created
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.Paused">
      <summary>
            Is the particle simulation paused?
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.OnPreStep">
      <summary>
            Called before the particles are stepped
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.OnPostStep">
      <summary>
            Called after the particles are stepped
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.OnStep">
      <summary>
            Called after the particles are stepped
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.ParticleBounds">
      <summary>
            The bounds of the current particles
            </summary>
    </member>
    <member name="P:Sandbox.ParticleEffect.MaxParticleSize">
      <summary>
            The biggest particle scale (x, y or z of scale)
            </summary>
    </member>
    <member name="M:Sandbox.ParticleEffect.Emit(Vector3,System.Single)">
      <summary>
            Emit a particle at the given position.
            </summary>
      <param name="position">The position in which to spawn the particle</param>
      <param name="delta">The time delta of the spawn. The first spawned particle is 0, the last spawned particle is 1. This is used to evaluate the spawn particles like lifetime and delay.</param>
      <returns>A particle, will never be null. It's up to you to obey max particles.</returns>
    </member>
    <member name="P:Sandbox.ParticleEffect.Sandbox#Component#ITemporaryEffect#IsActive">
      <summary>
            Should return true if we have active particles
            </summary>
    </member>
    <member name="T:Sandbox.ParticleGameSystem">
      <summary>
            Ticks the physics in FrameStage.PhysicsStep
            </summary>
    </member>
    <member name="M:Sandbox.ParticleGameSystem.ProcessWork(Sandbox.ParticleEffect.ParticleWork)">
      <summary>
            We process the particles in chunks, in parallel. We don't do one particle at a time because 
            it'd spend more time doing all the admin of giving them to threads than it would actually take.
            </summary>
      <param name="work" />
    </member>
    <member name="T:Sandbox.ParticleRandomNumber">
      <summary>
            Create a bunch of random numbers that can be looked up by index. This lets
            particles look up a number by index, so they can have consistent random numbers
            in different parts of their update, without generating a bunch of them.
            </summary>
    </member>
    <member name="F:Sandbox.ParticleRandomNumber.Count">
      <summary>
            Total number of available randoms
            </summary>
    </member>
    <member name="T:Sandbox.ParticleLightRenderer">
      <summary>
            Adds lighting to particles in your effect.
            </summary>
    </member>
    <member name="P:Sandbox.ParticleLightRenderer.Ratio">
      <summary>
            If 1, then every particle will get a light. If 0, no particles will get a light. If 0.5, half will get a particle.
            </summary>
    </member>
    <member name="T:Sandbox.ParticleModelRenderer">
      <summary>
            Renders particles as models, using the particle's position, rotation, and size.
            </summary>
    </member>
    <member name="T:Sandbox.ParticleRenderer">
      <summary>
            Renders a set of particles. Should be attached to a <see cref="P:Sandbox.ParticleRenderer.ParticleEffect" />.
            </summary>
    </member>
    <member name="T:Sandbox.ParticleSpriteRenderer">
      <summary>
            Renders particles as 2D sprites
            </summary>
    </member>
    <member name="P:Sandbox.ParticleSpriteRenderer.Opaque">
      <summary>
            If opaque there's no need to sort particles, because they will write to
            the depth buffer during the opaque pass.
            </summary>
    </member>
    <member name="F:Sandbox.ParticleSpriteRenderer.BillboardAlignment.LookAtCamera">
      <summary>
            Look directly at the camera, apply roll
            </summary>
    </member>
    <member name="F:Sandbox.ParticleSpriteRenderer.BillboardAlignment.RotateToCamera">
      <summary>
            Look at the camera but don't pitch up and down, up is always up, can roll
            </summary>
    </member>
    <member name="F:Sandbox.ParticleSpriteRenderer.BillboardAlignment.Particle">
      <summary>
            Use rotation provided by the particle, pitch yaw and roll
            </summary>
    </member>
    <member name="F:Sandbox.ParticleSpriteRenderer.BillboardAlignment.Object">
      <summary>
            Align to game object rotation, apply pitch yaw and roll
            </summary>
    </member>
    <member name="P:Sandbox.ParticleSpriteRenderer.Alignment">
      <summary>
            Should th
            </summary>
    </member>
    <member name="T:Sandbox.ParticleTextRenderer">
      <summary>
            Renders particles as 2D sprites
            </summary>
    </member>
    <member name="P:Sandbox.ParticleTextRenderer.Opaque">
      <summary>
            If opaque there's no need to sort particles, because they will write to
            the depth buffer during the opaque pass.
            </summary>
    </member>
    <member name="F:Sandbox.ParticleTextRenderer.BillboardAlignment.LookAtCamera">
      <summary>
            Look directly at the camera, apply roll
            </summary>
    </member>
    <member name="F:Sandbox.ParticleTextRenderer.BillboardAlignment.RotateToCamera">
      <summary>
            Look at the camera but don't pitch up and down, up is always up, can roll
            </summary>
    </member>
    <member name="F:Sandbox.ParticleTextRenderer.BillboardAlignment.Particle">
      <summary>
            Use rotation provided by the particle, pitch yaw and roll
            </summary>
    </member>
    <member name="P:Sandbox.ParticleTextRenderer.Alignment">
      <summary>
            Should th
            </summary>
    </member>
    <member name="T:Sandbox.ParticleTrailRenderer">
      <summary>
            Renders a trail for each particle in the effect.
            </summary>
    </member>
    <member name="T:Sandbox.AmbientOcclusion">
      <summary>
            Adds an approximation of ambient occlusion using Screen Space Ambient Occlusion (SSAO).
            It darkens areas where ambient light is generally occluded from such as corners, crevices
            and surfaces that are close to each other.
            </summary>
    </member>
    <member name="F:Sandbox.AmbientOcclusion.SampleQuality.Low">
      <summary>
            9 samples
            </summary>
    </member>
    <member name="F:Sandbox.AmbientOcclusion.SampleQuality.Medium">
      <summary>
            16 samples
            </summary>
    </member>
    <member name="F:Sandbox.AmbientOcclusion.SampleQuality.High">
      <summary>
            25 samples
            </summary>
    </member>
    <member name="P:Sandbox.AmbientOcclusion.Intensity">
      <summary>
            The intensity of the darkening effect. Has no impact on performance.
            </summary>
    </member>
    <member name="P:Sandbox.AmbientOcclusion.Radius">
      <summary>
            Maximum distance of samples from pixel when determining its occlusion, in world units.
            </summary>
    </member>
    <member name="P:Sandbox.AmbientOcclusion.FalloffRange">
      <summary>
            Gently reduce sample impact as it gets out of the effect's radius bounds
            </summary>
    </member>
    <member name="P:Sandbox.AmbientOcclusion.Quality">
      <summary>
            Number of pixel samples taken to determine occlusion
            </summary>
    </member>
    <member name="P:Sandbox.AmbientOcclusion.DenoiseMode">
      <summary>
            How we should denoise the effect
            </summary>
    </member>
    <member name="P:Sandbox.AmbientOcclusion.ThinCompensation">
      <summary>
            Slightly reduce impact of samples further back to counter the bias from depth-based (incomplete) input scene geometry data
            </summary>
    </member>
    <member name="F:Sandbox.AmbientOcclusion.DenoiseModes.Spatial">
      <summary>
            Applies spatial denoising to reduce noise by averaging pixel values within a local neighborhood.
            This method smooths out noise by considering the spatial relationship between pixels in a single frame.
            </summary>
    </member>
    <member name="F:Sandbox.AmbientOcclusion.DenoiseModes.Temporal">
      <summary>
            Applies temporal denoising to reduce noise by averaging pixel values over multiple frames.
            This method leverages the temporal coherence of consecutive frames to achieve a noise-free result.
            </summary>
    </member>
    <member name="T:Sandbox.Bloom">
      <summary>
            Applies a bloom effect to the camera
            </summary>
    </member>
    <member name="T:Sandbox.Blur">
      <summary>
            Applies a blur effect to the camera.
            </summary>
    </member>
    <member name="T:Sandbox.ChromaticAberration">
      <summary>
            Applies a chromatic aberration effect to the camera
            </summary>
    </member>
    <member name="P:Sandbox.ChromaticAberration.Scale">
      <summary>
            Enable chromatic aberration
            </summary>
    </member>
    <member name="P:Sandbox.ChromaticAberration.Offset">
      <summary>
            The pixel offset for each color channel. These values should
            be very small as it's in UV space. (0.004 for example)
            X = Red
            Y = Green
            Z = Blue
            </summary>
    </member>
    <member name="T:Sandbox.ColorAdjustments">
      <summary>
            Applies color adjustments to the camera.
            </summary>
    </member>
    <member name="T:Sandbox.ColorGrading">
      <summary>
            Applies color grading to the camera
            </summary>
    </member>
    <member name="M:Sandbox.ColorGrading.ProcessCurve(Sandbox.Curve,System.String)">
      <summary>
            Represent our curves into shaders
            </summary>
    </member>
    <member name="M:Sandbox.ColorGrading.RenderEffect(Sandbox.SceneCamera)">
      <summary>
            Render the effect onto given scene camera.
            </summary>
    </member>
    <member name="T:Sandbox.DepthOfField">
      <summary>
            Applies a depth of field effect to the camera
            </summary>
    </member>
    <member name="P:Sandbox.DepthOfField.BlurSize">
      <summary>
            How blurry to make stuff that isn't in focus.
            </summary>
    </member>
    <member name="P:Sandbox.DepthOfField.FocalDistance">
      <summary>
            How far away from the camera to focus in world units.
            </summary>
    </member>
    <member name="P:Sandbox.DepthOfField.FocusRange">
      <summary>
            This modulates how far is the blur to the image.
            </summary>
    </member>
    <member name="P:Sandbox.DepthOfField.FrontBlur">
      <summary>
            Should we blur what's ahead the focal point towards us?
            </summary>
    </member>
    <member name="P:Sandbox.DepthOfField.BackBlur">
      <summary>
            Should we blur what's behind the focal point?
            </summary>
    </member>
    <member name="M:Sandbox.DepthOfField.RenderEffect(Sandbox.SceneCamera)">
      <summary>
            Render the effect onto given scene camera.
            </summary>
    </member>
    <member name="T:Sandbox.FilmGrain">
      <summary>
            Applies a film grain effect to the camera
            </summary>
    </member>
    <member name="T:Sandbox.Highlight">
      <summary>
            This should be added to a camera that you want to outline stuff
            </summary>
    </member>
    <member name="T:Sandbox.HighlightOutline">
      <summary>
            This component should be added to stuff you want to be outlined. You will also need to 
            add the Highlight component to the camera you want to render the outlines.
            </summary>
    </member>
    <member name="P:Sandbox.HighlightOutline.Material">
      <summary>
            If defined, the glow will use this material rather than a generated one.
            </summary>
    </member>
    <member name="P:Sandbox.HighlightOutline.Color">
      <summary>
            The colour of the glow outline
            </summary>
    </member>
    <member name="P:Sandbox.HighlightOutline.ObscuredColor">
      <summary>
            The colour of the glow when the mesh is obscured by something closer.
            </summary>
    </member>
    <member name="P:Sandbox.HighlightOutline.InsideColor">
      <summary>
            Color of the inside of the glow
            </summary>
    </member>
    <member name="P:Sandbox.HighlightOutline.InsideObscuredColor">
      <summary>
            Color of the inside of the glow when the mesh is obscured by something closer.
            </summary>
    </member>
    <member name="P:Sandbox.HighlightOutline.Width">
      <summary>
            The width of the line of the glow
            </summary>
    </member>
    <member name="T:Sandbox.MotionBlur">
      <summary>
            Applies a motion blur effect to the camera
            </summary>
    </member>
    <member name="T:Sandbox.Pixelate">
      <summary>
            Applies a pixelate effect to the camera
            </summary>
    </member>
    <member name="T:Sandbox.PostProcess">
      <summary>
            Adds an effect to the camera
            </summary>
    </member>
    <member name="T:Sandbox.Sharpen">
      <summary>
            Applies a sharpen effect to the camera
            </summary>
    </member>
    <member name="T:Sandbox.Vignette">
      <summary>
            Applies a vignette to the camera
            </summary>
    </member>
    <member name="P:Sandbox.Vignette.Color">
      <summary>
            The color of the vignette or the "border"
            </summary>
    </member>
    <member name="P:Sandbox.Vignette.Intensity">
      <summary>
            How strong the vignette is. This is a value between 0 -&gt; 1
            </summary>
    </member>
    <member name="P:Sandbox.Vignette.Smoothness">
      <summary>
            How much fall off or how blurry the vignette is
            </summary>
    </member>
    <member name="P:Sandbox.Vignette.Roundness">
      <summary>
            How circular or round the vignette is
            </summary>
    </member>
    <member name="P:Sandbox.Vignette.Center">
      <summary>
            The center of the vignette in relation to UV space. This means
            a value of {0.5, 0.5} is the center of the screen
            </summary>
    </member>
    <member name="T:Sandbox.Decal">
      <summary>
            The Decal component projects textures onto model's opaque or transparent surfaces.
            They inherit and modify the PBR properties of the surface they're projected on.
            </summary>
    </member>
    <member name="P:Sandbox.Decal.ColorTexture">
      <summary>
            The color map to use for the decal including transparency which masks the decal.
            This must be set for other textures to use the decal mask.
            </summary>
    </member>
    <member name="P:Sandbox.Decal.NormalTexture">
      <summary>
            The normal texture map to use for the decal.
            </summary>
    </member>
    <member name="P:Sandbox.Decal.RMOTexture">
      <summary>
            The Roughness/Metal/Ambient Occlusion texture map to use for the decal, stored in the respective RGB channels.
            </summary>
    </member>
    <member name="P:Sandbox.Decal.ColorTint">
      <summary>
            Tints the color of the decal's albedo and can be used to adjust the overall opacity of the decal.
            </summary>
    </member>
    <member name="P:Sandbox.Decal.AttenuationAngle">
      <summary>
            Attenuation angle controls how much the decal fades at an angle.
            At 0 it does not fade at all. Up to 1 it fades the most.
            </summary>
    </member>
    <member name="P:Sandbox.Decal.Size">
      <summary>
            Sets the local size in units for the decal's projection.
            This is multiplied by the GameObject's world transform to get the final size.
            </summary>
    </member>
    <member name="P:Sandbox.Decal.SortLayer">
      <summary>
            Determines the order the decal gets rendered in, the higher the layer the more priority it has.
            Decals on the same layer get automatically sorted by their GameObject ID.
            </summary>
    </member>
    <member name="P:Sandbox.Decal.SequenceId">
      <summary>
            Which sequence to use
            </summary>
    </member>
    <member name="T:Sandbox.DecalRenderer">
      <summary>
            Component that creates a projected decal relative to its GameObject.
            </summary>
    </member>
    <member name="P:Sandbox.DecalRenderer.Material">
      <summary>
            The material to use for this decal
            </summary>
    </member>
    <member name="P:Sandbox.DecalRenderer.Size">
      <summary>
            The size of the decal. x being width, y being the height, z being the projection distance
            </summary>
    </member>
    <member name="P:Sandbox.DecalRenderer.TintColor">
      <summary>
            Tint the decal
            </summary>
    </member>
    <member name="P:Sandbox.DecalRenderer.TriPlanar">
      <summary>
            Triplanar - projects in multiple directions
            </summary>
    </member>
    <member name="P:Sandbox.DecalRenderer.Mod2XBlending">
      <summary>
            Triplanar - projects in multiple directions
            </summary>
    </member>
    <member name="T:Sandbox.GradientFog">
      <summary>
            Adds a gradient fog to the world
            </summary>
    </member>
    <member name="T:Sandbox.LineRenderer">
      <summary>
            Renders a line between a list of points
            </summary>
    </member>
    <member name="T:Sandbox.ModelRenderer">
      <summary>
            Renders a model in the world
            </summary>
    </member>
    <member name="M:Sandbox.ModelRenderer.GetAttachmentObject(System.String)">
      <summary>
            Get the GameObject of a specific attachment.
            </summary>
    </member>
    <member name="M:Sandbox.ModelRenderer.GetAttachmentObject(Sandbox.ModelAttachments.Attachment)">
      <summary>
            Get the GameObject of a specific attachment.
            </summary>
    </member>
    <member name="M:Sandbox.ModelRenderer.SetBodyGroup(System.String,System.Int32)">
      <summary>
            Set body group value by name
            </summary>
    </member>
    <member name="M:Sandbox.ModelRenderer.SetBodyGroup(System.Int32,System.Int32)">
      <summary>
            Set body group value by index
            </summary>
    </member>
    <member name="M:Sandbox.ModelRenderer.GetBodyGroup(System.String)">
      <summary>
            Get body group value by name
            </summary>
    </member>
    <member name="M:Sandbox.ModelRenderer.GetBodyGroup(System.Int32)">
      <summary>
            Get body group value by index
            </summary>
    </member>
    <member name="M:Sandbox.ModelRenderer.OnTagsChanged">
      <summary>
            Tags have been updated - lets update our scene object tags
            </summary>
    </member>
    <member name="M:Sandbox.ModelRenderer.CopyFrom(Sandbox.Renderer)">
      <summary>
            Copy everything from another renderer
            </summary>
    </member>
    <member name="M:Sandbox.Renderer.CopyFrom(Sandbox.Renderer)">
      <summary>
            Copy everything from another renderer
            </summary>
    </member>
    <member name="P:Sandbox.RenderOptions.Game">
      <summary>
            Regular game rendering layers
            </summary>
    </member>
    <member name="P:Sandbox.RenderOptions.Overlay">
      <summary>
            Rendered above everything else
            </summary>
    </member>
    <member name="P:Sandbox.RenderOptions.Bloom">
      <summary>
            Rendererd during bloom
            </summary>
    </member>
    <member name="P:Sandbox.RenderOptions.AfterUI">
      <summary>
            Rendered after the UI is rendered
            </summary>
    </member>
    <member name="M:Sandbox.RenderOptions.Apply(Sandbox.SceneObject)">
      <summary>
            Apply these options to a SceneObject
            </summary>
    </member>
    <member name="T:Sandbox.SkinnedModelRenderer">
      <summary>
            Renders a skinned model in the world. A skinned model is any model with bones/animations.
            </summary>
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.GetBoneObject(System.Int32)">
      <summary>
            Get the GameObject of a specific bone.
            </summary>
      <param name="index" />
      <returns />
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.GetBoneObject(System.String)">
      <summary>
            Find a bone's GameObject by bone name. 
            </summary>
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.GetBoneObject(Sandbox.BoneCollection.Bone)">
      <inheritdoc cref="M:Sandbox.SkinnedModelRenderer.GetBoneObject(System.Int32)" />
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.TryGetBoneTransform(System.String,Transform@)">
      <summary>
            Try to get the final worldspace bone transform.
            </summary>
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.TryGetBoneTransform(Sandbox.BoneCollection.Bone@,Transform@)">
      <summary>
            Try to get the final worldspace bone transform.
            </summary>
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.TryGetBoneTransformAnimation(Sandbox.BoneCollection.Bone@,Transform@)">
      <summary>
            Try to get the worldspace bone transform after animation but before physics and procedural bones.
            </summary>
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.GetBoneTransforms(System.Boolean)">
      <summary>
            Allocate an array of bone transforms in either world space or parent space.
            </summary>
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.GetBoneVelocities">
      <summary>
            Allocate an array of bone veloicities in world space
            </summary>
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.UseAnimGraph">
      <summary>
            Usually used for turning off animation on ragdolls.
            </summary>
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.AnimationGraph">
      <summary>
            Override animgraph, otherwise uses animgraph of the model.
            </summary>
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.Sequence">
      <summary>
            Allows playback of sequences directly, rather than using an animation graph.
            Requires <see cref="P:Sandbox.SkinnedModelRenderer.UseAnimGraph" /> disabled if the scene model has one.
            </summary>
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.PlaybackRate">
      <summary>
            Control playback rate of animgraph or current sequence.
            </summary>
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.ReadBonesFromGameObjects">
      <summary>
            For Procedural Bones, copy the current value to the animation bone
            </summary>
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.UpdateGameObjectsFromBones">
      <summary>
            For non procedural bones, copy the "parent space" bone from to the GameObject transform. Will
            return true if any transforms have changed.
            </summary>
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.OnFootstepEvent">
      <summary>
            Called when a footstep event happens
            </summary>
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.OnGenericEvent">
      <summary>
            Called when a generic animation event happens
            </summary>
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.OnSoundEvent">
      <summary>
            Called when a sound event happens
            </summary>
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.OnAnimTagEvent">
      <summary>
            Called when an anim tag event happens
            </summary>
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.Morphs">
      <summary>
            Access to the morphs for this model
            </summary>
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.MorphAccessor.Set(System.String,System.Single)">
      <summary>
            Set this value
            </summary>
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.MorphAccessor.ContainsOverride(System.String)">
      <summary>
            Returns true if we have this value overridden (set). False means its value is likely
            being driven by animation etc.
            </summary>
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.MorphAccessor.Get(System.String)">
      <summary>
            Get this value
            </summary>
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.MorphAccessor.Clear(System.String)">
      <summary>
            Clear this value, don't override it
            </summary>
    </member>
    <member name="F:Sandbox.SkinnedModelRenderer.parameters">
      <summary>
            If something sets parameters before the model is spawned, then we store them
            and apply them when it does spawn. This isn't ideal, but it is what it is.
            </summary>
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.ClearParameters">
      <summary>
            Remove any stored parameters
            </summary>
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.SetLookDirection(System.String,Vector3)">
      <summary>
            Converts value to vector local to this entity's eyepos and passes it to SetAnimVector
            </summary>
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.SetLookDirection(System.String,Vector3,System.Single)">
      <summary>
            Converts value to vector local to this entity's eyepos and passes it to SetAnimVector. 
            This also sets {name}_weight to the weight value.
            </summary>
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.SetIk(System.String,Transform)">
      <summary>
            Sets an IK parameter. This sets 3 variables that should be set in the animgraph:
            1. ik.{name}.enabled
            2. ik.{name}.position
            3. ik.{name}.rotation
            </summary>
    </member>
    <member name="M:Sandbox.SkinnedModelRenderer.ClearIk(System.String)">
      <summary>
            This sets ik.{name}.enabled to false.
            </summary>
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.Parameters">
      <summary>
            Access to the animgraph parameters for this model
            </summary>
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.SequenceAccessor.Duration">
      <inheritdoc cref="P:Sandbox.AnimationSequence.Duration" />
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.SequenceAccessor.IsFinished">
      <inheritdoc cref="P:Sandbox.AnimationSequence.IsFinished" />
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.SequenceAccessor.TimeNormalized">
      <inheritdoc cref="P:Sandbox.AnimationSequence.TimeNormalized" />
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.SequenceAccessor.Time">
      <inheritdoc cref="P:Sandbox.AnimationSequence.Time" />
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.SequenceAccessor.SequenceNames">
      <inheritdoc cref="P:Sandbox.AnimationSequence.SequenceNames" />
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.SequenceAccessor.Name">
      <inheritdoc cref="P:Sandbox.AnimationSequence.Name" />
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.SequenceAccessor.Looping">
      <inheritdoc cref="P:Sandbox.AnimationSequence.Looping" />
    </member>
    <member name="P:Sandbox.SkinnedModelRenderer.SequenceAccessor.PlaybackRate">
      <summary>
            Control playback rate of sequence.
            </summary>
    </member>
    <member name="T:Sandbox.SkyBox2D">
      <summary>
            Adds a 2D skybox to the world
            </summary>
    </member>
    <member name="M:Sandbox.SkyBox2D.OnTagsChanged">
      <summary>
            Tags have been updated
            </summary>
    </member>
    <member name="T:Sandbox.SpriteRenderer">
      <summary>
            Renders a sprite in the world
            </summary>
    </member>
    <member name="M:Sandbox.SpriteRenderer.OnTagsChanged">
      <summary>
            Tags have been updated - lets update our scene object tags
            </summary>
    </member>
    <member name="T:Sandbox.TextRenderer">
      <summary>
            Renders text in the world
            </summary>
    </member>
    <member name="M:Sandbox.TextRenderer.OnTagsChanged">
      <summary>
            Tags have been updated - lets update our scene object tags
            </summary>
    </member>
    <member name="T:Sandbox.TrailRenderer">
      <summary>
            Renders a trail behind the object, when it moves.
            </summary>
    </member>
    <member name="P:Sandbox.TrailRenderer.Emitting">
      <summary>
            When enabled, new points are added to the trail.
            </summary>
    </member>
    <member name="T:Sandbox.VolumetricFogController">
      <summary>
            Internal component for storing the baked fog texture
            We don't need to expose the volumetric fog controller like we did previously with entities,
            But we need to be fetch the baked fog texture from the map file
            </summary>
    </member>
    <member name="T:Sandbox.VolumetricFogVolume">
      <summary>
            Adds a volumetric fog volume to the scene.
            </summary>
    </member>
    <member name="T:Sandbox.Terrain">
      <summary>
            Terrain renders heightmap based terrain.
            </summary>
    </member>
    <member name="M:Sandbox.Terrain.Create">
      <summary>
            Call on enable or storage change
            </summary>
    </member>
    <member name="M:Sandbox.Terrain.RayIntersects(Ray,System.Single,Vector3@)">
      <summary>
            Given a world ray, finds out the LOCAL position it intersects with this terrain.
            </summary>
    </member>
    <member name="M:Sandbox.Terrain.SyncCPUTexture(Sandbox.Terrain.SyncFlags,Sandbox.RectInt)">
      <summary>
            Downloads dirty regions from the GPU texture maps onto the CPU, updating collider data and making changes saveable.
            This is used from the editor after modifying.
            </summary>
    </member>
    <member name="M:Sandbox.Terrain.SyncGPUTexture">
      <summary>
            Updates the GPU texture maps with the CPU data
            </summary>
    </member>
    <member name="P:Sandbox.Terrain.Storage">
      <summary>
            Storage contains pretty much everything: heightmap, controlmaps, materials, grass, etc etc
            </summary>
    </member>
    <member name="F:Sandbox.Terrain._materialOverride">
      <summary>
            Override the terrain rendering with your own material shader.
            This needs to be explicitly set up to work with the Terrain Shader API.
            </summary>
    </member>
    <member name="P:Sandbox.Terrain.TerrainSize">
      <summary>
            Uniform world size of the width and length of the terrain.
            </summary>
    </member>
    <member name="P:Sandbox.Terrain.TerrainHeight">
      <summary>
            World size of the maximum height of the terrain.
            </summary>
    </member>
    <member name="M:Sandbox.Terrain.UpdateTerrainBuffer">
      <summary>
            Upload the Terrain buffer, this should be called when some base settings change.
            </summary>
    </member>
    <member name="M:Sandbox.Terrain.UpdateMaterialsBuffer">
      <summary>
            Upload the Terrain buffer, this should be called when materials are added, removed or modified.
            </summary>
    </member>
    <member name="M:Sandbox.TerrainClipmap.GenerateMesh_DiamondSquare(System.Int32,System.Int32,Sandbox.Material)">
      <summary>
            Inefficient implementation of diamond square, it's not merging verticies.
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.PanelComponent.HasClass(System.String)">
      <inheritdoc cref="M:Sandbox.UI.Panel.HasClass(System.String)" />
    </member>
    <member name="M:Sandbox.PanelComponent.RemoveClass(System.String)">
      <inheritdoc cref="M:Sandbox.UI.Panel.RemoveClass(System.String)" />
    </member>
    <member name="M:Sandbox.PanelComponent.AddClass(System.String)">
      <inheritdoc cref="M:Sandbox.UI.Panel.AddClass(System.String)" />
    </member>
    <member name="M:Sandbox.PanelComponent.BindClass(System.String,System.Func{System.Boolean})">
      <inheritdoc cref="M:Sandbox.UI.Panel.BindClass(System.String,System.Func{System.Boolean})" />
    </member>
    <member name="M:Sandbox.PanelComponent.SetClass(System.String,System.Boolean)">
      <inheritdoc cref="M:Sandbox.UI.Panel.SetClass(System.String,System.Boolean)" />
    </member>
    <member name="P:Sandbox.PanelComponent.Panel">
      <summary>
            The panel. Can be null if the panel doesn't exist yet.
            </summary>
    </member>
    <member name="M:Sandbox.PanelComponent.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder)">
      <summary>
            Gets overridden by .razor file
            </summary>
    </member>
    <member name="M:Sandbox.PanelComponent.GetRenderTreeChecksum">
      <summary>
            Gets overridden by .razor file
            </summary>
    </member>
    <member name="M:Sandbox.PanelComponent.OnTreeFirstBuilt">
      <summary>
            Called when the razor ui has been built.
            </summary>
    </member>
    <member name="M:Sandbox.PanelComponent.OnTreeBuilt">
      <summary>
            Called after the tree has been built. This can happen any time the contents change.
            </summary>
    </member>
    <member name="M:Sandbox.PanelComponent.BuildHash">
      <summary>
            When this has changes, we will re-render this panel. This is usually
            implemented as a HashCode.Combine containing stuff that causes the
            panel's content to change.
            </summary>
    </member>
    <member name="M:Sandbox.PanelComponent.StateHasChanged">
      <summary>
            Should be called when you want the component to be re-rendered.
            </summary>
    </member>
    <member name="M:Sandbox.PanelComponent.OnMouseDown(Sandbox.UI.MousePanelEvent)">
      <inheritdoc cref="M:Sandbox.UI.Panel.OnMouseDown(Sandbox.UI.MousePanelEvent)" />
    </member>
    <member name="M:Sandbox.PanelComponent.OnMouseMove(Sandbox.UI.MousePanelEvent)">
      <inheritdoc cref="M:Sandbox.UI.Panel.OnMouseMove(Sandbox.UI.MousePanelEvent)" />
    </member>
    <member name="M:Sandbox.PanelComponent.OnMouseUp(Sandbox.UI.MousePanelEvent)">
      <inheritdoc cref="M:Sandbox.UI.Panel.OnMouseUp(Sandbox.UI.MousePanelEvent)" />
    </member>
    <member name="M:Sandbox.PanelComponent.OnMouseOut(Sandbox.UI.MousePanelEvent)">
      <inheritdoc cref="M:Sandbox.UI.Panel.OnMouseOut(Sandbox.UI.MousePanelEvent)" />
    </member>
    <member name="M:Sandbox.PanelComponent.OnMouseOver(Sandbox.UI.MousePanelEvent)">
      <inheritdoc cref="M:Sandbox.UI.Panel.OnMouseOver(Sandbox.UI.MousePanelEvent)" />
    </member>
    <member name="M:Sandbox.PanelComponent.OnMouseWheel(Vector2)">
      <inheritdoc cref="M:Sandbox.UI.Panel.OnMouseWheel(Vector2)" />
    </member>
    <member name="T:Sandbox.CustomBuildPanel">
      <summary>
            A panel where we control the tree build.
            </summary>
    </member>
    <member name="T:Sandbox.ScreenPanel">
      <summary>
            Renders any attached PanelComponents to the screen. Acts as the root for all your UI components.
            </summary>
    </member>
    <member name="F:Sandbox.ScreenPanel.AutoScale.ConsistentHeight">
      <summary>
            The height is scaled on the assumptiuon that we're always 1080p
            </summary>
    </member>
    <member name="F:Sandbox.ScreenPanel.AutoScale.FollowDesktopScaling">
      <summary>
            We use the same scaling as the desktop
            </summary>
    </member>
    <member name="T:Sandbox.WorldInput">
      <summary>
            A router for world input, the best place to put this is on your player's camera.
            </summary>
    </member>
    <member name="P:Sandbox.WorldInput.LeftMouseAction">
      <summary>
            Which action is our left clicking button?
            </summary>
    </member>
    <member name="P:Sandbox.WorldInput.RightMouseAction">
      <summary>
            Which action is our right clicking button?
            </summary>
    </member>
    <member name="P:Sandbox.WorldInput.Hovered">
      <summary>
            The <see cref="T:Sandbox.UI.Panel" /> that is currently hovered by this input.
            </summary>
    </member>
    <member name="T:Sandbox.WorldPanel">
      <summary>
            Renders any attached PanelComponents to the world in 3D space.
            </summary>
    </member>
    <member name="P:Sandbox.WorldPanel.InteractionRange">
      <summary>
            How far can we interact with this world panel?
            </summary>
    </member>
    <member name="M:Sandbox.WorldPanel.OnTagsChanged">
      <summary>
            Tags have been updated
            </summary>
    </member>
    <member name="T:Sandbox.Volumes.SceneVolume">
      <summary>
            A generic way to represent volumes in a scene. If we all end up using this instead of defining our own version
            in everything, we can improve this and improve everything at the same time.
            </summary>
    </member>
    <member name="F:Sandbox.Volumes.SceneVolume.VolumeTypes.Sphere">
      <summary>
            A sphere. It's like the earth. Or an eyeball.
            </summary>
    </member>
    <member name="F:Sandbox.Volumes.SceneVolume.VolumeTypes.Box">
      <summary>
            A box, like a cube.
            </summary>
    </member>
    <member name="M:Sandbox.Volumes.SceneVolume.DrawGizmos(System.Boolean)">
      <summary>
            Draws an editable sphere/box gizmo, for adjusting the volume
            </summary>
    </member>
    <member name="M:Sandbox.Volumes.SceneVolume.Test(Transform@,Vector3@)">
      <summary>
            Is this point within the volume
            </summary>
    </member>
    <member name="M:Sandbox.Volumes.SceneVolume.Test(Transform@,BBox@)">
      <summary>
            Is this point within the volume
            </summary>
    </member>
    <member name="M:Sandbox.Volumes.SceneVolume.Test(Transform@,Sandbox.Sphere@)">
      <summary>
            Is this point within the volume
            </summary>
    </member>
    <member name="M:Sandbox.Volumes.SceneVolume.Test(Vector3@)">
      <summary>
            Is this point within the (local space) volume
            </summary>
    </member>
    <member name="M:Sandbox.Volumes.SceneVolume.GetVolume">
      <summary>
            Get the actual amount of volume in this shape. This is useful if you want to make
            a system where you prioritize by volume size. Don't forget to multiply by scale!
            </summary>
    </member>
    <member name="T:Sandbox.Volumes.VolumeSystem">
      <summary>
            A base GameObjectSystem for handling of IVolume components. You can use this to find volume components
            by position.
            </summary>
    </member>
    <member name="M:Sandbox.Volumes.VolumeSystem.FindSingle``1(Vector3)">
      <summary>
            Find a volume of this type, at this point. Will return null if none.
            </summary>
    </member>
    <member name="M:Sandbox.Volumes.VolumeSystem.FindAll``1(Vector3)">
      <summary>
            Find all volumes of this type, at this point
            </summary>
    </member>
    <member name="T:Sandbox.VR.VRAnchor">
      <summary>
            Updates the the VR anchor based on a GameObject's transform.
            </summary>
    </member>
    <member name="M:Sandbox.VR.VRAnchor.UpdateAnchor">
      <summary>
            Update the VR anchor based on the GameObject's transform
            </summary>
    </member>
    <member name="T:Sandbox.VR.VRHand">
      <summary>
            Updates the parameters on an <see cref="T:Sandbox.SkinnedModelRenderer" /> on this GameObject based on the skeletal data from SteamVR.
            Useful for quick hand posing based on controller input.
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRHand.SkinnedModelComponent">
      <summary>
            Which <see cref="T:Sandbox.SkinnedModelRenderer" /> to use when updating this component
            </summary>
    </member>
    <member name="T:Sandbox.VR.VRHand.HandSources">
      <summary>
            Represents a controller to use when fetching skeletal data (finger curl/splay values)
            </summary>
    </member>
    <member name="F:Sandbox.VR.VRHand.HandSources.Left">
      <summary>
            The left controller
            </summary>
    </member>
    <member name="F:Sandbox.VR.VRHand.HandSources.Right">
      <summary>
            The right controller
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRHand.HandSource">
      <summary>
            Which hand should we use to update the parameters?
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRHand.MotionRange">
      <summary>
            What motion range should we use to update the parameters?
            </summary>
    </member>
    <member name="T:Sandbox.VR.VRModelRenderer">
      <summary>
            Renders a device-specific model for a VR device
            </summary>
    </member>
    <member name="T:Sandbox.VR.VRModelRenderer.ModelSources">
      <summary>
            Represents a controller to use when fetching the model (which device)
            </summary>
    </member>
    <member name="F:Sandbox.VR.VRModelRenderer.ModelSources.LeftHand">
      <summary>
            The left controller
            </summary>
    </member>
    <member name="F:Sandbox.VR.VRModelRenderer.ModelSources.RightHand">
      <summary>
            The right controller
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRModelRenderer.ModelSource">
      <summary>
            Which device should we use to fetch the model?
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRModelRenderer.ModelRenderer">
      <summary>
            Which model renderer should we use as the target?
            </summary>
    </member>
    <member name="T:Sandbox.VR.VRTrackedObject">
      <summary>
            Updates this GameObject's transform based on a given tracked object (e.g. left controller, HMD).
            </summary>
    </member>
    <member name="T:Sandbox.VR.VRTrackedObject.PoseSources">
      <summary>
            Represents tracked devices to use when updating
            </summary>
    </member>
    <member name="F:Sandbox.VR.VRTrackedObject.PoseSources.Head">
      <summary>
            Retrieve data from the head-mounted display
            </summary>
    </member>
    <member name="F:Sandbox.VR.VRTrackedObject.PoseSources.LeftHand">
      <summary>
            Retrieve data from the left controller
            </summary>
    </member>
    <member name="F:Sandbox.VR.VRTrackedObject.PoseSources.RightHand">
      <summary>
            Retrieve data from the right controller
            </summary>
    </member>
    <member name="T:Sandbox.VR.VRTrackedObject.TrackingTypes">
      <summary>
            Represents transform values to update
            </summary>
    </member>
    <member name="F:Sandbox.VR.VRTrackedObject.TrackingTypes.None">
      <summary>
            Don't update the position or the rotation
            </summary>
    </member>
    <member name="F:Sandbox.VR.VRTrackedObject.TrackingTypes.Rotation">
      <summary>
            Update the rotation only
            </summary>
    </member>
    <member name="F:Sandbox.VR.VRTrackedObject.TrackingTypes.Position">
      <summary>
            Update the rotation only
            </summary>
    </member>
    <member name="F:Sandbox.VR.VRTrackedObject.TrackingTypes.All">
      <summary>
            Update both the position and rotation
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRTrackedObject.PoseSource">
      <summary>
            Which tracked object should we use to update the transform?
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRTrackedObject.TrackingType">
      <summary>
            Which parts of the transform should be updated? (eg. rotation, position)
            </summary>
    </member>
    <member name="P:Sandbox.VR.VRTrackedObject.UseRelativeTransform">
      <summary>
            If this is checked, then the transform used will be relative to the VR anchor (rather than an absolute world position).
            </summary>
    </member>
    <member name="M:Sandbox.VR.VRTrackedObject.GetTransform">
      <summary>
            Get the appropriate VR transform for the specified <see cref="P:Sandbox.VR.VRTrackedObject.PoseSource" /></summary>
    </member>
    <member name="M:Sandbox.VR.VRTrackedObject.UpdatePose">
      <summary>
            Set the GameObject's transform based on the <see cref="P:Sandbox.VR.VRTrackedObject.PoseSource" /> and <see cref="P:Sandbox.VR.VRTrackedObject.TrackingType" /></summary>
    </member>
    <member name="T:Sandbox.VR.VROverlayPanel">
      <summary>
        <para>A <see cref="T:Sandbox.VR.VROverlay" /> that draws and handles input of a <see cref="T:Sandbox.UI.RootPanel" />.</para>
        <para>VR overlays draw over the top of the 3D scene, they will not be affected by lighting,
            post processing effects or anything else in the world.<br />
            This makes them ideal for HUDs or menus, or anything else that should be local to the
            HMD or tracked devices.</para>
        <para>If you need something in the world, consider using WorldPanel
            and <see cref="T:Sandbox.UI.WorldInput" /> instead.</para>
      </summary>
    </member>
    <member name="P:Sandbox.VR.VROverlayPanel.RootPanel">
      <summary>
            The <see cref="P:Sandbox.VR.VROverlayPanel.RootPanel" /> to render to the VR overlay
            </summary>
    </member>
    <member name="M:Sandbox.VR.VROverlayPanel.#ctor(Sandbox.UI.RootPanel)">
      <summary>
            Create a VR overlay panel using a given <see cref="P:Sandbox.VR.VROverlayPanel.RootPanel" />.
            </summary>
      <param name="panel">The panel to render to the VR overlay</param>
    </member>
    <member name="T:Sandbox.VRWorldInput.HandSources">
      <summary>
            Represents a controller to use
            </summary>
    </member>
    <member name="F:Sandbox.VRWorldInput.HandSources.Left">
      <summary>
            The left controller
            </summary>
    </member>
    <member name="F:Sandbox.VRWorldInput.HandSources.Right">
      <summary>
            The right controller
            </summary>
    </member>
    <member name="P:Sandbox.VRWorldInput.HandSource">
      <summary>
            Which hand should we use?
            </summary>
    </member>
    <member name="P:Sandbox.VRWorldInput.DampingFactor">
      <summary>
            How much should we dampen movement when the trigger is pressed?
            </summary>
    </member>
    <member name="T:Sandbox.IGameObjectNetworkEvents">
      <summary>
            Allows listening to network events on a specific GameObject
            </summary>
    </member>
    <member name="M:Sandbox.IGameObjectNetworkEvents.NetworkOwnerChanged(Sandbox.Connection,Sandbox.Connection)">
      <summary>
            Called when the owner of a network GameObject is changed
            </summary>
    </member>
    <member name="M:Sandbox.IGameObjectNetworkEvents.StartControl">
      <summary>
            We have become the controller of this object, we are no longer a proxy
            </summary>
    </member>
    <member name="M:Sandbox.IGameObjectNetworkEvents.StopControl">
      <summary>
            This object has become a proxy, controlled by someone else
            </summary>
    </member>
    <member name="T:Sandbox.ISceneCollisionEvents">
      <summary>
            Listen to all collision events that happen during a physics step.
            </summary>
    </member>
    <member name="M:Sandbox.ISceneCollisionEvents.OnCollisionStart(Sandbox.Collision)">
      <summary>
            Called when a collider/rigidbody starts touching another collider.
            </summary>
    </member>
    <member name="M:Sandbox.ISceneCollisionEvents.OnCollisionUpdate(Sandbox.Collision)">
      <summary>
            Called once per physics step for every collider being touched.
            </summary>
    </member>
    <member name="M:Sandbox.ISceneCollisionEvents.OnCollisionStop(Sandbox.CollisionStop)">
      <summary>
            Called when a collider/rigidbody stops touching another collider.
            </summary>
    </member>
    <member name="T:Sandbox.ISceneLoadingEvents">
      <summary>
            Allows listening to events related to scene loading
            </summary>
    </member>
    <member name="M:Sandbox.ISceneLoadingEvents.BeforeLoad(Sandbox.Scene,Sandbox.SceneLoadOptions)">
      <summary>
            Called before the loading starts
            </summary>
    </member>
    <member name="M:Sandbox.ISceneLoadingEvents.OnLoad(Sandbox.Scene,Sandbox.SceneLoadOptions)">
      <summary>
            Called during loading. The game will wait for your task to finish
            </summary>
    </member>
    <member name="M:Sandbox.ISceneLoadingEvents.AfterLoad(Sandbox.Scene)">
      <summary>
            Loading has finished
            </summary>
    </member>
    <member name="T:Sandbox.IScenePhysicsEvents">
      <summary>
            Allows events before and after the the physics step
            </summary>
    </member>
    <member name="M:Sandbox.IScenePhysicsEvents.PrePhysicsStep">
      <summary>
            Called before the physics step is run. This is called pretty much
            right after FixedUpdate.
            </summary>
    </member>
    <member name="M:Sandbox.IScenePhysicsEvents.PostPhysicsStep">
      <summary>
            Called after the physics step is run
            </summary>
    </member>
    <member name="T:Sandbox.ISceneStartup">
      <summary>
            Allows listening to events related to scene startup. This should really only apply to GameObjectSystem's
            because components won't have been spawned/created when most of this is invoked.
            </summary>
    </member>
    <member name="M:Sandbox.ISceneStartup.OnHostPreInitialize(Sandbox.SceneFile)">
      <summary>
            Called before the scene is loaded. In game only, on host only.
            </summary>
    </member>
    <member name="M:Sandbox.ISceneStartup.OnHostInitialize">
      <summary>
            Called after the scene is loaded. In game only, on the host only.
            </summary>
    </member>
    <member name="M:Sandbox.ISceneStartup.OnClientInitialize">
      <summary>
            Called in game after the client has loaded the initial scene from the server, or after OnHostInitialize. 
            This is not called on the dedicated server.
            </summary>
    </member>
    <member name="T:Sandbox.CollisionSoundSystem">
      <summary>
            This system exists to collect pending collision sounds and filter them into a unique set, to avoid
            unnesssary sounds playing, when they're going to be making the same sound anyway.
            </summary>
    </member>
    <member name="M:Sandbox.CollisionSoundSystem.RegisterCollision(Sandbox.Collision@)">
      <summary>
            Register this physics collision with the sound system
            </summary>
    </member>
    <member name="M:Sandbox.CollisionSoundSystem.AddShapeCollision(Sandbox.PhysicsShape,Sandbox.Surface,Vector3@,System.Single)">
      <summary>
            Add a collision sound for this shape
            </summary>
    </member>
    <member name="M:Sandbox.CollisionSoundSystem.AddShapeCollision(Sandbox.PhysicsShape,Sandbox.Surface,Sandbox.PhysicsContact@)">
      <summary>
            Add a collision sound for this shape
            </summary>
    </member>
    <member name="M:Sandbox.CollisionSoundSystem.ProcessQueue">
      <summary>
            Create the pending sounds
            </summary>
    </member>
    <member name="M:Sandbox.DebugOverlaySystem.Box(Vector3,Vector3,Color,System.Single,Transform,System.Boolean)">
      <summary>
            Draw a box
            </summary>
    </member>
    <member name="M:Sandbox.DebugOverlaySystem.Box(BBox,Color,System.Single,Transform,System.Boolean)">
      <summary>
            Draw a box
            </summary>
    </member>
    <member name="M:Sandbox.DebugOverlaySystem.GameObject(Sandbox.GameObject,Color,System.Single,Transform,System.Boolean,System.Boolean,Sandbox.Material)">
      <summary>
            Draw a GameObject in the world
            </summary>
    </member>
    <member name="M:Sandbox.DebugOverlaySystem.Normal(Vector3,Vector3,Color,System.Single,Transform,System.Boolean)">
      <summary>
            Draw a line 
            </summary>
    </member>
    <member name="M:Sandbox.DebugOverlaySystem.Line(Line,Color,System.Single,Transform,System.Boolean)">
      <summary>
            Draw a line 
            </summary>
    </member>
    <member name="M:Sandbox.DebugOverlaySystem.Line(Vector3,Vector3,Color,System.Single,Transform,System.Boolean)">
      <summary>
            Draw a line 
            </summary>
    </member>
    <member name="M:Sandbox.DebugOverlaySystem.Line(System.Collections.Generic.IEnumerable{Vector3},Color,System.Single,Transform,System.Boolean)">
      <summary>
            Draw a line 
            </summary>
    </member>
    <member name="M:Sandbox.DebugOverlaySystem.Model(Sandbox.Model,Color,System.Single,Transform,System.Boolean,System.Boolean,Sandbox.Material)">
      <summary>
            Draw model in the world
            </summary>
    </member>
    <member name="M:Sandbox.DebugOverlaySystem.Sphere(Sandbox.Sphere,Color,System.Single,Transform,System.Boolean)">
      <summary>
            Draw a sphere
            </summary>
    </member>
    <member name="M:Sandbox.DebugOverlaySystem.Text(Vector3,System.String,System.Single,Sandbox.TextFlag,Color,System.Single,Transform,System.Boolean)">
      <summary>
            Draw text in the world
            </summary>
    </member>
    <member name="M:Sandbox.DebugOverlaySystem.Text(Vector3,Sandbox.TextRendering.Scope,Sandbox.TextFlag,System.Single,Transform,System.Boolean)">
      <summary>
            Draw text in the world
            </summary>
    </member>
    <member name="M:Sandbox.DebugOverlaySystem.Add(System.Single,Sandbox.SceneObject)">
      <summary>
            Add an entry manually
            </summary>
    </member>
    <member name="M:Sandbox.DebugOverlaySystem.ScreenText(Vector2,System.String,System.Single,Sandbox.TextFlag,Color,System.Single,Transform)">
      <summary>
            Draw text on the screen
            </summary>
    </member>
    <member name="M:Sandbox.DebugOverlaySystem.ScreenText(Vector2,Sandbox.TextRendering.Scope,Sandbox.TextFlag,System.Single,Transform)">
      <summary>
            Draw text on the screen
            </summary>
    </member>
    <member name="T:Sandbox.HitboxSystem">
      <summary>
            Ticks the physics in FrameStage.PhysicsStep
            </summary>
    </member>
    <member name="T:Sandbox.InterpolationSystem">
      <summary>
            Updates interpolation for any <see cref="T:Sandbox.GameTransform" /> that needs it.
            </summary>
    </member>
    <member name="M:Sandbox.InterpolationSystem.AddGameObject(Sandbox.GameObject)">
      <summary>
            Add a <see cref="T:Sandbox.GameObject" /> to the interpolation list.
            </summary>
    </member>
    <member name="M:Sandbox.InterpolationSystem.RemoveGameObject(Sandbox.GameObject)">
      <summary>
            Remove a <see cref="T:Sandbox.GameObject" /> from the interpolation list.
            </summary>
    </member>
    <member name="M:Sandbox.NetworkDebugSystem.Track``1(System.String,``0)">
      <summary>
            Track an incoming message so that we can gather data about how frequently it is called
            and the size of the messages.
            </summary>
    </member>
    <member name="T:Sandbox.ScenePhysicsSystem">
      <summary>
            Ticks the physics in FrameStage.PhysicsStep
            </summary>
    </member>
    <member name="T:Sandbox.SceneSoundscapeSystem">
      <summary>
            Implements logic for the SoundScape system
            </summary>
    </member>
    <member name="T:Sandbox.GameObjectSystem">
      <summary>
            Allows creation of a system that always exists in every scene, is hooked into the scene's lifecycle, 
            and is disposed when the scene is disposed.
            </summary>
    </member>
    <member name="M:Sandbox.GameObjectSystem.Listen(Sandbox.GameObjectSystem.Stage,System.Int32,System.Action,System.String)">
      <summary>
            Listen to a frame stage. Order is used to determine the order in which listeners are called, the default action always happens at 0, so if you
            want it to happen before you should go to -1, if you want it to happen after go to 1 etc.
            </summary>
    </member>
    <member name="T:Sandbox.GameObjectSystem.Stage">
      <summary>
            A list of stages in the scene tick in which we can hook
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectSystem.Stage.StartUpdate">
      <summary>
            At the very start of the scene update
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectSystem.Stage.UpdateBones">
      <summary>
            Bones are worked out
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectSystem.Stage.PhysicsStep">
      <summary>
            Physics step, called in fixed update
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectSystem.Stage.Interpolation">
      <summary>
            When transforms are interpolated
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectSystem.Stage.FinishUpdate">
      <summary>
            At the very end of the scene update
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectSystem.Stage.StartFixedUpdate">
      <summary>
            Called at the start of fixed update
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectSystem.Stage.FinishFixedUpdate">
      <summary>
            Called at the end of fixed update
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectSystem.Stage.SceneLoaded">
      <summary>
            Called after a scene has been loaded
            </summary>
    </member>
    <member name="T:Sandbox.GameObjectSystem.ITraceProvider">
      <summary>
            When implementing an ITraceProvider, the most importannt thing to keep in mind 
            is that the call to DoTrace should be thread safe. This might be called from 
            multiple threads at once, so you better watch out.
            </summary>
    </member>
    <member name="M:Sandbox.GameObjectSystem.ForceChangeId(System.Guid)">
      <summary>
            Should only be called by <see cref="M:Sandbox.GameObjectDirectory.Add(Sandbox.GameObjectSystem)" />.
            </summary>
    </member>
    <member name="M:Sandbox.GameObjectSystem.GetOrCreateInterpolatedVar``1(``0,System.String)">
      <summary>
            Get or create a new interpolated variable. This will set the current interpolated value to the
            provided one if it hasn't been created yet.
            </summary>
    </member>
    <member name="M:Sandbox.GameObjectSystem.Sandbox#IDeltaSnapshot#WriteDeltaSnapshot(Sandbox.DeltaSnapshot)">
      <summary>
            Write delta snapshot data to the specified <see cref="T:Sandbox.DeltaSnapshot" />.
            </summary>
    </member>
    <member name="M:Sandbox.GameObjectSystem.Sandbox#IDeltaSnapshot#SendNetworkUpdate">
      <summary>
            Try to send a network update or do nothing if no update is required. This is most
            likely called after WriteDeltaSnapshot.
            </summary>
    </member>
    <member name="M:Sandbox.GameObjectSystem.WriteDataTable(System.Boolean)">
      <summary>
            Write all pending data table changes.
            </summary>
    </member>
    <member name="M:Sandbox.GameObjectSystem.ReadDataTable(System.Byte[],Sandbox.NetworkTable.ReadFilter)">
      <summary>
            Read the network table data.
            </summary>
    </member>
    <member name="T:Sandbox.GameObjectSystem`1">
      <summary>
            A syntax sugar wrapper around GameObjectSystem, which allows you to access your system using
            SystemName.Current instead of Scene.GetSystem.
            </summary>
    </member>
    <member name="T:Sandbox.TimedCallbackList">
      <summary>
            Keeps a list of callbacks
            The intention of this is that in the future we'll have a nice window that will
            show the relative performance of each callback, and allow you to disable them to debug.
            </summary>
    </member>
    <member name="T:Sandbox.CallbackBatch">
      <summary>
            We want to execute callbacks in a predictable order. This happens
            naturally when spawning one GameObject, but when spawning a scene, or a 
            prefab, we want to hold the calls to things like OnEnable and call them all
            after OnStart or whatever has been called on all the objects in the batch.
            </summary>
    </member>
    <member name="M:Sandbox.CallbackBatch.Batch(System.String)">
      <summary>
            Add callbacks to the previous batch (or create one). This allows for one single batch, the
            most outer one, and won't create a new batch for inner ones. This is used when doing things like
            deserializing a map, so all the OnEnable etc are executed at the same time, and in the right order.
            </summary>
    </member>
    <member name="M:Sandbox.CallbackBatch.Isolated(System.String)">
      <summary>
            Collect callbacks in this scope and execute them immediately at the end of this batch. This is used
            for things like gameobject Clones, where we're going to want access to the object straight after 
            creating it.. and if we're inside a Batch then OnEnable etc won't have been called, so it will be
            confusing to everyone.
            </summary>
    </member>
    <member name="T:Sandbox.CommonCallback">
      <summary>
            A list of component methods that are deferred and batched into groups, and exected in group order.
            This is used to ensure that components are initialized in a predictable order.
            The order of this enum is critical.
            </summary>
    </member>
    <member name="F:Sandbox.CommonCallback.Deserialize">
      <summary>
            The component is deserializing.
            </summary>
    </member>
    <member name="F:Sandbox.CommonCallback.Validate">
      <summary>
            The component has been deserialized, or edited in the editor
            </summary>
    </member>
    <member name="F:Sandbox.CommonCallback.Loading">
      <summary>
            An opportunity for the component to load any data they need to load
            </summary>
    </member>
    <member name="F:Sandbox.CommonCallback.Awake">
      <summary>
            The component is awake. Called only once, on first enable.
            </summary>
    </member>
    <member name="F:Sandbox.CommonCallback.Enable">
      <summary>
            Component has been enabled
            </summary>
    </member>
    <member name="F:Sandbox.CommonCallback.Dirty">
      <summary>
            The component has become dirty, usually due to a property changing
            </summary>
    </member>
    <member name="F:Sandbox.CommonCallback.Disable">
      <summary>
            Component has been disabled
            </summary>
    </member>
    <member name="F:Sandbox.CommonCallback.Destroy">
      <summary>
            Component has been destroyed
            </summary>
    </member>
    <member name="F:Sandbox.CommonCallback.Term">
      <summary>
            GameObject actually deleted
            </summary>
    </member>
    <member name="T:Sandbox.FindMode">
      <summary>
            Flags to search for Components.
            I've named this something generic because I think we can re-use it to search for GameObjects too.
            </summary>
    </member>
    <member name="F:Sandbox.FindMode.Enabled">
      <summary>
            Components that are enabled
            </summary>
    </member>
    <member name="F:Sandbox.FindMode.Disabled">
      <summary>
            Components that are disabled
            </summary>
    </member>
    <member name="F:Sandbox.FindMode.InSelf">
      <summary>
            Components in this object
            </summary>
    </member>
    <member name="F:Sandbox.FindMode.InParent">
      <summary>
            Components in our parent
            </summary>
    </member>
    <member name="F:Sandbox.FindMode.InAncestors">
      <summary>
            Components in all ancestors (parent, their parent, their parent, etc)
            </summary>
    </member>
    <member name="F:Sandbox.FindMode.InChildren">
      <summary>
            Components in our children
            </summary>
    </member>
    <member name="F:Sandbox.FindMode.InDescendants">
      <summary>
            Components in all decendants (our children, their children, their children etc)
            </summary>
    </member>
    <member name="F:Sandbox.ComponentList._list">
      <summary>
            This is the hard list of components.
            This isn't a HashSet because we need the order to stay.
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.GetAll">
      <summary>
            Get all components, including disabled ones
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.OnHotload">
      <summary>
            Hotload has occurred
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.Create(Sandbox.TypeDescription,System.Boolean)">
      <summary>
            Add a component of this type
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.Create``1(System.Boolean)">
      <summary>
            Add a component of this type
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.Create(System.Type,System.Boolean)">
      <summary>
            Add a component of this type
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.Get``1(Sandbox.FindMode)">
      <summary>
            Get a component of this type
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.Get(System.Type,Sandbox.FindMode)">
      <summary>
            Get a component of this type
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.GetAll(System.Type,Sandbox.FindMode)">
      <summary>
            Get all components of this type
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.GetAll(Sandbox.FindMode)">
      <summary>
            Get all components
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.GetAll``1(Sandbox.FindMode)">
      <summary>
            Get a list of components on this game object, optionally recurse when deep is true
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.TryGet``1(``0@,Sandbox.FindMode)">
      <summary>
            Try to get this component
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.FirstOrDefault(System.Func{Sandbox.Component,System.Boolean})">
      <summary>
            Allows linq style queries
            </summary>
    </member>
    <member name="P:Sandbox.ComponentList.Count">
      <summary>
            Amount of components - including disabled
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.Move(Sandbox.Component,System.Int32)">
      <summary>
            Move the position of the component in the list by delta (-1 means up one, 1 means down one)
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.Get``1(System.Boolean)">
      <summary>
            Find component on this gameobject
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.GetOrCreate``1(Sandbox.FindMode)">
      <summary>
            Find this component, if it doesn't exist - create it.
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.GetInAncestorsOrSelf``1(System.Boolean)">
      <summary>
            Find component on this gameobject's ancestors or on self
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.GetInAncestors``1(System.Boolean)">
      <summary>
            Find component on this gameobject's ancestors
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.GetInDescendantsOrSelf``1(System.Boolean)">
      <summary>
            Find component on this gameobject's decendants or on self
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.GetInDescendants``1(System.Boolean)">
      <summary>
            Find component on this gameobject's decendants
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.GetInChildrenOrSelf``1(System.Boolean)">
      <summary>
            Find component on this gameobject's immediate children or on self
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.GetInChildren``1(System.Boolean)">
      <summary>
            Find component on this gameobject's immediate children
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.GetInParentOrSelf``1(System.Boolean)">
      <summary>
            Find component on this gameobject's parent or on self
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.GetInParent``1(System.Boolean)">
      <summary>
            Find component on this gameobject's parent
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.Get(System.Guid)">
      <summary>
            Find component on this gameobject with the specified id
            </summary>
    </member>
    <member name="M:Sandbox.ComponentList.AddMissing(Sandbox.MissingComponent)">
      <summary>
            Adds a special component that will keep information about a missing component.
            This component just holds the raw json of this component.
            </summary>
    </member>
    <member name="T:Sandbox.IComponentLister">
      <summary>
            Interface for types that reference a <see cref="T:Sandbox.ComponentList" />, to provide
            convenience method for accessing that list.
            </summary>
    </member>
    <member name="T:Sandbox.GameObject">
      <summary>
            An object in the scene. Functionality is added using Components. A GameObject has a transform, which explains its position,
            rotation and scale, relative to its parent. It also has a name, and can be enabled or disabled. When disabled, the GameObject
            is still in the scene, but the components don't tick and are all disabled.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Clone(Sandbox.CloneConfig@)">
      <summary>
            Create a unique copy of the passed in GameObject
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.PostClone(System.Collections.Generic.Dictionary{System.Object,System.Object},System.Collections.Generic.Dictionary{System.Guid,System.Guid})">
      <summary>
            Runs after this clone has been created by a cloned GameObject.
            </summary>
      <param name="originalToClonedObject">A mapping of original objects to their clones, used for all reference types.</param>
      <param name="originalIdToCloneId">A mapping of original GUIDs to cloned GUIDs, used for GameObject and Component references in JSON.</param>
    </member>
    <member name="M:Sandbox.GameObject.Clone(System.String,System.Nullable{Sandbox.CloneConfig})">
      <summary>
            Clone a prefab from path
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Clone(System.String,Transform,Sandbox.GameObject,System.Boolean,System.String)">
      <summary>
            Clone a prefab from path
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Clone(Sandbox.PrefabFile,System.Nullable{Sandbox.CloneConfig})">
      <summary>
            Clone a prefab from path
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Clone(Sandbox.PrefabFile,Transform,Sandbox.GameObject,System.Boolean,System.String)">
      <summary>
            Clone a prefab from path
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Clone(Transform,Sandbox.GameObject,System.Boolean,System.String)">
      <summary>
            Create a unique copy of the GameObject
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Clone">
      <summary>
            Create a unique copy of the GameObject
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Clone(Vector3)">
      <summary>
            Create a unique copy of the GameObject
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Clone(Vector3,Rotation)">
      <summary>
            Create a unique copy of the GameObject
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Clone(Vector3,Rotation,Vector3)">
      <summary>
            Create a unique copy of the GameObject
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Clone(Sandbox.GameObject,Vector3,Rotation,Vector3)">
      <summary>
            Create a unique copy of the GameObject
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.Scene">
      <summary>
            The scene that this GameObject is in.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.Transform">
      <summary>
            Our position relative to our parent, or the scene if we don't have any parent.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.Name">
      <summary>
            The GameObject's name is usually used for debugging, and for finding it in the scene.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.IsRoot">
      <summary>
            Returns true of this is a root object. Root objects are parented to the scene.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.Root">
      <summary>
            Return the root GameObject. The root is the object that is parented to the scene - which could very much be this object.
            </summary>
    </member>
    <member name="F:Sandbox.GameObject.enabledTokenSource">
      <summary>
            This token source is expired when leaving the game session, or when the GameObject is disabled/destroyed.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.EnabledToken">
      <summary>
            This token is cancelled when the GameObject ceases to exist, or is disabled
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.Components">
      <summary>
            Access components on this GameObject
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.Enabled">
      <summary>
            Is this gameobject enabled?
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.CreateTaskSource">
      <summary>
            Creates a new task source. Any Waits etc created by Task will be cancelled
            when the GameObject is disabled, or destroyed, or the game is exited.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.CancelTaskSource">
      <summary>
            Cancel this task source
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.Active">
      <summary>
            Is this gameobject active. For it to be active, it needs to be enabled, all of its ancestors
            need to be enabled, and it needs to be in a scene.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.ForEachChildFast``1(System.String,System.Boolean,,``0@)">
      <summary>
            Like the above, but faster, no allocations
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.UpdateEnabledStatus">
      <summary>
            Should be called whenever we change anything that we suspect might
            cause the active status to change on us, or our components. Don't call
            this directly. Only call it via SceneUtility.ActivateGameObject( this );
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.IsDescendant(Sandbox.GameObject)">
      <summary>
            Returns true if the passed in object is a decendant of ours
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.IsAncestor(Sandbox.GameObject)">
      <summary>
            Returns true if the passed in object is an ancestor
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.GetBounds">
      <summary>
            This is slow, and somewhat innacurate. Don't call it every frame!
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.GetLocalBounds">
      <summary>
            This is slow, and somewhat innacurate. Don't call it every frame!
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.GetNextSibling(System.Boolean)">
      <summary>
            Get the GameObject after us,
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.OnHotload">
      <summary>
            Internal stuff only
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.DebugOverlay">
      <summary>
            Allows drawing of temporary debug shapes and text in the scene
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.IsValid">
      <summary>
            True if the GameObject is not destroyed
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Term">
      <summary>
            Actually destroy the object and its children. Turn off and destroy components.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.TermSilent">
      <summary>
            Destroy the object and its children and destroy any components without
            invoking any callbacks.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.TermFinal">
      <summary>
            The last thing ever called.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Destroy">
      <summary>
            Destroy this object. Will actually be destroyed at the start of the next frame.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.IsDestroyed">
      <summary>
            Return true if this object is destroyed. This will also return true if the object is marked to be destroyed soon.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.DestroyImmediate">
      <summary>
            Destroy this object immediately. Calling this might cause some problems if functions
            are expecting the object to still exist, so it's not always a good idea.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.RemoveChild(Sandbox.GameObject)">
      <summary>
            Remove all children
            </summary>
      <param name="child" />
    </member>
    <member name="M:Sandbox.GameObject.Clear">
      <summary>
            Destroy all components and child objects
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.ShouldSurviveSceneTransition">
      <summary>
            True if this GameObject should survive a scene load
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Clear(System.Boolean)">
      <summary>
            Destroy all components and child objects
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.HasFlagOrParent(Sandbox.GameObjectFlags)">
      <summary>
            Do we or our ancestor have this flag
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.AddComponent``1(System.Boolean)">
      <summary>
            Add a component to this GameObject
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.GetOrAddComponent``1(System.Boolean)">
      <summary>
            Add a component to this GameObject
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.GetComponent``1(System.Boolean)">
      <summary>
            Get a component on this GameObject
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.GetComponents``1(System.Boolean)">
      <summary>
            Get components on this GameObject
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.GetComponentsInChildren``1(System.Boolean,System.Boolean)">
      <summary>
            Get components on this GameObject and on descendant GameObjects
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.GetComponentInChildren``1(System.Boolean,System.Boolean)">
      <summary>
            Get component on this GameObject or on descendant GameObjects
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.GetComponentsInParent``1(System.Boolean,System.Boolean)">
      <summary>
            Get components on this GameObject and on ancestor GameObjects
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.GetComponentInParent``1(System.Boolean,System.Boolean)">
      <summary>
            Get component on this GameObject and on ancestor GameObjects
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.ForceChangeId(System.Guid)">
      <summary>
            Should only be called by <see cref="M:Sandbox.GameObjectDirectory.Add(Sandbox.GameObject)" />.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.LocalTransform">
      <summary>
            The local transform of the game object.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.LocalPosition">
      <summary>
            The local position of the game object.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.LocalRotation">
      <summary>
            The local rotation of the game object.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.LocalScale">
      <summary>
            The local scale of the game object.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.IsProxy">
      <summary>
            True if this is a networked object and is owned by another client. This means that we're
            not controlling this object, so shouldn't try to move it or anything.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.IsNetworkRoot">
      <summary>
            If true then this object is the root of a networked object.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.Networked">
      <summary>
            OBSOLETE: Use NetworkMode instead.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.NetworkMode">
      <summary>
            How should this object be networked to other clients? By default, a <see cref="T:Sandbox.GameObject" /> will be
            networked as part of the <see cref="P:Sandbox.GameObject.Scene" /> snapshot.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.OwnerTransfer">
      <summary>
            If this object is networked, who can control ownership of it? This property will only
            be synchronized for a root network object.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.NetworkOrphaned">
      <summary>
            Determines what happens when the owner disconnects. This property will only
            be synchronized for a root network object.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.NetworkInterpolation">
      <summary>
            Whether or not our networked transform will be interpolated. This property will only
            be synchronized for a root network object.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.NetworkSpawn">
      <summary>
            Spawn on the network. If you have permission to spawn entities, this will spawn on
            everyone else's clients and you will be the owner.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.NetworkSpawn(System.Boolean,Sandbox.Connection)">
      <summary>
            Spawn on the network. If you have permission to spawn entities, this will spawn on
            everyone else's clients, and you will be the owner.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.NetworkSpawn(Sandbox.Connection)">
      <summary>
            Spawn on the network. If you have permission to spawn entities, this will spawn on
            everyone else's clients and the owner will be the connection provided.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.NetworkSpawnRemote(Sandbox.ObjectCreateMsg)">
      <summary>
            Initialize this object from the network
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Msg_RequestDropOwnership">
      <summary>
            Make a request from the host to stop being the network owner of this game object.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Msg_DropOwnership">
      <summary>
            Stop being the network owner of this game object, or clear ownership if you're the host.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Msg_RequestTakeOwnership">
      <summary>
            Make a request from the host to become the network owner of this game object.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Msg_TakeOwnership">
      <summary>
            Become the network owner of this game object.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Msg_RequestAssignOwnership(System.Guid)">
      <summary>
            Make a request from the host to assign ownership of this game object to the specified connection <see cref="T:System.Guid" />.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.Msg_AssignOwnership(System.Guid)">
      <summary>
            Assign ownership of this game object to the specified connection <see cref="T:System.Guid" />.
            </summary>
      <param name="guid" />
    </member>
    <member name="P:Sandbox.GameObject.NetworkRoot">
      <summary>
            The network root is the first networked GameObject above this.
            This gets set from the parent's NetworkSpawn and invalidated when the parent changes.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.NetworkRefresh(System.Text.Json.Nodes.JsonObject)">
      <summary>
            Update hierarchy from a network refresh.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.NetworkPrune(System.Collections.Generic.Dictionary{System.Guid,System.Text.Json.Nodes.JsonNode})">
      <summary>
            Prune children based on valid ids from a network refresh.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.NetworkSpawnRecursive(Sandbox.Connection)">
      <summary>
            Loop all of our children, and any with networking enabled, we should spawn them
            with the same creator + owner as this.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.Network">
      <summary>
            Access network information for this GameObject.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.NetworkAccessor.Active">
      <summary>
            Is this object networked
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.NetworkAccessor.IsOwner">
      <summary>
            Are we the owner of this network object
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.NetworkAccessor.OwnerId">
      <summary>
            The Id of the owner of this object
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.NetworkAccessor.IsCreator">
      <summary>
            Are we the creator of this network object
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.NetworkAccessor.CreatorId">
      <summary>
            The Id of the create of this object
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.NetworkAccessor.IsProxy">
      <summary>
            Is this object a network proxy. A network proxy is a network object that is not being simulated on the local pc.
            This means it's either owned by no-one and is being simulated by the host, or owned by another client.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.NetworkAccessor.OwnerConnection">
      <summary>
            Try to get the connection that owns this object. This can and will return null
            if we don't have information for this connection.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.NetworkAccessor.Owner">
      <summary>
            Try to get the connection that owns this object. This can and will return null
            if we don't have information for this connection.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.NetworkAccessor.OwnerTransfer">
      <summary>
            Who can control ownership of this networked object?
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.NetworkAccessor.NetworkOrphaned">
      <summary>
            Determines what happens when the owner disconnects.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.NetworkAccessor.Interpolation">
      <summary>
            Whether the networked object's transform is interpolated.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.NetworkAccessor.EnableInterpolation">
      <summary>
            Enable interpolation for the networked object's transform.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.NetworkAccessor.DisableInterpolation">
      <summary>
            Disable interpolation for the networked object's transform.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.NetworkAccessor.ClearInterpolation">
      <summary>
        <inheritdoc cref="M:Sandbox.GameTransform.ClearInterpolation" />
      </summary>
    </member>
    <member name="M:Sandbox.GameObject.NetworkAccessor.SetOrphanedMode(Sandbox.NetworkOrphaned)">
      <summary>
            Set what happens to this networked object when the owner disconnects.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.NetworkAccessor.SetOwnerTransfer(Sandbox.OwnerTransfer)">
      <summary>
            Set who can control ownership of this networked object. Only the current owner can change this.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.NetworkAccessor.Refresh">
      <summary>
            Send a complete refresh snapshot of this networked object to other clients. This is useful if you have
            made vast changes to components or children.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.NetworkAccessor.TakeOwnership">
      <summary>
            Become the network owner of this object.
            <br /><br />
            Note: whether or not you can take ownership of this object depends on the
            <see cref="P:Sandbox.GameObject.NetworkAccessor.OwnerTransfer" /> of this networked object.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.NetworkAccessor.AssignOwnership(Sandbox.Connection)">
      <summary>
            Set the owner of this object to the specified <see cref="T:Sandbox.Connection" />.
            <br /><br />
            Note: whether or not you can assign ownership of this object depends on the
            <see cref="P:Sandbox.GameObject.NetworkAccessor.OwnerTransfer" /> of this networked object.
            </summary>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="channel" /> cannot be null. To clear owner, use <see cref="M:Sandbox.GameObject.NetworkAccessor.DropOwnership" /> instead.</exception>
    </member>
    <member name="M:Sandbox.GameObject.NetworkAccessor.AssignOwnership(System.Guid)">
      <summary>
            Assign ownership to the specific connection id. This should only be used internally
            when we want to force an ownership change, such as for a <see cref="P:Sandbox.GameObject.NetworkAccessor.NetworkOrphaned" /> action.
            </summary>
      <param name="connectionId" />
      <returns />
    </member>
    <member name="M:Sandbox.GameObject.NetworkAccessor.DropOwnership">
      <summary>
            Stop being the owner of this object. Will clear the owner so the object becomes
            controlled by the server, and owned by no-one.
            <br /><br />
            Note: whether or not you can drop ownership of this object depends on the
            <see cref="P:Sandbox.GameObject.NetworkAccessor.OwnerTransfer" /> of this networked object.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.NetworkAccessor.Spawn">
      <summary>
        <inheritdoc cref="M:Sandbox.GameObject.NetworkSpawn" />
      </summary>
    </member>
    <member name="M:Sandbox.GameObject.NetworkAccessor.Spawn(Sandbox.Connection)">
      <summary>
        <inheritdoc cref="M:Sandbox.GameObject.NetworkSpawn(Sandbox.Connection)" />
      </summary>
    </member>
    <member name="P:Sandbox.GameObject.PrefabSource">
      <summary>
            The filename of the prefab this object is defined in.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.MapSource">
      <summary>
            The filename of the map this object is defined in.
            </summary>
    </member>
    <member name="F:Sandbox.GameObject._guidToInstance">
      <summary>
            Translate from prefab guid to this object's guid
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.BreakFromPrefab">
      <summary>
            We are cloned from a prefab. Stop that.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.InitPrefabTable(System.Collections.Generic.Dictionary{System.Guid,System.Guid})">
      <summary>
            Create a two way lookup allowing from prefab to instance, instance to prefab
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.PrefabToInstance(System.Guid@)">
      <summary>
            Translate a Prefab guid to the instanced version
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.InstanceToPrefab(System.Guid@)">
      <summary>
            Translate an instanced Prefab guid to the original prefab version
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.FindPrefabObject(System.Guid)">
      <summary>
            Given a prefab object guid, return the instance object on this current object. This
            could be a GameObject or a Component.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.ToPrefabFile(Sandbox.PrefabFile)">
      <summary>
            Save the contents of this object to the PrefabFile.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.GetPrefab(System.String)">
      <summary>
            Get the GameObject of a prefab from file path
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.SerializeOptions.SceneForNetwork">
      <summary>
            If we're serializing for network, we won't include any networked objects
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.SerializeOptions.Cloning">
      <summary>
            We're cloning this object
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.SerializeOptions.SingleNetworkObject">
      <summary>
            We're going to send a single network object
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.SerializeOptions.UpdatingFromPrefab">
      <summary>
            We're updating from a changed prefab
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.SerializeOptions.IsEditor">
      <summary>
            We're getting the serialization data for the editor, like for undo or something.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.SerializeOptions.IgnoreChildren">
      <summary>
            Don't serialize gameObject children.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.SerializeOptions.IgnoreComponents">
      <summary>
            Don't serialize gameObject components.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.DeserializeOptions.IsEditor">
      <summary>
            We're getting the serialization data for the editor, like for undo or something.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.GetFlattenedHierarchy(System.Text.Json.Nodes.JsonNode,System.Collections.Generic.Dictionary{System.Guid,System.Text.Json.Nodes.JsonNode})">
      <summary>
            Get a flattened hierarchy of all <see cref="T:Sandbox.GameObject" /> nodes from the providied JSON node as a dictionary
            with the key being the <see cref="P:Sandbox.GameObject.Id" />.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.PushDeserializeContext">
      <summary>
            Push ActionGraph source location and cache if we're a prefab instance or map object.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.PlaySound(Sandbox.SoundEvent,Vector3)">
      <summary>
            Play this sound on this GameObject. The sound will follow the position of the GameObject.
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.StopAllSounds(System.Single)">
      <summary>
            Stop any sounds playing on this GameObject
            </summary>
    </member>
    <member name="M:Sandbox.GameObject.OnTagsUpdatedInternal">
      <summary>
            Called by GameTags when the tags change
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.WorldTransform">
      <summary>
            The world transform of the game object.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.WorldPosition">
      <summary>
            The world position of the game object.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.WorldRotation">
      <summary>
            The world rotation of the game object.
            </summary>
    </member>
    <member name="P:Sandbox.GameObject.WorldScale">
      <summary>
            The world scale of the game object.
            </summary>
    </member>
    <member name="T:Sandbox.CloneConfig">
      <summary>
            The low level input of a GameObject.Clone
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectFlags.Hidden">
      <summary>
            Hide this object in heirachy/inspector
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectFlags.NotSaved">
      <summary>
            Don't save this object to disk, or when duplicating
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectFlags.Bone">
      <summary>
            Auto created - it's a bone, driven by animation
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectFlags.Attachment">
      <summary>
            Auto created - it's an attachment
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectFlags.Error">
      <summary>
            There's something wrong with this
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectFlags.Loading">
      <summary>
            Loading something
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectFlags.Deserializing">
      <summary>
            Is in the process of deserializing
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectFlags.DontDestroyOnLoad">
      <summary>
            When loading a new scene, keep this gameobject active
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectFlags.NotNetworked">
      <summary>
            Keep local - don't network this object as part of the scene snapshot
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectFlags.Refreshing">
      <summary>
            In the process of refreshing from the network
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectFlags.ProceduralBone">
      <summary>
            Stops animation stomping the bone, will use the bone's local position
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectFlags.EditorOnly">
      <summary>
            Only exists in the editor. Don't spawn it in game.
            </summary>
    </member>
    <member name="F:Sandbox.GameObjectFlags.Absolute">
      <summary>
            Ignore the parent transform. Basically, position: absolute for gameobjects.
            </summary>
    </member>
    <member name="T:Sandbox.GameObjectReference">
      <summary>
            A serialized reference to a <see cref="T:Sandbox.GameObject" /> that can be resolved at runtime.
            Can either have a <see cref="P:Sandbox.GameObjectReference.GameObjectId" /> for objects in a scene, or a <see cref="P:Sandbox.GameObjectReference.PrefabPath" />
            if we're referencing a prefab.
            </summary>
    </member>
    <member name="M:Sandbox.GameObjectReference.FromId(System.Guid)">
      <summary>
            Reference a <see cref="T:Sandbox.GameObject" /> in a scene by its <see cref="P:Sandbox.GameObject.Id" />.
            </summary>
    </member>
    <member name="M:Sandbox.GameObjectReference.FromPrefabPath(System.String)">
      <summary>
            Reference a prefab by its <see cref="P:Sandbox.Resource.ResourcePath" />.
            </summary>
    </member>
    <member name="M:Sandbox.GameObjectReference.FromInstance(Sandbox.GameObject)">
      <summary>
            Reference a given <see cref="T:Sandbox.GameObject" />.
            </summary>
    </member>
    <member name="P:Sandbox.GameObjectReference.ReferenceType">
      <summary>
            Expected to be <c>"gameobject"</c> for a game object reference.
            </summary>
    </member>
    <member name="P:Sandbox.GameObjectReference.GameObjectId">
      <summary>
            If we're referencing an object in a scene, this is its <see cref="P:Sandbox.GameObject.Id" />.
            </summary>
    </member>
    <member name="P:Sandbox.GameObjectReference.PrefabPath">
      <summary>
            If we're referencing a prefab, this is its <see cref="P:Sandbox.Resource.ResourcePath" />.
            </summary>
    </member>
    <member name="M:Sandbox.GameObjectReference.Resolve">
      <summary>
            Attempt to resolve this reference in the current <see cref="P:Sandbox.Game.ActiveScene" />. Returns <see langword="null" /> if
            the reference couldn't be resolved, and logs a warning.
            </summary>
    </member>
    <member name="M:Sandbox.GameObjectReference.Resolve(Sandbox.Scene,System.Boolean)">
      <summary>
            Attempt to resolve this reference in the given <paramref name="scene" />. Returns <see langword="null" /> if
            the reference couldn't be resolved.
            </summary>
      <param name="scene">Scene to attempt to resolve the reference in.</param>
      <param name="warn">If true, log a warning to the console if the reference couldn't be resolved.</param>
    </member>
    <member name="T:Sandbox.GameTags">
      <summary>
            Entity Tags are strings you can set and check for on any entity. Internally
            these strings are tokenized and networked so they're also available clientside.
            </summary>
    </member>
    <member name="M:Sandbox.GameTags.TryGetAll">
      <summary>
            Returns all the tags this object has.
            </summary>
    </member>
    <member name="M:Sandbox.GameTags.TryGetAll(System.Boolean)">
      <summary>
            Returns all the tags this object has.
            </summary>
    </member>
    <member name="M:Sandbox.GameTags.Has(System.String)">
      <summary>
            Returns true if this object (or its parents) has given tag.
            </summary>
    </member>
    <member name="M:Sandbox.GameTags.Has(System.String,System.Boolean)">
      <summary>
            Returns true if this object has given tag.
            </summary>
    </member>
    <member name="M:Sandbox.GameTags.HasAny(System.Collections.Generic.HashSet{System.String})">
      <summary>
            Returns true if this object has one or more tags from given tag list.
            </summary>
    </member>
    <member name="M:Sandbox.GameTags.Add(System.String)">
      <summary>
            Try to add the tag to this object.
            </summary>
    </member>
    <member name="M:Sandbox.GameTags.Add(System.String[])">
      <summary>
            Adds multiple tags. Calls <see cref="M:Sandbox.GameTags.Add(System.String)">EntityTags.Add</see> for each tag.
            </summary>
    </member>
    <member name="M:Sandbox.GameTags.Remove(System.String)">
      <summary>
            Try to remove the tag from this entity.
            </summary>
    </member>
    <member name="M:Sandbox.GameTags.RemoveAll">
      <summary>
            Remove all tags
            </summary>
    </member>
    <member name="M:Sandbox.GameTags.GetTokens">
      <summary>
            Returns a list of ints, representing the tags. These are used internally by the engine.
            </summary>
    </member>
    <member name="P:Sandbox.GameTransform.FixedUpdateInterpolation">
      <summary>
            Automatically interpolate the transform over multiple frames when changed within the context
            of a fixed update. This results in a smoother appearance for a moving <see cref="P:Sandbox.GameTransform.GameObject" />.
            </summary>
    </member>
    <member name="P:Sandbox.GameTransform.InterpolatedLocal">
      <summary>
            The current interpolated local transform.
            </summary>
    </member>
    <member name="P:Sandbox.GameTransform.Local">
      <summary>
            The current local transform.
            </summary>
    </member>
    <member name="P:Sandbox.GameTransform.TargetLocal">
      <summary>
            The desired local transform. If we are interpolating we'll use the last value in the interpolation buffer.
            This is useful for networking because we always want to send the "real" transform.
            </summary>
    </member>
    <member name="M:Sandbox.GameTransform.TransformChanged(System.Boolean)">
      <summary>
            Our transform has changed, which means our children transforms changed too
            tell them all.
            </summary>
    </member>
    <member name="M:Sandbox.GameTransform.HasAuthority">
      <summary>
            Do we have permission to change this transform?
            </summary>
    </member>
    <member name="M:Sandbox.GameTransform.SetLocalTransformFast(Transform@)">
      <summary>
            Sets the local transform without firing a bunch of "transform changed" callbacks.
            The assumption is that you're changing a bunch of child transforms, and will then call
            transform changed on the root, which will then invoke all the callbacks just once.
            This is what the animation system does!
            </summary>
    </member>
    <member name="P:Sandbox.GameTransform.InterpolatedWorld">
      <summary>
            The interpolated world transform. For internal use only.
            </summary>
    </member>
    <member name="P:Sandbox.GameTransform.TargetWorld">
      <summary>
            The target world transform. For internal use only.
            </summary>
    </member>
    <member name="P:Sandbox.GameTransform.World">
      <summary>
            The current world transform.
            </summary>
    </member>
    <member name="P:Sandbox.GameTransform.Position">
      <summary>
            The position in world coordinates.
            </summary>
    </member>
    <member name="P:Sandbox.GameTransform.Rotation">
      <summary>
            The rotation in world coordinates.
            </summary>
    </member>
    <member name="P:Sandbox.GameTransform.Scale">
      <summary>
            The scale in world coordinates.
            </summary>
    </member>
    <member name="P:Sandbox.GameTransform.LocalPosition">
      <summary>
            Position in local coordinates.
            </summary>
    </member>
    <member name="P:Sandbox.GameTransform.LocalRotation">
      <summary>
            Rotation in local coordinates.
            </summary>
    </member>
    <member name="P:Sandbox.GameTransform.LocalScale">
      <summary>
            Scale in local coordinates.
            </summary>
    </member>
    <member name="M:Sandbox.GameTransform.LerpTo(Transform@,System.Single)">
      <summary>
            Performs linear interpolation between this and the given transform.
            </summary>
      <param name="target">The destination transform.</param>
      <param name="frac">Fraction, where 0 would return this, 0.5 would return a point between this and given transform, and 1 would return the given transform.</param>
    </member>
    <member name="M:Sandbox.GameTransform.ClearInterpolation">
      <summary>
            Clear any interpolation and force us to reach our final destination immediately. If we own this object
            we'll tell other clients to clear interpolation too when they receive the next network update from us.
            </summary>
    </member>
    <member name="M:Sandbox.GameTransform.ClearLocalInterpolation">
      <summary>
            Like <see cref="M:Sandbox.GameTransform.ClearInterpolation" /> but will not clear interpolation across the network.
            </summary>
    </member>
    <member name="M:Sandbox.GameTransform.DisableProxy">
      <summary>
            Disable the proxy temporarily
            </summary>
    </member>
    <member name="M:Sandbox.GameTransform.DisableInterpolation">
      <summary>
            Temporarily disable Fixed Update Interpolation.
            </summary>
      <returns />
    </member>
    <member name="T:Sandbox.TransformProxyComponent">
      <summary>
            Help to implement a component that completely overrides the transform. This is useful for scenarios
            where you will want to keep the local transform of a GameObject, but want to offset based on that 
            for some reason.
            Having multiple of these on one GameObject is not supported, and will result in weirdness.
            </summary>
    </member>
    <member name="M:Sandbox.TransformProxyComponent.GetLocalTransform">
      <summary>
            Override to provide the local transform
            </summary>
    </member>
    <member name="M:Sandbox.TransformProxyComponent.SetLocalTransform(Transform@)">
      <summary>
            Called when the local transform is being set
            </summary>
    </member>
    <member name="M:Sandbox.TransformProxyComponent.GetWorldTransform">
      <summary>
            Override to provide the world transform. The default implementation will calculate it using GetLocalTransform() based on the parent.
            </summary>
    </member>
    <member name="M:Sandbox.TransformProxyComponent.SetWorldTransform(Transform)">
      <summary>
            Called when the world transform is being set
            </summary>
    </member>
    <member name="M:Sandbox.TransformProxyComponent.MarkTransformChanged">
      <summary>
            Tell our other components, and our children that our transform has changed. This will
            update things like Renderers to update their render positions.
            </summary>
    </member>
    <member name="T:Sandbox.INetworkCustom">
      <summary>
            An interface for specifying how a custom type can be serialized and deserialized
            over the network with support for only sending changes.
            </summary>
    </member>
    <member name="T:Sandbox.INetworkReliable">
      <summary>
            Indicates that this type must be sent reliably and cannot be sent as part of a
            delta snapshot.
            </summary>
    </member>
    <member name="T:Sandbox.NetDictionary`2">
      <summary>
            A networkable dictionary for use with the <see cref="T:Sandbox.SyncAttribute" /> and <see cref="T:Sandbox.HostSyncAttribute" />. Only changes will be
            networked instead of sending the whole dictionary every time, so it's more efficient.
            <br /><para><b>Example usage:</b><code>
            public class MyComponent : Component
            {
            	[Sync] public NetDictionary&lt;string,bool&gt; MyBoolTable { get; set; } = new();
            	<br />
            	public void SetBoolState( string key, bool state )
            	{
            		if ( IsProxy ) return;
            		MyBoolTable[key] = state;
            	}
            }
            </code></para></summary>
    </member>
    <member name="T:Sandbox.NetDictionary`2.Change">
      <summary>
            Represents a change in the dictionary.
            </summary>
    </member>
    <member name="P:Sandbox.NetDictionary`2.Values">
      <summary>
        <inheritdoc cref="P:System.Collections.ObjectModel.ObservableDictionary`2.Values" />
      </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary>
        <inheritdoc cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
      <summary>
        <inheritdoc cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
      <summary>
        <inheritdoc cref="M:System.Collections.IDictionary.Contains(System.Object)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
      <summary>
        <inheritdoc cref="M:System.Collections.IDictionary.Remove(System.Object)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.Add(`0,`1)">
      <summary>
        <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.Add(`0,`1)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
        <inheritdoc cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.Clear">
      <summary>
        <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.Clear" />
      </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.ContainsKey(`0)">
      <summary>
        <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.ContainsKey(`0)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
        <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
      </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
      <summary>
        <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
      </summary>
    </member>
    <member name="P:Sandbox.NetDictionary`2.Keys">
      <summary>
        <inheritdoc cref="P:System.Collections.ObjectModel.ObservableDictionary`2.Keys" />
      </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.Remove(`0)">
      <summary>
        <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.Remove(`0)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.TryGetValue(`0,`1@)">
      <summary>
        <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.TryGetValue(`0,`1@)" />
      </summary>
    </member>
    <member name="P:Sandbox.NetDictionary`2.Count">
      <summary>
        <inheritdoc cref="P:System.Collections.ObjectModel.ObservableDictionary`2.Count" />
      </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.System#Collections#IDictionary#GetEnumerator">
      <summary>
        <inheritdoc cref="M:System.Collections.IDictionary.GetEnumerator" />
      </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.GetEnumerator">
      <summary>
        <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.GetEnumerator" />
      </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.System#Collections#IEnumerable#GetEnumerator">
      <summary>
        <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.GetEnumerator" />
      </summary>
    </member>
    <member name="P:Sandbox.NetDictionary`2.Sandbox#INetworkCustom#ControlCondition">
      <summary>
            Whether we have control (write permission) over this dictionary.
            </summary>
    </member>
    <member name="P:Sandbox.NetDictionary`2.Sandbox#INetworkCustom#HasChanges">
      <summary>
            Do we have any pending changes?
            </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.Sandbox#INetworkCustom#WriteChanged(Sandbox.ByteStream@)">
      <summary>
            Write any changed items to a <see cref="T:Sandbox.ByteStream" />.
            </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.Sandbox#INetworkCustom#Read(Sandbox.ByteStream@)">
      <summary>
            Read a network update from a <see cref="T:Sandbox.ByteStream" />.
            </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.Sandbox#INetworkCustom#WriteAll(Sandbox.ByteStream@)">
      <summary>
            Write all items to a <see cref="T:Sandbox.ByteStream" />.
            </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.ReadAll(Sandbox.ByteStream@)">
      <summary>
            Read all changes in the dictionary as if we're building it for the first time.
            </summary>
    </member>
    <member name="M:Sandbox.NetDictionary`2.ReadChanged(Sandbox.ByteStream@)">
      <summary>
            Read any changed items from a <see cref="T:Sandbox.ByteStream" />.
            </summary>
    </member>
    <member name="T:Sandbox.NetList`1">
      <summary>
            A networkable list for use with the <see cref="T:Sandbox.SyncAttribute" /> and <see cref="T:Sandbox.HostSyncAttribute" />. Only changes will be
            networked instead of sending the whole list every time, so it's more efficient.
            <br /><para><b>Example usage:</b><code>
            public class MyComponent : Component
            {
            	[Sync] public NetList&lt;int&gt; MyIntegerList { get; set; } = new();
            	<br />
            	public void AddNumber( int number )
            	{
            		if ( IsProxy ) return;
            		MyIntegerList.Add( number );
            	}
            }
            </code></para></summary>
    </member>
    <member name="T:Sandbox.NetList`1.Change">
      <summary>
            Represents a change in the list.
            </summary>
    </member>
    <member name="M:Sandbox.NetList`1.System#Collections#IList#Add(System.Object)">
      <summary>
        <inheritdoc cref="M:System.Collections.IList.Add(System.Object)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetList`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
      <summary>
        <inheritdoc cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetList`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <summary>
        <inheritdoc cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetList`1.System#Collections#IList#Contains(System.Object)">
      <summary>
        <inheritdoc cref="M:System.Collections.IList.Contains(System.Object)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetList`1.System#Collections#IList#IndexOf(System.Object)">
      <summary>
        <inheritdoc cref="M:System.Collections.IList.IndexOf(System.Object)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetList`1.System#Collections#IList#Insert(System.Int32,System.Object)">
      <summary>
        <inheritdoc cref="M:System.Collections.IList.Insert(System.Int32,System.Object)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetList`1.System#Collections#IList#Remove(System.Object)">
      <summary>
        <inheritdoc cref="M:System.Collections.IList.Remove(System.Object)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetList`1.Clear">
      <summary>
        <inheritdoc cref="M:System.Collections.Generic.List`1.Clear" />
      </summary>
    </member>
    <member name="M:Sandbox.NetList`1.Contains(`0)">
      <summary>
        <inheritdoc cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetList`1.CopyTo(`0[],System.Int32)">
      <summary>
        <inheritdoc cref="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetList`1.Add(`0)">
      <summary>
        <inheritdoc cref="M:System.Collections.Generic.List`1.Add(`0)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetList`1.Remove(`0)">
      <summary>
        <inheritdoc cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetList`1.IndexOf(`0)">
      <summary>
        <inheritdoc cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetList`1.Insert(System.Int32,`0)">
      <summary>
        <inheritdoc cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </summary>
    </member>
    <member name="M:Sandbox.NetList`1.RemoveAt(System.Int32)">
      <summary>
        <inheritdoc cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      </summary>
    </member>
    <member name="P:Sandbox.NetList`1.Count">
      <summary>
        <inheritdoc cref="P:System.Collections.Generic.List`1.Count" />
      </summary>
    </member>
    <member name="M:Sandbox.NetList`1.GetEnumerator">
      <summary>
        <inheritdoc cref="M:System.Collections.Generic.List`1.GetEnumerator" />
      </summary>
    </member>
    <member name="M:Sandbox.NetList`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>
        <inheritdoc cref="M:System.Collections.Generic.List`1.GetEnumerator" />
      </summary>
    </member>
    <member name="P:Sandbox.NetList`1.Sandbox#INetworkCustom#ControlCondition">
      <summary>
            Whether we have control (write permission) over this list.
            </summary>
    </member>
    <member name="P:Sandbox.NetList`1.Sandbox#INetworkCustom#HasChanges">
      <summary>
            Do we have any pending changes?
            </summary>
    </member>
    <member name="M:Sandbox.NetList`1.Sandbox#INetworkCustom#WriteChanged(Sandbox.ByteStream@)">
      <summary>
            Write any changed items to a <see cref="T:Sandbox.ByteStream" />.
            </summary>
    </member>
    <member name="M:Sandbox.NetList`1.Sandbox#INetworkCustom#Read(Sandbox.ByteStream@)">
      <summary>
            Read a network update from a <see cref="T:Sandbox.ByteStream" />.
            </summary>
    </member>
    <member name="M:Sandbox.NetList`1.Sandbox#INetworkCustom#WriteAll(Sandbox.ByteStream@)">
      <summary>
            Write all items to a <see cref="T:Sandbox.ByteStream" />.
            </summary>
    </member>
    <member name="M:Sandbox.NetList`1.ReadAll(Sandbox.ByteStream@)">
      <summary>
            Read all changes in the list as if we're building it for the first time.
            </summary>
      <param name="data" />
    </member>
    <member name="M:Sandbox.NetList`1.ReadChanged(Sandbox.ByteStream@)">
      <summary>
            Read any changed items from a <see cref="T:Sandbox.ByteStream" />.
            </summary>
    </member>
    <member name="M:Sandbox.DeltaSnapshot.AddSerialized(System.Int32,System.Byte[])">
      <summary>
            Add a serialized byte array value to the specified slot.
            </summary>
      <param name="slot" />
      <param name="value" />
    </member>
    <member name="M:Sandbox.DeltaSnapshot.Add``1(System.Int32,``0)">
      <summary>
            Add a value to the specified slot and serialize it to a byte array.
            </summary>
      <param name="slot" />
      <param name="value" />
      <typeparam name="T" />
    </member>
    <member name="M:Sandbox.DeltaSnapshot.TryGetValue``1(System.Int32,``0@)">
      <summary>
            Try to get a deserialized value from the specified slot.
            </summary>
      <param name="slot" />
      <param name="value" />
    </member>
    <member name="M:Sandbox.DeltaSnapshot.Clone(Sandbox.DeltaSnapshot)">
      <summary>
            Create a clone of a <see cref="T:Sandbox.DeltaSnapshot" />.
            </summary>
    </member>
    <member name="M:Sandbox.DeltaSnapshot.From(System.Collections.Generic.Dictionary{System.Int32,System.Byte[]})">
      <summary>
            Build a <see cref="T:Sandbox.DeltaSnapshot" /> from the specified dictionary of type and value.
            </summary>
    </member>
    <member name="F:Sandbox.DeltaSnapshotCluster.MaxSize">
      <summary>
            The maximum size (in bytes) of a single snapshot cluster. Since clusters are generally sent unreliably,
            the maximum size should really be under the typical MTU size of 1500 bytes.
            </summary>
    </member>
    <member name="M:Sandbox.DeltaSnapshotCluster.Add(Sandbox.DeltaSnapshot)">
      <summary>
            Add a <see cref="T:Sandbox.DeltaSnapshot" /> to the cluster. It will be ignored if the snapshot is empty.
            </summary>
      <param name="snapshot" />
    </member>
    <member name="M:Sandbox.DeltaSnapshotSystem.ConnectionData.RemoveNetworkObject(Sandbox.NetworkObject)">
      <summary>
            Clean up any data about a removed networked object.
            </summary>
      <param name="nwo" />
    </member>
    <member name="M:Sandbox.DeltaSnapshotSystem.ConnectionData.Tick">
      <summary>
            Tick the connection and clear any out-of-date data.
            </summary>
    </member>
    <member name="M:Sandbox.DeltaSnapshotSystem.RemoveConnection(Sandbox.Connection)">
      <summary>
            Remove a connection from the snapshot system.
            </summary>
      <param name="target" />
    </member>
    <member name="M:Sandbox.DeltaSnapshotSystem.Reset">
      <summary>
            Reset all connection data for the snapshot system. This might happen when a hotload
            occurs, or the host changes.
            </summary>
    </member>
    <member name="M:Sandbox.DeltaSnapshotSystem.ClearNetworkObject(Sandbox.NetworkObject)">
      <summary>
            Locally clear any stored snapshot information about a networked object.
            </summary>
      <param name="nwo" />
    </member>
    <member name="M:Sandbox.DeltaSnapshotSystem.CreateSnapshotId(System.Guid)">
      <summary>
            Create a new snapshot id for the provided <see cref="T:Sandbox.NetworkObject" />.
            </summary>
    </member>
    <member name="M:Sandbox.DeltaSnapshotSystem.Tick">
      <summary>
            Tick the snapshot system and clear any out-of-date data.
            </summary>
    </member>
    <member name="M:Sandbox.DeltaSnapshotSystem.Send(System.Collections.Generic.IEnumerable{Sandbox.IDeltaSnapshot},System.Collections.Generic.IEnumerable{Sandbox.Connection})">
      <summary>
            Send a delta snapshot for a set of networked objects to the specified connections.
            </summary>
      <param name="objects" />
      <param name="connections" />
    </member>
    <member name="M:Sandbox.DeltaSnapshotSystem.Send(Sandbox.IDeltaSnapshot,Sandbox.NetFlags,System.Boolean)">
      <summary>
            Send a delta snapshot for a single networked object.
            </summary>
    </member>
    <member name="M:Sandbox.DeltaSnapshotSystem.GetFullSnapshotData(Sandbox.DeltaSnapshot)">
      <summary>
            Get a full serialized data update for a snapshot.
            </summary>
    </member>
    <member name="P:Sandbox.IDeltaSnapshot.Id">
      <summary>
            Unique identifier for this object.
            </summary>
    </member>
    <member name="P:Sandbox.IDeltaSnapshot.IsProxy">
      <summary>
            Whether this object is a proxy (or we own it.)
            </summary>
    </member>
    <member name="M:Sandbox.IDeltaSnapshot.OnSnapshot(Sandbox.Connection,Sandbox.DeltaSnapshot)">
      <summary>
            Called when a snapshot is received by a <see cref="T:Sandbox.Connection" />.
            </summary>
      <param name="source" />
      <param name="snapshot" />
      <returns />
    </member>
    <member name="M:Sandbox.IDeltaSnapshot.WriteDeltaSnapshot(Sandbox.DeltaSnapshot)">
      <summary>
            Write delta snapshot data to the specified <see cref="T:Sandbox.DeltaSnapshot" />.
            </summary>
    </member>
    <member name="M:Sandbox.IDeltaSnapshot.SendNetworkUpdate">
      <summary>
            Try to send a network update or do nothing if no update is required. This is most
            likely called after WriteDeltaSnapshot.
            </summary>
    </member>
    <member name="T:Sandbox.SnapshotState">
      <summary>
            Represents the current snapshot state for an object based on delta snapshots received
            from another client.
            </summary>
    </member>
    <member name="F:Sandbox.SnapshotState.MaximumAckResponseTime">
      <summary>
            How many seconds we'll allow to pass for a snapshot acknowledgement packet
            to be received from a client.
            </summary>
    </member>
    <member name="M:Sandbox.SnapshotState.IsNewer(System.UInt16,System.UInt16)">
      <summary>
            Whether the incoming snapshot id is newer than our last processed one. This
            automatically handles wrapping of the ushort.
            </summary>
    </member>
    <member name="M:Sandbox.SnapshotState.AddPredicted(System.Int32,System.Byte[])">
      <summary>
            Add a predicted entry to the snapshot. 
            </summary>
      <param name="slot" />
      <param name="value" />
    </member>
    <member name="M:Sandbox.SnapshotState.Update(System.Int32,System.UInt16,System.Byte[])">
      <summary>
            Update the value in the stored snapshot.
            </summary>
    </member>
    <member name="M:Sandbox.SnapshotState.TryGetValue(System.Int32,System.Byte[]@)">
      <summary>
            Try to get them serialized byte array value from the specified slot.
            </summary>
    </member>
    <member name="M:Sandbox.SnapshotState.ToDeltaSnapshot(System.UInt16,System.Collections.Generic.IEnumerable{System.Int32})">
      <summary>
            Create a new delta snapshot using the values of this snapshot state but only with the slots
            from the provided <see cref="T:Sandbox.DeltaSnapshot" />.
            </summary>
    </member>
    <member name="M:Sandbox.SnapshotState.From(Sandbox.DeltaSnapshot)">
      <summary>
            Build a new <see cref="T:Sandbox.SnapshotState" /> from the specified <see cref="T:Sandbox.DeltaSnapshot" />.
            </summary>
    </member>
    <member name="T:Sandbox.HostSyncAttribute">
      <summary>
            Automatically synchronize a property of a networked object from the host to other clients.
            Obsolete: 11/12/2024
            </summary>
    </member>
    <member name="M:Sandbox.IInterpolatedSyncVar.Create``1(``0)">
      <summary>
            Create a new interpolator for the type of the provided value.
            </summary>
    </member>
    <member name="M:Sandbox.IInterpolatedSyncVar.Query(System.Single)">
      <summary>
            Query the interpolated value at the provided time.
            </summary>
    </member>
    <member name="T:Sandbox.InterpolatedSyncVar`1">
      <summary>
            Contains a target value and the current interpolated value for the
            property it represents.
            </summary>
    </member>
    <member name="M:Sandbox.InterpolatedSyncVar`1.Update(`0)">
      <summary>
            Update the value with the latest value from the network.
            </summary>
    </member>
    <member name="T:Sandbox.NetworkMode">
      <summary>
            Specifies how a <see cref="T:Sandbox.GameObject" /> should be networked.
            </summary>
    </member>
    <member name="F:Sandbox.NetworkMode.Never">
      <summary>
            Never network this <see cref="T:Sandbox.GameObject" />.
            </summary>
    </member>
    <member name="F:Sandbox.NetworkMode.Object">
      <summary>
            Network this <see cref="T:Sandbox.GameObject" /> as a single network object. Objects networked in this
            way can have an owner, and synchronized properties with <see cref="T:Sandbox.SyncAttribute" />.
            </summary>
    </member>
    <member name="F:Sandbox.NetworkMode.Snapshot">
      <summary>
            Network this <see cref="T:Sandbox.GameObject" /> to other clients as part of the <see cref="T:Sandbox.Scene" /> snapshot.
            </summary>
    </member>
    <member name="P:Sandbox.NetworkObject.Id">
      <summary>
            The unique <see cref="T:System.Guid" /> of the underlying <see cref="P:Sandbox.NetworkObject.GameObject" />.
            </summary>
    </member>
    <member name="P:Sandbox.NetworkObject.Creator">
      <summary>
            The <see cref="T:System.Guid" /> of the connection that created this.
            </summary>
    </member>
    <member name="P:Sandbox.NetworkObject.Owner">
      <summary>
            The <see cref="T:System.Guid" /> of the connection that owns this.
            </summary>
    </member>
    <member name="P:Sandbox.NetworkObject.IsOwner">
      <summary>
            Are we the owner of this networked object?
            </summary>
    </member>
    <member name="P:Sandbox.NetworkObject.IsUnowned">
      <summary>
            Is this networked object unowned?
            </summary>
    </member>
    <member name="P:Sandbox.NetworkObject.IsProxy">
      <summary>
            This is this a proxy if we don't own this networked object.
            </summary>
    </member>
    <member name="M:Sandbox.NetworkObject.Initialize(Sandbox.Connection)">
      <summary>
            Initialize and spawn this networked object with the specified owner <see cref="T:Sandbox.Connection" />.
            </summary>
    </member>
    <member name="M:Sandbox.NetworkObject.Initialize(Sandbox.ObjectCreateMsg)">
      <summary>
            Initialize this networked object from a create message.
            </summary>
    </member>
    <member name="M:Sandbox.NetworkObject.HasControl(Sandbox.Connection)">
      <summary>
            Whether the specified <see cref="T:Sandbox.Connection" /> has control over this networked object. A connection
            has control if the object is unowned and they are the host, or if they own it directly.
            </summary>
    </member>
    <member name="M:Sandbox.NetworkObject.GetPropertySlot(System.Int32,System.Guid)">
      <summary>
            Get a deterministic property slot for use with a network table. This kind of sucks but it's easy
            to change it later if there's a better / faster way.
            </summary>
    </member>
    <member name="M:Sandbox.NetworkObject.WriteReliableData">
      <summary>
            Write all reliable data table entries.
            </summary>
    </member>
    <member name="M:Sandbox.NetworkObject.WriteDataTable(System.Boolean)">
      <summary>
            Write all pending data table changes.
            </summary>
    </member>
    <member name="M:Sandbox.NetworkObject.ReadDataTable(System.Byte[],Sandbox.NetworkTable.ReadFilter)">
      <summary>
            Read the network table data.
            </summary>
    </member>
    <member name="T:Sandbox.NetworkOrphaned">
      <summary>
            Specifies what happens when the owner of a networked object disconnects.
            </summary>
    </member>
    <member name="F:Sandbox.NetworkOrphaned.Destroy">
      <summary>
            Destroy the networked object.
            </summary>
    </member>
    <member name="F:Sandbox.NetworkOrphaned.Host">
      <summary>
            Assign the host as the owner.
            </summary>
    </member>
    <member name="F:Sandbox.NetworkOrphaned.Random">
      <summary>
            Randomly assign another connection as the owner.
            </summary>
    </member>
    <member name="F:Sandbox.NetworkOrphaned.ClearOwner">
      <summary>
            Clear the owner of the networked object.
            </summary>
    </member>
    <member name="P:Sandbox.NetworkTable.IsReadingChanges">
      <summary>
            Internal flag set while reading changes. Useful when you want to force
            something to be set when we otherwise wouldn't have permission to.
            </summary>
    </member>
    <member name="M:Sandbox.NetworkTable.Entry.HasControl(Sandbox.Connection)">
      <summary>
            Whether the specified <see cref="T:Sandbox.Connection" /> has control of this entry.
            </summary>
    </member>
    <member name="M:Sandbox.NetworkTable.Entry.HasControl">
      <summary>
            Whether we (our local <see cref="T:Sandbox.Connection" />) have control of this entry.
            </summary>
      <returns />
    </member>
    <member name="P:Sandbox.NetworkTable.HasAnyChanges">
      <summary>
            Do we have any pending changes for entries we control?
            </summary>
    </member>
    <member name="P:Sandbox.NetworkTable.HasReliableChanges">
      <summary>
            Do we have any pending reliable changes for entries we control?
            </summary>
    </member>
    <member name="M:Sandbox.NetworkTable.Unregister(System.Int32)">
      <summary>
            Unregister a variable assigned to a slot id.
            </summary>
      <param name="slot" />
    </member>
    <member name="M:Sandbox.NetworkTable.Register(System.Int32,Sandbox.NetworkTable.Entry)">
      <summary>
            Register a variable assigned to a slot id.
            </summary>
    </member>
    <member name="M:Sandbox.NetworkTable.GetValue(System.Int32)">
      <summary>
            Get a variable from a slot id.
            </summary>
    </member>
    <member name="M:Sandbox.NetworkTable.IsRegistered(System.Int32)">
      <summary>
            Does a variable with the specified slot exist?
            </summary>
    </member>
    <member name="M:Sandbox.NetworkTable.HasControl(System.Int32)">
      <summary>
            Do we have control over the value for a specific slot id?
            </summary>
    </member>
    <member name="M:Sandbox.NetworkTable.UpdateSlotHash(System.Int32,System.Object)">
      <summary>
            Update the hash for a specific slot id.
            </summary>
    </member>
    <member name="M:Sandbox.NetworkTable.SetValue(System.Int32,System.Object)">
      <summary>
            Set a variable from a slot id.
            </summary>
    </member>
    <member name="M:Sandbox.NetworkTable.WriteSnapshot(Sandbox.DeltaSnapshot)">
      <summary>
            Write supported snapshot variables serialized to the specified dictionary.
            </summary>
      <param name="snapshot" />
    </member>
    <member name="M:Sandbox.NetworkTable.ReadSnapshot(Sandbox.Connection,Sandbox.DeltaSnapshot)">
      <summary>
            Read and apply any variables from the provided snapshot.
            </summary>
      <param name="snapshot" />
      <param name="source" />
    </member>
    <member name="M:Sandbox.NetworkTable.WriteAllReliable(Sandbox.ByteStream@)">
      <summary>
            Write all reliable variables to the provided <see cref="T:Sandbox.ByteStream" />.
            </summary>
      <param name="data" />
    </member>
    <member name="M:Sandbox.NetworkTable.WriteAll(Sandbox.ByteStream@)">
      <summary>
            Write all variables to the provided <see cref="T:Sandbox.ByteStream" />.
            </summary>
      <param name="data" />
    </member>
    <member name="M:Sandbox.NetworkTable.WriteEntryToStream(Sandbox.NetworkTable.Entry,Sandbox.ByteStream@,System.Boolean)">
      <summary>
            Write an entry to the specified <see cref="T:Sandbox.ByteStream" />.
            </summary>
      <param name="entry" />
      <param name="bs" />
      <param name="onlyWriteChanges" />
    </member>
    <member name="M:Sandbox.NetworkTable.WriteReliableChanged(Sandbox.ByteStream@)">
      <summary>
            Write any changes to the provided <see cref="T:Sandbox.ByteStream" /> for entries that must be sent reliably. Calling this will clear the changes.
            </summary>
      <param name="data" />
    </member>
    <member name="M:Sandbox.NetworkTable.WriteChanged(Sandbox.ByteStream@)">
      <summary>
            Write any changes to the provided <see cref="T:Sandbox.ByteStream" />. Calling this will clear the changes.
            </summary>
      <param name="data" />
    </member>
    <member name="M:Sandbox.NetworkTable.Read(Sandbox.ByteStream@,Sandbox.NetworkTable.ReadFilter)">
      <summary>
            Read and apply any variables from the provided <see cref="T:Sandbox.ByteStream" />.
            </summary>
    </member>
    <member name="M:Sandbox.NetworkTable.QueryValues">
      <summary>
            If any properties are "query" types, we'll copy the new values to ourselves
            and mark as changed, if changed.
            </summary>
    </member>
    <member name="T:Sandbox.OwnerTransfer">
      <summary>
            Specifies who can control ownership of a networked object.
            </summary>
    </member>
    <member name="F:Sandbox.OwnerTransfer.Takeover">
      <summary>
            Anyone can control ownership.
            </summary>
    </member>
    <member name="F:Sandbox.OwnerTransfer.Fixed">
      <summary>
            Only the host can change the ownership.
            </summary>
    </member>
    <member name="F:Sandbox.OwnerTransfer.Request">
      <summary>
            Anyone can request ownership changes from the host.
            </summary>
    </member>
    <member name="T:Sandbox.RpcAttribute">
      <summary>
            Marks a method as being an RPC. This means that it can be called over the network.
            </summary>
    </member>
    <member name="T:Sandbox.Rpc.BroadcastAttribute">
      <summary>
            Marks a method as being an RPC. It will be called for everyone.
            </summary>
    </member>
    <member name="T:Sandbox.Rpc.HostAttribute">
      <summary>
            Marks a method as being an RPC. It will only be called on the host.
            </summary>
    </member>
    <member name="T:Sandbox.Rpc.OwnerAttribute">
      <summary>
            Marks a method as being an RPC. It will only be called on owner of this object.
            </summary>
    </member>
    <member name="P:Sandbox.Rpc.Caller">
      <summary>
            The <see cref="T:Sandbox.Connection" /> that is calling this method.
            </summary>
    </member>
    <member name="P:Sandbox.Rpc.CallerId">
      <summary>
            The id of the <see cref="T:Sandbox.Connection" /> that is calling this method.
            </summary>
    </member>
    <member name="P:Sandbox.Rpc.Calling">
      <summary>
            Whether we're currently being called from a remote <see cref="T:Sandbox.Connection" />.
            </summary>
    </member>
    <member name="M:Sandbox.Rpc.Resume(Sandbox.WrappedMethod)">
      <summary>
            Resume a method from an RPC. If the RPC caller is our local connection then we'll
            first disable any active filter and restore it afterwards.
            </summary>
      <param name="m" />
    </member>
    <member name="M:Sandbox.Rpc.PreCall">
      <summary>
            Called right before calling an RPC function.
            </summary>
    </member>
    <member name="M:Sandbox.Rpc.FilterInclude(System.Collections.Generic.IEnumerable{Sandbox.Connection})">
      <summary>
            Filter the recipients of any Rpc called in this scope to only include the specified <see cref="T:Sandbox.Connection" /> set.
            </summary>
      <param name="connections">Only send the RPC to these connections.</param>
    </member>
    <member name="M:Sandbox.Rpc.FilterInclude(System.Predicate{Sandbox.Connection})">
      <summary>
            Filter the recipients of any Rpc called in this scope to only include a <see cref="T:Sandbox.Connection" /> based on a predicate.
            </summary>
      <param name="predicate">Only send the RPC to connections that meet the criteria of the predicate.</param>
    </member>
    <member name="M:Sandbox.Rpc.FilterInclude(Sandbox.Connection)">
      <summary>
            Filter the recipients of any Rpc called in this scope to only include the specified <see cref="T:Sandbox.Connection" />.
            </summary>
      <param name="connection">Only send the RPC to this connection.</param>
    </member>
    <member name="M:Sandbox.Rpc.FilterExclude(System.Predicate{Sandbox.Connection})">
      <summary>
            Filter the recipients of any Rpc called in this scope to exclude a <see cref="T:Sandbox.Connection" /> based on a predicate.
            </summary>
      <param name="predicate">Exclude connections that don't meet the criteria of the predicate from receiving the RPC.</param>
    </member>
    <member name="M:Sandbox.Rpc.FilterExclude(System.Collections.Generic.IEnumerable{Sandbox.Connection})">
      <summary>
            Filter the recipients of any Rpc called in this scope to exclude the specified <see cref="T:Sandbox.Connection" /> set.
            </summary>
      <param name="connections">Exclude these connections from receiving the RPC.</param>
    </member>
    <member name="M:Sandbox.Rpc.FilterExclude(Sandbox.Connection)">
      <summary>
            Filter the recipients of any Rpc called in this scope to exclude the specified <see cref="T:Sandbox.Connection" />.
            </summary>
      <param name="connection">Exclude this connection from receiving the RPC.</param>
    </member>
    <member name="M:Sandbox.Rpc.IncomingInstanceRpcMsg(Sandbox.ObjectRpcMsg,Sandbox.Connection)">
      <summary>
            An instance RPC call is incoming from the network. Look up the method and call it.
            </summary>
    </member>
    <member name="M:Sandbox.Rpc.IncomingInstanceRpcMsg(Sandbox.SceneRpcMsg,Sandbox.Connection)">
      <summary>
            An instance RPC call is incoming from the network. Look up the method and call it.
            </summary>
    </member>
    <member name="M:Sandbox.Rpc.HasHostInstancePermission(Sandbox.Connection,Sandbox.NetFlags)">
      <summary>
            Does the current caller have permission to invoke the RPC?
            </summary>
    </member>
    <member name="M:Sandbox.Rpc.HasInstancePermission(Sandbox.Connection,Sandbox.GameObject,Sandbox.NetFlags)">
      <summary>
            Does the current caller have permission to invoke the RPC?
            </summary>
    </member>
    <member name="M:Sandbox.Rpc.OnCallInstanceRpc(Sandbox.GameObjectSystem@,Sandbox.WrappedMethod@,System.Object[]@)">
      <summary>
            Called when an instance RPC is called for a <see cref="T:Sandbox.Scene" /> and <see cref="T:Sandbox.GameObjectSystem" />.
            </summary>
    </member>
    <member name="M:Sandbox.Rpc.OnCallInstanceRpc(Sandbox.GameObject@,Sandbox.Component@,Sandbox.WrappedMethod@,System.Object[]@)">
      <summary>
            Called when an instance RPC is called for a <see cref="T:Sandbox.GameObject" /> and <see cref="T:Sandbox.Component" />.
            </summary>
    </member>
    <member name="M:Sandbox.Rpc.SendInstanceRpc(Sandbox.GameObjectSystem,Sandbox.WrappedMethod@,System.Object[],Sandbox.RpcAttribute)">
      <summary>
            Do the actual send of the instance RPC.
            </summary>
    </member>
    <member name="M:Sandbox.Rpc.SendInstanceRpc(Sandbox.GameObject,Sandbox.Component,Sandbox.WrappedMethod@,System.Object[],Sandbox.RpcAttribute)">
      <summary>
            Do the actual send of the instance RPC.
            </summary>
    </member>
    <member name="M:Sandbox.Rpc.IncomingStaticRpcMsg(Sandbox.StaticRpcMsg,Sandbox.Connection)">
      <summary>
            A static RPC call is incoming from the network. Look up the method and call it.
            </summary>
    </member>
    <member name="M:Sandbox.Rpc.OnCallRpc(Sandbox.WrappedMethod,System.Object[])">
      <summary>
            Called when a static RPC is called
            </summary>
    </member>
    <member name="M:Sandbox.Rpc.HasStaticPermission(Sandbox.Connection,Sandbox.NetFlags)">
      <summary>
            Does the current caller have permission to invoke the RPC?
            </summary>
    </member>
    <member name="M:Sandbox.Rpc.SendStaticRpc(Sandbox.WrappedMethod,System.Object[],Sandbox.RpcAttribute)">
      <summary>
            Do the actual send of the static RPC.
            </summary>
    </member>
    <member name="T:Sandbox.BroadcastAttribute">
      <summary>
            Marks a method as being an RPC that when invoked will be called for all connected clients including the host.
            The state of the object the RPC is called on will be up-to-date including its <see cref="T:Sandbox.GameTransform" /> and any
            properties with the <see cref="T:Sandbox.SyncAttribute" /> or <see cref="T:Sandbox.HostSyncAttribute" /> attributes by the time the method
            is called on remote clients. The only except is any synchronized properties marked with <see cref="P:Sandbox.SyncAttribute.Query" /> which
            will generally only be received every network tick.
            </summary>
    </member>
    <member name="T:Sandbox.AuthorityAttribute">
      <summary>
            Marks a method as being an RPC specifically targeted to the owner of the <see cref="T:Sandbox.GameObject" />, or the host
            if the <see cref="T:Sandbox.GameObject" /> doesn't have an owner.
            <br /><br />
            The state of the object the RPC is called on will be up-to-date including its <see cref="T:Sandbox.GameTransform" /> and any
            properties with the <see cref="T:Sandbox.SyncAttribute" /> or <see cref="T:Sandbox.HostSyncAttribute" /> attributes by the time the method
            is called on remote clients. The only except is any synchronized properties marked with <see cref="P:Sandbox.SyncAttribute.Query" /> which
            will generally only be received every network tick.
            </summary>
    </member>
    <member name="T:Sandbox.NetPermission">
      <summary>
            Specifies who can invoke an action over the network.
            </summary>
    </member>
    <member name="F:Sandbox.NetPermission.Anyone">
      <summary>
            Anyone can invoke this.
            </summary>
    </member>
    <member name="F:Sandbox.NetPermission.HostOnly">
      <summary>
            Only the host can invoke this.
            </summary>
    </member>
    <member name="F:Sandbox.NetPermission.OwnerOnly">
      <summary>
            Only the owner can invoke this. If the action is static, this works the same way as <see cref="F:Sandbox.NetPermission.HostOnly" />.
            </summary>
    </member>
    <member name="T:Sandbox.SceneNetworkSystem">
      <summary>
            This is created and referenced by the network system, as a way to route.
            </summary>
    </member>
    <member name="M:Sandbox.SceneNetworkSystem.SuppressSpawnMessages(System.Boolean)">
      <summary>
            Any <see cref="T:Sandbox.GameObject">GameObjects</see> created within this scope will not send spawn messages to other clients.
            </summary>
    </member>
    <member name="M:Sandbox.SceneNetworkSystem.LoadSceneBroadcast(Sandbox.SceneLoadOptions)">
      <summary>
            Load a scene for all other clients. This can only be called by the host.
            </summary>
    </member>
    <member name="M:Sandbox.SceneNetworkSystem.NetworkSpawnBatch">
      <summary>
            Start a network spawn batch. Any networked objects created within this scope
            will be sent with one spawn message. This makes sure that any references are
            kept to child networked objects when the objects are spawned on the other side.
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.SceneNetworkSystem.NetworkSpawnBroadcast(Sandbox.NetworkObject)">
      <summary>
            Broadcast the spawning of a networked object. This will add the networked object
            to batch list if we're spawning as part of a batch, and will ignore the spawn message
            entirely if we're supposed to be suppressing spawn messages.
            </summary>
      <param name="networkObject" />
    </member>
    <member name="M:Sandbox.SceneNetworkSystem.OnLoadSceneSnapshotMsg(Sandbox.LoadSceneSnapshotMsg,Sandbox.Connection,System.Guid)">
      <summary>
            Called when the host has provided us with a snapshot for a newly loaded scene.
            </summary>
    </member>
    <member name="M:Sandbox.SceneNetworkSystem.OnLoadSceneRequestSnapshotMsg(Sandbox.LoadSceneRequestSnapshotMsg,Sandbox.Connection,System.Guid)">
      <summary>
            Called when a client has requested the snapshot for a newly loaded scene. This is usually
            once they've done any preloading that they need to do.
            </summary>
    </member>
    <member name="M:Sandbox.SceneNetworkSystem.OnLoadSceneMsg(Sandbox.LoadSceneBeginMsg,Sandbox.Connection,System.Guid)">
      <summary>
            Called when the host has told us to load a new scene.
            </summary>
    </member>
    <member name="M:Sandbox.SceneNetworkSystem.OnSceneLoadedMsg(Sandbox.SceneLoadedMsg,Sandbox.Connection,System.Guid)">
      <summary>
            Called by clients to confirm they have finished loading the new scene.
            </summary>
    </member>
    <member name="M:Sandbox.SceneNetworkSystem.GetMountedVPKs(Sandbox.Connection,Sandbox.Network.MountedVPKsResponse@)">
      <summary>
            A client has joined and wants to know what VPKs to preload.
            </summary>
    </member>
    <member name="M:Sandbox.SceneNetworkSystem.MountVPKs(Sandbox.Connection,Sandbox.Network.MountedVPKsResponse)">
      <summary>
            Asynchronously load and mount any VPKs from the provided server response.
            </summary>
    </member>
    <member name="M:Sandbox.SceneNetworkSystem.GetSnapshot(Sandbox.Connection,Sandbox.Network.SnapshotMsg@)">
      <summary>
            A client has joined and wants a snapshot of the world.
            </summary>
    </member>
    <member name="M:Sandbox.SceneNetworkSystem.SetSnapshotAsync(Sandbox.Network.SnapshotMsg)">
      <summary>
            We have recieved a snapshot of the world.
            </summary>
    </member>
    <member name="M:Sandbox.SceneNetworkSystem.AcceptConnection(Sandbox.Connection,System.String@)">
      <summary>
            Called on the host to decide whether to accept a <see cref="T:Sandbox.Connection" />. If any <see cref="T:Sandbox.Component" />
            that implements this returns false, the connection will be denied.
            </summary>
      <param name="channel" />
      <param name="reason">The reason to display to the client.</param>
    </member>
    <member name="M:Sandbox.SceneNetworkSystem.OnHeartbeat(System.Single)">
      <summary>
            A heartbeat has been received from the host. We should make sure our times are in sync.
            </summary>
    </member>
    <member name="M:Sandbox.SceneNetworkSystem.OnDeltaSnapshotMessage(Sandbox.Network.InternalMessageType,Sandbox.ByteStream,Sandbox.Connection)">
      <summary>
            A delta snapshot message has been received from another connection.
            </summary>
    </member>
    <member name="T:Sandbox.SyncAttribute">
      <summary>
            Automatically synchronize a property of a networked object from the owner to other clients.
            </summary>
    </member>
    <member name="P:Sandbox.SyncAttribute.Query">
      <summary>
             Query this value for changes rather than counting on set being called. This is appropriate
             if the value returned by its getter can change without calling its setter.
            
             Obsoleted: 13/12/2024
             </summary>
    </member>
    <member name="P:Sandbox.SyncAttribute.Flags">
      <summary>
            Flags that describe how this property is synchronized.
            </summary>
    </member>
    <member name="T:Sandbox.SyncFlags">
      <summary>
            Describes the behaviour of network synchronization.
            </summary>
    </member>
    <member name="F:Sandbox.SyncFlags.FromHost">
      <summary>
            The host has ownership over the value.
            </summary>
    </member>
    <member name="F:Sandbox.SyncFlags.Query">
      <summary>
            Query this value for changes rather than counting on set being called. This is appropriate
            if the value returned by its getter can change without calling its setter.
            </summary>
    </member>
    <member name="F:Sandbox.SyncFlags.Interpolate">
      <summary>
            The value will be interpolated between ticks. This is currently only supported for <see cref="T:System.Single" />, <see cref="T:System.Double" />, <see cref="T:Angles" />,
            <see cref="T:Rotation" />, <see cref="T:Transform" />, <see cref="T:Vector3" />.
            </summary>
    </member>
    <member name="M:Sandbox.SceneUtility.MakeIdGuidsUnique(System.Text.Json.Nodes.JsonObject,System.Nullable{System.Guid})">
      <summary>
            Find all "__guid" guids, and replace them with new guids. This is used to make GameObject serializations unique,
            so when you duplicate stuff, it copies over uniquely and keeps associations.
            </summary>
    </member>
    <member name="M:Sandbox.SceneUtility.MakeGameObjectsUnique(System.Text.Json.Nodes.JsonObject,System.Nullable{System.Guid})">
      <summary>
            Find all "Id" guids, and replace them with new guids. This is used to make GameObject serializations unique,
            so when you duplicate stuff, it copies over uniquely and keeps associations.
            </summary>
    </member>
    <member name="M:Sandbox.SceneUtility.Instantiate(Sandbox.GameObject,Transform)">
      <summary>
            Create a unique copy of the passed in GameObject
            </summary>
    </member>
    <member name="M:Sandbox.SceneUtility.Instantiate(Sandbox.GameObject)">
      <summary>
            Create a unique copy of the passed in GameObject
            </summary>
    </member>
    <member name="M:Sandbox.SceneUtility.Instantiate(Sandbox.GameObject,Vector3,Rotation)">
      <summary>
            Create a unique copy of the passed in GameObject
            </summary>
    </member>
    <member name="M:Sandbox.SceneUtility.Instantiate(Sandbox.GameObject,Vector3)">
      <summary>
            Create a unique copy of the passed in GameObject
            </summary>
    </member>
    <member name="M:Sandbox.SceneUtility.GetPrefabScene(Sandbox.PrefabFile)">
      <summary>
            Get a (cached) scene from a PrefabFile
            </summary>
    </member>
    <member name="T:Sandbox.GameObjectDirectory">
      <summary>
            New GameObjects and Components are registered with this class when they're created, and 
            unregistered when they're removed. This gives us a single place to enforce
            Id uniqueness in the scene, and allows for fast lookups by Id.
            </summary>
    </member>
    <member name="M:Sandbox.GameObjectDirectory.FindSystemByGuid(System.Guid)">
      <summary>
            Find a GameObjectSystem in the scene by Guid. This should be really really fast.
            </summary>
    </member>
    <member name="M:Sandbox.GameObjectDirectory.FindComponentByGuid(System.Guid)">
      <summary>
            Find a Component in the scene by Guid. This should be really really fast.
            </summary>
    </member>
    <member name="M:Sandbox.GameObjectDirectory.FindByGuid(System.Guid)">
      <summary>
            Find a GameObject in the scene by Guid. This should be really really fast.
            </summary>
    </member>
    <member name="M:Sandbox.GameObjectDirectory.FindByName(System.String,System.Boolean)">
      <summary>
            Find objects with this name. Not performant.
            </summary>
    </member>
    <member name="T:Sandbox.ISceneMetadata">
      <summary>
            Allows components to add metadata to the scene/prefab file, which is accessible before loading it.
            </summary>
    </member>
    <member name="T:Sandbox.PrefabCacheScene">
      <summary>
            A prefab which is loaded and accessible via GameObject.GetPrefab( x )
            </summary>
    </member>
    <member name="M:Sandbox.PrefabCacheScene.Create(Sandbox.PrefabFile)">
      <summary>
            Creates a scene from the PrefabFile.
            </summary>
    </member>
    <member name="P:Sandbox.PrefabScene.Variables">
      <summary>
            A list of variables and their targets for this prefab scene
            </summary>
    </member>
    <member name="T:Sandbox.PrefabScene.VariableCollection">
      <summary>
            A collection of variabnles that have been configured for this scene
            </summary>
    </member>
    <member name="M:Sandbox.Scene.RegisterComponent(Sandbox.Component)">
      <summary>
            Called for every enabled component
            </summary>
    </member>
    <member name="M:Sandbox.Scene.GetAllComponents``1">
      <summary>
            Get all components of type. This can include interfaces.
            This function can only find enabled/active components.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.GetAllComponents(System.Type)">
      <summary>
            Get all components of type. This can include interfaces.
            This function can only find enabled/active components.
            </summary>
    </member>
    <member name="P:Sandbox.Scene.OverrideSourceLocation">
      <summary>
            For scenes within a hammer MapWorld, for action graph stack traces,
            and so the editor knows the map must be saved when editing graphs from it.
            </summary>
    </member>
    <member name="P:Sandbox.Scene.WantsSystemScene">
      <summary>
            If true we'll additive load the system scene when this scene is loaded. Defaults
            to true. You might want to disable this for specific scenes, like menu scenes etc.
            </summary>
    </member>
    <member name="P:Sandbox.Scene.RenderAttributes">
      <summary>
            Global render attributes accessible on any renderable in this Scene.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.CreateObject(System.Boolean)">
      <summary>
            Create a GameObject on this scene. This doesn't require the scene to be the active scene.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.Push">
      <summary>
            Push this scene as the active scene, for a scope
            </summary>
    </member>
    <member name="M:Sandbox.Scene.PreCameraRender">
      <summary>
            Should be called before rendering. This allows things like reflections to render.
            </summary>
    </member>
    <member name="P:Sandbox.Scene.Volumes">
      <summary>
            Allows quickly finding components that have a volume
            </summary>
    </member>
    <member name="M:Sandbox.Scene.AddSystemScene">
      <summary>
            Adds the "system" scene, which is defined in the project settings.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.QueueDelete(Sandbox.GameObject)">
      <summary>
            Adds a GameObject to delete later
            </summary>
    </member>
    <member name="M:Sandbox.Scene.ProcessDeletes">
      <summary>
            Delete any GameObjects waiting to be deleted
            </summary>
    </member>
    <member name="P:Sandbox.Scene.Editor">
      <summary>
            Allows access to the scene's editor session from the game. This will be null if there is no
            editor session active on this scene.
            </summary>
    </member>
    <member name="P:Sandbox.Scene.ISceneEditorSession.HasUnsavedChanges">
      <summary>
            True if this scene has unsaved changes
            </summary>
    </member>
    <member name="M:Sandbox.Scene.ISceneEditorSession.AddSelectionUndo">
      <summary>
            You have changed the editor's selection, add a new undo entry
            </summary>
    </member>
    <member name="M:Sandbox.Scene.ISceneEditorSession.FrameTo(BBox@)">
      <summary>
            Focus the editor camera onto this box
            </summary>
    </member>
    <member name="M:Sandbox.Scene.ISceneEditorSession.Save(System.Boolean)">
      <summary>
            Save this scene to disk
            </summary>
    </member>
    <member name="M:Sandbox.Scene.ISceneEditorSession.RecordChange(Sandbox.SerializedProperty)">
      <summary>
            Tell undo about this property change
            </summary>
    </member>
    <member name="M:Sandbox.Scene.ISceneEditorSession.AddUndo(System.String,System.Action,System.Action)">
      <summary>
            Add a new undo entry
            </summary>
    </member>
    <member name="M:Sandbox.Scene.RunEvent``1(System.Action{``0})">
      <summary>
            Run an event on all components
            </summary>
    </member>
    <member name="P:Sandbox.Scene.IsLoading">
      <summary>
            Return true if we're in an initial loading phase
            </summary>
    </member>
    <member name="M:Sandbox.Scene.WaitForLoading">
      <summary>
            Wait for scene loading to finish
            </summary>
    </member>
    <member name="M:Sandbox.Scene.CreateSceneFile">
      <summary>
            Create a new SceneFile from this scene
            </summary>
    </member>
    <member name="M:Sandbox.Scene.ToSceneFile(Sandbox.SceneFile)">
      <summary>
            Save the contents of this scene to the SceneFile
            </summary>
    </member>
    <member name="M:Sandbox.Scene.Nav_Update">
      <summary>
            In editor this gets called every frame
            In game this gets called every fixed update
            </summary>
    </member>
    <member name="P:Sandbox.Scene.NetworkRate">
      <summary>
            One divided by ProjectSettings.Networking.UpdateRate.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.SceneNetworkUpdate">
      <summary>
            Send any pending network updates at our desired <see cref="P:Sandbox.Scene.NetworkRate" />.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.DoOrphanedActions(Sandbox.Connection)">
      <summary>
            Do appropriate actions based on the <see cref="T:Sandbox.NetworkOrphaned" /> mode for all networked objects owned by a specific connection.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.ClearObjectIndex">
      <summary>
            Should only be called when destroying the scene. This here just to avoid unregistering
            all of the objects when we don't need to, because we're just quitting.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.HotloadObjectIndex">
      <summary>
            When hotload occurs, the interfaces etc could have changed. So first of all we want to
            go through and remove any null entries, then we want to go through and re-add everything.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.AddObjectToDirectory(System.Object)">
      <summary>
            Adds object instance, indexed by type, to the directory so that its values are accessible by GetAll
            </summary>
    </member>
    <member name="M:Sandbox.Scene.RemoveObjectFromDirectory(System.Object)">
      <summary>
            Adds object instance, indexed by type, to the directory so that its values are accessible by GetAll
            </summary>
    </member>
    <member name="M:Sandbox.Scene.GetAll``1">
      <summary>
            Get all objects of this type. This could be a component or a GameObjectSystem, or other stuff in the future.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.ShutdownSystems">
      <summary>
            Call dispose on all installed hooks
            </summary>
    </member>
    <member name="M:Sandbox.Scene.InitSystems">
      <summary>
            Find all types of SceneHook, create an instance of each one and install it.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.Signal(Sandbox.GameObjectSystem.Stage@)">
      <summary>
            Signal a hook stage
            </summary>
    </member>
    <member name="M:Sandbox.Scene.GetCallbacks(Sandbox.GameObjectSystem.Stage@)">
      <summary>
            Get the hook container for this stage
            </summary>
    </member>
    <member name="M:Sandbox.Scene.ResetListenerMetrics">
      <summary>
            Reset the listener metrics to 0, like before a benchmark or something
            </summary>
    </member>
    <member name="M:Sandbox.Scene.GetListenerMetrics">
      <summary>
            Get a JSON serializable list of metrics from the scene's listeners.
            (this is just internal object[] right now because I can't be fucked to exose it properly)
            </summary>
    </member>
    <member name="M:Sandbox.Scene.AddHook(Sandbox.GameObjectSystem.Stage,System.Int32,System.Action,System.String,System.String)">
      <summary>
            Call this method on this stage. This returns a disposable that will remove the hook when disposed.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.GetSystem``1">
      <summary>
            Get a specific system by type.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.GetSystem``1(``0@)">
      <summary>
            Get a specific system by type.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.GetSystemByType(Sandbox.TypeDescription)">
      <summary>
            Get a specific system by <see cref="T:Sandbox.TypeDescription" />.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.GetSystems">
      <summary>
            Get all systems belonging to this scene.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.PreTickReset">
      <summary>
            The update loop will turn certain settings on
            Here we turn them to their defaults.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.UpdateTimeFromHost(System.Single)">
      <summary>
            Update the current time from the host
            </summary>
    </member>
    <member name="M:Sandbox.Scene.RunPendingStarts">
      <summary>
            Run OnStart on all components that haven't had OnStart called yet
            </summary>
    </member>
    <member name="M:Sandbox.Scene.SharedTick">
      <summary>
            This is called in EditorTick and GameTick. It's only called in EditorTick if we're actually
            an editor scene. 
            </summary>
    </member>
    <member name="M:Sandbox.Scene.FindInPhysics(Sandbox.Sphere)">
      <summary>
            Find game objects in a sphere using physics.
            </summary>
    </member>
    <member name="M:Sandbox.Scene.FindInPhysics(BBox)">
      <summary>
            Find game objects in a box using physics.
            </summary>
    </member>
    <member name="T:Sandbox.ISceneEvent`1">
      <summary>
            A wrapper for scene event interfaces. Allows syntax sugar of something like
            `IPlayerEvents.Post( x =&gt; x.OnPlayerHurt( this, amount ) )` instead of using
            Scene.Run to call them manually.
            </summary>
    </member>
    <member name="M:Sandbox.ISceneEvent`1.Post(System.Action{`0})">
      <summary>
            Post an event to the entire scene, including GameObjectSystem's
            </summary>
    </member>
    <member name="M:Sandbox.ISceneEvent`1.PostToGameObject(Sandbox.GameObject,System.Action{`0})">
      <summary>
            Post event to a specific GameObject - not to its descendants.
            </summary>
    </member>
    <member name="P:Sandbox.SceneTrace.NeedsFilterCallback">
      <summary>
            returns true if we need to do some managed side filtering
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Sphere(System.Single,Vector3@,Vector3@)">
      <summary>
            Casts a sphere from point A to point B.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Sphere(System.Single,Ray@,System.Single@)">
      <summary>
            Casts a sphere from a given position and direction, up to a given distance.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Box(Vector3,Vector3@,Vector3@)">
      <summary>
            Casts a box from point A to point B.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Box(Vector3,Ray@,System.Single@)">
      <summary>
            Casts a box from a given position and direction, up to a given distance.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Box(BBox,Vector3@,Vector3@)">
      <summary>
            Casts a box from point A to point B.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Box(BBox,Ray@,System.Single@)">
      <summary>
            Casts a box from a given position and direction, up to a given distance.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Capsule(Capsule)">
      <summary>
            Casts a capsule
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Capsule(Capsule,Vector3@,Vector3@)">
      <summary>
            Casts a capsule from point A to point B.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Capsule(Capsule,Ray@,System.Single@)">
      <summary>
            Casts a capsule from a given position and direction, up to a given distance.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Cylinder(System.Single,System.Single)">
      <summary>
            Casts a cylinder
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Cylinder(System.Single,System.Single,Vector3@,Vector3@)">
      <summary>
            Casts a cylinder from point A to point B.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Cylinder(System.Single,System.Single,Ray@,System.Single@)">
      <summary>
            Casts a cylinder from a given position and direction, up to a given distance.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Ray(Vector3@,Vector3@)">
      <summary>
            Casts a ray from point A to point B.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Ray(Ray@,System.Single@)">
      <summary>
            Casts a ray from a given position and direction, up to a given distance.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Body(Sandbox.PhysicsBody)">
      <summary>
            Casts a <see cref="T:Sandbox.PhysicsBody" />.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Body(Sandbox.PhysicsBody,Vector3@)">
      <summary>
            Casts a PhysicsBody from its current position and rotation to desired end point.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Body(Sandbox.Rigidbody,Vector3@)">
      <summary>
            Casts a PhysicsBody from its current position and rotation to desired end point.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Body(Sandbox.PhysicsBody,Transform@,Vector3@)">
      <summary>
            Casts a PhysicsBody from a position and rotation to desired end point.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Sweep(Sandbox.PhysicsBody@,Transform@,Transform@)">
      <summary>
            Sweeps each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> of given PhysicsBody and returns the closest collision. Does not support Mesh PhysicsShapes.
            Basically 'hull traces' but with physics shapes.
            Same as tracing a body but allows rotation to change during the sweep.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Sweep(Sandbox.Rigidbody@,Transform@,Transform@)">
      <summary>
            Sweeps each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> of given PhysicsBody and returns the closest collision. Does not support Mesh PhysicsShapes.
            Basically 'hull traces' but with physics shapes.
            Same as tracing a body but allows rotation to change during the sweep.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Sweep(Sandbox.PhysicsBody@,Transform@)">
      <summary>
            Creates a Trace.Sweep using the <see cref="T:Sandbox.PhysicsBody">PhysicsBody</see>'s position as the starting position.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.FromTo(Vector3@,Vector3@)">
      <summary>
            Sets the start and end positions of the trace request
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.FromTo(Transform@,Vector3@)">
      <summary>
            Sets the start transform and end position of the trace request
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Size(BBox@)">
      <summary>
            Makes this trace an axis aligned box of given size. Extracts mins and maxs from the Bounding Box.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Size(Vector3@)">
      <summary>
            Makes this trace an axis aligned box of given size. Calculates mins and maxs by assuming given size is (maxs-mins) and the center is in the middle.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Size(Vector3@,Vector3@)">
      <summary>
            Makes this trace an axis aligned box of given size.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Rotated(Rotation@)">
      <summary>
            Makes this a rotated trace, for tracing rotated boxes and capsules.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Radius(System.Single)">
      <summary>
            Makes this trace a sphere of given radius.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.UseHitPosition(System.Boolean)">
      <summary>
            Should we compute hit position.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.UseHitboxes(System.Boolean)">
      <summary>
            Should we hit hitboxes
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.UseRenderMeshes(System.Boolean)">
      <summary>
            Should we hit meshes too? This can be slow and only really recommended for editor work.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.UseRenderMeshes(System.Boolean,System.Boolean)">
      <summary>
            Should we hit meshes too? This can be slow and only really recommended for editor work.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.UsePhysicsWorld(System.Boolean)">
      <summary>
            Should we hit physics objects?
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.WithTag(System.String)">
      <summary>
            Only return entities with this tag. Subsequent calls to this will add multiple requirements
            and they'll all have to be met (ie, the entity will need all tags).
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.WithAllTags(System.String[])">
      <summary>
            Only return entities with all of these tags
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.WithAllTags(Sandbox.ITagSet)">
      <summary>
            Only return entities with all of these tags
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.WithAnyTags(System.String[])">
      <summary>
            Only return entities with any of these tags
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.WithAnyTags(Sandbox.ITagSet)">
      <summary>
            Only return entities with any of these tags
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.WithoutTags(System.String[])">
      <summary>
            Only return entities without any of these tags
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.WithoutTags(Sandbox.ITagSet)">
      <summary>
            Only return entities without any of these tags
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.WithCollisionRules(System.String,System.Boolean)">
      <summary>
            Use the collision rules of an object with the given tags.
            </summary>
      <param name="tag">Which tag this trace will adopt the collision rules of.</param>
      <param name="asTrigger">If true, trace against triggers only. Otherwise, trace for collisions (default).</param>
    </member>
    <member name="M:Sandbox.SceneTrace.WithCollisionRules(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
      <summary>
            Use the collision rules for the given set of tags.
            </summary>
      <param name="tags">Which tags this trace will adopt the collision rules of.</param>
      <param name="asTrigger">If true, trace against triggers only. Otherwise, trace for collisions (default).</param>
    </member>
    <member name="M:Sandbox.SceneTrace.IgnoreGameObject(Sandbox.GameObject)">
      <summary>
            Do not hit this object
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.IgnoreGameObjectHierarchy(Sandbox.GameObject)">
      <summary>
            Do not hit this object
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.HitTriggers">
      <summary>
            Hit Triggers
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.HitTriggersOnly">
      <summary>
            Hit Only Triggers
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.IgnoreStatic">
      <summary>
            Do not hit static objects
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.IgnoreDynamic">
      <summary>
            Do not hit dynamic objects
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.IgnoreKeyframed">
      <summary>
            Do not hit keyframed objects
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.Run">
      <summary>
            Run the trace and return the result. The result will return the first hit.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.RunAll">
      <summary>
            Run the trace and record everything we hit along the way. The result will be an array of hits.
            </summary>
    </member>
    <member name="M:Sandbox.SceneTrace.FilterCallback(Sandbox.PhysicsShape)">
      <summary>
            Return true if we should hit this shape.
            We puposely keep this locked down, don't offer a user specified callback.
            </summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.Hit">
      <summary>
            Whether the trace hit something or not
            </summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.StartedSolid">
      <summary>
            Whether the trace started in a solid
            </summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.StartPosition">
      <summary>
            The start position of the trace
            </summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.EndPosition">
      <summary>
            The end or hit position of the trace
            </summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.HitPosition">
      <summary>
            The hit position of the trace. Requires <see cref="M:Sandbox.SceneTrace.UseHitPosition(System.Boolean)" />.
            </summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.Normal">
      <summary>
            The hit surface normal (direction vector)
            </summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.Fraction">
      <summary>
            A fraction [0..1] of where the trace hit between the start and the original end positions
            </summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.GameObject">
      <summary>
            The GameObject that was hit
            </summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.Component">
      <summary>
            The Component that was hit
            </summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.Collider">
      <summary>
            The Collider that was hit
            </summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.Body">
      <summary>
            The physics object that was hit, if any
            </summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.Shape">
      <summary>
            The physics shape that was hit, if any
            </summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.Surface">
      <summary>
            The physical properties of the hit surface
            </summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.Bone">
      <summary>
            The id of the hit bone (either from hitbox or physics shape)
            </summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.Direction">
      <summary>
            The direction of the trace ray
            </summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.Triangle">
      <summary>
            The triangle index hit, if we hit a mesh <see cref="T:Sandbox.PhysicsShape">physics shape</see></summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.Tags">
      <summary>
            The tags that the hit shape had
            </summary>
    </member>
    <member name="F:Sandbox.SceneTraceResult.Hitbox">
      <summary>
            The hitbox that we hit
            </summary>
    </member>
    <member name="P:Sandbox.SceneTraceResult.Distance">
      <summary>
            The distance between start and end positions.
            </summary>
    </member>
    <member name="T:Sandbox.UI.KeyFrames">
      <summary>
            Represents a CSS <c>@keyframes</c> rule.
            </summary>
    </member>
    <member name="P:Sandbox.UI.KeyFrames.Name">
      <summary>
            Name of the <c>@keyframes</c> rule.
            </summary>
    </member>
    <member name="T:Sandbox.UI.KeyFrames.Block">
      <summary>
            A keyframe within the animation.
            </summary>
    </member>
    <member name="P:Sandbox.UI.KeyFrames.Block.Interval">
      <summary>
            The position of the keyframe within the overall animation. 0 to 1, where 0 is the start, and 1 is the end of the animation.
            </summary>
    </member>
    <member name="P:Sandbox.UI.KeyFrames.Block.Styles">
      <summary>
            The styles that should be applied at this position in the animation.
            </summary>
    </member>
    <member name="F:Sandbox.UI.KeyFrames.Blocks">
      <summary>
            List of keyframes with in the <c>@keyframes</c> rule.
            </summary>
    </member>
    <member name="T:Sandbox.UI.BasePopup">
      <summary>
            A panel that gets deleted automatically when clicked away from
            </summary>
    </member>
    <member name="P:Sandbox.UI.BasePopup.StayOpen">
      <summary>
            Stay open, even when CloseAll popups is called
            </summary>
    </member>
    <member name="T:Sandbox.UI.Image">
      <summary>
            A generic box that displays a given texture within itself.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Image.Texture">
      <summary>
            The texture being displayed by this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Image.SetTexture(System.String)">
      <summary>
            Set <see cref="P:Sandbox.UI.Image.Texture" /> from a file path. URLs supported.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Construct.ImageConstructor.Image(Sandbox.UI.Construct.PanelCreator,System.String,System.String)">
      <summary>
            Create an image with given texture and CSS classname.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Construct.LabelConstructor.Label(Sandbox.UI.Construct.PanelCreator,System.String,System.String)">
      <summary>
            Create a simple text label with given text and CSS classname.
            </summary>
    </member>
    <member name="T:Sandbox.UI.Construct.PanelCreator">
      <summary>
            Used for <see cref="P:Sandbox.UI.Panel.Add" /> for quick panel creation with certain settings. Other panels types are added via extension methods.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Construct.PanelCreator.panel">
      <summary>
            The panel to add children to.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Construct.PanelCreator.Panel">
      <summary>
            Add a new blank panel as a child.
            </summary>
      <returns>The crated panel.</returns>
    </member>
    <member name="M:Sandbox.UI.Construct.PanelCreator.Panel(System.String)">
      <summary>
            Add a new blank panel with given CSS classes as a child.
            </summary>
      <returns>The crated panel.</returns>
    </member>
    <member name="T:Sandbox.UI.Label">
      <summary>
            A generic text label. Can be made editable.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Label.StringInfo">
      <summary>
            Information about the <see cref="P:Sandbox.UI.Label.Text" /> on a per-element scale. It handles multi-character Unicode units (graphemes) correctly.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Label.Selectable">
      <summary>
            Can be selected
            </summary>
    </member>
    <member name="P:Sandbox.UI.Label.Text">
      <summary>
            Text to display on the label.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Label.IsRich">
      <summary>
            Set to true if this is rich text. This means it can support some inline html elements.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Label.CaretPosition">
      <summary>
            Position of the text cursor/caret within the text, at which newly typed characters are inserted.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Label.TextLength">
      <summary>
            Amount of characters in the text of the text entry. Not bytes.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Label.CaretSantity">
      <summary>
            Ensure the text caret and selection are in sane positions, that is, not outside of the text bounds.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Label.GetSelectedText">
      <summary>
            Returns the selected text.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Label.LanguageChanged">
      <summary>
            When the language changes, if we're token based we need to update to the new phrase.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Label.Multiline">
      <summary>
            Enables multi-line support for editing purposes.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Label.ReplaceSelection(System.String)">
      <summary>
            Replace the currently selected text with given text.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Label.SetSelection(System.Int32,System.Int32)">
      <summary>
            Sets the text selection.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Label.SetCaretPosition(System.Int32,System.Boolean)">
      <summary>
            Set the text caret position to the given index.
            </summary>
      <param name="pos">Where to move the text caret to within the text.</param>
      <param name="select">Whether to also add the characters we passed by to the selection.</param>
    </member>
    <member name="M:Sandbox.UI.Label.ScrollToCaret">
      <summary>
            Put the caret within the visible region.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Label.MoveToWordBoundaryLeft(System.Boolean)">
      <summary>
            Move the text caret to the closest word start or end to the left of current position.<br />
            This simulates holding Control key while pressing left arrow key.
            </summary>
      <param name="select">Whether to also add the characters we passed by to the selection.</param>
    </member>
    <member name="M:Sandbox.UI.Label.MoveToWordBoundaryRight(System.Boolean)">
      <summary>
            Move the text caret to the closest word start or end to the right of current position.<br />
            This simulates holding Control key while pressing right arrow key.
            </summary>
      <param name="select">Whether to also add the characters we passed by to the selection.</param>
    </member>
    <member name="M:Sandbox.UI.Label.MoveCaretPos(System.Int32,System.Boolean)">
      <summary>
            Move the text caret by given amount.
            </summary>
      <param name="delta">How many characters to the right to move. Negative values move left.</param>
      <param name="select">Whether to also add the characters we passed by to the selection.</param>
    </member>
    <member name="M:Sandbox.UI.Label.InsertText(System.String,System.Int32,System.Nullable{System.Int32})">
      <summary>
            Insert given text at given position.
            </summary>
      <param name="text">Text to insert.</param>
      <param name="pos">Position to insert the text at.</param>
      <param name="endpos">If set, the end position in the current <see cref="P:Sandbox.UI.Label.Text" />,
            which will be used to replace portion of the existing text with the given <paramref name="text" />.</param>
    </member>
    <member name="M:Sandbox.UI.Label.RemoveText(System.Int32,System.Int32)">
      <summary>
            Remove given amount of characters from the label at given <paramref name="start" /> position.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Label.MoveToLineStart(System.Boolean)">
      <summary>
            Move the text caret to the start of the current line.
            </summary>
      <param name="select">Whether to also add the characters we passed by to the selection.</param>
    </member>
    <member name="M:Sandbox.UI.Label.MoveToLineEnd(System.Boolean)">
      <summary>
            Move the text caret to the end of the current line.
            </summary>
      <param name="select">Whether to also add the characters we passed by to the selection.</param>
    </member>
    <member name="M:Sandbox.UI.Label.MoveCaretLine(System.Int32,System.Boolean)">
      <summary>
            Move the text caret to next or previous line.
            </summary>
      <param name="offset_line">How many lines to offset. Negative values move up.</param>
      <param name="select">Whether to also add the characters we passed by to the selection.</param>
    </member>
    <member name="M:Sandbox.UI.Label.SelectWord(System.Int32)">
      <summary>
            Select a work at given word position.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Label.GetWordBoundaryIndices">
      <summary>
            Returns a list of positions in the text of each side of each word within the <see cref="P:Sandbox.UI.Label.Text" />.<br />
            This is used for Control + Arrow Key navigation.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Label.IsNewline(System.String)">
      <summary>
            Returns true if the input string is a 1 or 2 (\r\n) character newline symbol.
            </summary>
    </member>
    <member name="T:Sandbox.UI.ScenePanel">
      <summary>
            Allows to render a scene world onto a panel.
            </summary>
    </member>
    <member name="P:Sandbox.UI.ScenePanel.World">
      <summary>
            Shortcut to Camera.World
            </summary>
    </member>
    <member name="P:Sandbox.UI.ScenePanel.Camera">
      <summary>
            The camera we're going to be using to render
            </summary>
    </member>
    <member name="P:Sandbox.UI.ScenePanel.RenderOnce">
      <summary>
            If enabled, the scene will only render once. That isn't totally accurate though, because we'll
            also re-render the scene when the size of the panel changes.
            </summary>
    </member>
    <member name="P:Sandbox.UI.ScenePanel.RenderTexture">
      <summary>
            The texture that the panel is rendering to internally. This will change to a different
            texture if the panel changes size, so I wouldn't hold onto this object.
            </summary>
    </member>
    <member name="P:Sandbox.UI.ScenePanel.RenderScene">
      <summary>
            The scene to render to this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.ScenePanel.RenderNextFrame">
      <summary>
            Render the panel again next frame. This is meant to be used with RenderOnce, where
            you might want to render on demand or only once.
            </summary>
    </member>
    <member name="T:Sandbox.UI.SvgPanel">
      <summary>
            A generic panel that draws an SVG scaled to size
            </summary>
    </member>
    <member name="P:Sandbox.UI.SvgPanel.Src">
      <summary>
            Content path to the SVG file
            </summary>
    </member>
    <member name="P:Sandbox.UI.SvgPanel.Color">
      <summary>
            Optional color to draw the SVG with
            </summary>
    </member>
    <member name="T:Sandbox.UI.WebPanel">
      <summary>
            A panel that displays an interactive web page.
            </summary>
    </member>
    <member name="P:Sandbox.UI.WebPanel.Surface">
      <summary>
            Access to the HTML surface to change URL, etc.
            </summary>
    </member>
    <member name="M:Sandbox.UI.WebPanel.BrowserDataChanged(System.ReadOnlySpan{System.Byte},Vector2)">
      <summary>
            The texture has changed
            </summary>
    </member>
    <member name="M:Sandbox.UI.LayoutCascade.ApplyCascading(Sandbox.UI.Styles)">
      <summary>
            Some properties cascade from their parent onto children if the children
            don't set them. Things like font size, color, cursor.
            </summary>
    </member>
    <member name="M:Sandbox.UI.TextBlock.Render(Sandbox.UI.PanelRenderer,Sandbox.UI.RenderState@,Sandbox.UI.Styles,Sandbox.Rect,System.Single)">
      <summary>
            Proper Rendering
            </summary>
    </member>
    <member name="M:Sandbox.UI.TextBlock.SizeFinalized(System.Single,System.Single)">
      <summary>
            Called on layout. We should decide here if we actually need to rebuild
            </summary>
    </member>
    <member name="M:Sandbox.UI.TextBlock.RebuildTexture(System.Single,System.Single)">
      <summary>
            Actually recreate the texture
            </summary>
    </member>
    <member name="T:Sandbox.UI.ButtonEvent">
      <summary>
            Keyboard (and mouse) key press <see cref="T:Sandbox.UI.PanelEvent" />.
            </summary>
    </member>
    <member name="P:Sandbox.UI.ButtonEvent.Button">
      <summary>
            The button that triggered the event.
            </summary>
    </member>
    <member name="P:Sandbox.UI.ButtonEvent.Pressed">
      <summary>
            Whether the button was pressed in, or release.
            </summary>
    </member>
    <member name="P:Sandbox.UI.ButtonEvent.KeyboardModifiers">
      <summary>
            The keyboard modifier keys that were held down at the moment the event triggered.
            </summary>
    </member>
    <member name="P:Sandbox.UI.ButtonEvent.HasShift">
      <summary>
            Whether <c>Shift</c> key was being held down at the time of the event.
            </summary>
    </member>
    <member name="P:Sandbox.UI.ButtonEvent.HasCtrl">
      <summary>
            Whether <c>Control</c> key was being held down at the time of the event.
            </summary>
    </member>
    <member name="P:Sandbox.UI.ButtonEvent.HasAlt">
      <summary>
            Whether <c>Alt</c> key was being held down at the time of the event.
            </summary>
    </member>
    <member name="P:Sandbox.UI.ButtonEvent.StopPropagation">
      <summary>
            Set to <see langword="true" /> to prevent the event from propagating to the parent panel.
            </summary>
    </member>
    <member name="T:Sandbox.UI.InputEventQueue">
      <summary>
            Queue input events on here to be processed by the UISystem.
            </summary>
    </member>
    <member name="T:Sandbox.UI.InputFocus">
      <summary>
            Handles input focus for <see cref="T:Sandbox.UI.Panel" />s.
            </summary>
    </member>
    <member name="P:Sandbox.UI.InputFocus.Current">
      <summary>
            The panel that currently has input focus.
            </summary>
    </member>
    <member name="P:Sandbox.UI.InputFocus.Next">
      <summary>
            The panel that will have the input focus next.
            </summary>
    </member>
    <member name="M:Sandbox.UI.InputFocus.Set(Sandbox.UI.Panel)">
      <summary>
            Set the focus to this panel (or its nearest ancestor with AcceptsFocus).
            Note that <see cref="P:Sandbox.UI.InputFocus.Current" /> won't change until the next frame.
            </summary>
    </member>
    <member name="M:Sandbox.UI.InputFocus.Clear(Sandbox.UI.Panel)">
      <summary>
            Clear focus away from this panel.
            </summary>
    </member>
    <member name="P:Sandbox.UI.PanelInput.Hovered">
      <summary>
            Panel we're currently hovered over
            </summary>
    </member>
    <member name="P:Sandbox.UI.PanelInput.Active">
      <summary>
            Panel we're currently pressing down
            </summary>
    </member>
    <member name="M:Sandbox.UI.PanelInput.AddMouseWheel(Vector2,Sandbox.KeyboardModifiers)">
      <summary>
            Called from input when mouse wheel changes
            </summary>
    </member>
    <member name="M:Sandbox.UI.PanelInput.AddMouseButton(NativeEngine.ButtonCode,System.Boolean,Sandbox.KeyboardModifiers)">
      <summary>
            Called from input when mouse wheel changes
            </summary>
    </member>
    <member name="M:Sandbox.UI.PanelInput.SetCursor(System.String)">
      <summary>
            The cursor should change. Name could be null, meaning default.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PanelInput.MouseButtonState.DragTarget">
      <summary>
            Then panel that is potentially being dragged
            </summary>
    </member>
    <member name="F:Sandbox.UI.PanelInput.MouseButtonState.StartHoldOffsetLocal">
      <summary>
            The point where we first pressed on the Active element
            </summary>
    </member>
    <member name="T:Sandbox.UI.WorldInput">
      <summary>
            WorldInput can be used to simulate standard mouse inputs on WorldPanels.
            </summary>
      <remarks>
        <para>
            You need to set <see cref="P:Sandbox.UI.WorldInput.Ray" /> and <see cref="P:Sandbox.UI.WorldInput.MouseLeftPressed" /> to simulate inputs,
            ideally this should be done in a BuildInput event.
            </para>
      </remarks>
    </member>
    <member name="P:Sandbox.UI.WorldInput.Enabled">
      <summary>
            This input won't tick when this is false.
            Any hovered panels will be cleared.
            </summary>
    </member>
    <member name="P:Sandbox.UI.WorldInput.Ray">
      <summary>
            The Ray used to intersect with your world panels, simulating mouse position.
            </summary>
      <remarks>
            This should ideally be set in BuildInput or FrameSimulate.
            </remarks>
    </member>
    <member name="P:Sandbox.UI.WorldInput.MouseWheel">
      <summary>
            Simulate the mouse scroll wheel.
            You could use <seealso cref="P:Sandbox.Input.MouseWheel" />
            Or you could simulate it with the camera view delta for example.
            </summary>
    </member>
    <member name="P:Sandbox.UI.WorldInput.UseMouseInput">
      <summary>
            Instead of simulating mouse input, this will simply use the mouse input.
            </summary>
    </member>
    <member name="P:Sandbox.UI.WorldInput.Hovered">
      <summary>
            The <see cref="T:Sandbox.UI.Panel" /> that is currently hovered by this input.
            </summary>
    </member>
    <member name="P:Sandbox.UI.WorldInput.Active">
      <summary>
            The <see cref="T:Sandbox.UI.Panel" /> that is currently pressed by this input.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PanelStyle.activeRules">
      <summary>
            This could be a local variable if we wanted to create a new class every time
            </summary>
    </member>
    <member name="F:Sandbox.UI.PanelStyle.LastActiveRules">
      <summary>
            Store the last active rules so we can compare them when they change and trigger sounds etc on new styles
            </summary>
    </member>
    <member name="F:Sandbox.UI.PanelStyle.ActiveRulesGuid">
      <summary>
            Cache of the active rules that are applied, that way we can trigger stuff only if they actually changed
            </summary>
    </member>
    <member name="M:Sandbox.UI.PanelStyle.UnderlyingStyleHasChanged">
      <summary>
            Should be called when a stylesheet in our bundle has changed. This can happen as a result of
            editing it in the style editor.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PanelStyle.StyleBlocks">
      <summary>
            All these styles could possibly apply to us. To get this list we get the stylesheets from
            ourself and our anscestors and then filter them by the broadphase. The broadphase is a check
            against classes, element names and ids, things that don't change in a recursive way.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PanelStyle.broadPhaseHash">
      <summary>
            A hash of the things that are checked in the broadphase.
            </summary>
    </member>
    <member name="M:Sandbox.UI.PanelStyle.InvalidateBroadphase">
      <summary>
            Called when a stylesheet has been added or removed from ourselves or one of
            our ancestor panels - because under that condition we need to rebuild our
            broadphase.
            </summary>
    </member>
    <member name="M:Sandbox.UI.PanelStyle.BuildRulesInThread">
      <summary>
            Called from the root panel in a thread. We replace activeRules with all of the rules that
            we want applied and return true if the rules changed.
            </summary>
    </member>
    <member name="M:Sandbox.UI.PanelStyle.ContainsStyle(Sandbox.UI.Styles)">
      <summary>
            Returns true if we have the style
            </summary>
    </member>
    <member name="F:Sandbox.UI.DragEvent.MouseDelta">
      <summary>
            For ondrag event - the delta of the mouse movement
            </summary>
    </member>
    <member name="F:Sandbox.UI.DragEvent.LocalGrabPosition">
      <summary>
            The position on the Target panel where the drag started
            </summary>
    </member>
    <member name="F:Sandbox.UI.DragEvent.ScreenGrabPosition">
      <summary>
            The position relative to the screen where the drag started
            </summary>
    </member>
    <member name="F:Sandbox.UI.DragEvent.LocalPosition">
      <summary>
            The current mouse position relative to target
            </summary>
    </member>
    <member name="F:Sandbox.UI.DragEvent.ScreenPosition">
      <summary>
            The current position relative to the screen
            </summary>
    </member>
    <member name="T:Sandbox.UI.MousePanelEvent">
      <summary>
            Mouse related <see cref="T:Sandbox.UI.PanelEvent" />.
            </summary>
    </member>
    <member name="F:Sandbox.UI.MousePanelEvent.LocalPosition">
      <summary>
            Position of the cursor relative to the panel's top left corner at the time the event was triggered.
            </summary>
    </member>
    <member name="F:Sandbox.UI.MousePanelEvent.Button">
      <summary>
            Which button triggered the event, in string form.
            </summary>
    </member>
    <member name="P:Sandbox.UI.MousePanelEvent.MouseButton">
      <summary>
            Which button triggered the event, as a <see cref="T:Sandbox.MouseButtons" /> enum.
            </summary>
    </member>
    <member name="T:Sandbox.UI.PanelEvent">
      <summary>
            Base <see cref="T:Sandbox.UI.Panel" /> event.<br />
            See <see cref="M:Sandbox.UI.Panel.CreateEvent(Sandbox.UI.PanelEvent)" />.
            </summary>
    </member>
    <member name="P:Sandbox.UI.PanelEvent.This">
      <summary>
            The panel on which the event is being called. For example, if you have a button with a label.. when the
            button gets clicked the actual click event might come from the label. When the event is called on the
            label, This will be the label. When the event propagates up to the button This will be the button - but
            Target will be the label. This is mainly of use with Razor callbacks, where you want to get the actual
            panel that created the event.
            </summary>
    </member>
    <member name="T:Sandbox.UI.PanelEventAttribute">
      <summary>
            Add an event listener to a <see cref="T:Sandbox.UI.Panel" /> event with the given name.<br />
            See <see cref="M:Sandbox.UI.Panel.CreateEvent(System.String,System.Object,System.Nullable{System.Single})" />.
            </summary>
    </member>
    <member name="P:Sandbox.UI.PanelEventAttribute.Name">
      <summary>
            Name of the event to listen to.
            </summary>
    </member>
    <member name="T:Sandbox.UI.Panel">
      <summary>
            A simple User Interface panel. Can be styled with <a href="https://en.wikipedia.org/wiki/CSS">CSS</a>.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.Add">
      <summary>
            Quickly add common panels with certain values as children.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Panel._children">
      <inheritdoc cref="P:Sandbox.UI.Panel.Children" />
    </member>
    <member name="F:Sandbox.UI.Panel._parent">
      <inheritdoc cref="P:Sandbox.UI.Panel.Parent" />
    </member>
    <member name="P:Sandbox.UI.Panel.Children">
      <summary>
            List of panels that are attached/<see cref="P:Sandbox.UI.Panel.Parent">parented</see> directly to this one.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.HasChildren">
      <summary>
            Whether this panel has any <see cref="P:Sandbox.UI.Panel.Children">child panels</see> at all.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.Parent">
      <summary>
            The panel we are directly attached to. This panel will be positioned relative to the given parent, and therefore move with it, typically also be hidden by the parents bounds.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.RemoveChild(Sandbox.UI.Panel)">
      <summary>
            Called internally when a child is removed, to remove from our Children list
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnChildRemoved(Sandbox.UI.Panel)">
      <summary>
            A child panel has been removed from this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.DeleteChildren(System.Boolean)">
      <summary>
            Deletes all child panels via <see cref="M:Sandbox.UI.Panel.Delete(System.Boolean)" />.
            </summary>
      <inheritdoc cref="M:Sandbox.UI.Panel.Delete(System.Boolean)" />
    </member>
    <member name="M:Sandbox.UI.Panel.AddChild(Sandbox.UI.Panel)">
      <summary>
            Add given panel as a child to this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.InternalAddChild(Sandbox.UI.Panel)">
      <summary>
            Called internally when a child is added, to add to our <see cref="P:Sandbox.UI.Panel.Children">children</see> list.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnChildAdded(Sandbox.UI.Panel)">
      <summary>
            A child panel has been added to this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.SortChildren(System.Comparison{Sandbox.UI.Panel})">
      <summary>
            Sort the <see cref="P:Sandbox.UI.Panel.Children">children</see> using given comparison function.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.SortChildren``1(System.Func{``0,System.Int32})">
      <summary>
            Sort the <see cref="P:Sandbox.UI.Panel.Children">children</see> using given comparison function.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.SortChildren(System.Func{Sandbox.UI.Panel,System.Int32})">
      <summary>
            Sort the <see cref="P:Sandbox.UI.Panel.Children">children</see> using given comparison function.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.SiblingIndex">
      <summary>
            The index of this panel in its parent's child list.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.AddChild``1(System.String)">
      <summary>
            Creates a panel of given type and makes it our child.
            </summary>
      <typeparam name="T">The panel to create.</typeparam>
      <param name="classnames">Optional CSS class names to apply to the newly created panel.</param>
      <returns>The created panel.</returns>
    </member>
    <member name="M:Sandbox.UI.Panel.AddChild``1(``0@,System.String)">
      <summary>
            Creates a panel of given type and makes it our child, returning it as an out argument.
            </summary>
      <typeparam name="T">The panel to create.</typeparam>
      <param name="outPanel">The created panel.</param>
      <param name="classnames">Optional CSS class names to apply to the newly created panel.</param>
      <returns>Always returns <see langword="true" />.</returns>
    </member>
    <member name="P:Sandbox.UI.Panel.AncestorsAndSelf">
      <summary>
            Returns this panel and all its <see cref="P:Sandbox.UI.Panel.Ancestors">ancestors</see>, i.e. the <see cref="P:Sandbox.UI.Panel.Parent">Parent</see>, parent of its parent, etc.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.Ancestors">
      <summary>
            Returns all ancestors, i.e. the parent, parent of our parent, etc.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.Descendants">
      <summary>
            List of all panels that are attached to this panel, recursively, i.e. all <see cref="P:Sandbox.UI.Panel.Children">children</see> of this panel, children of those children, etc.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.IsAncestor(Sandbox.UI.Panel)">
      <summary>
            Is the given panel a parent, grandparent, etc.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.FindRootPanel">
      <summary>
            Returns the <see cref="T:Sandbox.UI.RootPanel" /> we are ultimately attached to, if any.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.FindPopupPanel">
      <summary>
            Returns the first <see cref="P:Sandbox.UI.Panel.Ancestors">ancestor</see> panel that has no parent.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.Scene">
      <summary>
            Returns the scene that this panel belongs to
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.GetChildIndex(Sandbox.UI.Panel)">
      <summary>
            Returns the index at which the given panel is <see cref="P:Sandbox.UI.Panel.Parent">parented</see> to this panel, or -1 if it is not.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.GetChild(System.Int32,System.Boolean)">
      <summary>
            Return a child at given index.
            </summary>
      <param name="index">Index at which to look.</param>
      <param name="loop">Whether to loop indices when out of bounds, i.e. -1 becomes last child, 11 becomes second child in a list of 10, etc.</param>
      <returns>Returns the requested child, or <see langword="null" /> if it was not found.</returns>
    </member>
    <member name="P:Sandbox.UI.Panel.ChildrenCount">
      <summary>
            Amount of panels directly <see cref="P:Sandbox.UI.Panel.Parent">parented</see> to this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.ChildrenOfType``1">
      <summary>
            Returns a list of <see cref="P:Sandbox.UI.Panel.Children">child panels</see> of given type.
            </summary>
      <typeparam name="T">The type of panels to retrieve.</typeparam>
    </member>
    <member name="P:Sandbox.UI.Panel.Class">
      <summary>
            A list of CSS classes applied to this panel.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Panel._class">
      <inheritdoc cref="P:Sandbox.UI.Panel.Class" />
    </member>
    <member name="P:Sandbox.UI.Panel.Classes">
      <summary>
            All CSS classes applied to this panel, separated with spaces.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.AddClass(System.String)">
      <summary>
            Adds CSS class(es) separated by spaces to this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.SetClass(System.String,System.Boolean)">
      <summary>
            Sets a specific CSS class active or not.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.FlashClass(System.String,System.Single)">
      <summary>
            Add a class for a set amount of seconds. If called multiple times, we will stomp the earlier call.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.ToggleClass(System.String)">
      <summary>
            Add a class if we don't have it, remove a class if we do have it
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.AddClasses(System.String)">
      <summary>
            Add multiple CSS classes separated by spaces to this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.RemoveClass(System.String)">
      <summary>
            Removes given CSS class from this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.HasClass(System.String)">
      <summary>
            Whether we have the given CSS class or not.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.HasClasses(System.String[])">
      <summary>
            Whether if we have <b>all</b> of these CSS classes.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.DirtyStylesRecursive">
      <summary>
            Dirty the styles on this panel
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.DirtyStylesWithStyle(Sandbox.UI.Styles,System.Boolean)">
      <summary>
            Dirty the styles of this class and its children recursively.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.BindClass(System.String,System.Func{System.Boolean})">
      <summary>
            Switch the class on or off depending on the value of the bool.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.ElementName">
      <summary>
            The element name. If you've created this Panel via a template this will be whatever the element
            name is on there. If not then it'll be the name of the class (ie Panel, Button)
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.Id">
      <summary>
            Works the same as the html id="" attribute. If you set Id to "poop", it'll match any styles
            that define #poop in their selector.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.SourceFile">
      <summary>
            If this was created by razor, this is the file in which it was created
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.SourceLine">
      <summary>
            If this was created by razor, this is the line number in the file
            </summary>
    </member>
    <member name="F:Sandbox.UI.Panel.Task">
      <summary>
            Quick access to timing events, for async/await.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Panel.StyleSheet">
      <summary>
            A collection of stylesheets applied to this panel directly.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.PseudoClass">
      <summary>
            Special flags used by the styling system for hover, active etc..
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.HasFocus">
      <summary>
            Whether this panel has the <c>:focus</c> pseudo class active.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.HasActive">
      <summary>
            Whether this panel has the <c>:active</c> pseudo class active.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.HasHovered">
      <summary>
            Whether this panel has the <c>:hover</c> pseudo class active.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.HasIntro">
      <summary>
            Whether this panel has the <c>:intro</c> pseudo class active.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.HasOutro">
      <summary>
            Whether this panel has the <c>:outro</c> pseudo class active.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnHotloaded">
      <summary>
            Called when a hotload happened. (Not necessarily on this panel)
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.AllStyleSheets">
      <summary>
            List of all <see cref="T:Sandbox.UI.StyleSheet" />s applied to this panel and all its <see cref="P:Sandbox.UI.Panel.AncestorsAndSelf">ancestors</see>.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.Switch(Sandbox.UI.PseudoClass,System.Boolean)">
      <summary>
            Switch a pseudo class on or off.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.IsVisible">
      <summary>
            Return true if this panel isn't hidden by opacity or displaymode.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.IsVisibleSelf">
      <summary>
            Return true if this panel isn't hidden by opacity or displaymode.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.Tick">
      <summary>
            Called every frame. This is your "Think" function.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnParentChanged">
      <summary>
            Called after the parent of this panel has changed.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.WantsMouseInput">
      <summary>
            Returns true if this panel would like the mouse cursor to be visible.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.ScreenPositionToPanelDelta(Vector2)">
      <summary>
            Convert a point from the screen to a point representing a delta on this panel where
            the top left is [0,0] and the bottom right is [1,1]
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.ScreenPositionToPanelPosition(Vector2)">
      <summary>
            Convert a point from the screen to a position relative to the top left of this panel
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.PanelPositionToScreenPosition(Vector2)">
      <summary>
            Convert a point from local space to screen space
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.FindInRect(Sandbox.Rect,System.Boolean)">
      <summary>
            Find and return any children of this panel (including self) within the given rect.
            </summary>
      <param name="box">The area to look for panels in, in screen-space coordinates.</param>
      <param name="fullyInside">Whether we want only the panels that are completely within the given bounds.</param>
    </member>
    <member name="P:Sandbox.UI.Panel.AllowChildSelection">
      <summary>
            Allow selecting child text
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnDragSelect(Sandbox.UI.SelectionEvent)">
      <summary>
            Called when the player moves the mouse after "press and holding" (or dragging) the panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.SelectAllInChildren">
      <summary>
            If AllowChildSelection is enabled, we'll try to select all children text
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.UnselectAllInChildren">
      <summary>
            Clear any selection in children
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.LanguageChanged">
      <summary>
            Called when the current language has changed. This allows you to rebuild
            anything that might need rebuilding. Tokenized text labels should automatically update.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.Invoke(System.Single,System.Action)">
      <summary>
            Invoke a method after a delay. If the panel is deleted before this delay the method will not be called.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.InvokeOnce(System.String,System.Single,System.Action)">
      <summary>
            Invoke a method after a delay. If the panel is deleted before this delay the method will not be called. If the invoke is called
            while the old one is waiting, the old one will be cancelled.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.CancelInvoke(System.String)">
      <summary>
            Cancel a named invocation
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.StringValue">
      <summary>
            Set via <c>"value"</c> property from HTML.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.CreateValueEvent(System.String,System.Object)">
      <summary>
            Call this when the value has changed due to user input etc. This updates any
            bindings, backwards. Also triggers $"{name}.changed" event, with value being the Value on the event.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.IsDeleting">
      <summary>
            Whether <see cref="M:Sandbox.UI.Panel.Delete(System.Boolean)" /> was called on this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.Delete(System.Boolean)">
      <summary>
            Deletes the panel.
            </summary>
      <param name="immediate">If <see langword="true" />, will skip any outros. (<c>:outro</c> CSS pseudo class)</param>
    </member>
    <member name="M:Sandbox.UI.Panel.OnDeleted">
      <summary>
            Called when the panel is about to be deleted.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnDeleteRecursive">
      <summary>
            Called on delete.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.WantsDrag">
      <summary>
            Return true if this panel wants to be dragged
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.CanDragScroll">
      <summary>
            Set this to false if you want to opt out of drag scrolling
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.FindDragTarget">
      <summary>
            Find a panel in our heirachy that wants to be dragged
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.InternalDragEvent(Sandbox.UI.DragEvent)">
      <summary>
            Distribute the drag events to specific virtual functions
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.HasScrollX">
      <summary>
            Return true if this panel is scrollable on the X axis
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.HasScrollY">
      <summary>
            Return true if this panel is scrollable on the Y axis
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.InitializeEvents">
      <summary>
            Called on creation and hotload to delete and re-initialize event listeners.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.AddEventListener(System.String,System.Action{Sandbox.UI.PanelEvent})">
      <summary>
            Runs given callback when the given event is triggered.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.AddEventListener(System.String,System.Action)">
      <summary>
            Runs given callback when the given event is triggered, without access to the <see cref="T:Sandbox.UI.PanelEvent" />.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.CreateEvent(System.String,System.Object,System.Nullable{System.Single})">
      <summary>
            Create a new event and pass it to the panels event queue.
            </summary>
      <param name="name">Event name.</param>
      <param name="value">Event value.</param>
      <param name="debounce">Time, in seconds, to wait before firing the event.<br />
            All subsequent calls to <see cref="M:Sandbox.UI.Panel.CreateEvent(System.String,System.Object,System.Nullable{System.Single})" /> with the same event
            name will update the original event instead of creating a new event, until it finally triggers.</param>
    </member>
    <member name="M:Sandbox.UI.Panel.CreateEvent(Sandbox.UI.PanelEvent)">
      <summary>
            Pass given event to the event queue.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnEvent(Sandbox.UI.PanelEvent)">
      <summary>
            Called when various <see cref="T:Sandbox.UI.PanelEvent" />s happen. Handles event listeners and many standard events by default.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnClick(Sandbox.UI.MousePanelEvent)">
      <summary>
            Called when the player releases their left mouse button (Mouse 1) while hovering this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnMiddleClick(Sandbox.UI.MousePanelEvent)">
      <summary>
            Called when the player releases their middle mouse button (Mouse 3) while hovering this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnRightClick(Sandbox.UI.MousePanelEvent)">
      <summary>
            Called when the player releases their right mouse button (Mouse 2) while hovering this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnMouseDown(Sandbox.UI.MousePanelEvent)">
      <summary>
            Called when the player presses down the left or right mouse buttons while hovering this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnMouseUp(Sandbox.UI.MousePanelEvent)">
      <summary>
            Called when the player releases left or right mouse button.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnDoubleClick(Sandbox.UI.MousePanelEvent)">
      <summary>
            Called when the player double clicks the panel with the left mouse button.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnMouseMove(Sandbox.UI.MousePanelEvent)">
      <summary>
            Called when the cursor moves while hovering this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnMouseOver(Sandbox.UI.MousePanelEvent)">
      <summary>
            Called when the cursor enters this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnMouseOut(Sandbox.UI.MousePanelEvent)">
      <summary>
            Called when the cursor leaves this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnBack(Sandbox.UI.PanelEvent)">
      <summary>
            Called when the player presses the "Back" button while hovering this panel, which is typically "mouse 5", aka one of the mouse buttons on its side.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnForward(Sandbox.UI.PanelEvent)">
      <summary>
            Called when the player presses the "Forward" button while hovering this panel, which is typically "mouse 4", aka one of the mouse buttons on its side.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnEscape(Sandbox.UI.PanelEvent)">
      <summary>
            Called when the escape key is pressed
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnFocus(Sandbox.UI.PanelEvent)">
      <summary>
            Called when this panel receives input focus.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnBlur(Sandbox.UI.PanelEvent)">
      <summary>
            Called when this panel loses input focus.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.MousePosition">
      <summary>
            Current mouse position local to this panels top left corner.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.GetTransformPosition(Vector2)">
      <summary>
            Called by <see cref="M:Sandbox.UI.PanelInput.CheckHover(Sandbox.UI.Panel,Vector2,Sandbox.UI.Panel@)" /> to transform
            the current mouse position using the panel's LocalMatrix (by default). This can be overriden for special cases.
            </summary>
      <param name="pos" />
      <returns />
    </member>
    <member name="M:Sandbox.UI.Panel.IsInside(Vector2)">
      <summary>
            Whether given screen position is within this panel. This will accurately handle border radius as well.
            </summary>
      <param name="pos">The position to test, in screen coordinates.</param>
    </member>
    <member name="M:Sandbox.UI.Panel.IsInside(Sandbox.Rect,System.Boolean)">
      <summary>
            Whether the given rect is inside this panels bounds. (<see cref="F:Sandbox.UI.Box.Rect" />)
            </summary>
      <param name="rect">The rect to test, which should have screen-space coordinates.</param>
      <param name="fullyInside">
        <see langword="true" /> to test if the given rect is completely inside the panel. <see langword="false" /> to test for an intersection.</param>
    </member>
    <member name="P:Sandbox.UI.Panel.AcceptsFocus">
      <summary>
            False by default, can this element accept keyboard focus. If an element accepts
            focus it'll be able to receive keyboard input.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.ButtonInput">
      <summary>
            Describe what to do with keyboard input. The default is InputMode.UI which means that when
            focused, this panel will receive Keys Typed and Button Events.
            If you set this to InputMode.Game, this panel will redirect its inputs to the game, which means
            for example that if you're focused on this panel and press space, it'll send the jump button to the game.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.AcceptsImeInput">
      <summary>
            False by default. Anything that is capable of accepting IME input should return true. Which is probably just a TextEntry.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.Focus">
      <summary>
            Give input focus to this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.Blur">
      <summary>
            Remove input focus from this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnButtonEvent(Sandbox.UI.ButtonEvent)">
      <summary>
            Called when any button, mouse (except for mouse4/5) and keyboard, are pressed or depressed while hovering this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnKeyTyped(System.Char)">
      <summary>
            Called when a printable character has been typed (pressed) while this panel has input focus. (<see cref="M:Sandbox.UI.Panel.Focus" />)
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnButtonTyped(Sandbox.UI.ButtonEvent)">
      <summary>
            Called when any keyboard button has been typed (pressed) while this panel has input focus. (<see cref="M:Sandbox.UI.Panel.Focus" />)
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnPaste(System.String)">
      <summary>
            Called when the user presses CTRL+V while this panel has input focus.
            </summary>
      <param name="text" />
    </member>
    <member name="M:Sandbox.UI.Panel.GetClipboardValue(System.Boolean)">
      <summary>
            If we have a value that can be copied to the clipboard, return it here.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnMouseWheel(Vector2)">
      <summary>
            Called when the player scrolls their mouse wheel while hovering this panel.
            </summary>
      <param name="value">The scroll wheel delta. Positive values are scrolling down, negative - up.</param>
    </member>
    <member name="M:Sandbox.UI.Panel.TryScroll(Vector2)">
      <summary>
            Called from <see cref="M:Sandbox.UI.Panel.OnMouseWheel(Vector2)" /> to try to scroll.
            </summary>
      <param name="value">The scroll wheel delta. Positive values are scrolling down, negative - up.</param>
      <returns>Return true to NOT propagate the event to the <see cref="P:Sandbox.UI.Panel.Parent" />.</returns>
    </member>
    <member name="M:Sandbox.UI.Panel.TryScrollToBottom">
      <summary>
            Scroll to the bottom, if the panel has scrolling enabled.
            </summary>
      <returns>Whether we scrolled to the bottom or not.</returns>
    </member>
    <member name="M:Sandbox.UI.Panel.SetMouseCapture(System.Boolean)">
      <summary>
            Captures the mouse cursor while active. The cursor will be hidden and will be stuck in place.
            <para>You will want to use <see cref="P:Sandbox.Mouse.Delta" /> in
            <see cref="M:Sandbox.UI.Panel.Tick" /> while <see cref="P:Sandbox.UI.Panel.HasMouseCapture" /> to read mouse movements.</para><para>You can call this from <see cref="M:Sandbox.UI.Panel.OnButtonEvent(Sandbox.UI.ButtonEvent)" /> for mouse clicks.</para></summary>
      <param name="b">Whether to enable or disable the capture.</param>
    </member>
    <member name="P:Sandbox.UI.Panel.HasMouseCapture">
      <summary>
            Whether this panel is capturing the mouse cursor. See <see cref="M:Sandbox.UI.Panel.SetMouseCapture(System.Boolean)" />.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.RayToLocalPosition(Ray,Vector2@,System.Single@)">
      <summary>
            Transform a ray in 3D space to a position on the panel. This is used for world panel input.
            </summary>
      <param name="ray">The ray in 3D world space to test against this panel.</param>
      <param name="position">Position on the panel where the intersection happened, local to the panel's top left corner.</param>
      <param name="distance">Distance from the ray's origin to the intersection in 3D space.</param>
      <returns>Return true if a hit/intersection was detected.</returns>
    </member>
    <member name="M:Sandbox.UI.Panel.Sandbox#Internal#IPanel#UpdateTooltip(Sandbox.Internal.IPanel)">
      <summary>
            If the tooltip text changed, we'll update it here. I haven't exposed this to game code yet
            because I doubt the usefulness to people that are manually creating tooltip panels.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.PushLayer(Sandbox.UI.PanelRenderer)">
      <summary>
            Called before rendering this panel
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.PopLayer(Sandbox.UI.PanelRenderer,Sandbox.RenderTarget)">
      <summary>
            Called after rendering this panel
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.DrawPreFilterShadows">
      <summary>
            Draws shadows for the current layer 
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.DrawPreFilterBorder">
      <summary>
            Draws borders for the current layer
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.Box">
      <summary>
            Access to various bounding boxes of this panel.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.HasContent">
      <summary>
            If true, calls <see cref="M:Sandbox.UI.Panel.DrawContent(Sandbox.UI.RenderState@)" />.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Panel.ScrollVelocity">
      <summary>
            The velocity of the current scroll
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.ScrollOffset">
      <summary>
            Offset of the panel's children position for scrolling purposes.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.ScaleToScreen">
      <summary>
            Scale of the panel on the screen.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.ScaleFromScreen">
      <summary>
            Inverse scale of <see cref="P:Sandbox.UI.Panel.ScaleToScreen" />.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.LocalMatrix">
      <summary>
            If this panel has transforms, they'll be reflected here
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.GlobalMatrix">
      <summary>
            If this panel or its parents have transforms, they'll be compounded here.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.TransformMatrix">
      <summary>
            The matrix that is applied as a result of transform: styles
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.HasBackdropFilter">
      <summary>
            The computed style has a non-default backdrop filter property
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.HasFilter">
      <summary>
            The computed style has a non-default filter property
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.HasBackground">
      <summary>
            The computed style has a renderable background
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.Opacity">
      <summary>
            The currently calculated opacity.
            This is set by multiplying our current style opacity with our parent's opacity.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnLayout(Sandbox.Rect@)">
      <summary>
            This panel has just been laid out. You can modify its position now and it will affect its children.
            This is a useful place to restrict shit to the screen etc.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.FinalLayout(Vector2)">
      <summary>
            Takes a <see cref="T:Sandbox.UI.LayoutCascade" /> and returns an outer rect
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.PreferScrollToBottom">
      <summary>
            If true, we'll try to stay scrolled to the bottom when the panel changes size
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.IsScrollAtBottom">
      <summary>
            Whether the scrolling is currently pinned to the bottom of the panel as dictated by <see cref="P:Sandbox.UI.Panel.PreferScrollToBottom" />.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.ScrollSize">
      <summary>
            The size of the scrollable area within this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.FinalLayoutChildren(Vector2)">
      <summary>
            Layout the children of this panel.
            </summary>
      <param name="offset">The parent's position.</param>
    </member>
    <member name="M:Sandbox.UI.Panel.ConstrainScrolling(Vector2)">
      <summary>
            Constrain <see cref="P:Sandbox.UI.Panel.ScrollOffset">scrolling</see> to the given size.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.PlaySound(System.String)">
      <summary>
            Play a sound from this panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.MoveAfterSibling(Sandbox.UI.Panel)">
      <summary>
            Move this panel to be after the given sibling.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.SetChildIndex(Sandbox.UI.Panel,System.Int32)">
      <summary>
            Move given child panel to be given index, where 0 is the first child.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Panel.templateBindsChanged">
      <summary>
            True when a bind has changed and OnParametersSet call is pending a call
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.SetPropertyObject(System.String,System.Object)">
      <summary>
            Same as <see cref="M:Sandbox.UI.Panel.SetProperty(System.String,System.String)" />, but first tries to set the property on the panel object, then process any special properties such as <c>class</c>.
            </summary>
      <inheritdoc cref="M:Sandbox.UI.Panel.SetProperty(System.String,System.String)" />
    </member>
    <member name="M:Sandbox.UI.Panel.SetProperty(System.String,System.String)">
      <summary>
            Set a property on the panel, such as special properties (<c>class</c>, <c>id</c>, <c>style</c> and <c>value</c>, etc.) and properties of the panel's C# class.
            </summary>
      <param name="name">name of the property to modify.</param>
      <param name="value">Value to assign to the property.</param>
    </member>
    <member name="M:Sandbox.UI.Panel.SetAttribute(System.String,System.String)">
      <summary>
            Used in templates, gets an attribute that was set in the template.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.GetAttribute(System.String,System.String)">
      <summary>
            Used in templates, try to get the attribute that was set in creation.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.Bind(System.String,System.Object,System.String)">
      <summary>
             Bind property of this panel to the value of a property of a given panel.
            
             When our property changes due to the bind, <see cref="M:Sandbox.UI.Panel.OnParametersSet" /> will be called.
             </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnParametersSet">
      <summary>
            Called after all templated panel binds have been set.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnParametersSetAsync">
      <summary>
            Called after all templated panel binds have been set.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.SetContent(System.String)">
      <summary>
            Called by the templating system when an element has content between its tags.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Panel.razorTreeDirty">
      <summary>
            true when the tree should be re-rendered next frame.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.StateHasChanged">
      <summary>
            For razor panels, call when the state of the render tree has changed such that
            it would be a good idea to re-render the tree. You would usually not need to call
            this manually.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.GetRenderTreeChecksum">
      <summary>
            Overridden/implemented by Razor templating, contains render tree checksum to determine when the render tree content has changed.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder)">
      <summary>
            Overridden/implemented by Razor templating to build a render tree.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.BuildHash">
      <summary>
            By overriding this you can return a hash of variables used by the Razor layout, which
            will cause a rebuild when changed. This is useful when your layout uses a global variable
            because by adding it to a HashCode.Combine here you can easily trigger a build when it changes.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnRenderFragmentChanged(Sandbox.UI.Panel)">
      <summary>
            A RenderFragment has been set on us, so our tree has potential changes now.
            Lets update and see.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.InternalRenderTree">
      <summary>
            Allows building render tree from outside of the class.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.OnAfterTreeRender(System.Boolean)">
      <summary>
            Called after the razor tree has been created/rendered.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.ClearRenderTree">
      <summary>
            Delete all children generated by the Razor render tree.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.DrawContent(Sandbox.UI.RenderState@)">
      <summary>
            Called when <see cref="P:Sandbox.UI.Panel.HasContent" /> is set to <see langword="true" /> to custom draw the panels content.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.DrawBackground(Sandbox.UI.RenderState@)">
      <summary>
            Called to draw the panels background.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.ComputedStyle">
      <summary>
            This is the style that we computed last. If you're looking to see which
            styles are set on this panel then this is what you're looking for.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.ActiveStyleBlocks">
      <summary>
            A importance sorted list of style blocks that are active on this panel
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.Style">
      <summary>
            Allows you to set styles specifically on this panel. Setting the style will
            only affect this panel and no others and will override any other styles.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.TryFindKeyframe(System.String,Sandbox.UI.KeyFrames@)">
      <summary>
            Try to find <c>@keyframes</c> CSS rule with given name in <see cref="P:Sandbox.UI.Panel.AllStyleSheets" />.
            </summary>
      <param name="name">The name to search for.</param>
      <param name="keyframes">The keyframes, if any are found, or <see langword="null" />.</param>
      <returns>
        <see langword="true" /> if <c>@keyframes</c> with given name were found.</returns>
    </member>
    <member name="M:Sandbox.UI.Panel.StyleSelectorsChanged(System.Boolean,System.Boolean,Sandbox.UI.RootPanel)">
      <summary>
            Should be called when something happens that means that this panel's stylesheets need to be
            re-evaluated. Like becoming hovered or classes changed. You don't call this when changing styles
            directly on the panel, just on anything that will change which stylesheets should get selected.
            </summary>
      <param name="ancestors">Also re-evaluate all ancestor panels. (for <c>:has()</c>)</param>
      <param name="descendants">Also re-evaluate all child panels. (for parent selectors)</param>
      <param name="root">Root panel cache so we don't need to keep looking it up.</param>
    </member>
    <member name="M:Sandbox.UI.Panel.LoadStyleSheetFromAttribute">
      <summary>
            Loads a stylesheet from one specified within a [StyleSheet] attribute.
            </summary>
      <returns>True if the attribute exists and we loaded from it, otherwise false</returns>
    </member>
    <member name="M:Sandbox.UI.Panel.LoadStyleSheetAuto">
      <summary>
            Loads a stylesheet from one based on the class name.
            </summary>
      <returns>True if the attribute exists and we loaded from it, otherwise false</returns>
    </member>
    <member name="M:Sandbox.UI.Panel.LoadStyleSheetFromPath(System.String,System.Boolean)">
      <summary>
            Loads a stylesheet from the specified path.
            </summary>
      <param name="path">The path to the stylesheet.</param>
      <param name="checkExists">Do we want to check if the file exists beforehand so we can return gracefully?</param>
      <returns>True if the stylesheet was loaded successfully, otherwise false</returns>
    </member>
    <member name="M:Sandbox.UI.Panel.OnTemplateSlot(Sandbox.Html.INode,System.String,Sandbox.UI.Panel)">
      <summary>
            TODO: Obsolete this and instead maybe we have something like [PanelSlot( "slotname" )] that 
            is applied on properties. Then when we find a slot="slotname" we chase up the heirachy and set the property.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.Tooltip">
      <summary>
            A string to show when hovering over this panel.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.TooltipClass">
      <summary>
            The created tooltip element will have this class, if set.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.HasTooltip">
      <summary>
            You should override and return true if you're overriding <see cref="M:Sandbox.UI.Panel.CreateTooltipPanel" />.
            Otherwise this will return true if <see cref="P:Sandbox.UI.Panel.Tooltip" /> is not empty.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.CreateTooltipPanel">
      <summary>
            Create a tooltip panel. You can override this to create a custom tooltip panel.<br />
            If you're overriding this and not setting <see cref="P:Sandbox.UI.Panel.Tooltip" />, then you must override and return true in <see cref="P:Sandbox.UI.Panel.HasTooltip" />.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.Transitions">
      <summary>
            Handles the storage, progression and application of CSS transitions.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.HasActiveTransitions">
      <summary>
            Returns true if this panel has any active CSS transitions.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Panel.SkipTransitions">
      <summary>
            Any transitions running, or about to run, will jump straight to the end.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.UserData">
      <summary>
            Can be used to store random data without sub-classing the panel.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Panel.DeletionToken">
      <summary>
            Get a token that is cancelled when the panel is deleted
            </summary>
    </member>
    <member name="T:Sandbox.UI.Box">
      <summary>
            Represents position and size of a <see cref="T:Sandbox.UI.Panel" /> on the screen.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Box.RectOuter">
      <summary>
            Position and size of the element on the screen, <b>including both - its padding AND margin</b>.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Box.RectInner">
      <summary>
            Position and size of only the element's inner content on the screen, <i>without padding OR margin</i>.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Box.Padding">
      <summary>
            The size of padding.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Box.Border">
      <summary>
            The size of border.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Box.Margin">
      <summary>
            The size of border.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Box.Rect">
      <summary>
            Position and size of the element on the screen, <b>including its padding</b>, <i>but not margin</i>.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Box.ClipRect">
      <summary>
        <see cref="F:Sandbox.UI.Box.Rect" /> minus the border sizes.
            Used internally to "clip" (hide) everything outside of these bounds, if the panels <see cref="T:Sandbox.UI.OverflowMode" /> is not set to <see cref="F:Sandbox.UI.OverflowMode.Visible" />.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Box.Left">
      <summary>
            Position of the left edge in screen coordinates.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Box.Right">
      <summary>
            Position of the right edge in screen coordinates.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Box.Top">
      <summary>
            Position of the top edge in screen coordinates.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Box.Bottom">
      <summary>
            Position of the bottom edge in screen coordinates.
            </summary>
    </member>
    <member name="M:Sandbox.UI.StyleParser.ParseStyles(Sandbox.Parse@,Sandbox.UI.Styles,System.Boolean)">
      <summary>
            Parse the styles as you would if they were passed in an style="width: 100px" attribute
            </summary>
    </member>
    <member name="M:Sandbox.UI.StyleParser.Selector(System.String,Sandbox.UI.StyleBlock)">
      <summary>
            Here we divide the selectors into groups
            .fucker, .cocks, .hairy
            </summary>
    </member>
    <member name="M:Sandbox.UI.StyleParser.ParseSingleSelector(System.String,Sandbox.UI.StyleBlock)">
      <summary>
            Parse a single rule, which as "panel.closed.error:hover"
            </summary>
      <returns />
    </member>
    <member name="F:Sandbox.UI.PanelRenderer.Scissor">
      <summary>
            Software scissor, panels outside of this should not be rendered
            </summary>
    </member>
    <member name="F:Sandbox.UI.PanelRenderer.ScissorGPU">
      <summary>
            Scissor passed to gpu shader to be transformed
            </summary>
    </member>
    <member name="M:Sandbox.UI.PanelRenderer.ShouldEarlyCull(Sandbox.UI.Panel)">
      <summary>
            Quick check to see if a panel should be culled based on the current scissor
            </summary>
    </member>
    <member name="M:Sandbox.UI.PanelRenderer.Render(Sandbox.UI.Panel,Sandbox.UI.RenderState)">
      <summary>
            Render a panel
            </summary>
    </member>
    <member name="M:Sandbox.UI.PanelRenderer.PopLayer(Sandbox.UI.Panel,Sandbox.RenderTarget)">
      <returns>Will return <c>false</c> if we're at the top of the layer stack.</returns>
    </member>
    <member name="M:Sandbox.UI.PanelRenderer.DrawBoxShadows(Sandbox.UI.Panel,Sandbox.UI.RenderState@,System.Boolean)">
      <summary>
            Draw the outset box shadows - this is called *before* drawing the background
            </summary>
    </member>
    <member name="T:Sandbox.UI.RootPanel">
      <summary>
            A root panel. Serves as a container for other panels, handles things such as rendering.
            </summary>
    </member>
    <member name="P:Sandbox.UI.RootPanel.PanelBounds">
      <summary>
            Bounds of the panel, i.e. its size and position on the screen.
            </summary>
    </member>
    <member name="P:Sandbox.UI.RootPanel.ChildrenWantMouseInput">
      <summary>
            If any of our panels are visible and want mouse input (pointer-events != none) then
            this will be set to true.
            </summary>
    </member>
    <member name="P:Sandbox.UI.RootPanel.Scale">
      <summary>
            The scale of this panel and its children.
            </summary>
    </member>
    <member name="P:Sandbox.UI.RootPanel.RenderedManually">
      <summary>
            If set to true this panel won't be rendered to the screen like a normal panel.
            This is true when the panel is drawn via other means (like as a world panel).
            </summary>
    </member>
    <member name="P:Sandbox.UI.RootPanel.IsWorldPanel">
      <summary>
            True if this is a world panel, so should be skipped when determining cursor visibility etc
            </summary>
    </member>
    <member name="P:Sandbox.UI.RootPanel.IsVR">
      <summary>
            If this panel belongs to a VR overlay
            </summary>
    </member>
    <member name="P:Sandbox.UI.RootPanel.IsHighQualityVR">
      <summary>
            If this panel should be rendered with ~4K resolution.
            </summary>
    </member>
    <member name="M:Sandbox.UI.RootPanel.Layout">
      <summary>
            This is called from tests to emulate the regular root panel simulate loop
            </summary>
    </member>
    <member name="M:Sandbox.UI.RootPanel.UpdateBounds(Sandbox.Rect)">
      <summary>
            Called before layout to lock the bounds of this root panel to the screen size (which is passed).
            Internally this sets PanelBounds to rect and calls UpdateScale.
            </summary>
    </member>
    <member name="M:Sandbox.UI.RootPanel.UpdateScale(Sandbox.Rect)">
      <summary>
            Work out scaling here. Default is to scale relative to the screen being
            1920 wide. ie - scale = screensize.Width / 1920.0f;
            </summary>
    </member>
    <member name="M:Sandbox.UI.RootPanel.RenderManual(System.Single)">
      <summary>
            Render this panel manually. This gives more flexibility to where UI is rendered, to texture for example.
            <see cref="P:Sandbox.UI.RootPanel.RenderedManually" /> must be set to true.
            </summary>
    </member>
    <member name="F:Sandbox.UI.RootPanel.styleRuleUpdates">
      <summary>
            A list of panels that are waiting to have their styles re-evaluated
            </summary>
    </member>
    <member name="M:Sandbox.UI.RootPanel.AddToBuildStyleRulesList(Sandbox.UI.Panel)">
      <summary>
            Add this panel to a list to have their styles re-evaluated. This should be done any
            time the panel changes in a way that could affect its style selector.. like if its child
            index changed, or classes added or removed, or became hovered etc.
            </summary>
    </member>
    <member name="M:Sandbox.UI.RootPanel.BuildStyleRules">
      <summary>
            Run through all panels that are pending a re-check on their style rules.
            Only properly invalidate them if their rules actually change.
            </summary>
    </member>
    <member name="T:Sandbox.UI.StyleBlock">
      <summary>
            A CSS rule - ie ".chin { width: 100%; height: 100%; }"
            </summary>
    </member>
    <member name="P:Sandbox.UI.StyleBlock.Selectors">
      <summary>
            A list of appropriate selectors for this block (ie ".button")
            </summary>
    </member>
    <member name="P:Sandbox.UI.StyleBlock.SelectorStrings">
      <summary>
            A list of selectors for this block
            </summary>
    </member>
    <member name="M:Sandbox.UI.StyleBlock.GetRawValues">
      <summary>
            Get the list of raw style values
            </summary>
    </member>
    <member name="M:Sandbox.UI.StyleBlock.SetRawValue(System.String,System.String,System.String)">
      <summary>
            Update a raw style value
            </summary>
    </member>
    <member name="P:Sandbox.UI.StyleBlock.FileName">
      <summary>
            The filename of the file containing this style block (or null if none)
            </summary>
    </member>
    <member name="P:Sandbox.UI.StyleBlock.AbsolutePath">
      <summary>
            The absolute on disk filename for this style block (or null if not on disk)
            </summary>
    </member>
    <member name="P:Sandbox.UI.StyleBlock.FileLine">
      <summary>
            The line in the file containing this style block
            </summary>
    </member>
    <member name="F:Sandbox.UI.StyleBlock.Styles">
      <summary>
            The styles that are defined in this block
            </summary>
    </member>
    <member name="M:Sandbox.UI.StyleBlock.TestBroadphase(Sandbox.UI.IStyleTarget)">
      <summary>
            Tests a few broadphase conditions to build a list of feasible
            styleblocks tailored for a panel.
            </summary>
    </member>
    <member name="T:Sandbox.UI.Styles">
      <summary>
            Represents all supported CSS properties and their currently assigned values.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Styles.ResetAnimation">
      <summary>
            Stops the animation. If we have animation vars we'll start again.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Styles.StartAnimation(System.String,System.Single,System.Int32,System.Single,System.String,System.String,System.String)">
      <summary>
            Stop any previous animations and start this one. Make it last this long.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Styles.HasTransitions">
      <summary>
            Whether this style sheet has any transitions that would need to be run.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Styles.Transitions">
      <summary>
            List of transitions this style sheet has.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Styles.BuildTransformMatrix(Vector2)">
      <summary>
            Creates a matrix based on this style's "transform" and other related properties
            </summary>
    </member>
    <member name="M:Sandbox.UI.Styles.MarkPanelsDirty">
      <summary>
            Try to find all panels using this style and mark them dirty so they'll
            redraw with the style. This should be called when the style is changed. Which
            is only technically when done via the editor.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Styles.SetImage(System.String,System.Func{System.Lazy{Sandbox.Texture},System.Boolean},System.Func{System.String,System.Boolean},System.Func{System.String,System.Boolean},System.Func{System.Single,System.Boolean})">
      <param name="value" />
      <param name="setImage">Optional</param>
      <param name="setSize">Optional</param>
      <param name="setRepeat">Optional</param>
      <param name="setAngle">Optional</param>
    </member>
    <member name="T:Sandbox.UI.StyleSelector">
      <summary>
            A CSS selector like "Panel.button.red:hover .text"
            </summary>
    </member>
    <member name="P:Sandbox.UI.StyleSelector.Id">
      <summary>
            The Id selector - minus the #
            https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors
            </summary>
    </member>
    <member name="F:Sandbox.UI.StyleSelector.Parent">
      <summary>
            Descendant combinator
            A B
            Child combinator
            A &gt; B
            Adjacent sibling combinator
            A + B
            General sibling combinator
            A ~B
            </summary>
    </member>
    <member name="F:Sandbox.UI.StyleSelector.UniversalSelector">
      <summary>
            True if this has a universal selector (*)
            </summary>
    </member>
    <member name="M:Sandbox.UI.StyleSheet.InitStyleSheets">
      <summary>
            Between sessions we clear the stylesheets, so one gamemode can't accidentally
            use cached values from another.
            </summary>
    </member>
    <member name="M:Sandbox.UI.StyleSheet.Release">
      <summary>
            Releases the filesystem watcher so we won't get file changed events.
            </summary>
    </member>
    <member name="T:Sandbox.UI.StyleSheetCollection">
      <summary>
            A collection of <see cref="T:Sandbox.UI.StyleSheet" /> objects applied directly to a panel.
            See <see cref="F:Sandbox.UI.Panel.StyleSheet" />.
            </summary>
    </member>
    <member name="M:Sandbox.UI.StyleSheetCollection.Add(Sandbox.UI.StyleSheet)">
      <summary>
            Add a stylesheet directly
            </summary>
    </member>
    <member name="M:Sandbox.UI.StyleSheetCollection.Load(System.String,System.Boolean)">
      <summary>
            Load the stylesheet from a file.
            </summary>
    </member>
    <member name="M:Sandbox.UI.StyleSheetCollection.Parse(System.String,System.Boolean)">
      <summary>
            Load the stylesheet from a string.
            </summary>
    </member>
    <member name="M:Sandbox.UI.StyleSheetCollection.Remove(Sandbox.UI.StyleSheet)">
      <summary>
            Remove a specific <see cref="T:Sandbox.UI.StyleSheet" /> from the collection.
            </summary>
    </member>
    <member name="M:Sandbox.UI.StyleSheetCollection.Remove(System.String)">
      <summary>
            Remove all stylesheets whose filename matches this wildcard glob.
            </summary>
    </member>
    <member name="M:Sandbox.UI.StyleSheetCollection.CollectVariables">
      <summary>
            Returns all CSS variables from the owning panel and its ancestors.
            </summary>
    </member>
    <member name="T:Sandbox.UI.Transitions">
      <summary>
            Handles the storage, progression and application of CSS transitions for a single <see cref="T:Sandbox.UI.Panel" />.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Transitions.Entries">
      <summary>
            Active CSS transitions.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Transitions.HasAny">
      <summary>
            Whether there are any active CSS transitions.
            </summary>
    </member>
    <member name="T:Sandbox.UI.WorldPanel">
      <summary>
            An interactive 2D panel rendered in the 3D world.
            </summary>
    </member>
    <member name="P:Sandbox.UI.WorldPanel.SceneObject">
      <summary>
            Scene object that renders the panel.
            </summary>
    </member>
    <member name="P:Sandbox.UI.WorldPanel.Transform">
      <summary>
            Transform of the world panel in 3D space.
            </summary>
    </member>
    <member name="P:Sandbox.UI.WorldPanel.Tags">
      <summary>
            Tags that are applied to the underlying SceneObject
            </summary>
    </member>
    <member name="P:Sandbox.UI.WorldPanel.Position">
      <summary>
            Position of the world panel in 3D space.
            </summary>
    </member>
    <member name="P:Sandbox.UI.WorldPanel.Rotation">
      <summary>
            Rotation of the world panel in 3D space.
            </summary>
    </member>
    <member name="P:Sandbox.UI.WorldPanel.WorldScale">
      <summary>
            Scale of the world panel in 3D space.
            </summary>
    </member>
    <member name="P:Sandbox.UI.WorldPanel.MaxInteractionDistance">
      <summary>
            Maximum distance at which a player can interact with this world panel.
            </summary>
    </member>
    <member name="M:Sandbox.UI.WorldPanel.UpdateBounds(Sandbox.Rect)">
      <summary>
            Update the bounds for this panel. We purposely do nothing here because
            on world panels you can change the bounds by setting <see cref="P:Sandbox.UI.RootPanel.PanelBounds" />.
            </summary>
    </member>
    <member name="M:Sandbox.UI.WorldPanel.UpdateScale(Sandbox.Rect)">
      <summary>
            We override this to prevent the scale automatically being set based on screen
            size changing.. because that's obviously not needed here.
            </summary>
    </member>
    <member name="M:Sandbox.UISystem.AddDeferredDeletion(Sandbox.UI.Panel)">
      <summary>
            This panel should get deleted at some point
            </summary>
    </member>
    <member name="M:Sandbox.UISystem.RunDeferredDeletion(System.Boolean)">
      <summary>
            Delete all panels that were deferred and are no longer playing outro transitions
            </summary>
    </member>
    <member name="T:Sandbox.ScenePanelObject">
      <summary>
            Renders a panel in a scene world. You are probably looking for <a href="https://sbox.game/api/Sandbox.UI.WorldPanel">WorldPanel</a>.
            </summary>
    </member>
    <member name="F:Sandbox.ScenePanelObject.ScreenToWorldScale">
      <summary>
            Global scale for panel rendering within a scene world.
            </summary>
    </member>
    <member name="P:Sandbox.ScenePanelObject.Panel">
      <summary>
            The panel that will be rendered.
            </summary>
    </member>
    <member name="T:Sandbox.DamageInfo">
      <summary>
            Describes the damage that should be done to something. This is purposefully a class
            so it can be derived from, allowing games to create their own special types of damage, while
            not having to create a whole new system.
            </summary>
    </member>
    <member name="P:Sandbox.DamageInfo.Attacker">
      <summary>
            Usually a player or Npc
            </summary>
    </member>
    <member name="P:Sandbox.DamageInfo.Weapon">
      <summary>
            The weapon that did the damage, or a vehicle etc
            </summary>
    </member>
    <member name="P:Sandbox.DamageInfo.Hitbox">
      <summary>
            The hitbox that we hit (if any)
            </summary>
    </member>
    <member name="P:Sandbox.DamageInfo.Damage">
      <summary>
            Amount of damage this should do
            </summary>
    </member>
    <member name="P:Sandbox.DamageInfo.Position">
      <summary>
            The location of the damage
            </summary>
    </member>
    <member name="P:Sandbox.DamageInfo.Shape">
      <summary>
            The physics shape that we hit (if any)
            </summary>
    </member>
    <member name="P:Sandbox.DamageInfo.Tags">
      <summary>
            Tags for this damage, allows you to enter and read different damage types etc
            </summary>
    </member>
    <member name="P:Sandbox.DamageInfo.IsExplosion">
      <summary>
            True if this is explosive damage
            </summary>
    </member>
    <member name="T:Sandbox.Utility.EditorTools">
      <summary>
            Functions to interact with the tools system. Does nothing if tools aren't enabled.
            </summary>
    </member>
    <member name="P:Sandbox.Utility.EditorTools.InspectorObject">
      <summary>
            Set the object to be inspected by the inspector in the editor
            </summary>
    </member>
    <member name="T:Sandbox.Language">
      <summary>
            Allows access to translated phrases, allowing the translation of gamemodes etc
            </summary>
    </member>
    <member name="P:Sandbox.Language.SelectedCode">
      <summary>
            The abbreviation for the language the user wants. This is set by the user in the options menu.
            </summary>
    </member>
    <member name="P:Sandbox.Language.Current">
      <summary>
            Information about the current selected language. Will default to English if the current language isn't found.
            </summary>
    </member>
    <member name="M:Sandbox.Language.OnFileChanged">
      <summary>
            Called when a localization file has changed (and we should reload)
            </summary>
    </member>
    <member name="M:Sandbox.Language.GetPhrase(System.String)">
      <summary>
            Lookup a phrase
            </summary>
      <param name="textToken">The token used to identify the phrase</param>
      <returns>If found will return the phrase, else will return the token itself</returns>
    </member>
    <member name="M:Sandbox.Language.GetPhrase(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
      <summary>
            Look up a phrase
            </summary>
      <param name="textToken">The token used to identify the phrase</param>
      <param name="data">Key values of data used by the string. Example: {Variable} -&gt; { "Variable", someVar }</param>
      <returns>If found will return the phrase, else will return the token itself</returns>
    </member>
    <member name="T:Sandbox.Mouse">
      <summary>
            Gives access to mouse position etc
            </summary>
    </member>
    <member name="M:Sandbox.Mouse.Frame">
      <summary>
            Called once per frame
            </summary>
    </member>
    <member name="P:Sandbox.Mouse.Position">
      <summary>
            Access to local clients' cursor position, relative to game windows' top left corner.
            </summary>
    </member>
    <member name="P:Sandbox.Mouse.Delta">
      <summary>
            Change in local clients' cursor position since last frame.
            </summary>
    </member>
    <member name="P:Sandbox.Mouse.CursorType">
      <summary>
            Sets the cursor type until another panel stomps this value.
            Doesn't affect main menu.
            </summary>
    </member>
    <member name="P:Sandbox.Mouse.Active">
      <summary>
            Whether the local clients' cursor is active or not, meaning it can interact with UI elements, etc.
            </summary>
    </member>
    <member name="P:Sandbox.Mouse.Visible">
      <summary>
            DEPRECATED. Use Mouse.Visibility instead.
            </summary>
    </member>
    <member name="P:Sandbox.Mouse.Visibility">
      <summary>
            The visibility state of the mouse cursor. Auto will only show the mouse when clickable UI elements are visible.
            </summary>
    </member>
    <member name="T:Sandbox.MouseVisibility">
      <summary>
            The visibility state of the mouse cursor.
            </summary>
    </member>
    <member name="F:Sandbox.MouseVisibility.Visible">
      <summary>
            The mouse is visible and can interact with UI elements.
            </summary>
    </member>
    <member name="F:Sandbox.MouseVisibility.Auto">
      <summary>
            The mouse is only visible when UI elements with `pointer-events: auto` are on-screen.
            </summary>
    </member>
    <member name="F:Sandbox.MouseVisibility.Hidden">
      <summary>
            The mouse is locked to the game and cannot interact with UI elements.
            </summary>
    </member>
    <member name="T:Sandbox.ReflectionQueryCache">
      <summary>
            We cache results for some expensive reflection queries.
            This results in large performance improvements during various operations (Cloning, NetworkSpawn, Serilization...)
            </summary>
    </member>
    <member name="M:Sandbox.ReflectionQueryCache.ClearTypeCache">
      <summary>
            Clears the type cache, called after HotLoad and after a game ended.
            Called from EditorUtilities.ClearCloneTypeCache and Game.Close
            </summary>
    </member>
    <member name="M:Sandbox.ReflectionQueryCache.OrderedSerializableMembers(System.Type)">
      <summary>
            Returns all properties and fields that should be (de)serialized.
            Also sorts the members for historic reasons.
            </summary>
    </member>
    <member name="M:Sandbox.ReflectionQueryCache.RequiredComponentMembers(System.Type)">
      <summary>
            Returns all properties that have a [RequireComponent] attribute.
            </summary>
    </member>
    <member name="M:Sandbox.ReflectionQueryCache.SyncProperties(System.Type)">
      <summary>
            Returns all properties that have a [Sync] attribute.
            </summary>
    </member>
    <member name="M:Sandbox.ReflectionQueryCache.IsTypeCloneableByCopy(System.Type)">
      <summary>
            Determines if a type can be cloned by a simple copy.
            This recursevly walks through all properties and fields of the type to determine if they are cloneable by copy.
            Since this is fairly expensive, we cache the results for each type.
            </summary>
    </member>
    <member name="M:Sandbox.ResourceLoader.LoadGameResource(System.String)">
      <summary>
            garry: why the fuck does this exist
            garry: fuck me why the fuck does this exist
            </summary>
    </member>
    <member name="T:Sandbox.GameTask">
      <summary>
            A generic <see cref="T:Sandbox.TaskSource" />.
            </summary>
    </member>
    <member name="M:Sandbox.GameTask.Yield">
      <inheritdoc cref="M:Sandbox.TaskSource.Yield" />
    </member>
    <member name="M:Sandbox.GameTask.Delay(System.Int32)">
      <inheritdoc cref="M:Sandbox.TaskSource.Delay(System.Int32)" />
    </member>
    <member name="M:Sandbox.GameTask.Delay(System.Int32,System.Threading.CancellationToken)">
      <inheritdoc cref="M:Sandbox.TaskSource.Delay(System.Int32,System.Threading.CancellationToken)" />
    </member>
    <member name="M:Sandbox.GameTask.DelaySeconds(System.Single)">
      <inheritdoc cref="M:Sandbox.TaskSource.DelaySeconds(System.Single)" />
    </member>
    <member name="M:Sandbox.GameTask.DelaySeconds(System.Single,System.Threading.CancellationToken)">
      <inheritdoc cref="M:Sandbox.TaskSource.DelaySeconds(System.Single,System.Threading.CancellationToken)" />
    </member>
    <member name="M:Sandbox.GameTask.DelayRealtime(System.Int32)">
      <inheritdoc cref="M:Sandbox.TaskSource.DelayRealtime(System.Int32)" />
    </member>
    <member name="M:Sandbox.GameTask.DelayRealtime(System.Int32,System.Threading.CancellationToken)">
      <inheritdoc cref="M:Sandbox.TaskSource.DelayRealtime(System.Int32,System.Threading.CancellationToken)" />
    </member>
    <member name="M:Sandbox.GameTask.DelayRealtimeSeconds(System.Single)">
      <inheritdoc cref="M:Sandbox.TaskSource.DelayRealtimeSeconds(System.Single)" />
    </member>
    <member name="M:Sandbox.GameTask.DelayRealtimeSeconds(System.Single,System.Threading.CancellationToken)">
      <inheritdoc cref="M:Sandbox.TaskSource.DelayRealtimeSeconds(System.Single,System.Threading.CancellationToken)" />
    </member>
    <member name="M:Sandbox.GameTask.RunInThreadAsync(System.Action)">
      <inheritdoc cref="M:Sandbox.TaskSource.RunInThreadAsync(System.Action)" />
    </member>
    <member name="M:Sandbox.GameTask.RunInThreadAsync``1(System.Func{``0})">
      <inheritdoc cref="M:Sandbox.TaskSource.RunInThreadAsync``1(System.Func{``0})" />
    </member>
    <member name="M:Sandbox.GameTask.RunInThreadAsync(System.Func{System.Threading.Tasks.Task})">
      <inheritdoc cref="M:Sandbox.TaskSource.RunInThreadAsync(System.Func{System.Threading.Tasks.Task})" />
    </member>
    <member name="M:Sandbox.GameTask.RunInThreadAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
      <inheritdoc cref="M:Sandbox.TaskSource.RunInThreadAsync``1(System.Func{System.Threading.Tasks.Task{``0}})" />
    </member>
    <member name="P:Sandbox.GameTask.CompletedTask">
      <inheritdoc cref="P:Sandbox.TaskSource.CompletedTask" />
    </member>
    <member name="M:Sandbox.GameTask.FromResult``1(``0)">
      <inheritdoc cref="M:Sandbox.TaskSource.FromResult``1(``0)" />
    </member>
    <member name="M:Sandbox.GameTask.WhenAll(System.Threading.Tasks.Task[])">
      <inheritdoc cref="M:Sandbox.TaskSource.WhenAll(System.Threading.Tasks.Task[])" />
    </member>
    <member name="M:Sandbox.GameTask.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
      <inheritdoc cref="M:Sandbox.TaskSource.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
    </member>
    <member name="M:Sandbox.GameTask.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
      <inheritdoc cref="M:Sandbox.TaskSource.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
    </member>
    <member name="M:Sandbox.GameTask.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
      <inheritdoc cref="M:Sandbox.TaskSource.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
    </member>
    <member name="M:Sandbox.GameTask.WhenAny(System.Threading.Tasks.Task[])">
      <inheritdoc cref="M:Sandbox.TaskSource.WhenAny(System.Threading.Tasks.Task[])" />
    </member>
    <member name="M:Sandbox.GameTask.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
      <inheritdoc cref="M:Sandbox.TaskSource.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
    </member>
    <member name="M:Sandbox.GameTask.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
      <inheritdoc cref="M:Sandbox.TaskSource.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
    </member>
    <member name="M:Sandbox.GameTask.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
      <inheritdoc cref="M:Sandbox.TaskSource.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
    </member>
    <member name="M:Sandbox.GameTask.WaitAll(System.Threading.Tasks.Task[])">
      <inheritdoc cref="M:Sandbox.TaskSource.WaitAll(System.Threading.Tasks.Task[])" />
    </member>
    <member name="M:Sandbox.GameTask.WaitAny(System.Threading.Tasks.Task[])">
      <inheritdoc cref="M:Sandbox.TaskSource.WaitAny(System.Threading.Tasks.Task[])" />
    </member>
    <member name="M:Sandbox.GameTask.MainThread">
      <inheritdoc cref="M:Sandbox.TaskSource.MainThread" />
    </member>
    <member name="M:Sandbox.GameTask.MainThread(System.Threading.CancellationToken)">
      <inheritdoc cref="M:Sandbox.TaskSource.MainThread" />
    </member>
    <member name="M:Sandbox.GameTask.WorkerThread">
      <inheritdoc cref="M:Sandbox.TaskSource.WorkerThread" />
    </member>
    <member name="M:Sandbox.GameTask.WorkerThread(System.Threading.CancellationToken)">
      <inheritdoc cref="M:Sandbox.TaskSource.WorkerThread" />
    </member>
    <member name="T:Sandbox.TaskSource">
      <summary>
            Provides a way for us to cancel tasks after common async shit is executed.
            </summary>
    </member>
    <member name="M:Sandbox.TaskSource.CreateLinkedTokenSource">
      <summary>
            Create a token source, which will also be cancelled when sessions end
            </summary>
    </member>
    <member name="P:Sandbox.TaskSource.IsValid">
      <inheritdoc cref="P:Sandbox.IValid.IsValid" />
    </member>
    <member name="M:Sandbox.TaskSource.Expire">
      <summary>
            Marks this task source as invalid. All associated running tasks will be canceled ASAP.
            </summary>
    </member>
    <member name="M:Sandbox.TaskSource.Delay(System.Int32)">
      <summary>
            A task that does nothing for given amount of time in milliseconds.
            </summary>
      <param name="ms">Time to wait in milliseconds.</param>
    </member>
    <member name="M:Sandbox.TaskSource.Delay(System.Int32,System.Threading.CancellationToken)">
      <summary>
            A task that does nothing for given amount of time in milliseconds.
            </summary>
      <param name="ms">Time to wait in milliseconds.</param>
      <param name="ct">Token to cancel the delay early.</param>
    </member>
    <member name="M:Sandbox.TaskSource.DelaySeconds(System.Single)">
      <summary>
            A task that does nothing for given amount of time in seconds.
            </summary>
      <param name="seconds">&gt;Time to wait in seconds.</param>
    </member>
    <member name="M:Sandbox.TaskSource.DelaySeconds(System.Single,System.Threading.CancellationToken)">
      <summary>
            A task that does nothing for given amount of time in seconds.
            </summary>
      <param name="seconds">&gt;Time to wait in seconds.</param>
      <param name="ct">Token to cancel the delay early.</param>
    </member>
    <member name="M:Sandbox.TaskSource.MainThread">
      <summary>
            Continues on the main thread.
            </summary>
    </member>
    <member name="M:Sandbox.TaskSource.WorkerThread">
      <summary>
            Continues on a worker thread.
            </summary>
    </member>
    <member name="P:Sandbox.TaskSource.CompletedTask">
      <inheritdoc cref="P:System.Threading.Tasks.Task.CompletedTask" />
    </member>
    <member name="M:Sandbox.TaskSource.FromResult``1(``0)">
      <inheritdoc cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
    </member>
    <member name="M:Sandbox.TaskSource.FromCanceled(System.Threading.CancellationToken)">
      <inheritdoc cref="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
    </member>
    <member name="M:Sandbox.TaskSource.FromException(System.Exception)">
      <inheritdoc cref="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
    </member>
    <member name="M:Sandbox.TaskSource.WhenAll(System.Threading.Tasks.Task[])">
      <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
    </member>
    <member name="M:Sandbox.TaskSource.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
      <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
    </member>
    <member name="M:Sandbox.TaskSource.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
      <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
    </member>
    <member name="M:Sandbox.TaskSource.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
      <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
    </member>
    <member name="M:Sandbox.TaskSource.WhenAny(System.Threading.Tasks.Task[])">
      <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
    </member>
    <member name="M:Sandbox.TaskSource.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
      <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
    </member>
    <member name="M:Sandbox.TaskSource.WaitAny(System.Threading.Tasks.Task[])">
      <inheritdoc cref="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
    </member>
    <member name="M:Sandbox.TaskSource.WaitAll(System.Threading.Tasks.Task[])">
      <inheritdoc cref="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
    </member>
    <member name="M:Sandbox.TaskSource.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
      <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
    </member>
    <member name="M:Sandbox.TaskSource.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
      <inheritdoc cref="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
    </member>
    <member name="M:Sandbox.TaskSource.Yield">
      <inheritdoc cref="M:System.Threading.Tasks.Task.Yield" />
    </member>
    <member name="M:Sandbox.TaskSource.Frame">
      <summary>
            Wait until the start of the next frame
            </summary>
    </member>
    <member name="M:Sandbox.TaskSource.FrameEnd">
      <summary>
            Wait until the end of the frame
            </summary>
    </member>
    <member name="M:Sandbox.TaskSource.FixedUpdate">
      <summary>
            Wait until the next fixed update
            </summary>
    </member>
    <member name="T:Sandbox.WebSocket">
      <summary>
            A WebSocket client for connecting to external services.
            </summary>
      <remarks>
            Events handlers will be called on the synchronization context that Connect was called on.
            </remarks>
    </member>
    <member name="T:Sandbox.WebSocket.MessageReceivedHandler">
      <summary>
            Event handler which processes text messages from the WebSocket service.
            </summary>
      <param name="message">The message text that was received.</param>
    </member>
    <member name="T:Sandbox.WebSocket.DataReceivedHandler">
      <summary>
            Event handler which processes binary messages from the WebSocket service.
            </summary>
      <param name="data">The binary message data that was received.</param>
    </member>
    <member name="T:Sandbox.WebSocket.DisconnectedHandler">
      <summary>
            Event handler which fires when the WebSocket disconnects from the server.
            </summary>
      <param name="status">The close status code from the server, or 0 if there was none. See known values here: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent</param>
      <param name="reason">The reason string for closing the connection. This may not be populated, may be from the server, or may be a client exception message.</param>
    </member>
    <member name="P:Sandbox.WebSocket.IsConnected">
      <summary>
            Returns true as long as a WebSocket connection is established.
            </summary>
    </member>
    <member name="P:Sandbox.WebSocket.SubProtocol">
      <summary>
            Get the sub-protocol that was negotiated during the opening handshake.
            </summary>
    </member>
    <member name="E:Sandbox.WebSocket.OnMessageReceived">
      <summary>
            Event which fires when a text message is received from the server.
            </summary>
    </member>
    <member name="E:Sandbox.WebSocket.OnDataReceived">
      <summary>
            Event which fires when a binary message is received from the server.
            </summary>
    </member>
    <member name="E:Sandbox.WebSocket.OnDisconnected">
      <summary>
            Event which fires when the connection to the WebSocket service is lost, for any reason.
            </summary>
    </member>
    <member name="P:Sandbox.WebSocket.EnableCompression">
      <summary>
            Enable or disable compression for the websocket. If the server supports it, compression will be enabled for all messages.
            Note: compression is disabled by default, and can be dangerous if you are sending secrets across the network.
            </summary>
    </member>
    <member name="M:Sandbox.WebSocket.#ctor(System.Int32)">
      <summary>
            Initialized a new WebSocket client.
            </summary>
      <param name="maxMessageSize">The maximum message size to allow from the server, in bytes. Default 64 KiB.</param>
    </member>
    <member name="M:Sandbox.WebSocket.Dispose">
      <summary>
            Cleans up resources used by the WebSocket client. This will also immediately close the connection if it is currently open.
            </summary>
    </member>
    <member name="M:Sandbox.WebSocket.AddSubProtocol(System.String)">
      <summary>
            Add a sub-protocol to be negotiated during the WebSocket connection handshake.
            </summary>
      <param name="protocol" />
    </member>
    <member name="M:Sandbox.WebSocket.Connect(System.String,System.Threading.CancellationToken)">
      <summary>
            Establishes a connection to an external WebSocket service.
            </summary>
      <param name="websocketUri">The WebSocket URI to connect to. For example, "ws://hostname.local:1280/" for unencrypted WebSocket or "wss://hostname.local:1281/" for encrypted.</param>
      <param name="ct">A <see cref="T:System.Threading.CancellationToken" /> which allows the connection attempt to be aborted if necessary.</param>
      <returns>A <see cref="T:System.Threading.Tasks.Task" /> which completes when the connection is established, or throws if it failed to connect.</returns>
    </member>
    <member name="M:Sandbox.WebSocket.Connect(System.String,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
      <summary>
            Establishes a connection to an external WebSocket service.
            </summary>
      <param name="websocketUri">The WebSocket URI to connect to. For example, "ws://hostname.local:1280/" for unencrypted WebSocket or "wss://hostname.local:1281/" for encrypted.</param>
      <param name="headers">Headers to send with the connection request.</param>
      <param name="ct">A <see cref="T:System.Threading.CancellationToken" /> which allows the connection attempt to be aborted if necessary.</param>
      <returns>A <see cref="T:System.Threading.Tasks.Task" /> which completes when the connection is established, or throws if it failed to connect.</returns>
    </member>
    <member name="M:Sandbox.WebSocket.Send(System.String)">
      <summary>
            Sends a text message to the WebSocket server.
            </summary>
      <param name="message">The message text to send. Must not be null.</param>
      <returns>A <see cref="T:System.Threading.Tasks.ValueTask" /> which completes when the message was queued to be sent.</returns>
    </member>
    <member name="M:Sandbox.WebSocket.Send(System.Byte[])">
      <summary>
            Sends a binary message to the WebSocket server.
            </summary>
      <remarks>
            The <see cref="M:Sandbox.WebSocket.Send(System.ArraySegment{System.Byte})" /> and <see cref="M:Sandbox.WebSocket.Send(System.Span{System.Byte})" /> overloads allow sending subsections of byte arrays.
            </remarks>
      <param name="data">The message data to send. Must not be null.</param>
      <returns>A <see cref="T:System.Threading.Tasks.ValueTask" /> which completes when the message was queued to be sent.</returns>
    </member>
    <member name="M:Sandbox.WebSocket.Send(System.ArraySegment{System.Byte})">
      <summary>
            Sends a binary message to the WebSocket server.
            </summary>
      <param name="data">The message data to send. Must not be null.</param>
      <returns>A <see cref="T:System.Threading.Tasks.ValueTask" /> which completes when the message was queued to be sent.</returns>
    </member>
    <member name="M:Sandbox.WebSocket.Send(System.Span{System.Byte})">
      <summary>
            Sends a binary message to the WebSocket server.
            </summary>
      <param name="data">The message data to send.</param>
      <returns>A <see cref="T:System.Threading.Tasks.ValueTask" /> which completes when the message was queued to be sent.</returns>
    </member>
    <member name="T:TemporaryEffect">
      <summary>
            Destroys a GameObject after a number of seconds. If the GameObject or its children have any 
            components that implement ITemporaryEffect we will wait for those to be finished before destroying.
            This is particularly useful if you want to delete a GameObject but want to wait for sounds or particles 
            to conclude.
            </summary>
    </member>
    <member name="F:TemporaryEffect.DestroyAfterSeconds">
      <summary>
            Number of seconds to wait before destroying
            </summary>
    </member>
    <member name="F:TemporaryEffect.WaitForChildEffects">
      <summary>
            If true we will wait for any ITemporaryEffect's to finish before destroying
            </summary>
    </member>
    <member name="M:TemporaryEffect.CreateOrphans(Sandbox.GameObject,System.Boolean)">
      <summary>
            Look at the children in this GameObject and orphan any temporary effects
            </summary>
    </member>
    <member name="T:Microsoft.AspNetCore.Components.RenderFragment">
      <summary>
            Represents a segment of UI content, implemented as a delegate that
            writes the content to a <see cref="T:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder" />.
            </summary>
    </member>
    <member name="T:Microsoft.AspNetCore.Components.RenderFragment`1">
      <summary>
            Represents a segment of UI content for an object of type <typeparamref name="TValue" />, implemented as
            a function that returns a <see cref="T:Microsoft.AspNetCore.Components.RenderFragment" />.
            </summary>
    </member>
    <member name="T:Microsoft.AspNetCore.Components.IComponent">
      <summary>
            A component type
            </summary>
    </member>
    <member name="T:Microsoft.AspNetCore.Components.ParameterAttribute">
      <summary>
            Signifies a parameter attribute
            </summary>
    </member>
    <member name="T:Microsoft.AspNetCore.Components.ComponentBase">
      <summary>
            A base component
            </summary>
    </member>
    <member name="T:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder">
      <summary>
            This is a tree renderer for panels. If we ever use razor on other ui we'll want to make a copy of
            this class and do the specific things to that.
            </summary>
      <summary>
            This is a tree renderer for panels. If we ever use razor on other ui we'll want to make a copy of
            this class and do the specific things to that.
            </summary>
      <summary>
            This is a tree renderer for panels. If we ever use razor on other ui we'll want to make a copy of 
            this class and do the specific things to that.
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.Block.Reset">
      <summary>
            Reset to an unseen, unlooped state
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.Block.CheckCacheValue(System.Int32,System.Int32)">
      <summary>
            Allows caching a block so you can avoid repeating unnecessary steps. 
            Calling this will return true if it's already cached, false if it's not.
            If it's not it'll add to the cache so that next time it will return true.
            </summary>
    </member>
    <member name="F:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.Block.increments">
      <summary>
            For loops, how many times has this been seen
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.Start">
      <summary>
            Called once before building the tree
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.Finish">
      <summary>
            Called once after building the tree
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddLocation(System.String,System.Int32,System.Int32)">
      <summary>
            Add the current source location. Used to record in which file the element was created.
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.OpenElement(System.Int32,System.String,System.Object)">
      <summary>
            Start working on this element
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddAttribute(System.Int32,System.String,System.Object)">
      <summary>
            Handles "style" and "class" attributes..
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddStyleDefinitions(System.Int32,System.String)">
      <summary>
            Styles from a style block
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddAttribute``1(System.Int32,System.Action{``0})">
      <summary><![CDATA[ <Icon OnSomething=@Function></Icon> ]]></summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.CloseElement">
      <summary>
            Finish working on this element
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddContent``1(System.Int32,``0)">
      <summary>
            Handles text content within an element
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.Clear">
      <summary>
            Delete all of the elements created by this render tree
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddReferenceCapture``1(System.Int32,``0,System.Action{``0})">
      <summary>
            Implements @ref
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddAttribute(System.Int32,System.String,System.Action)">
      <summary>
            Handles @onclick=@( () =&gt; DoSomething( "boobies" ) )
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddAttribute(System.Int32,System.String,System.Func{System.Threading.Tasks.Task})">
      <summary>
            Handles @onclick=@( () =&gt; await DoSomethingAsync( "boobies" ) )
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddAttribute(System.Int32,System.String,System.Action{Sandbox.UI.PanelEvent})">
      <summary>
            Handles @onclick=@( ( PanelEvent e ) =&gt; DoSomething( e.This, "boobies" ) )
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddMarkupContent(System.Int32,System.String)">
      <summary>
            Add markup to the current element
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.OpenElement``1(System.Int32,System.Object)">
      <summary>
            Create a panel of type T
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddAttribute``1(System.Int32,System.Object,System.Action{``0})">
      <summary>
            Called to set attributes on a panel directly
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.AddBind``1(System.Int32,System.String,System.Func{``0},System.Action{``0})">
      <summary>
            Called to set attributes on a panel directly
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder.UpdateBinds">
      <summary>
            Update bound variables and return true if any of them changed
            </summary>
    </member>
    <member name="P:Microsoft.AspNetCore.Components.EventHandlerAttribute.AttributeName">
      <summary>
            Gets the attribute name.
            </summary>
    </member>
    <member name="P:Microsoft.AspNetCore.Components.EventHandlerAttribute.EventArgsType">
      <summary>
            Gets the event argument type.
            </summary>
    </member>
    <member name="P:Microsoft.AspNetCore.Components.EventHandlerAttribute.EnableStopPropagation">
      <summary>
            Gets the event's ability to stop propagation.
            </summary>
    </member>
    <member name="P:Microsoft.AspNetCore.Components.EventHandlerAttribute.EnablePreventDefault">
      <summary>
            Gets the event's ability to prevent default event flow.
            </summary>
    </member>
    <member name="T:Microsoft.AspNetCore.Components.EditorRequiredAttribute">
      <summary>
            Specifies that the component parameter is required to be provided by the user when authoring it in the editor.
            <para>
            If a value for this parameter is not provided, editors or build tools may provide warnings indicating the user to
            specify a value. This attribute is only valid on properties marked with <see cref="T:Microsoft.AspNetCore.Components.ParameterAttribute" />.
            </para></summary>
    </member>
    <member name="P:Microsoft.AspNetCore.Components.RouteAttribute.Url">
      <summary>
            The full url of this route (ie "/home/section/page")
            </summary>
    </member>
    <member name="P:Microsoft.AspNetCore.Components.RouteAttribute.Parts">
      <summary>
            The url split into parts (ie "home" "section" "page" )
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.RouteAttribute.FindValidTarget(System.String,System.String)">
      <summary>
            Given a URL, check out TypeLibrary and find a valid target
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.RouteAttribute.IsUrl(System.String)">
      <summary>
            True if this matches the passed in url.
            Queries are trimmed and ignored <c>( ?query=fff )</c>
            Variables are tested (but not type matched or anything)
            </summary>
    </member>
    <member name="M:Microsoft.AspNetCore.Components.RouteAttribute.ExtractProperties(System.String)">
      <summary>
            Given a Url, check for {properties} and convert them to key values
            </summary>
    </member>
  </members>
  <assembly>
    <name>Sandbox.GameInstance</name>
  </assembly>
  <members>
    <member name="M:Analytics.DedicatedServerUpdate">
      <summary>
            Dedicated servers send a ping every minute with their memory usage etc
            </summary>
    </member>
    <member name="T:Sandbox.GameInstance">
      <summary>
            Holds the state of a game menu
            </summary>
    </member>
    <member name="P:Sandbox.GameInstance.IsDeveloperHost">
      <summary>
            True if this is a game we've joined as a multiplayer client
            </summary>
    </member>
    <member name="P:Sandbox.GameInstance.GameFileSystem">
      <summary>
            Access to the filesystem for this game. This is either going to be inside the package or the project folder.
            </summary>
    </member>
    <member name="P:Sandbox.GameInstance.IsRemote">
      <summary>
            Returns true if this game is from a downloaded package, rather than something running locally
            </summary>
    </member>
    <member name="F:Sandbox.GameInstance._packageAssembly">
      <summary>
            Assembly that will be used set during <see cref="M:Sandbox.GameInstance.LoadAsync(Sandbox.PackageLoader.Enroller,System.Threading.CancellationToken)" />.
            </summary>
    </member>
    <member name="M:Sandbox.GameInstance.Close">
      <summary>
            Delete this menu, remove all traces of it
            </summary>
    </member>
    <member name="M:Sandbox.GameInstance.Shutdown">
      <summary>
            Delete/destroy this instance. Unlike Close, this is not called from
            the addon gamemenu.. so we don't call gamemenu.closed (which is used
            to trigger a navigate to main menu.
            </summary>
    </member>
    <member name="M:Sandbox.GameInstance.LoadAsync(Sandbox.PackageLoader.Enroller,System.Threading.CancellationToken)">
      <summary>
            Attempt to download this package and mount it as a game menu
            </summary>
    </member>
    <member name="M:Sandbox.GameInstance.LoadCursors">
      <summary>
            Load or reload the <see cref="T:Sandbox.CursorSettings" /> from the active project settings.
            </summary>
    </member>
    <member name="M:Sandbox.GameInstance.TrapButtons(System.Action{System.String[]})">
      <summary>
            For binding reasons, get a list of buttons that are currently pressed
            </summary>
    </member>
    <member name="M:Sandbox.GameInstanceDll.UpdateConfigFromNetworkTable">
      <summary>
            Read the json configurations from the network table and apply them.
            To encourage a single path, this is called on the host too - even if they're
            not hosting a multiplayer game!
            </summary>
    </member>
    <member name="M:Sandbox.GameInstanceDll.UpdateProjectConfig(Sandbox.Package)">
      <summary>
            Called when loading a game or when a localproject has been modified while playing a game.
            </summary>
    </member>
    <member name="M:Sandbox.GameInstanceDll.OnProjectConfigChanged(Sandbox.Package)">
      <summary>
            Called when the config for a game project has been changed. 
            We might need to update the config table.
            </summary>
    </member>
    <member name="M:Sandbox.GameInstanceDll.ResolvePackageAsset(System.String)">
      <summary>
            Called from the code generator. The game package should already contain this package's content
            so we just need to work out where it's meant to point to
            </summary>
    </member>
    <member name="M:Sandbox.GameInstanceDll.ResetEnvironment">
      <summary>
            This should reset our environment to a clean state.
            </summary>
    </member>
    <member name="M:Sandbox.GameInstanceDll.PauseLoadingAssemblies">
      <summary>
            Don't attempt to load new assemblies during <see cref="M:Sandbox.GameInstanceDll.Tick" /> inside this scope.
            </summary>
    </member>
    <member name="M:Sandbox.GameInstanceDll.LoadGamePackageAsync(System.String,Sandbox.Engine.GameLoadingFlags,System.Threading.CancellationToken)">
      <summary>
            Loads the game asynchronously
            </summary>
    </member>
    <member name="M:Sandbox.GameInstanceDll.OnGameInstanceClosed(Sandbox.IGameInstance)">
      <summary>
            Called when the game menu is closed
            </summary>
      <param name="instance" />
    </member>
    <member name="M:Sandbox.GameInstanceDll.EditorPlay">
      <summary>
            The play button was pressed in the editor
            </summary>
    </member>
    <member name="M:Sandbox.GameInstanceDll.PushScope">
      <summary>
            Pushes the game scope. This will push the active scene and the right time.
            </summary>
    </member>
    <member name="M:Sandbox.GameInstanceDll.TickSceneStats">
      <summary>
            Called per frame to add scene's stats to our analytics
            </summary>
    </member>
    <member name="M:Sandbox.GameInstanceDll.TryGetReplicatedVarValue(System.String,System.String@)">
      <summary>
            Try to get the replicated var value from the host
            </summary>
    </member>
    <member name="F:Sandbox.GameInstanceDll.ConfigTable">
      <summary>
            The config table is used to send config (like physics config, input config) to the client.
            This isn't always needed, because the config is loaded from the package. But if we're operating
            without a package, it is needed.
            </summary>
    </member>
    <member name="F:Sandbox.GameInstanceDll.NetworkedSmallFiles">
      <summary>
            Hold and network any small files such as StyleSheets and compiled prefab assets.
            </summary>
    </member>
    <member name="F:Sandbox.GameInstanceDll.NetworkedConfigFiles">
      <summary>
            Hold and network any files from Project Settings (.config files.)
            </summary>
    </member>
    <member name="F:Sandbox.GameInstanceDll.NetworkedLargeFiles">
      <summary>
            Hold and network any small files such as StyleSheets and compiled prefab assets.
            </summary>
    </member>
    <member name="F:Sandbox.GameInstanceDll.ReplicatedConvars">
      <summary>
            Hold and network any small files such as StyleSheets and compiled prefab assets.
            </summary>
    </member>
    <member name="F:Sandbox.GameInstanceDll.compileGroup">
      <summary>
            This is used to compile code archives that come in from the network.
            </summary>
    </member>
    <member name="M:Sandbox.GameInstanceDll.BuildNetworkedFiles">
      <summary>
            Go through our mounted files and make them available to joining clients for download
            </summary>
    </member>
    <member name="T:Sandbox.IRichPresenceSystem">
      <summary>
            We might have multiple rich presence systems running (Steam, Discord, ...)
            </summary>
    </member>
    <member name="T:Sandbox.RichPresenceSystem">
      <summary>
            Rich Presence System - polls rich presence state periodically.
            All in one place so we don't update rich presence in 100 places
            </summary>
    </member>
    <member name="P:Sandbox.RichPresenceSystem.Current">
      <summary>
            The current rich presence system
            </summary>
    </member>
    <member name="M:Sandbox.RichPresenceSystem.Tick">
      <summary>
            Called by ClientDll Tick to poll active rich presence systems
            </summary>
    </member>
    <member name="T:Sandbox.SteamRichPresenceSystem">
      <summary>
            Rich Presence System for Steam
            </summary>
    </member>
    <member name="T:Sandbox.StandaloneGameInstance">
      <summary>
            Holds the state of a standalone game
            </summary>
    </member>
    <member name="M:Sandbox.StandaloneGameInstance.LoadAsync(Sandbox.PackageLoader.Enroller,System.Threading.CancellationToken)">
      <summary>
            Attempt to download this package and mount it as a game menu
            </summary>
    </member>
    <member name="M:Sandbox.ReplicatedConvars.OnAssembliesLoaded">
      <summary>
            Should be called after the assemblies are loaded. We'll update all the replicated convars now.
            </summary>
    </member>
    <member name="M:Sandbox.ReplicatedConvars.OnConVarChanged(Sandbox.Command,System.String)">
      <summary>
            Called any time a ConVar changes.
            </summary>
    </member>
    <member name="M:Sandbox.ReplicatedConvars.TryGetValue(System.String,System.String@)">
      <summary>
            Get the value of a replicated ConVar.
            </summary>
    </member>
  </members>
  <assembly>
    <name>Sandbox.Hotload</name>
  </assembly>
  <members>
    <member name="T:Sandbox.Hotload">
      <summary>
            Provides methods for replacing loaded assemblies with new versions at runtime.
            </summary>
    </member>
    <member name="M:Sandbox.Hotload.TryGetDefaultValue(System.Reflection.FieldInfo,System.Object@)">
      <summary>
            Attempts to get the default value for a newly created field on an
            existing type. Returns true if successful.
            </summary>
      <remarks>
            This value should not be cached, but evaluated for each instance.
            Works by finding the CIL that initializes the given field and
            generating a dynamic method, which is then cached and invoked.
            </remarks>
      <param name="field">Field to retrieve a default value for.</param>
      <param name="value">If successful, contains the default value.</param>
    </member>
    <member name="F:Sandbox.Hotload.StackBehaviourValues">
      <summary>
            Stack size delta for each stack behaviour.
            </summary>
    </member>
    <member name="M:Sandbox.Hotload.GetArgCount(Mono.Cecil.Cil.OpCode,Mono.Cecil.MethodReference)">
      <summary>
            Find the number of arguments that invoking the given method will pop.
            </summary>
    </member>
    <member name="M:Sandbox.Hotload.GetArgCount(Mono.Cecil.Cil.OpCode,System.Reflection.MethodBase)">
      <summary>
            Find the number of arguments that invoking the given method will pop.
            </summary>
    </member>
    <member name="F:Sandbox.Hotload.Swaps">
      <summary>
            A mapping of assembles to swap with new versions.
            </summary>
    </member>
    <member name="F:Sandbox.Hotload.New">
      <summary>
            Assemblies that are being loaded in this hotload, either as a swap or replacing null.
            </summary>
    </member>
    <member name="F:Sandbox.Hotload.IgnoredAssemblies">
      <summary>
            A list of assemblies containing members that should be skipped during a reference update.
            </summary>
    </member>
    <member name="P:Sandbox.Hotload.TraceRoots">
      <summary>
            If true, the static field or watched object that instances are found under will be stored in <see cref="P:Sandbox.InstanceTimingEntry.Roots" />.
            Defaults to false.
            </summary>
    </member>
    <member name="P:Sandbox.Hotload.TracePaths">
      <summary>
            If true, keep track of the path to instances to include in logging. Defaults to false.
            </summary>
    </member>
    <member name="P:Sandbox.Hotload.IncludeTypeTimings">
      <summary>
            If true, record per-type timing information.
            </summary>
    </member>
    <member name="P:Sandbox.Hotload.IncludeProcessorTimings">
      <summary>
            If true, record instance processor timing information.
            </summary>
    </member>
    <member name="P:Sandbox.Hotload.AssemblyResolver">
      <summary>
            Optional resolver required for features like setting default values of newly-added fields.
            </summary>
    </member>
    <member name="P:Sandbox.Hotload.AssemblyNameFormatter">
      <summary>
            Optional formatter when pretty-printing assembly names in logs.
            </summary>
    </member>
    <member name="M:Sandbox.Hotload.#ctor(System.Boolean,Sandbox.Diagnostics.Logger)">
      <summary>
            Default constructor that includes Sandbox.Hotload.dll and Mono.Cecil.dll to the
            ignored assembly list.
            </summary>
    </member>
    <member name="M:Sandbox.Hotload.IgnoreAssembly(System.Reflection.Assembly)">
      <summary>
            Any fields declared on types defined in the given assembly will be skipped
            during future reference updates.
            </summary>
      <param name="toIgnore">Assembly to ignore the members of.</param>
    </member>
    <member name="M:Sandbox.Hotload.IgnoreAssembly``1">
      <summary>
            Any fields declared on types defined in the given assembly will be skipped
            during future reference updates.
            </summary>
    </member>
    <member name="M:Sandbox.Hotload.IgnoreAssembly(System.String)">
      <summary>
            Any fields declared on types defined in the named assembly will be skipped
            during future reference updates.
            </summary>
    </member>
    <member name="M:Sandbox.Hotload.ReplacingAssembly(System.Reflection.Assembly,System.Reflection.Assembly)">
      <summary>
             To be called when one assembly is being replaced by another, is loaded for the first time,
             or unloaded for the last time.
            
             This will add <paramref name="newAssembly" /> to be watched (if not null), and remove
             <paramref name="oldAssembly" /> from being watched (if not null). If both assemblies aren't
             null, they will be added to be swapped when <see cref="M:Sandbox.Hotload.UpdateReferences" /> is next called, and
             true is returned.
             </summary>
    </member>
    <member name="M:Sandbox.Hotload.GetQueuedAssemblyReplacements">
      <summary>
            Returns the queue of assemblies that will be swapped when
            <see cref="M:Sandbox.Hotload.UpdateReferences" /> is called. These are added using the
            <see cref="M:Sandbox.Hotload.ReplacingAssembly(System.Reflection.Assembly,System.Reflection.Assembly)" /> method.
            </summary>
      <returns>The mapping of assembly replacements.</returns>
    </member>
    <member name="T:Sandbox.Hotload.IInstanceUpgrader">
      <summary>
             Interface to implement a custom object instance upgrade process for types that match a condition.
             Instances of any derived types will be created and added to a <see cref="T:Sandbox.Hotload" /> instance that uses
             <see cref="M:Sandbox.Hotload.AddUpgraders(System.Reflection.Assembly)" /> on the declaring assembly of the derived type, unless a
             <see cref="T:Sandbox.Upgraders.DisableAutoCreationAttribute" /> has been specified.
            
             You can configure which order <see cref="T:Sandbox.Hotload.IInstanceUpgrader" />s are queried by using <see cref="T:Sandbox.Upgraders.UpgraderGroupAttribute" />,
             <see cref="T:Sandbox.Upgraders.AttemptBeforeAttribute" /> and / or <see cref="T:Sandbox.Upgraders.AttemptAfterAttribute" />.
             </summary>
    </member>
    <member name="P:Sandbox.Hotload.InstanceUpgrader.Swaps">
      <summary>
            A mapping of assembles to swap with new versions.
            </summary>
    </member>
    <member name="M:Sandbox.Hotload.InstanceUpgrader.GetNewType(System.Type)">
      <summary>
            When hotswapping this will switch types from the old assembly into the type from the new assembly.
            </summary>
      <param name="oldType">The old type.</param>
      <returns>The new type, or null if no substitution exists. The old type will be returned if it's still valid (not from a swapped assembly).</returns>
    </member>
    <member name="M:Sandbox.Hotload.InstanceUpgrader.GetNewInstance(System.Object)">
      <summary>
            Returns an upgraded version of the given object, replacing any types from a swapped-out
            assembly with their new up-to-date types. The result is cached, so if you pass the same
            object to this method multiple times it will always return the same instance. Fields inside
            the new instance may not be initialized until later in the hotload.
            </summary>
      <param name="oldInstance">Object to upgrade.</param>
      <returns>An upgraded version of the given object.</returns>
    </member>
    <member name="M:Sandbox.Hotload.InstanceUpgrader.Log(Sandbox.HotloadEntryType,System.FormattableString,System.Reflection.MemberInfo)">
      <summary>
            Logs a message in the current hotload.
            </summary>
    </member>
    <member name="M:Sandbox.Hotload.InstanceUpgrader.Log(System.Exception,System.FormattableString,System.Reflection.MemberInfo)">
      <summary>
            Logs an exception in the current hotload.
            </summary>
    </member>
    <member name="M:Sandbox.Hotload.InstanceUpgrader.OnInitialize">
      <summary>
            Called when this upgrader has been added to a <see cref="F:Sandbox.Hotload.InstanceUpgrader.Hotload" /> instance.
            </summary>
    </member>
    <member name="M:Sandbox.Hotload.InstanceUpgrader.OnClearCache">
      <summary>
            Called between hotloads, should clear up any cached resources that won't be needed in future hotloads.
            </summary>
    </member>
    <member name="M:Sandbox.Hotload.InstanceUpgrader.ShouldProcessType(System.Type)">
      <summary>
            Check to see if this upgrader can possibly handle the given type.
            </summary>
      <param name="type">Type to upgrade an instance of.</param>
      <returns>True if this upgrader should attempt to upgrade an instance of the given type.</returns>
    </member>
    <member name="M:Sandbox.Hotload.InstanceUpgrader.OnTryCreateNewInstance(System.Object,System.Object@)">
      <summary>
            If this upgrader supports upgrading the given <paramref name="oldInstance" />, returns <value>true</value> and
            assigns <paramref name="newInstance" /> to be the value that should replace <paramref name="oldInstance" />. This
            method doesn't need to copy the inner state of the instance across, but just creates an empty instance to be
            populated later.
            </summary>
      <remarks>
        <para>
            It's safe to just directly assign <paramref name="newInstance" /> to <paramref name="oldInstance" /> if the type
            isn't declared in a replaced assembly.
            </para>
        <para>
            Returning true will cause <see cref="M:Sandbox.Hotload.InstanceUpgrader.OnTryUpgradeInstance(System.Object,System.Object,System.Boolean)" /> to be called immediately after this method, which
            schedules copying the state of the old instance to the new one.
            </para>
      </remarks>
      <param name="oldInstance">Instance that should be replaced / upgraded.</param>
      <param name="newInstance">
            If this method returns true, this should contain the instance that replaces <paramref name="oldInstance" />,
            or <paramref name="oldInstance" /> itself if no replacement is necessary.
            </param>
      <returns>True if this upgrader handles the replacement of the given <paramref name="oldInstance" />.</returns>
    </member>
    <member name="M:Sandbox.Hotload.InstanceUpgrader.OnTryUpgradeInstance(System.Object,System.Object,System.Boolean)">
      <summary>
            Called immediately after <see cref="M:Sandbox.Hotload.InstanceUpgrader.OnTryCreateNewInstance(System.Object,System.Object@)" /> if it returned true, or on instances from fields
            that can't be re-assigned (see <see cref="P:System.Reflection.FieldInfo.IsInitOnly" />). This method determines what kind of extra
            processing is required for the given replacement.
            </summary>
      <remarks>
        <para>
            In this method we can call things like <see cref="M:Sandbox.Hotload.InstanceUpgrader.ProcessInstance(System.Object,System.Object)" />, <see cref="M:Sandbox.Hotload.ScheduleInstanceTask(Sandbox.Hotload.IInstanceProcessor,System.Object,System.Object)" /> or
            <see cref="M:Sandbox.Hotload.ScheduleLateInstanceTask(Sandbox.Hotload.IInstanceProcessor,System.Object,System.Object)" /> to handle copying values from the old instance to the new one.
            </para>
        <para>
            If <paramref name="newInstance" /> should be cached as the canonical replacement for <paramref name="oldInstance" />,
            call <see cref="M:Sandbox.Hotload.InstanceUpgrader.AddCachedInstance(System.Object,System.Object)" /> here.
            </para>
        <para>
            If finalization should be suppressed, call <see cref="M:Sandbox.Hotload.InstanceUpgrader.SuppressFinalize(System.Object,System.Object)" />.
            </para>
      </remarks>
      <param name="oldInstance">Original instance that is being replaced / upgraded from.</param>
      <param name="newInstance">
            New instance that replaces <paramref name="oldInstance" />, or <paramref name="oldInstance" /> itself if no replacement is necessary.
            </param>
      <param name="createdElsewhere">
            True if <paramref name="newInstance" /> was created outside of the hotloading system, for example when the
            containing field has <see cref="P:System.Reflection.FieldInfo.IsInitOnly" /> set to true. Otherwise, when false, <see cref="M:Sandbox.Hotload.InstanceUpgrader.OnTryCreateNewInstance(System.Object,System.Object@)" />
            will have been called just before this method.
            </param>
      <returns />
    </member>
    <member name="M:Sandbox.Hotload.InstanceUpgrader.OnProcessInstance(System.Object,System.Object)">
      <summary>
            Perform extra field processing on a new instance that has previously been created by this upgrader in
            <see cref="M:Sandbox.Hotload.InstanceUpgrader.OnTryCreateNewInstance(System.Object,System.Object@)" />. This is a good place to discover any other instances that should be upgraded
            that are stored in <paramref name="oldInstance" />, which can be upgraded by calling <see cref="M:Sandbox.Hotload.InstanceUpgrader.GetNewInstance(System.Object)" />.
            </summary>
      <param name="oldInstance">The original instance that was upgraded.</param>
      <param name="newInstance">Upgraded version of <paramref name="oldInstance" />, or even the same object if no upgrade
            was required.</param>
      <returns>Roughly how many instances were processed by this method. Only used for performance stats.</returns>
    </member>
    <member name="M:Sandbox.Hotload.SimplifySwaps">
      <summary>
            Merge chains of swaps. For example, if A is swapped with B, and B is swapped with C, simplify to A swapping with C.
            </summary>
    </member>
    <member name="M:Sandbox.Hotload.UpdateReferences">
      <summary>
            Cycle though all types in all watched assemblies.
            Find statics, iterate over all their fields recursively.
            Replace any instances of classes that are defined in the assemblies added using ReplacingAssembly
            </summary>
    </member>
    <member name="M:Sandbox.Hotload.ValidateNewType(System.Type)">
      <summary>
            Make sure a candidate type substitution isn't at all defined in a swapped-out assembly.
            This can go wrong if assembly B references assembly A, but only assembly A was swapped.
            </summary>
    </member>
    <member name="M:Sandbox.Hotload.GetNewType(System.Type)">
      <summary>
            In a swapped assembly find a replacement type for this type.
            Return null if no replacement is found.
            </summary>
    </member>
    <member name="P:Sandbox.Hotload.WatchedAssemblies">
      <summary>
            Currently watched assemblies, to enumerate the static fields of. This will contain assemblies added with <see cref="M:Sandbox.Hotload.WatchAssembly(System.Reflection.Assembly)" />,
            along with (after a hotload) the most recent replacing assemblies passed to <see cref="M:Sandbox.Hotload.ReplacingAssembly(System.Reflection.Assembly,System.Reflection.Assembly)" />.
            </summary>
    </member>
    <member name="P:Sandbox.Hotload.WatchedInstances">
      <summary>
            Currently watched object instances. Use <see cref="M:Sandbox.Hotload.WatchInstance``1(``0)" /> to add to this set.
            </summary>
    </member>
    <member name="M:Sandbox.Hotload.WatchAssembly(System.Reflection.Assembly)">
      <summary>
            Look for instances to replace in the static fields of types defined in the given assembly.
            </summary>
      <param name="a">Assembly to watch the static fields of.</param>
    </member>
    <member name="M:Sandbox.Hotload.WatchAssembly``1">
      <summary>
            Look for instances to replace in the static fields of types defined in 
            the defining assembly of <typeparamref name="T" />.
            </summary>
      <typeparam name="T">Type defined in the assembly to watch the static fields of.</typeparam>
    </member>
    <member name="M:Sandbox.Hotload.WatchAssembly(System.String)">
      <summary>
            Look for instances to replace in the static fields of types defined in the given assembly.
            </summary>
      <param name="assemblyName">Name of the assembly to watch the static fields of.</param>
    </member>
    <member name="M:Sandbox.Hotload.UnwatchAssembly(System.Reflection.Assembly)">
      <summary>
            Stop watching static fields of types defined in the given assembly.
            </summary>
      <param name="a">Assembly to stop watching the static fields of.</param>
    </member>
    <member name="M:Sandbox.Hotload.WatchInstance``1(``0)">
      <summary>
            Look for instances to replace in the fields of the given object.
            </summary>
      <param name="obj">Object to watch the fields of.</param>
    </member>
    <member name="M:Sandbox.Hotload.UnwatchInstance``1(``0)">
      <summary>
            Stop looking for instances to replace in the fields of the given object.
            </summary>
      <param name="obj">Object to stop watching the fields of.</param>
    </member>
    <member name="T:Sandbox.GeneratedNameKind">
      <summary>
            See Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedNameKind
            </summary>
    </member>
    <member name="T:Sandbox.GeneratedName">
      <summary>
            See Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedNames.MakeMethodScopedSynthesizedName
            </summary>
    </member>
    <member name="M:Sandbox.GeneratedName.#ctor(System.String,Sandbox.GeneratedNameKind,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            See Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedNames.MakeMethodScopedSynthesizedName
            </summary>
    </member>
    <member name="T:Sandbox.HotloadEntryType">
      <summary>
            Used to categorize messages emitted when performing a hotload.
            </summary>
    </member>
    <member name="F:Sandbox.HotloadEntryType.Trace">
      <summary>
            Used for messages related to debugging or profiling.
            </summary>
    </member>
    <member name="F:Sandbox.HotloadEntryType.Information">
      <summary>
            Used for general messages.
            </summary>
    </member>
    <member name="F:Sandbox.HotloadEntryType.Warning">
      <summary>
            Hotload couldn't upgrade an instance, so you should reload the game to avoid runtime bugs.
            </summary>
    </member>
    <member name="F:Sandbox.HotloadEntryType.Error">
      <summary>
            Something went wrong during the hotload that Facepunch should fix.
            </summary>
    </member>
    <member name="T:Sandbox.HotloadResultEntry">
      <summary>
            Contains information for an individual hotload result message or error.
            </summary>
    </member>
    <member name="P:Sandbox.HotloadResultEntry.Type">
      <summary>
            Hotload result category.
            </summary>
    </member>
    <member name="P:Sandbox.HotloadResultEntry.Message">
      <summary>
            Contains the main information of the result.
            </summary>
    </member>
    <member name="P:Sandbox.HotloadResultEntry.Exception">
      <summary>
            If the result type is <see cref="F:Sandbox.HotloadEntryType.Error" />, contains the
            exception thrown.
            </summary>
    </member>
    <member name="P:Sandbox.HotloadResultEntry.Member">
      <summary>
            When relevant, contains the member that this result relates to.
            </summary>
    </member>
    <member name="M:Sandbox.HotloadResultEntry.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <returns>
            A string that represents the current object.
            </returns>
    </member>
    <member name="P:Sandbox.TimingEntry.Instances">
      <summary>
            Total number of instances processed.
            </summary>
    </member>
    <member name="P:Sandbox.TimingEntry.Milliseconds">
      <summary>
            Total time taken processing instances.
            </summary>
    </member>
    <member name="T:Sandbox.InstanceTimingEntry">
      <summary>
            Holds information about the number of instances and total time taken when
            processing instances in a certain category.
            </summary>
    </member>
    <member name="P:Sandbox.InstanceTimingEntry.Roots">
      <summary>
            The full names and instance count for each static field that instances were found under.
            Only populated if <see cref="P:Sandbox.Hotload.TraceRoots" /> is set to true.
            </summary>
    </member>
    <member name="T:Sandbox.HotloadResult">
      <summary>
            Contains information about an assembly hotload event, including any warnings or errors emitted,
            the time taken to process instances of different types, and the total number of instances processed.
            </summary>
    </member>
    <member name="P:Sandbox.HotloadResult.TypeTimings">
      <summary>
            Contains timing information for each type processed during the hotload.
            </summary>
    </member>
    <member name="P:Sandbox.HotloadResult.ProcessorTimings">
      <summary>
            Contains timing information for each IInstanceProcessor during the hotload.
            </summary>
    </member>
    <member name="P:Sandbox.HotloadResult.HasErrors">
      <summary>
            If true, at least one error was emitted during the hotload. Information about the error(s) can
            be found in <see cref="P:Sandbox.HotloadResult.Errors" />.
            </summary>
    </member>
    <member name="P:Sandbox.HotloadResult.HasWarnings">
      <summary>
            If true, at least one warning was emitted during the hotload. Information about the error(s) can
            be found in <see cref="P:Sandbox.HotloadResult.Errors" />.
            </summary>
    </member>
    <member name="P:Sandbox.HotloadResult.NoAction">
      <summary>
            If true, the hotload was skipped because no replacement assemblies were specified since the last
            hotload.
            </summary>
    </member>
    <member name="P:Sandbox.HotloadResult.ProcessingTime">
      <summary>
            Total time elapsed during the hotload (in milliseconds)
            </summary>
    </member>
    <member name="P:Sandbox.HotloadResult.Success">
      <summary>
            If true, no errors were emitted during the hotload.
            </summary>
    </member>
    <member name="P:Sandbox.HotloadResult.InstancesProcessed">
      <summary>
            Total number of instances processed during the hotload.
            </summary>
    </member>
    <member name="P:Sandbox.HotloadResult.Entries">
      <summary>
            Retrieves all warnings, errors and other messages emitted during the hotload.
            </summary>
    </member>
    <member name="P:Sandbox.HotloadResult.AutoSkippedTypes">
      <summary>
            Types that were automatically determined to be safely skippable.
            </summary>
    </member>
    <member name="P:Sandbox.HotloadResult.Errors">
      <summary>
            Retrieves all error messages emitted during the hotload.
            </summary>
    </member>
    <member name="P:Sandbox.HotloadResult.Warnings">
      <summary>
            Retrieves all warning messages emitted during the hotload.
            </summary>
    </member>
    <member name="T:Sandbox.ILHotload">
      <summary>
            A fast path hotload that patches the existing assemblies IL when applicable
            </summary>
    </member>
    <member name="F:Sandbox.ILHotload.ActiveDetours">
      <summary>
            All active detours within an Assembly
            </summary>
    </member>
    <member name="F:Sandbox.ILHotload.DetourFactory">
      <summary>
            Make sure we have an initialized detour factory, as it takes a small while to load
            </summary>
    </member>
    <member name="P:Sandbox.ILHotload.IsSupported">
      <summary>
            True if <see cref="T:Sandbox.ILHotload" /> is supported on this platform.
            </summary>
    </member>
    <member name="M:Sandbox.ILHotload.FixReferences(MonoMod.Utils.DynamicMethodDefinition,System.Reflection.Module,System.Reflection.Module)">
      <summary>
            Replace any references to types or members in <paramref name="replaceModule" /> with references in <paramref name="sourceModule" />.
            Returns an array of referenced compiler-generated methods that should also be detoured.
            </summary>
    </member>
    <member name="T:Sandbox.SortingHelper">
      <summary>
            Generate an ordering based on a set of first-most and last-most items, and
            individual constraints between pairs of items. All first-most items will be
            ordered before all last-most items, and any other items will be put in the
            middle unless forced to be elsewhere by a constraint.
            </summary>
    </member>
    <member name="M:Sandbox.Upgraders.ArrayUpgrader.ProcessArrayElements(System.Array,System.Array,System.Type,System.Type)">
      <returns>True if a deep copy was required.</returns>
    </member>
    <member name="M:Sandbox.Upgraders.ArrayUpgrader.HasStructChanged(System.Type,System.Type)">
      <summary>
            Determine if the size and field layout of a struct has changed. This should
            only return true if it is safe to bitwise copy from old instances of the struct
            to new instances. This will return true if the struct contains reference-type
            members.
            </summary>
    </member>
    <member name="M:Sandbox.Upgraders.ArrayUpgrader.CanSkipType(System.Type)">
      <summary>
            Return true if type is to be thought of as a primitive
            ie - a type that never changes, and can just be copied
            such as a bool, string, float, pointer.
            </summary>
    </member>
    <member name="T:Sandbox.Upgraders.InitializedByAttribute">
      <summary>
            This field is initialized by a named method, for use when hotloading.
            If no method name is given, the field is deliberately left uninitialized.
            </summary>
    </member>
    <member name="T:Sandbox.Upgraders.DefaultUpgrader">
      <summary>
            This upgrader will use reflection to go through each field of a new instance, and
            populate it with an equivalent value found from the old instance. For newly-added
            fields, it attempts to determine a default value from the constructor of the type.
            </summary>
    </member>
    <member name="M:Sandbox.Upgraders.DefaultUpgrader.GetFieldsToProcess(System.Type,System.Type,System.Boolean)">
      <summary>
            Get all fields on this type, and types it inherits from, that we should process.
            </summary>
    </member>
    <member name="M:Sandbox.Upgraders.DefaultUpgrader.MatchTypeHierarchies(System.Type,System.Type)">
      <summary>
            For each type in <paramref name="newType" />'s hierarchy, try to find a matching type in <paramref name="oldType" />'s hierarchy.
            If no match is found, yields <c>(null, dstType)</c>. Ordered by most derived type first.
            </summary>
    </member>
    <member name="M:Sandbox.Upgraders.DefaultUpgrader.GetFieldsToProcessUncached(System.Type,System.Type,System.Boolean)">
      <summary>
            For each field in <paramref name="newType" />, try to find the matching field in <paramref name="oldType" />. If no match is found,
            yields <c>(null, dstField)</c>, so we can initialize the new field to a default value.
            </summary>
    </member>
    <member name="F:Sandbox.Upgraders.DelegateUpgrader.LambdaCaptureMode.None">
      <summary>
            The lambda captures nothing local.
            Method is declared in a nested "&lt;&gt;c" class in the context's declaring type.
            Method is named like "&lt;{ContextName:ident}&gt;b__{ContextIndex:int}_{LambdaIndex:int}".
            </summary>
    </member>
    <member name="F:Sandbox.Upgraders.DelegateUpgrader.LambdaCaptureMode.TargetInstance">
      <summary>
            The lambda captures only an instance of the context's declaring type.
            Method is declared in the context's declaring type itself.
            Method is named like "&lt;{ContextName:ident}&gt;b__{ContextIndex:int}_{LambdaIndex:int}".
            </summary>
    </member>
    <member name="F:Sandbox.Upgraders.DelegateUpgrader.LambdaCaptureMode.DisplayClass">
      <summary>
            The lambda captures other local values from the context.
            Method is declared in a nested "&lt;&gt;__DisplayClass{ContextIndex:int}_{DisplayClassIndex:int}" class.
            Method is named like "&lt;{ContextName:ident}&gt;b__{LambdaIndex:int}".
            </summary>
    </member>
    <member name="F:Sandbox.Upgraders.SkipUpgrader.AdditionalSkipableTypes">
      <summary>
            Types that we can safely skip, that we can't add a <see cref="T:Sandbox.SkipHotloadAttribute" /> to.
            </summary>
    </member>
    <member name="T:Sandbox.Upgraders.AutoSkipUpgrader">
      <summary>
            Instance upgrader that will try to automatically find types are definitely skippable. This upgrader isn't
            added automatically, you can enable it by calling <see cref="M:Sandbox.Hotload.AddUpgrader(Sandbox.Hotload.IInstanceUpgrader)" />.
            </summary>
      <remarks>
        <para>
            We attempt this almost last (just before <see cref="T:Sandbox.Upgraders.DefaultUpgrader" />) so that any upgraders
            that handle specific types will be chosen first, and therefore stop those types from being skipped.
            Adds any skippable types it finds to a cache, and forces <see cref="F:Sandbox.Upgraders.AutoSkipUpgrader.SkipUpgrader" /> to process them.
            </para>
        <para>
            This performs an under-approximation, but you can use <see cref="T:Sandbox.SkipHotloadAttribute" /> to mark any types it
            misses that you know are safe to skip.
            </para>
      </remarks>
    </member>
    <member name="P:Sandbox.Upgraders.AutoSkipUpgrader.SkippedTypes">
      <summary>
            The set of types that have been determined to be safe to skip.
            </summary>
    </member>
    <member name="T:Sandbox.Upgraders.SpecialCases.ConcurrentQueueUpgrader">
      <summary>
            Custom handling for <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" /> to reduce hotload processing time.
            </summary>
    </member>
    <member name="T:Sandbox.Upgraders.SpecialCases.ConcurrentDictionaryUpgrader">
      <summary>
            Custom handling for <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> to reduce hotload processing time.
            </summary>
    </member>
    <member name="M:Sandbox.Upgraders.SpecialCases.ComparerHelper.GetOldComparer(System.Object)">
      <summary>
            Uses the <see cref="P:System.Collections.Generic.Dictionary`2.Comparer" /> or <see cref="P:System.Collections.Generic.HashSet`1.Comparer" /> property to
            fetch the equality comparer used by <paramref name="oldDictOrHashSet" />.
            </summary>
      <param name="oldDictOrHashSet">Dictionary or HashSet to get the equality comparer from.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</returns>
    </member>
    <member name="T:Sandbox.Upgraders.SpecialCases.ListUpgrader">
      <summary>
            Upgrader for <see cref="T:System.Collections.Generic.List`1" /> so that we only process its live elements.
            Without this, hotload would process the whole inner array, even if the list was cleared.
            </summary>
    </member>
    <member name="T:Sandbox.Upgraders.SpecialCases.JsonSerializerOptionsUpgrader">
      <summary>
            System.Text.Json keeps a bunch of generated methods cached that we can't upgrade properly.
            Let's just clear the cache, and warn if the cache got populated again during the hotload.
            </summary>
    </member>
    <member name="F:Sandbox.Upgraders.GroupOrder.Default">
      <summary>
            Only use <see cref="T:Sandbox.Upgraders.AttemptBeforeAttribute" /> and <see cref="T:Sandbox.Upgraders.AttemptAfterAttribute" /> to
            determine ordering within a <see cref="T:Sandbox.Upgraders.UpgraderGroup" />.
            </summary>
    </member>
    <member name="F:Sandbox.Upgraders.GroupOrder.First">
      <summary>
            Try to put this upgrader as close to the start of the given group as possible.
            </summary>
    </member>
    <member name="F:Sandbox.Upgraders.GroupOrder.Last">
      <summary>
            Try to put this upgrader as close to the end of the given group as possible.
            </summary>
    </member>
    <member name="T:Sandbox.Upgraders.AttemptBeforeAttribute">
      <summary>
            Use this attribute to specify that a <see cref="T:Sandbox.Hotload.IInstanceUpgrader" /> should attempt to process
            each object before all other specified <see cref="T:Sandbox.Hotload.IInstanceUpgrader" /> types.
            </summary>
    </member>
    <member name="P:Sandbox.Upgraders.AttemptBeforeAttribute.InstanceUpgraderTypes">
      <summary>
        <see cref="T:Sandbox.Hotload.IInstanceUpgrader" /> types that should attempt to process each object after the type this attribute is on.
            </summary>
    </member>
    <member name="M:Sandbox.Upgraders.AttemptBeforeAttribute.#ctor(System.Type[])">
      <summary>
            Create an instance of <see cref="T:Sandbox.Upgraders.AttemptBeforeAttribute" /> with a list of <see cref="T:Sandbox.Hotload.IInstanceUpgrader" /> types.
            </summary>
      <param name="instanceUpgraderTypes">One or more <see cref="T:Sandbox.Hotload.IInstanceUpgrader" /> types.</param>
    </member>
    <member name="T:Sandbox.Upgraders.AttemptAfterAttribute">
      <summary>
            Use this attribute to specify that a <see cref="T:Sandbox.Hotload.IInstanceUpgrader" /> should attempt to process
            each object after all other specified <see cref="T:Sandbox.Hotload.IInstanceUpgrader" /> types.
            </summary>
    </member>
    <member name="P:Sandbox.Upgraders.AttemptAfterAttribute.InstanceUpgraderTypes">
      <summary>
        <see cref="T:Sandbox.Hotload.IInstanceUpgrader" /> types that should attempt to process each object before the type this attribute is on.
            </summary>
    </member>
    <member name="M:Sandbox.Upgraders.AttemptAfterAttribute.#ctor(System.Type[])">
      <summary>
            Create an instance of <see cref="T:Sandbox.Upgraders.AttemptAfterAttribute" /> with a list of <see cref="T:Sandbox.Hotload.IInstanceUpgrader" /> types.
            </summary>
      <param name="instanceUpgraderTypes">One or more <see cref="T:Sandbox.Hotload.IInstanceUpgrader" /> types.</param>
    </member>
    <member name="T:Sandbox.Upgraders.UpgraderGroup">
      <summary>
            Used to organize <see cref="T:Sandbox.Hotload.IInstanceUpgrader" />s into groups that update
            in a particular order. Use <see cref="T:Sandbox.Upgraders.UpgraderGroupAttribute" /> to specify which group an
            upgrader should be added to.
            </summary>
    </member>
    <member name="F:Sandbox.Upgraders.UpgraderGroup.ChildUpgraders">
      <summary>
            A list of <see cref="T:Sandbox.Hotload.IInstanceUpgrader" />s added to this group, where this group is their immediate parent.
            </summary>
    </member>
    <member name="F:Sandbox.Upgraders.UpgraderGroup.ChildUpgraderOrder">
      <summary>
            Indices into <see cref="F:Sandbox.Upgraders.UpgraderGroup.ChildUpgraders" />, sorted by <see cref="M:Sandbox.Upgraders.UpgraderGroup.SortUpgraders" />.
            </summary>
    </member>
    <member name="F:Sandbox.Upgraders.UpgraderGroup.UpgraderCache">
      <summary>
            For each <see cref="T:System.Type" />, caches which <see cref="T:Sandbox.Hotload.IInstanceUpgrader" />s should attempt to process
            instances of that type, as given by <see cref="M:Sandbox.Hotload.IInstanceUpgrader.ShouldProcessType(System.Type)" />.
            </summary>
    </member>
    <member name="F:Sandbox.Upgraders.UpgraderGroup.UpgraderOrderDirty">
      <summary>
            Should <see cref="F:Sandbox.Upgraders.UpgraderGroup.ChildUpgraders" /> be sorted?
            </summary>
    </member>
    <member name="M:Sandbox.Upgraders.UpgraderGroup.AddUpgrader(Sandbox.Hotload.IInstanceUpgrader,System.Type[],System.Int32)">
      <summary>
            Works out which child group to add the given upgrader to, or whether to add it to this group.
            </summary>
    </member>
    <member name="M:Sandbox.Upgraders.UpgraderGroup.GetUpgradersForType(System.Type)">
      <summary>
            Returns a flat array of upgraders that can process the given type, in
            order of precedence. This array won't contain <see cref="T:Sandbox.Upgraders.UpgraderGroup" />s,
            but it will contain upgraders found within those groups.
            </summary>
      <param name="type">Type to find upgraders for.</param>
    </member>
  </members>
  <assembly>
    <name>Sandbox.Menu</name>
  </assembly>
  <members>
    <member name="P:Sandbox.MenuEngine.Account.HasLinkedStreamerServices">
      <summary>
            Return true if the user has linked their account to a streamer service like twitch
            </summary>
    </member>
    <member name="P:Sandbox.MenuEngine.Account.Favourites">
      <summary>
            A list of favourites packages
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.SetFavouriteAsync(Sandbox.Package,System.Boolean)">
      <summary>
            Mark this package as a favourite
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.SetVoteAsync(Sandbox.Package,System.Boolean)">
      <summary>
            Add your vote for this package
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.OpenModal(Sandbox.Package)">
      <summary>
            Open a modal for the specific package. This will open the correct modal
            </summary>
    </member>
    <member name="M:Sandbox.Internal.AudioSettings.SetActiveDevice(System.String)">
      <summary>
            Set the active audio device by id
            </summary>
      <param name="id" />
    </member>
    <member name="M:Sandbox.Internal.AudioSettings.GetActiveDevice">
      <summary>
            Get the active audio device
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.Internal.AudioSettings.GetAudioDevices">
      <summary>
            Get all audio devices supported by the current platform
            </summary>
    </member>
    <member name="T:Sandbox.Global">
      <summary>
            Utility info for menu usage.
            </summary>
    </member>
    <member name="P:Sandbox.Global.IsApiConnected">
      <summary>
            Are we connected to the API? (If not, offline mode. Requires Steam Servers to be online to connect..)
            </summary>
    </member>
    <member name="M:Sandbox.MenuDll.OnMessageFromBackend(Sandbox.Services.Messaging.Message)">
      <summary>
            A message has come in from the web pubsub protbuf stuff
            </summary>
    </member>
    <member name="M:Sandbox.MenuScene.Tick">
      <summary>
            Tick the scene. This only happens when the menu is visible
            </summary>
    </member>
    <member name="P:Sandbox.MenuUtility.GamePackage">
      <summary>
            If current game is active, return the package
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.ConnectStream(Sandbox.StreamService)">
      <summary>
            Init a stream service
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.DisconnectStream">
      <summary>
            Init a stream service
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.OpenFileDialog">
      <summary>
            Open an 'open file' dialog
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.OpenFolder(System.String)">
      <summary>
            Open a folder 
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.OpenUrl(System.String)">
      <summary>
            Open a url
            </summary>
    </member>
    <member name="P:Sandbox.MenuUtility.Friends">
      <summary>
            Get all friends.
            </summary>
    </member>
    <member name="P:Sandbox.MenuUtility.EscapeTime">
      <summary>
            Number of seconds escape has been held down
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.JoinFriendGame(Sandbox.Friend)">
      <summary>
            Join the game a friend is in
            </summary>
    </member>
    <member name="P:Sandbox.MenuUtility.StartupGameIdent">
      <summary>
            We might be running the game from sbox.game, so we want the menu system to open the game immediately
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.CancelLoading">
      <summary>
            This is called when the cancel button is pressed when loading. 
            We should disconnect and leave the game.
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.SetConsoleVariable(System.String,System.Object)">
      <summary>
            Set a console variable. Unlike ConsoleSystem.*, this is unprotected and allows any console variable to be changed.
            </summary>
    </member>
    <member name="P:Sandbox.MenuUtility.RenderSettings">
      <summary>
            Access to the client's render settings
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.SetVoiceListen(System.Boolean)">
      <summary>
            Listen to the voice
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.CloseAllModals">
      <summary>
            Close every open modal
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.GetPlayerFeed(System.Int32)">
      <summary>
            Get the player's friend activity feed
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.GetNotificationCount">
      <summary>
            How many notifications does the player have?
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.MarkNotificationsRead">
      <summary>
            Mark the player's notifications as all read. Call when viewing notifications.
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.GetNotifications(System.Int32)">
      <summary>
            Get a list of notifications
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.GetAchievementOverviews(System.Int32)">
      <summary>
            Get a list of recent achievement progress
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.SaveAvatar(Sandbox.ClothingContainer,System.Boolean,System.Int32)">
      <summary>
            Get a list of recent achievement progress
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.DeleteAvatar(System.Int32)">
      <summary>
            Delete avatar in slot x
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.DeleteAvatars">
      <summary>
            Delete all avatars, return to default
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.InviteToParty(Sandbox.SteamId)">
      <summary>
            Invite someone to the current party. If one exists
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.InviteOverlayToParty">
      <summary>
            Opens the invite overlay
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.PostReview(System.String,Sandbox.Services.Review.ReviewScore,System.String)">
      <summary>
            Post a review for a package
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.CloseGame">
      <summary>
            Close the current game.
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.OpenGame(System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            A game has been opened. Load the game. If allowLaunchOverride then special launch conditions will be obeyed.
            For example, we might join a lobby instead of loading the game, or we might open the launcher.
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.OpenGameWithMap(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            A game has been opened. Load the game.
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.TryJoinLobby(System.String)">
      <summary>
            Try to join any lobby for this game.
            </summary>
    </member>
    <member name="T:Sandbox.MenuUtility.Input">
      <summary>
            Allows to menu addon to interact with input configuration
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.Input.TrapButtons(System.Action{System.String[]})">
      <summary>
            For binding reasons, get a list of buttons that are currently pressed
            </summary>
    </member>
    <member name="T:Sandbox.MenuUtility.Storage">
      <summary>
            Allows to menu addon to interact with the downloaded file cache
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.Storage.GetStorageFiles">
      <summary>
            Get a list of all the local cache files (download/)
            </summary>
    </member>
    <member name="M:Sandbox.MenuUtility.Storage.FlushAsync(System.DateTime)">
      <summary>
            Delete all files that haven't been used since x date.
            </summary>
    </member>
    <member name="T:Sandbox.SteamCallbacks">
      <summary>
            Handles callbacks from Steam lobbies and translates them to our Global, Party or Game lobbies.
            </summary>
    </member>
    <member name="T:AssemblyInitialize">
      <summary>
            Called before anything else. The only purpose of this is to load the native dlls
            and swap function pointers with them. We should not be doing anything else here.
            </summary>
    </member>
  </members>
  <assembly>
    <name>Sandbox.Mounting.Quake</name>
  </assembly>
  <members>
    <member name="T:QuakeMount">
      <summary>
            A mounting implementation for Quake
            </summary>
    </member>
  </members>
  <assembly>
    <name>Sandbox.Mounting</name>
  </assembly>
  <members>
    <member name="T:Sandbox.Mounting.ResourceLoader">
      <summary>
            A class responsible for loading a single resource. It will cache the result inside.
            </summary>
    </member>
    <member name="P:Sandbox.Mounting.ResourceLoader.Type">
      <summary>
            The type of resource this file can provide.
            </summary>
    </member>
    <member name="P:Sandbox.Mounting.ResourceLoader.Path">
      <summary>
            The path to the asset
            </summary>
    </member>
    <member name="M:Sandbox.Mounting.ResourceLoader.GetOrCreate">
      <summary>
            Should be implemented to load a specific type
            </summary>
    </member>
    <member name="M:Sandbox.Mounting.ResourceLoader.LoadAsync">
      <summary>
            Should be implemented to load a specific type
            </summary>
    </member>
    <member name="M:Sandbox.Mounting.ResourceLoader.Load">
      <summary>
            Should be implemented to load a specific type
            </summary>
    </member>
    <member name="T:Sandbox.Mounting.ResourceType">
      <summary>
            What resource can come out of this file
            </summary>
    </member>
    <member name="T:Sandbox.Mounting.BaseGameMount">
      <summary>
            The base class for all mounts. Your mount should implement the abstract methods from this class.
            </summary>
    </member>
    <member name="P:Sandbox.Mounting.BaseGameMount.IsInstalled">
      <summary>
            True if this source is installed on the system and can be mounted.
            </summary>
    </member>
    <member name="P:Sandbox.Mounting.BaseGameMount.IsMounted">
      <summary>
            True if this is currently active and mounted
            </summary>
    </member>
    <member name="P:Sandbox.Mounting.BaseGameMount.Ident">
      <summary>
            A short, lowercase string that will be used to uniquely identify this asset source
            ie "rust"
            </summary>
    </member>
    <member name="P:Sandbox.Mounting.BaseGameMount.Title">
      <summary>
            The display name of the game this mounts, ie "Rust"
            </summary>
    </member>
    <member name="P:Sandbox.Mounting.BaseGameMount.Log">
      <summary>
            Allows logging for this specific asset source
            </summary>
    </member>
    <member name="M:Sandbox.Mounting.BaseGameMount.Initialize(Sandbox.Mounting.InitializeContext)">
      <summary>
            Called on startup, in parallel with other sources. Use this to check for the presence of the game on disk and
            set the IsInstalled property if it is.
            </summary>
    </member>
    <member name="M:Sandbox.Mounting.BaseGameMount.Mount(Sandbox.Mounting.MountContext)">
      <summary>
            Try to mount. Should set Mounted to true if success.
            </summary>
    </member>
    <member name="M:Sandbox.Mounting.BaseGameMount.Shutdown">
      <summary>
            Called on destroy, if you have any files open, now is the time to close them.
            </summary>
    </member>
    <member name="P:Sandbox.Mounting.BaseGameMount.Resources">
      <summary>
            All of the resources in this game
            </summary>
    </member>
    <member name="M:Sandbox.Mounting.BaseGameMount.RefreshInternal">
      <summary>
            Unmount and re-mount the source. Used during development to update the files.
            </summary>
    </member>
    <member name="M:Sandbox.Mounting.InitializeContext.IsAppInstalled(System.Int64)">
      <summary>
            Return true if this app is installed on Steam
            </summary>
    </member>
    <member name="M:Sandbox.Mounting.InitializeContext.GetAppDirectory(System.Int64)">
      <summary>
            If this app is installed we'll return the folder in which it is installed
            </summary>
    </member>
    <member name="T:Sandbox.Mounting.MountHost">
      <summary>
            Holds all of the AssetSource systems and acts as a single access point.
            </summary>
    </member>
    <member name="M:Sandbox.Mounting.MountHost.GetSource(System.String)">
      <summary>
            Get an asset source by its ident
            </summary>
    </member>
    <member name="M:Sandbox.Mounting.MountHost.Mount(System.String)">
      <summary>
            Mount this asset source
            </summary>
    </member>
    <member name="M:Sandbox.Mounting.MountHost.Unmount(System.String)">
      <summary>
            Mount this asset source
            </summary>
    </member>
  </members>
  <assembly>
    <name>Sandbox.NetCore</name>
  </assembly>
  <members />
  <assembly>
    <name>Sandbox.Reflection</name>
  </assembly>
  <members>
    <member name="T:ExposeAttribute">
      <summary>
        <para>
            If set on a type, it (and its descendants) can be created
            and manipulated via the TypeLibrary system, and therefore also in action graphs.
            </para>
        <para>
            Note that this is only useful for our internal libraries because
            everything in compiled (addons) assemblies is accessible anyway.
            </para>
      </summary>
    </member>
    <member name="T:Sandbox.DisplayInfo">
      <summary>
            Collects all the relevant info (such as description, name, icon, etc) from attributes and other sources about a type or type member.
            </summary>
    </member>
    <member name="F:Sandbox.DisplayInfo.ClassName">
      <summary>
            "Internal" class name of this type or member. This typically should be all lowercase and without weird symbols or whitespace.
            </summary>
    </member>
    <member name="F:Sandbox.DisplayInfo.Namespace">
      <summary>
            Namespace of this type
            </summary>
    </member>
    <member name="F:Sandbox.DisplayInfo.Fullname">
      <summary>
            Namespace.ParentClass.Class.Member
            </summary>
    </member>
    <member name="F:Sandbox.DisplayInfo.Name">
      <summary>
            The name of this type or member.
            </summary>
    </member>
    <member name="F:Sandbox.DisplayInfo.Description">
      <summary>
            The summary or description of this type or member.
            </summary>
    </member>
    <member name="F:Sandbox.DisplayInfo.Group">
      <summary>
            Group or category of this type or member. (<see cref="T:CategoryAttribute" />)
            </summary>
    </member>
    <member name="F:Sandbox.DisplayInfo.ReadOnly">
      <summary>
            This is marked as ReadOnly
            </summary>
    </member>
    <member name="F:Sandbox.DisplayInfo.Icon">
      <summary>
            Material icon of this type or member. (<see cref="T:IconAttribute" />)
            </summary>
    </member>
    <member name="F:Sandbox.DisplayInfo.Order">
      <summary>
            Order of this member for UI ordering purposes. (<see cref="T:OrderAttribute" />)
            </summary>
    </member>
    <member name="F:Sandbox.DisplayInfo.Browsable">
      <summary>
            Whether this member should be visible in a properties sheet (<see cref="T:HideInEditorAttribute" />)
            </summary>
    </member>
    <member name="F:Sandbox.DisplayInfo.Placeholder">
      <summary>
            Placeholder text for string type properties. (<see cref="T:PlaceholderAttribute" />)
            Placeholder text is displayed in UI when input text field is empty.
            </summary>
    </member>
    <member name="F:Sandbox.DisplayInfo.Alias">
      <summary>
            Possible aliases for this type or member, if any. (<see cref="T:AliasAttribute" />)
            </summary>
    </member>
    <member name="F:Sandbox.DisplayInfo.Tags">
      <summary>
            Tags of this type or member. (<see cref="T:TagAttribute" />)
            </summary>
    </member>
    <member name="M:Sandbox.DisplayInfo.HasTag(System.String)">
      <summary>
            Returns whether this type or member has given tag. (<see cref="T:TagAttribute" />)
            </summary>
      <param name="t">The tag to test.</param>
      <returns>Whether the tag is present or not</returns>
    </member>
    <member name="M:Sandbox.DisplayInfo.ForType(System.Type,System.Boolean)">
      <summary>
            Retrieves display info about a given type.
            </summary>
      <param name="t">The type to look up display info for.</param>
      <param name="inherit">Whether to load in base type's display info first, then overrides all possible fields with given type's information.</param>
      <returns>The display info. Will contain empty fields on failure.</returns>
    </member>
    <member name="M:Sandbox.DisplayInfo.For(System.Object,System.Boolean)">
      <summary>
            Retrieves display info about a given objects type.
            </summary>
      <param name="t">The type to look up display info for.</param>
      <param name="inherit">Whether to load in base type's display info first, then overrides all possible fields with given type's information.</param>
      <returns>The display info. Will contain empty fields on failure.</returns>
    </member>
    <member name="M:Sandbox.DisplayInfo.ForMember(System.Reflection.MemberInfo,System.Boolean)">
      <summary>
            Retrieves display info about a given member or type.
            </summary>
      <param name="t">The member to look up display info for.</param>
      <param name="inherit">If member given is a <see cref="T:System.Type" />, loads in base type's display info first, then overrides all possible fields with given type's information.</param>
      <returns>The display info. Will contain empty fields on failure.</returns>
    </member>
    <member name="M:Sandbox.DisplayInfo.ForEnumValues(System.Type)">
      <summary>
            Returns display info for each member of an enumeration type.
            </summary>
    </member>
    <member name="M:Sandbox.DisplayInfo.ForEnumValues``1">
      <summary>
            Returns display info for each member of an enumeration type.
            </summary>
    </member>
    <member name="M:Sandbox.DisplayInfo.InterfaceTypeNameRegex">
      <remarks>
            Pattern:<br /><code>^I[A-Z]</code><br />
            Explanation:<br /><code>
            ○ Match if at the beginning of the string.<br />
            ○ Match 'I'.<br />
            ○ Match a character in the set [A-Z].<br /></code></remarks>
    </member>
    <member name="M:Sandbox.DisplayInfo.EventMethodNameRegex">
      <remarks>
            Pattern:<br /><code>^On[A-Z]</code><br />
            Explanation:<br /><code>
            ○ Match if at the beginning of the string.<br />
            ○ Match the string "On".<br />
            ○ Match a character in the set [A-Z].<br /></code></remarks>
    </member>
    <member name="M:Sandbox.ReflectionExtensions.LoadFromStreamWithEmbeds(System.Runtime.Loader.AssemblyLoadContext,System.IO.Stream)">
      <summary>
            The assembly might have a pdb embedded inside. So load it with PEReader and have a look inside to see if it
            is in there. Then if it is, load the assembly with the pdb.
            I don't know why this isn't done by default.. but apparently it's not. So we have to do it manually.
            </summary>
    </member>
    <member name="M:Sandbox.ReflectionExtensions.GetEventInfo(System.Reflection.FieldInfo)">
      <summary>
            Try to get the event for which this member is a backing field.
            </summary>
    </member>
    <member name="M:Sandbox.ReflectionExtensions.GetInheritedConstructedGenericType(System.Type,System.Type)">
      <summary>
            Looks through the inheritance hierarchy of <paramref name="type" />, including its
            implemented interfaces, for constructed instances of <paramref name="genericTypeDef" />.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetAttributes``1">
      <summary>
            Get all attributes of this type
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetTypesWithAttribute``1">
      <summary>
            Get all attributes of this type. Returns the type description along with the attribute. This will 
            also return types that inherit the attribute from base classes too.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetTypesWithAttribute``1(System.Boolean)">
      <summary>
            Get all attributes of this type. Returns the type description along with the attribute.
            If inherited is false, we will return only classes that contain this attribute directly.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetAttribute``1(System.Type)">
      <summary>
            Get single attribute of type, from type
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetAttributes``1(System.Type)">
      <summary>
            Get all attribute of type, from all types assignable to type
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.AssertType(System.Type)">
      <summary>
            Will throw an exception if the type isn't in the whitelist
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.IsAllowedType(System.Type)">
      <summary>
            We're allowed to use the type if we know about it
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.Create(System.String,System.Type,System.Object[])">
      <summary>
            Create a type instance by name and is assignable to given type, with optional arguments for its constructor.
            </summary>
      <param name="name">Name of the type to create.</param>
      <param name="targetType">Type "constraint", as in the type instance must be assignable to this given type.</param>
      <param name="args">Optional arguments for the constructor of the selected type.</param>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.Create``1(System.Type,System.Object[])">
      <summary>
            Create type instance from type.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.Create``1(System.String,System.Boolean)">
      <summary>
            Create a type instance by name and is assignable to given type.
            </summary>
      <param name="name">Name of the type to create.</param>
      <param name="complainOnMissing">Display a warning when requested type name was not found.</param>
      <typeparam name="T">Type "constraint", as in the type instance must be assignable to this given type.</typeparam>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.Create``1(System.String,System.Object[],System.Boolean)">
      <summary>
            Create a type instance by name and is assignable to given type.
            </summary>
      <param name="name">Name of the type to create.</param>
      <param name="complainOnMissing">Display a warning when requested type name was not found.</param>
      <param name="args" />
      <typeparam name="T">Type "constraint", as in the type instance must be assignable to this given type.</typeparam>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.Create``1(System.Int32)">
      <summary>
            Create a type instance by its identity. See <see cref="M:Sandbox.Internal.TypeLibrary.GetIdent(System.Type)" />.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.CreateGeneric``1(System.Type,System.Type,System.Object[])">
      <summary>
            Create type by type
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetMethodsWithAttribute``1">
      <summary>
            Find all static methods with given attribute.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.FindStaticMethods(System.String)">
      <summary>
            Find all static methods with given name.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.FindStaticMethods``1(System.String)">
      <summary>
            Find all static methods with given name and given attribute.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetMemberAttributes``1">
      <summary>
            Find all member attributes (instances) with given attribute type.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetMembersWithAttribute``1">
      <summary>
            Find all static members with given attribute.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetMemberAttributes``1(System.Boolean)">
      <summary>
            Find all static or non static only member attributes (instances) with given attribute type.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetPropertyDescriptions(System.Object,System.Boolean)">
      <summary>
            Get a list of properties on the target object. To do this we'll just call GetDescription( obj.GetType() ) and return .Properties.
            Will return an empty array if we can't access these properties.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.SetProperty(System.Object,System.String,System.Object)">
      <summary>
            Set a named property on given object.
            Will perform extra magic for string inputs and try to convert to target property type.
            </summary>
      <param name="target">The target object to set a named property on.</param>
      <param name="name">Name of the property to set.</param>
      <param name="value">Value for the property.</param>
      <returns>Whether the property was set or not.</returns>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetPropertyValue(System.Object,System.String)">
      <summary>
            Try to get a value from a property on an object
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.ToBytes``1(``0)">
      <summary>
            Serialize this value to bytes, where possible
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.ToBytes``1(``0,Sandbox.ByteStream@)">
      <summary>
            Serialize this value to bytes, where possible
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.FromBytes``1(System.Byte[])">
      <summary>
            Deserialize this from bytes. 
            If the type is unknown, T can be an object.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.FromBytes``1(System.ReadOnlySpan{System.Byte})">
      <summary>
            Deserialize this from bytes. 
            If the type is unknown, T can be an object.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.FromBytes``1(Sandbox.ByteStream@)">
      <summary>
            Deserialize this from bytes. 
            If the type is unknown, T can be an object.
            </summary>
    </member>
    <member name="F:Sandbox.Internal.TypeLibrary.Editor">
      <summary>
            The editor's TypeLibrary contains the game's typelibrary as well as all the editor types. 
            This is null when not running in editor mode!
            </summary>
    </member>
    <member name="F:Sandbox.Internal.TypeLibrary.Current">
      <summary>
            The current TypeLibrary. God we could make TypeLibrary a big sexy static class how awesome would that be.
            </summary>
    </member>
    <member name="F:Sandbox.Internal.TypeLibrary.OnClassName">
      <summary>
            Called to populate StringTokens with our custom tokens in c#
            </summary>
    </member>
    <member name="F:Sandbox.Internal.TypeLibrary.Types">
      <summary>
            A list of loaded types.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.Dispose">
      <summary>
            Clean up after ourselves
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.AddIntrinsicTypes">
      <summary>
            Add essential types from <c>System</c> assemblies, for example
            <see cref="T:System.Object" />, <see cref="T:System.String" />, and <see cref="T:System.Int32" />.
            Only public members of these types will be added.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.AddAssembly(System.Reflection.Assembly,System.Boolean)">
      <summary>
            Add an assembly yo the library.
            If marked as dynamic then all types are added.
            </summary>
    </member>
    <member name="P:Sandbox.Internal.TypeLibrary.WhitelistedSystemMembers">
      <summary>
            For some system types we only want to expose a subset of public members. In the future
            we should try to use the same whitelist as when checking user code, but that's a bit scary.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.TakeRemovedType(System.Type)">
      <summary>
            Find a type that was previously removed
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.StoreRemovedType(Sandbox.TypeDescription)">
      <summary>
            Store this type in the removed list, incase the assembly comes back. We
            can re-initialize it - so all the references to it will be unchanged.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.ClearRemovedTypes">
      <summary>
            Removed all of the stored removed types
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.RemoveAssembly(System.Reflection.Assembly)">
      <summary>
            Remove a specific assembly and all types associated with it
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetTypeIdent(System.Type)">
      <summary>
            Get hash of a type.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetType(System.Type)">
      <summary>
            Get the description for a specific type. This will return null if you don't have whitelist access to the type.
            For constructed generic types, this will give you the description of the generic type definition.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetGenericTypes(System.Type,System.Type[])">
      <summary>
            Get a list of types that implement this generic type
            </summary>
    </member>
    <member name="F:Sandbox.Internal.TypeLibrary._getTypesCache">
      <summary>
            Cache for quickly looking up derived types
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetTypes(System.Type)">
      <summary>
            Get descriptions for all types that derive from T
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetType``1(System.String)">
      <summary>
            Find a TypeDescription that derives from <typeparamref name="T" />, by name
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetType``1(System.String,System.Boolean)">
      <summary>
            Find a TypeDescription that derives from T by name, which can be an Alias etc.
            If preferAddonAssembly is true, then if there are conflicts we'll prefer types that are 
            in addon code.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetType(System.Type,System.String,System.Boolean)">
      <summary>
            Find a TypeDescription that derives from T by name, which can be an Alias etc.
            If preferAddonAssembly is true, then if there are conflicts we'll prefer types that are 
            in addon code.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetTypes``1">
      <summary>
            Get descriptions for all types that derive from T
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetTypes">
      <summary>
            Get all types
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetType``1">
      <summary>
            Find the description for templated type
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.TryGetType(System.Type,Sandbox.TypeDescription@)">
      <summary>
            Find the description type
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.TryGetType``1(Sandbox.TypeDescription@)">
      <summary>
            Find the description type
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetType(System.String)">
      <summary>
            Find a TypeDescription by name
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetTypeByIdent(System.Int32)">
      <summary>
            Find a TypeDescription by name
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetMemberByIdent(System.Int32)">
      <summary>
            Find a <see cref="T:Sandbox.MemberDescription" /> by its <see cref="P:Sandbox.MemberDescription.Identity" /></summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetType(System.String,System.Type)">
      <summary>
            Find a TypeDescription that derives from <paramref name="baseType" />, by name
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetGenericArguments(System.Type)">
      <summary>
            Performs <see cref="M:System.Type.GetGenericArguments" /> with access control checks.
            Will throw if any arguments aren't in the whitelist.
            </summary>
      <param name="genericType">Constructed generic type to get the arguments of</param>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.HasAttribute``1(System.Type)">
      <summary>
            Return true if this type contains this attribute
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.CheckValidationAttributes``1(``0)">
      <summary>
            Check if all properties of this class instance pass their <see cref="T:System.ComponentModel.DataAnnotations.ValidationAttribute" />.
            </summary>
      <param name="obj">Object to test.</param>
      <returns>True if all properties pass their validity checks (or if there are no checks), false otherwise.</returns>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetSerializedObject(System.Object)">
      <summary>
            Get a SerializedObject version of this object
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetSerializedObject(System.Func{System.Object},Sandbox.TypeDescription,Sandbox.SerializedProperty)">
      <summary>
            Gets a SerializedObject version of a value retrieved from a function.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetSerializedObjectDictionary``1(Sandbox.CaseInsensitiveDictionary{System.String})">
      <summary>
            Get a SerializedObject version of this type of object, but data is stored in a dictionary
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetSerializedObjectDictionary(System.Type,Sandbox.CaseInsensitiveDictionary{System.String})">
      <summary>
            Get a SerializedObject version of this type of object, but data is stored in a dictionary
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetEnumDescription(System.Type)">
      <summary>
            Get a class describing the values of an enum
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.CreateProperty``1(System.String,System.Func{``0},System.Action{``0},System.Attribute[],Sandbox.SerializedObject)">
      <summary>
            Create a serialized property that uses a getter and setter
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.CreateProperty``1(System.String,Sandbox.SerializedObject,System.Attribute[],Sandbox.SerializedObject)">
      <summary>
            Create a serialized property from a SerializedObject
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeLibrary.GetStaticMethods``1(System.String,System.String)">
      <summary>
            This is used primarily to get GlobalRpcHandler.OnRpc
            </summary>
    </member>
    <member name="P:Sandbox.Internal.TypeLibrary.DynamicAssemblyHash">
      <summary>
            This is a hash of loaded assembly names. We can use it to make sure we're using
            the same code as the server. This is important when it comes to things like decoding
            network messages and datatables - because if the code is different we're going to
            get errors, because it could expect different data.
            </summary>
    </member>
    <member name="T:Sandbox.Internal.IsolatedAssemblyContext">
      <summary>
            This isolates the dll so it can be unloaded and can have the same name as other loaded dlls
            </summary>
    </member>
    <member name="F:Sandbox.Internal.LoadContext.root">
      <summary>
            If the assembly isn't found in this context, we'll load from
            the context used by the root Assembly.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.LoadContext.LoadFromStreamWithEmbeds(System.IO.Stream,System.Boolean)">
      <summary>
            The assembly might have a pdb embedded inside. So load it with PEReader and have a look inside to see if it
            is in there. Then if it is, load the assembly with the pdb.
            I don't know why this isn't done by default.. but apparently it's not. So we have to do it manually.
            </summary>
    </member>
    <member name="T:Sandbox.Internal.DictionarySerializedObject">
      <summary>
            An implementation of TypeLibrary which uses TypeLibrary to fill out properties
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeSerializedField.GetAttributes">
      <inheritdoc />
    </member>
    <member name="M:Sandbox.Internal.TypeSerializedField.TryGetAsObject(Sandbox.SerializedObject@)">
      <inheritdoc />
    </member>
    <member name="M:Sandbox.Internal.TypeSerializedMethod.GetAttributes">
      <inheritdoc />
    </member>
    <member name="T:Sandbox.Internal.TypeSerializedObject">
      <summary>
            An implementation of SerializedObject which uses TypeLibrary to fill out properties
            </summary>
    </member>
    <member name="F:Sandbox.Internal.TypeSerializedObject.FetchTarget">
      <summary>
            If the object is a value type, we call a method to get the value each time before we change/update/read it.
            If it's a class, we fetch it once and set FetchTarget to null.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeSerializedObject.GetTargetObject">
      <summary>
            Get the target object. If the target object is a value type, we'll
            call FetchTarget() - which should fetch the latest copy of it from
            the parent. 
            Note that by design FetchTarget is null if it's not a value type.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeSerializedProperty.SetValue``1(``0,Sandbox.SerializedProperty)">
      <summary>
            When setting because a child property changed, we don't trigger NoteChanged
            because the expectation is that the NoteChanged from setting that property
            will instead propogate up, and will be more accurate.
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeSerializedProperty.GetAttributes">
      <inheritdoc />
    </member>
    <member name="M:Sandbox.Internal.TypeSerializedProperty.TryGetAsObject(Sandbox.SerializedObject@)">
      <inheritdoc />
    </member>
    <member name="T:Sandbox.Internal.SerializerPacker`1">
      <summary>
            A packer that handles serialization and deserialization for implementations of <see cref="T:Sandbox.BytePack.ISerializer" />.
            </summary>
      <typeparam name="T" />
    </member>
    <member name="M:Sandbox.Internal.SerializerPacker`1.Write(Sandbox.ByteStream@,System.Object)">
      <summary>
            Write an object to the <see cref="T:Sandbox.ByteStream" /> through the implementation of <see cref="M:Sandbox.BytePack.ISerializer.BytePackWrite(System.Object,Sandbox.ByteStream@)" /> for this type.
            </summary>
      <param name="bs" />
      <param name="value" />
    </member>
    <member name="M:Sandbox.Internal.SerializerPacker`1.Read(Sandbox.ByteStream@)">
      <summary>
            Read an object from the <see cref="T:Sandbox.ByteStream" /> through the implementation of <see cref="M:Sandbox.BytePack.ISerializer.BytePackRead(Sandbox.ByteStream@,System.Type)" /> for this type.
            </summary>
      <param name="bs" />
      <returns />
    </member>
    <member name="T:Sandbox.FieldDescription">
      <summary>
             Describes a field. We use this class to wrap and return <see cref="P:Sandbox.FieldDescription.FieldInfo">FieldInfo</see>'s that are safe to interact with.
            
             Returned by <see cref="T:Sandbox.Internal.TypeLibrary" /> and <see cref="T:Sandbox.TypeDescription" />.
             </summary>
    </member>
    <member name="P:Sandbox.FieldDescription.IsInitOnly">
      <inheritdoc cref="P:System.Reflection.FieldInfo.IsInitOnly" />
    </member>
    <member name="P:Sandbox.FieldDescription.FieldType">
      <summary>
            Property type.
            </summary>
    </member>
    <member name="M:Sandbox.FieldDescription.GetValue(System.Object)">
      <summary>
            Get the value of this property on given object.
            </summary>
    </member>
    <member name="M:Sandbox.FieldDescription.SetValue(System.Object,System.Object)">
      <summary>
            Set the value of this property on given object.
            </summary>
    </member>
    <member name="T:Sandbox.IMemberAttribute">
      <summary>
            When applied to an attribute, which is them applied to a member..
            This will make <see cref="P:Sandbox.IMemberAttribute.MemberDescription" /> set on the attribute upon load.
            <para>This provides a convenient way to know which member the attribute was attached to.</para></summary>
    </member>
    <member name="P:Sandbox.IMemberAttribute.MemberDescription">
      <summary>
            Description of the member this attribute was attached to.
            </summary>
    </member>
    <member name="T:Sandbox.MemberDescription">
      <summary>
             Wraps <see cref="F:Sandbox.MemberDescription.MemberInfo">MemberInfo</see> but with caching and sandboxing.
            
             Returned by <see cref="T:Sandbox.Internal.TypeLibrary" /> and <see cref="T:Sandbox.TypeDescription" />.
             </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.TypeDescription">
      <summary>
            The type that we're a member of
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.Ident">
      <summary>
            Unique identifier based on full name
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.Name">
      <summary>
            Name of this type member.
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.Identity">
      <summary>
            An integer that represents this member. Based off its type and name.
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.Title">
      <summary>
            Display name or title of this type member.
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.Description">
      <summary>
            Description of this type member. This usually provided from the summary XML comment above the definition.
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.Icon">
      <summary>
            The icon for this, if provided via the [Icon] attribute
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.Group">
      <summary>
            The group - usually provided via the [Group] attribute
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.ReadOnly">
      <summary>
            If this is marked as [ReadOnly]
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.Order">
      <summary>
            The display order - usually provided via the [Order] attribute
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.Tags">
      <summary>
            Tags are usually provided via the [Tags] attribute
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.Aliases">
      <summary>
            Aliases allow this to be found by alternative names.
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.Attributes">
      <summary>
            Attributes on this member
            </summary>
    </member>
    <member name="M:Sandbox.MemberDescription.GetDisplayInfo">
      <summary>
            Access the full DisplayInfo for this type. This is faster than creating the DisplayInfo every time we need it.
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.IsStatic">
      <summary>
            True if static
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.IsPublic">
      <summary>
            True if publicly accessible
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.IsFamily">
      <inheritdoc cref="P:System.Reflection.MethodBase.IsFamily" />
    </member>
    <member name="P:Sandbox.MemberDescription.IsMethod">
      <summary>
            True if we're a method
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.IsProperty">
      <summary>
            True if we're a property
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.IsField">
      <summary>
            True if we're a field
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.SourceLine">
      <summary>
            The line number of this member
            </summary>
    </member>
    <member name="P:Sandbox.MemberDescription.SourceFile">
      <summary>
            The file containing this member
            </summary>
    </member>
    <member name="M:Sandbox.MemberDescription.GetIdentityHash">
      <summary>
            Generate a unique hash to identity this member.
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.MemberDescription.IsNamed(System.String)">
      <summary>
            Utility function to check whether this string matches this type. Will search name and classname.
            </summary>
    </member>
    <member name="M:Sandbox.MemberDescription.HasTag(System.String)">
      <summary>
            Returns true if Tags contains this tag
            </summary>
    </member>
    <member name="M:Sandbox.MemberDescription.Create(Sandbox.TypeDescription,System.Reflection.MemberInfo,Sandbox.MemberDescription)">
      <summary>
            TODO - create MethodDescription?
            </summary>
    </member>
    <member name="M:Sandbox.MemberDescription.HasAttribute``1">
      <summary>
            Whether or not this has at least one of the specified attribute.
            </summary>
    </member>
    <member name="M:Sandbox.MemberDescription.HasAttribute(System.Type)">
      <summary>
            Whether or not this has at least one of the specified attribute.
            </summary>
    </member>
    <member name="M:Sandbox.MemberDescription.GetCustomAttribute``1">
      <summary>
            Returns the first of Attributes of the passed in type. Or null.
            </summary>
    </member>
    <member name="T:Sandbox.MethodDescription">
      <summary>
             Describes a method. We use this class to wrap and return <see cref="T:System.Reflection.MethodInfo">MethodInfo</see>'s that are safe to interact with.
            
             Returned by <see cref="T:Sandbox.Internal.TypeLibrary" /> and <see cref="T:Sandbox.TypeDescription" />.
             </summary>
    </member>
    <member name="P:Sandbox.MethodDescription.IsMethod">
      <summary>
            Returns true - because this is a method
            </summary>
    </member>
    <member name="P:Sandbox.MethodDescription.IsSpecialName">
      <inheritdoc cref="P:System.Reflection.MethodBase.IsSpecialName" />
    </member>
    <member name="P:Sandbox.MethodDescription.IsVirtual">
      <inheritdoc cref="P:System.Reflection.MethodBase.IsVirtual" />
    </member>
    <member name="P:Sandbox.MethodDescription.ReturnType">
      <summary>
            Gets the return type of this method.
            </summary>
    </member>
    <member name="P:Sandbox.MethodDescription.Parameters">
      <summary>
            Gets a list of parameters expected by this method
            </summary>
    </member>
    <member name="M:Sandbox.MethodDescription.GetIdentityHash">
      <inheritdoc />
    </member>
    <member name="M:Sandbox.MethodDescription.Invoke(System.Object,System.Object[])">
      <summary>
            Invokes this method.
            </summary>
      <param name="targetObject">Should be null if this is static, otherwise should be the object this is a member of.</param>
      <param name="parameters">An array of parameters to pass. Should be the same length as Parameters</param>
    </member>
    <member name="M:Sandbox.MethodDescription.InvokeWithReturn``1(System.Object,System.Object[])">
      <summary>
            Invokes this method and returns a value.
            </summary>
      <param name="targetObject">Should be null if this is static, otherwise should be the object this is a member of.</param>
      <param name="parameters">An array of parameters to pass. Should be the same length as Parameters</param>
    </member>
    <member name="M:Sandbox.MethodDescription.CreateDelegate``1">
      <summary>
            Creates a delegate bound to this method.
            </summary>
      <typeparam name="T">Delegate type</typeparam>
    </member>
    <member name="M:Sandbox.MethodDescription.CreateDelegate``1(System.Object)">
      <summary>
            Creates a delegate bound to this method.
            </summary>
      <typeparam name="T">Delegate type</typeparam>
      <param name="target">Value for the first parameter / target object</param>
    </member>
    <member name="M:Sandbox.MethodDescription.CreateDelegate(System.Type)">
      <summary>
            Creates a delegate bound to this method.
            </summary>
      <param name="delegateType">Delegate type to create</param>
    </member>
    <member name="M:Sandbox.MethodDescription.CreateDelegate(System.Type,System.Object)">
      <summary>
            Creates a delegate bound to this method.
            </summary>
      <param name="delegateType">Delegate type to create</param>
      <param name="target">Value for the first parameter / target object</param>
    </member>
    <member name="T:Sandbox.PropertyDescription">
      <summary>
             Describes a property. We use this class to wrap and return <see cref="P:Sandbox.PropertyDescription.PropertyInfo">PropertyInfo</see>'s that are safe to interact with.
            
             Returned by <see cref="T:Sandbox.Internal.TypeLibrary" /> and <see cref="T:Sandbox.TypeDescription" />.
             </summary>
    </member>
    <member name="P:Sandbox.PropertyDescription.CanWrite">
      <summary>
            Whether this property can be written to.
            </summary>
    </member>
    <member name="P:Sandbox.PropertyDescription.CanRead">
      <summary>
            Whether this property can be read.
            </summary>
    </member>
    <member name="P:Sandbox.PropertyDescription.IsGetMethodPublic">
      <summary>
            Whether the getter of this property is public.
            </summary>
    </member>
    <member name="P:Sandbox.PropertyDescription.IsSetMethodPublic">
      <summary>
            Whether the setter of this property is public.
            </summary>
    </member>
    <member name="P:Sandbox.PropertyDescription.PropertyType">
      <summary>
            Property type.
            </summary>
    </member>
    <member name="P:Sandbox.PropertyDescription.IsIndexer">
      <summary>
            True if this property has index parameters
            </summary>
    </member>
    <member name="M:Sandbox.PropertyDescription.GetValue(System.Object)">
      <summary>
            Get the value of this property on given object.
            </summary>
    </member>
    <member name="M:Sandbox.PropertyDescription.SetValue(System.Object,System.Object)">
      <summary>
            Set the value of this property on given object.
            </summary>
    </member>
    <member name="M:Sandbox.PropertyDescription.CheckValidationAttributes(System.Object,System.String[]@,System.String)">
      <inheritdoc cref="M:Sandbox.SandboxSystemExtensions.CheckValidationAttributes(System.Reflection.PropertyInfo,System.Object,System.String[]@,System.String)" />
    </member>
    <member name="F:Sandbox.ActionGraphs.ActionGraphExtensions.CurrentNodeLibrary">
      <summary>
        <see cref="T:Facepunch.ActionGraphs.NodeLibrary" /> to use when serializing / deserializing <see cref="T:Facepunch.ActionGraphs.ActionGraph" />s.
            </summary>
    </member>
    <member name="M:Sandbox.ActionGraphs.ActionGraphExtensions.GetReferencedComponentTypes(Facepunch.ActionGraphs.ActionGraph)">
      <summary>
            Gets all component types referenced using "scene.get" nodes. These components are expected
            to be on the GameObject containing the graph.
            </summary>
    </member>
    <member name="T:Sandbox.ActionGraphs.TypeLoader">
      <summary>
            All action graph reflection goes through here, so we can control what people can access.
            </summary>
    </member>
    <member name="M:Sandbox.ActionGraphs.TypeLoader.TypeToIdentifier(System.Type)">
      <summary>
            Used when an action graph serializes a <see cref="T:System.Type" />. Must match <see cref="M:Sandbox.ActionGraphs.TypeLoader.TypeFromIdentifier(System.String)" />.
            </summary>
    </member>
    <member name="M:Sandbox.ActionGraphs.TypeLoader.TypeFromIdentifier(System.String)">
      <summary>
            Used when an action graph deserializes a <see cref="T:System.Type" />. Must match <see cref="M:Sandbox.ActionGraphs.TypeLoader.TypeToIdentifier(System.Type)" />.
            </summary>
    </member>
    <member name="T:Sandbox.TypeDescription">
      <summary>
             Describes a type. We use this class to wrap and return <see cref="T:System.Type">System.Type</see>'s that are safe to interact with.
            
             Returned by <see cref="T:Sandbox.Internal.TypeLibrary" />.
             </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.TargetType">
      <summary>
            The type this class describes.
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.BaseType">
      <summary>
            The base type. This can return null if the type isn't in the type library!
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.IsValid">
      <summary>
            Whether the class is valid or not, i.e. whether the type still exists.
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.IsDynamicAssembly">
      <summary>
            Is from an assembly that was whitelist tested, so it can't have any bad stuff in it.
            We can feel happy to expose all members in these assemblies.
            </summary>
    </member>
    <member name="F:Sandbox.TypeDescription.Attributes">
      <summary>
            Attributes that we, and our bases, implement
            </summary>
    </member>
    <member name="F:Sandbox.TypeDescription.OwnAttributes">
      <summary>
            Attributes that we implement directly
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.Members">
      <summary>
            All members (methods, properties, etc) of this type.
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.DeclaredMembers">
      <summary>
            Members (methods, properties, etc) declared by exactly this type, and not inherited.
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.Methods">
      <summary>
            All methods of this type.
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.Properties">
      <summary>
            All properties of this type.
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.Fields">
      <summary>
            All fields on this type.
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.IsInterface">
      <summary>
            True if the target type is an interface
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.IsEnum">
      <summary>
            True if the target type is an enum
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.IsStatic">
      <summary>
            True if the target type is static
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.IsClass">
      <summary>
            True if the target type is a class
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.IsValueType">
      <summary>
            True if the target type is a value
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.IsAbstract">
      <summary>
            Gets a value indicating whether the System.Type is abstract and must be overridden.
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.Name">
      <summary>
            Name of this type.
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.Namespace">
      <summary>
            Namespace of this type.
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.FullName">
      <summary>
            Full name of this type.
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.SerializedName">
      <summary>
            Preferred name to use when serializing this type.
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.Title">
      <inheritdoc cref="F:Sandbox.DisplayInfo.Name" />
    </member>
    <member name="P:Sandbox.TypeDescription.Description">
      <inheritdoc cref="F:Sandbox.DisplayInfo.Description" />
    </member>
    <member name="P:Sandbox.TypeDescription.Icon">
      <inheritdoc cref="F:Sandbox.DisplayInfo.Icon" />
    </member>
    <member name="P:Sandbox.TypeDescription.Group">
      <inheritdoc cref="F:Sandbox.DisplayInfo.Group" />
    </member>
    <member name="P:Sandbox.TypeDescription.Order">
      <inheritdoc cref="F:Sandbox.DisplayInfo.Order" />
    </member>
    <member name="P:Sandbox.TypeDescription.Tags">
      <summary>
            Tags are set via the [Tag] attribute
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.Aliases">
      <inheritdoc cref="F:Sandbox.DisplayInfo.Alias" />
    </member>
    <member name="P:Sandbox.TypeDescription.Identity">
      <summary>
            An integer that represents this type. Based off the class name.
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.ClassName">
      <summary>
            A string representing this class name. Historically this was provided by [Library( classname )].
            If no special name is provided, this will be type.Name.
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.SourceLine">
      <summary>
            The line number of this member
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.SourceFile">
      <summary>
            The file containing this member
            </summary>
    </member>
    <member name="M:Sandbox.TypeDescription.GetMemberIdentity(System.Reflection.MemberInfo)">
      <summary>
            This needs to generate a unique string per member on a type.
            </summary>
    </member>
    <member name="M:Sandbox.TypeDescription.IsNamed(System.String)">
      <summary>
            Returns true if this is named the passed name, either through classname, target class name or an alias
            </summary>
    </member>
    <member name="M:Sandbox.TypeDescription.GetAttribute``1(System.Boolean)">
      <summary>
            Returns the first attribute of given type, if any are present.
            </summary>
    </member>
    <member name="M:Sandbox.TypeDescription.GetAttributes``1(System.Boolean)">
      <summary>
            Returns all attributes of given type, if any are present.
            </summary>
    </member>
    <member name="M:Sandbox.TypeDescription.HasAttribute``1(System.Boolean)">
      <summary>
            Returns true if the class has this attribute
            </summary>
    </member>
    <member name="M:Sandbox.TypeDescription.HasTag(System.String)">
      <summary>
            True if we have this tag.
            </summary>
    </member>
    <member name="M:Sandbox.TypeDescription.GetProperty(System.String)">
      <summary>
            Get property by name
            </summary>
    </member>
    <member name="M:Sandbox.TypeDescription.GetValue(System.Object,System.String)">
      <summary>
            Get value by field or property name
            </summary>
    </member>
    <member name="M:Sandbox.TypeDescription.GetValue(System.Object,System.String,System.Type@)">
      <summary>
            Get value by field or property name, and which type the member is declared to store.
            </summary>
    </member>
    <member name="M:Sandbox.TypeDescription.SetValue(System.Object,System.String,System.Object)">
      <summary>
            Get value by field or property name
            </summary>
    </member>
    <member name="M:Sandbox.TypeDescription.GetMethod(System.String)">
      <summary>
            Get a method by name (will not find static methods)
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.IsGenericType">
      <summary>
            True if we're a generic type
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.GenericArguments">
      <summary>
            If we're a generic type this will return our generic parameters.
            </summary>
    </member>
    <member name="P:Sandbox.TypeDescription.Interfaces">
      <summary>
            If we implement any interfaces they will be here
            </summary>
    </member>
    <member name="M:Sandbox.TypeDescription.Create``1(System.Object[])">
      <summary>
            Create an instance of this class, return it as a T.
            If it can't be cast to a T we won't create it and will return null.
            </summary>
    </member>
    <member name="M:Sandbox.TypeDescription.CreateGeneric``1(System.Type[],System.Object[])">
      <summary>
            Create an instance of this class using generic arguments
            We're going to assume you know what you're doing here and let it throw any exceptions it wants.
            </summary>
    </member>
    <member name="M:Sandbox.TypeDescription.MakeGenericType(System.Type[])">
      <summary>
            For generic type definitions, create a type by substituting the given types for each type parameter.
            We're going to assume you know what you're doing here and let it throw any exceptions it wants.
            </summary>
    </member>
    <member name="M:Sandbox.ReflectionUtility.PreJIT(System.Reflection.Assembly)">
      <summary>
            Pre-compile all of the methods that we can, to reduce the risk of them compiling during gameplay
            </summary>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.InterfaceTypeNameRegex_0">
      <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex" />-derived type for the InterfaceTypeNameRegex method.</summary>
    </member>
    <member name="F:System.Text.RegularExpressions.Generated.InterfaceTypeNameRegex_0.Instance">
      <summary>Cached, thread-safe singleton instance.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.InterfaceTypeNameRegex_0.#ctor">
      <summary>Initializes the instance.</summary>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.InterfaceTypeNameRegex_0.RunnerFactory">
      <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner" /> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.InterfaceTypeNameRegex_0.RunnerFactory.CreateInstance">
      <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner" /> used by methods on <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.InterfaceTypeNameRegex_0.RunnerFactory.Runner">
      <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.InterfaceTypeNameRegex_0.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
      <summary>Scan the <paramref name="inputSpan" /> starting from base.runtextstart for the next match.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.InterfaceTypeNameRegex_0.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
      <summary>Search <paramref name="inputSpan" /> starting from base.runtextpos for the next location a match could possibly start.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
      <returns>true if a possible match was found; false if no more matches are possible.</returns>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.InterfaceTypeNameRegex_0.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
      <summary>Determine whether <paramref name="inputSpan" /> at base.runtextpos is a match for the regular expression.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
      <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.EventMethodNameRegex_1">
      <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex" />-derived type for the EventMethodNameRegex method.</summary>
    </member>
    <member name="F:System.Text.RegularExpressions.Generated.EventMethodNameRegex_1.Instance">
      <summary>Cached, thread-safe singleton instance.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.EventMethodNameRegex_1.#ctor">
      <summary>Initializes the instance.</summary>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.EventMethodNameRegex_1.RunnerFactory">
      <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner" /> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.EventMethodNameRegex_1.RunnerFactory.CreateInstance">
      <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner" /> used by methods on <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.EventMethodNameRegex_1.RunnerFactory.Runner">
      <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.EventMethodNameRegex_1.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
      <summary>Scan the <paramref name="inputSpan" /> starting from base.runtextstart for the next match.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.EventMethodNameRegex_1.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
      <summary>Search <paramref name="inputSpan" /> starting from base.runtextpos for the next location a match could possibly start.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
      <returns>true if a possible match was found; false if no more matches are possible.</returns>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.EventMethodNameRegex_1.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
      <summary>Determine whether <paramref name="inputSpan" /> at base.runtextpos is a match for the regular expression.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
      <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.Utilities">
      <summary>Helper methods used by generated <see cref="T:System.Text.RegularExpressions.Regex" />-derived implementations.</summary>
    </member>
    <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout">
      <summary>Default timeout value set in <see cref="T:System.AppContext" />, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> if none was set.</summary>
    </member>
    <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_hasTimeout">
      <summary>Whether <see cref="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout" /> is non-infinite.</summary>
    </member>
  </members>
  <assembly>
    <name>Sandbox.SolutionGenerator</name>
  </assembly>
  <members>
    <member name="T:Sandbox.SolutionGenerator.Project">
      <summary>
            Class to produce the template output
            </summary>
    </member>
    <member name="M:Sandbox.SolutionGenerator.Project.TransformText">
      <summary>
            Create the template output
            </summary>
    </member>
    <member name="F:Sandbox.SolutionGenerator.Project.ManagedRoot">
      <summary>
            Relative path to the game/bin/managed folder
            </summary>
    </member>
    <member name="F:Sandbox.SolutionGenerator.Project.GameRoot">
      <summary>
            Relative path to the game/ folder
            </summary>
    </member>
    <member name="T:Sandbox.SolutionGenerator.ProjectBase">
      <summary>
            Base class for this transformation
            </summary>
    </member>
    <member name="P:Sandbox.SolutionGenerator.ProjectBase.GenerationEnvironment">
      <summary>
            The string builder that generation-time code is using to assemble generated output
            </summary>
    </member>
    <member name="P:Sandbox.SolutionGenerator.ProjectBase.Errors">
      <summary>
            The error collection for the generation process
            </summary>
    </member>
    <member name="P:Sandbox.SolutionGenerator.ProjectBase.indentLengths">
      <summary>
            A list of the lengths of each indent that was added with PushIndent
            </summary>
    </member>
    <member name="P:Sandbox.SolutionGenerator.ProjectBase.CurrentIndent">
      <summary>
            Gets the current indent we use when adding lines to the output
            </summary>
    </member>
    <member name="P:Sandbox.SolutionGenerator.ProjectBase.Session">
      <summary>
            Current transformation session
            </summary>
    </member>
    <member name="M:Sandbox.SolutionGenerator.ProjectBase.Write(System.String)">
      <summary>
            Write text directly into the generated output
            </summary>
    </member>
    <member name="M:Sandbox.SolutionGenerator.ProjectBase.WriteLine(System.String)">
      <summary>
            Write text directly into the generated output
            </summary>
    </member>
    <member name="M:Sandbox.SolutionGenerator.ProjectBase.Write(System.String,System.Object[])">
      <summary>
            Write formatted text directly into the generated output
            </summary>
    </member>
    <member name="M:Sandbox.SolutionGenerator.ProjectBase.WriteLine(System.String,System.Object[])">
      <summary>
            Write formatted text directly into the generated output
            </summary>
    </member>
    <member name="M:Sandbox.SolutionGenerator.ProjectBase.Error(System.String)">
      <summary>
            Raise an error
            </summary>
    </member>
    <member name="M:Sandbox.SolutionGenerator.ProjectBase.Warning(System.String)">
      <summary>
            Raise a warning
            </summary>
    </member>
    <member name="M:Sandbox.SolutionGenerator.ProjectBase.PushIndent(System.String)">
      <summary>
            Increase the indent
            </summary>
    </member>
    <member name="M:Sandbox.SolutionGenerator.ProjectBase.PopIndent">
      <summary>
            Remove the last indent that was added with PushIndent
            </summary>
    </member>
    <member name="M:Sandbox.SolutionGenerator.ProjectBase.ClearIndent">
      <summary>
            Remove any indentation
            </summary>
    </member>
    <member name="T:Sandbox.SolutionGenerator.ProjectBase.ToStringInstanceHelper">
      <summary>
            Utility class to produce culture-oriented representation of an object as a string.
            </summary>
    </member>
    <member name="P:Sandbox.SolutionGenerator.ProjectBase.ToStringInstanceHelper.FormatProvider">
      <summary>
            Gets or sets format provider to be used by ToStringWithCulture method.
            </summary>
    </member>
    <member name="M:Sandbox.SolutionGenerator.ProjectBase.ToStringInstanceHelper.ToStringWithCulture(System.Object)">
      <summary>
            This is called from the compile/run appdomain to convert objects within an expression block to a string
            </summary>
    </member>
    <member name="P:Sandbox.SolutionGenerator.ProjectBase.ToStringHelper">
      <summary>
            Helper to produce culture-oriented representation of an object as a string
            </summary>
    </member>
  </members>
  <assembly>
    <name>Sandbox.System</name>
  </assembly>
  <members>
    <member name="M:Sandbox.Diagnostics.Assert.NotNull``1(``0,System.String)">
      <summary>
            Throws an exception when the given object is null.
            </summary>
      <typeparam name="T">Any type capable of being null.</typeparam>
      <param name="obj">Object to test</param>
      <param name="message">Message to show when object is null</param>
      <exception cref="T:System.Exception">Thrown when the given object is null.</exception>
    </member>
    <member name="M:Sandbox.Diagnostics.Assert.NotNull``1(``0)">
      <summary>
            Throws an exception when the given object is null.
            </summary>
      <typeparam name="T">Any type capable of being null.</typeparam>
      <param name="obj">Object to test</param>
      <exception cref="T:System.Exception">Thrown when the given object is null.</exception>
    </member>
    <member name="M:Sandbox.Diagnostics.Assert.IsNull``1(``0,System.String)">
      <summary>
            Throws an exception when the given object is not null.
            </summary>
      <typeparam name="T">Any type capable of being null.</typeparam>
      <param name="obj">Object to test</param>
      <param name="message">Message to show when null</param>
      <exception cref="T:System.Exception">Thrown when the given object is null.</exception>
    </member>
    <member name="M:Sandbox.Diagnostics.Assert.IsNull``1(``0)">
      <summary>
            Throws an exception when the given object is not null.
            </summary>
      <typeparam name="T">Any type capable of being null.</typeparam>
      <param name="obj">Object to test</param>
      <exception cref="T:System.Exception">Thrown when the given object is null.</exception>
    </member>
    <member name="M:Sandbox.Diagnostics.Assert.IsValid(Sandbox.IValid)">
      <summary>
            Throws an exception when the given object is not valid.
            </summary>
    </member>
    <member name="M:Sandbox.Diagnostics.Assert.AreEqual``1(``0,``0,System.String)">
      <summary>
            Throws an exception when the 2 given objects are not equal to each other.
            </summary>
      <typeparam name="T">Any type that supports <see cref="M:System.Object.Equals(System.Object,System.Object)" />.</typeparam>
      <param name="a">Object A to test.</param>
      <param name="b">Object B to test.</param>
      <param name="message">Message to include in the exception, if any.</param>
      <exception cref="T:System.Exception">Thrown when 2 given objects are not equal</exception>
    </member>
    <member name="M:Sandbox.Diagnostics.Assert.AreNotEqual``1(``0,``0,System.String)">
      <summary>
            Throws an exception when the 2 given objects are equal to each other.
            </summary>
    </member>
    <member name="M:Sandbox.Diagnostics.Assert.True(System.Boolean,System.String)">
      <summary>
            Throws an exception when given expression does not resolve to <b>true</b>.
            </summary>
      <param name="isValid">The expression to test</param>
      <param name="message">Message to include in the exception, if any.</param>
      <exception cref="T:System.Exception">Thrown when given expression is not <b>true</b>.</exception>
    </member>
    <member name="M:Sandbox.Diagnostics.Assert.False(System.Boolean,System.String)">
      <summary>
            Throws an exception when given expression does not resolve to <b>false</b>.
            </summary>
      <param name="isValid">The expression to test</param>
      <param name="message">Message to include in the exception, if any.</param>
      <exception cref="T:System.Exception">Thrown when given expression is not <b>false</b>.</exception>
    </member>
    <member name="P:Sandbox.Diagnostics.Logger.Name">
      <summary>
            Name of this logger.
            </summary>
    </member>
    <member name="M:Sandbox.Diagnostics.Logger.Info(System.FormattableString)">
      <inheritdoc cref="M:Sandbox.Diagnostics.Logger.Info(System.Object)" />
    </member>
    <member name="M:Sandbox.Diagnostics.Logger.Trace(System.FormattableString)">
      <inheritdoc cref="M:Sandbox.Diagnostics.Logger.Trace(System.Object)" />
    </member>
    <member name="M:Sandbox.Diagnostics.Logger.Warning(System.FormattableString)">
      <inheritdoc cref="M:Sandbox.Diagnostics.Logger.Warning(System.Object)" />
    </member>
    <member name="M:Sandbox.Diagnostics.Logger.Error(System.FormattableString)">
      <inheritdoc cref="M:Sandbox.Diagnostics.Logger.Error(System.Object)" />
    </member>
    <member name="M:Sandbox.Diagnostics.Logger.Error(System.Exception,System.FormattableString)">
      <inheritdoc cref="M:Sandbox.Diagnostics.Logger.Error(System.Exception,System.Object)" />
    </member>
    <member name="M:Sandbox.Diagnostics.Logger.Error(System.Exception,System.Object)">
      <summary>
            Log an exception as an error, with given message override.
            </summary>
      <param name="exception">The exception to log.</param>
      <param name="message">The text to override exceptions' message with in the log.</param>
    </member>
    <member name="M:Sandbox.Diagnostics.Logger.Error(System.Exception)">
      <summary>
            Log an exception as an error.
            </summary>
      <param name="exception">The exception to log.</param>
    </member>
    <member name="M:Sandbox.Diagnostics.Logger.Warning(System.Exception,System.FormattableString)">
      <inheritdoc cref="M:Sandbox.Diagnostics.Logger.Warning(System.Exception,System.Object)" />
    </member>
    <member name="M:Sandbox.Diagnostics.Logger.Warning(System.Exception,System.Object)">
      <summary>
            Log an exception as a warning, with given message override.
            </summary>
      <param name="exception">The exception to log.</param>
      <param name="message">The text to override exceptions' message with in the log.</param>
    </member>
    <member name="M:Sandbox.Diagnostics.Logger.Info(System.Object)">
      <summary>
            Log some information. This is the default log severity level.
            </summary>
      <param name="message">The information to log.</param>
    </member>
    <member name="M:Sandbox.Diagnostics.Logger.Trace(System.Object)">
      <summary>
            Log some information. This is least severe log level.
            </summary>
      <param name="message">The information to log.</param>
    </member>
    <member name="M:Sandbox.Diagnostics.Logger.Warning(System.Object)">
      <summary>
            Log a warning. This is the second most severe log level.
            </summary>
      <param name="message">The warning to log.</param>
    </member>
    <member name="M:Sandbox.Diagnostics.Logger.Error(System.Object)">
      <summary>
            Log an error. This is the most severe log level.
            </summary>
      <param name="message">The error to log.</param>
    </member>
    <member name="M:Sandbox.Diagnostics.Logger.WrapObject(System.Object,System.Collections.Generic.List{System.Object})">
      <summary>
            Wrap / escape an object for html log messages. Inspectable objects
            will be wrapped in a link, and added to <paramref name="outArgs" />.
            The link will index into <paramref name="outArgs" />. <see cref="T:System.FormattableString" />s
            will recurse into <see cref="M:Sandbox.Diagnostics.Logger.WrapObject(System.Object,System.Collections.Generic.List{System.Object})" />, so their arguments can also be inspected.
            </summary>
      <param name="o">Object to wrap</param>
      <param name="outArgs">Inspectable objects will be added here</param>
      <returns>Html-wrapped object. Either a string or a primitive.</returns>
    </member>
    <member name="M:Sandbox.Diagnostics.Logging.ShouldLog(System.String,Sandbox.LogLevel)">
      <summary>
            Return true if we should print this log entry. Use a cache to avoid craziness.
            </summary>
    </member>
    <member name="F:Sandbox.Diagnostics.Logging.Loggers">
      <summary>
            Keep a list of loggers
            </summary>
    </member>
    <member name="T:Sandbox.Diagnostics.FastTimer">
      <summary>
            Like stopwatch, but more lightweight and straight to the point. Use FastTimer.StartNew()
            </summary>
    </member>
    <member name="T:Sandbox.PureAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.IPureAttribute" />
    </member>
    <member name="T:Sandbox.ImpureAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.IImpureAttribute" />
    </member>
    <member name="T:Sandbox.ActionGraphTargetAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.ITargetAttribute" />
    </member>
    <member name="T:Sandbox.HasImplementationAttribute">
      <summary>
            In ActionGraph, this type parameter can only be satisfied by a type <c>TArg</c>, such
            that there exists at least one non-abstract type that extends / implements both
            <c>TArg</c> and <see cref="P:Sandbox.HasImplementationAttribute.BaseType" />.
            </summary>
    </member>
    <member name="P:Sandbox.HasImplementationAttribute.BaseType">
      <summary>
            Base class or interface for which there must exist an extending / implementing type.
            </summary>
    </member>
    <member name="M:Sandbox.HasImplementationAttribute.#ctor(System.Type)">
      <inheritdoc cref="T:Sandbox.HasImplementationAttribute" />
      <param name="baseType">
            Base class or interface for which there must exist an extending / implementing type.
            </param>
    </member>
    <member name="T:Sandbox.ActionGraphPropertyAttribute">
      <summary>
            In ActionGraph, this parameter should only be configurable in the inspector as a property and not have a dedicated input.
            </summary>
    </member>
    <member name="T:Sandbox.ActionGraphExposeWhenCachedAttribute">
      <summary>
            Don't cache instances of this type when serializing action graph references, force them to be always serialized separately.
            We need this for component / game object references so we can update IDs when duplicating objects / instantiating prefabs.
            </summary>
    </member>
    <member name="T:Sandbox.ActionGraphNodeAttribute">
      <inheritdoc cref="T:Facepunch.ActionGraphs.INodeAttribute" />
    </member>
    <member name="P:Sandbox.ActionGraphNodeAttribute.Identifier">
      <inheritdoc />
    </member>
    <member name="P:Sandbox.ActionGraphNodeAttribute.DefaultInputSignal">
      <inheritdoc />
    </member>
    <member name="P:Sandbox.ActionGraphNodeAttribute.DefaultOutputSignal">
      <inheritdoc />
    </member>
    <member name="P:Sandbox.ActionGraphNodeAttribute.InheritAsync">
      <inheritdoc />
    </member>
    <member name="T:Sandbox.ActionGraphOperatorAttribute">
      <summary>
            Display this node as an operator, with no header or socket labels, and a big icon in the middle.
            </summary>
    </member>
    <member name="P:Sandbox.ActionGraphIncludeAttribute.AutoExpand">
      <summary>
            If true, double-clicking on an output of the declaring type will auto-expand this member.
            </summary>
    </member>
    <member name="T:Sandbox.SingleActionAttribute">
      <summary>
            Force a delegate-type property to only have a single attached Action Graph.
            </summary>
    </member>
    <member name="T:Sandbox.ChangeAttribute">
      <summary>
            This will invoke a method when the property changes. It can be used with any property but is especially useful
            when combined with [Sync] or [ConVar].
            <br /><br />
            If no name is provided, we will try to call On[PropertyName]Changed. The callback should have 2 arguments - oldValue and newValue, both of the same type as the property itself.
            </summary>
    </member>
    <member name="P:Sandbox.ChangeAttribute.Name">
      <summary>
            Name of the method to call on change. If no name is provided, we will try to call On[PropertyName]Changed.
            </summary>
    </member>
    <member name="T:Sandbox.Internal.ITitleProvider">
      <summary>
            Provides a title or a "nice name" for DisplayInfo of a member or a type.
            </summary>
    </member>
    <member name="P:Sandbox.Internal.ITitleProvider.Value">
      <summary>
            The title.
            </summary>
    </member>
    <member name="T:Sandbox.Internal.IPlaceholderProvider">
      <summary>
            Provides placeholder text for DisplayInfo of a member or a type.
            </summary>
    </member>
    <member name="P:Sandbox.Internal.IPlaceholderProvider.Value">
      <summary>
            The placeholder text.
            </summary>
    </member>
    <member name="T:Sandbox.Internal.IDescriptionProvider">
      <summary>
            Provides a description for DisplayInfo of a member or a type.
            </summary>
    </member>
    <member name="P:Sandbox.Internal.IDescriptionProvider.Value">
      <summary>
            The description.
            </summary>
    </member>
    <member name="T:Sandbox.Internal.ICategoryProvider">
      <summary>
            Provides category or group for DisplayInfo of a member or a type.
            </summary>
    </member>
    <member name="P:Sandbox.Internal.ICategoryProvider.Value">
      <summary>
            The category.
            </summary>
    </member>
    <member name="T:Sandbox.Internal.IClassNameProvider">
      <summary>
            Provides internal class name for DisplayInfo of a member or a type.
            </summary>
    </member>
    <member name="P:Sandbox.Internal.IClassNameProvider.Value">
      <summary>
            The class name.
            Typically a class name is all lower case, has spaces replaced by underscores (_) or dashes (-) and contains no other special symbols.
            </summary>
    </member>
    <member name="T:Sandbox.Internal.IIconProvider">
      <summary>
            Provides an icon for DisplayInfo of a member or a type.
            </summary>
    </member>
    <member name="P:Sandbox.Internal.IIconProvider.Value">
      <summary>
            The icon. Typically this is the name of a <a href="https://fonts.google.com/icons">material icon</a>.
            </summary>
    </member>
    <member name="T:Sandbox.Internal.IOrderProvider">
      <summary>
            Provides an order number for DisplayInfo of a member or a type.
            </summary>
    </member>
    <member name="P:Sandbox.Internal.IOrderProvider.Value">
      <summary>
            Order value, for sorting in menus.
            </summary>
    </member>
    <member name="T:Sandbox.Internal.ClassFileLocationAttribute">
      <summary>
            Automatically added to codegenerated classes to let them determine their location
            This helps when looking for resources relative to them, like style sheets.
            Replaced in Sept 2023 by SourceLocationAttribute, which is added to classes and members.
            </summary>
    </member>
    <member name="T:Sandbox.Internal.SourceLocationAttribute">
      <summary>
            Automatically added to classes and their members to let them determine their location
            This helps when looking for resources relative to them, like style sheets.
            </summary>
    </member>
    <member name="T:Sandbox.Internal.IUpdateSubscriber">
      <summary>
            Automatically added to classes that implement OnUpdate()
            </summary>
    </member>
    <member name="T:Sandbox.Internal.IFixedUpdateSubscriber">
      <summary>
            Automatically added to classes that implement OnFixedUpdate()
            </summary>
    </member>
    <member name="T:Sandbox.Internal.IPreRenderSubscriber">
      <summary>
            Automatically added to classes that implement OnPreRender()
            </summary>
    </member>
    <member name="T:Sandbox.Internal.JsonConvert.SplinePointConverter">
      <summary>
            We use a custom converter for <see cref="T:Sandbox.Spline.Point" /> to allow for more compact serialization.
            For example we ommit default values for a lot of properties.
            </summary>
    </member>
    <member name="T:Sandbox.WideModeAttribute">
      <summary>
            Expand the value editor to fill the next line in the inspector, leaving the title above it
            </summary>
    </member>
    <member name="T:Sandbox.ReadOnlyAttribute">
      <summary>
            Display this in the inspector - but don't let anyone edit it
            </summary>
    </member>
    <member name="T:Sandbox.TextAreaAttribute">
      <summary>
            When applied to a string property, show a multi-line text box instead of a single line.
            </summary>
    </member>
    <member name="T:Sandbox.InputActionAttribute">
      <summary>
            When applied to a string property, use an input action selector.
            </summary>
    </member>
    <member name="T:Sandbox.TargetTypeAttribute">
      <summary>
            When applied to a Type property, allows you to specify a Type that the property's value must derive from.
            </summary>
    </member>
    <member name="P:Sandbox.TargetTypeAttribute.Type">
      <summary>
            The type that the property's value must derive from.
            </summary>
    </member>
    <member name="T:Sandbox.FontNameAttribute">
      <summary>
            When applied to a string property, uses a font name selector.
            </summary>
    </member>
    <member name="T:Sandbox.IconNameAttribute">
      <summary>
            When applied to a string property, uses a Material Icon selector.
            </summary>
    </member>
    <member name="T:Sandbox.ColorUsageAttribute">
      <summary>
            When applied to a Color property, allows you to specify whether the color should have an alpha channel and/or be in HDR.
            </summary>
    </member>
    <member name="T:Sandbox.FeatureAttribute">
      <summary>
            Sets the category or the group of a type or a type member.
            This info can then be retrieved via DisplayInfo library.
            </summary>
    </member>
    <member name="P:Sandbox.FeatureAttribute.Identifier">
      <summary>
            How we will group features together
            </summary>
    </member>
    <member name="P:Sandbox.FeatureAttribute.Title">
      <summary>
            Title of the feature. Keep it short please!
            </summary>
    </member>
    <member name="P:Sandbox.FeatureAttribute.Description">
      <summary>
            The description of the feature
            </summary>
    </member>
    <member name="P:Sandbox.FeatureAttribute.Icon">
      <summary>
            Icon to show next to the feature
            </summary>
    </member>
    <member name="P:Sandbox.FeatureAttribute.Tint">
      <summary>
            The color of the feature button. Helps group things, helps things to stand out. Defaults to white.
            </summary>
    </member>
    <member name="T:Sandbox.FeatureEnabledAttribute">
      <summary>
            Mark a boolean property as a feature toggle
            </summary>
    </member>
    <member name="T:Sandbox.HeaderAttribute">
      <summary>
            Add a header above this property
            </summary>
    </member>
    <member name="T:Sandbox.SpaceAttribute">
      <summary>
            Add a space above this property
            </summary>
    </member>
    <member name="T:Sandbox.HelpUrlAttribute">
      <summary>
            Add a link to some documentation for this component, or <see langword="property" /></summary>
    </member>
    <member name="T:Sandbox.EventAttribute">
      <summary>
            A generic event listener. You are probably looking for Sandbox.Event.* attributes.
            </summary>
    </member>
    <member name="P:Sandbox.EventAttribute.EventName">
      <summary>
            The internal event identifier.
            </summary>
    </member>
    <member name="P:Sandbox.EventAttribute.Priority">
      <summary>
            Events with lower numbers are run first. This defaults to 0, so setting it to -1 will mean your
            event will run before all other events that don't define it. Setting it to 1 would mean it'll
            run after all events that don't.
            </summary>
    </member>
    <member name="T:Sandbox.SkipHotloadAttribute">
      <summary>
            Skip processing a specific field, or any fields in a type marked by this attribute. Field
            processing will still occur if a type marked by this attribute was defined in a swapped assembly.
            </summary>
      <remarks>
            This is nice for speeding up hotloading, particularly when used on types with lots of fields, or
            on fields that are the only path to large networks of objects that all don't need replacing during the hotload.
            </remarks>
    </member>
    <member name="T:Sandbox.SuppressNullKeyWarningAttribute">
      <summary>
            When applied to a member with <see cref="T:System.Collections.Generic.Dictionary`2" /> or <see cref="T:System.Collections.Generic.HashSet`1" /> type,
            don't warn if the key of an item becomes null during a hotload because a type is removed. You should
            only use this attribute if you're sure that it's safe to quietly remove entries.
            </summary>
    </member>
    <member name="T:Sandbox.IHotloadManaged">
      <summary>
            During hotloads, instances of types implementing this interface will be notified when
            they get replaced.
            </summary>
    </member>
    <member name="M:Sandbox.IHotloadManaged.Destroyed(System.Collections.Generic.Dictionary{System.String,System.Object})">
      <summary>
            Called when this instance is about to be replaced during a hotload.
            The implementor may optionally write to the <paramref name="state" />
            dictionary, which gets passed to the new replacing instance when
            <see cref="M:Sandbox.IHotloadManaged.Created(System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})" /> is called on it.
            </summary>
      <param name="state">Dictionary to store values to pass to the new instance.</param>
    </member>
    <member name="M:Sandbox.IHotloadManaged.Created(System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object})">
      <summary>
            Called when this instance has been created during a hotload, replacing an
            instance from an older version of the containing assembly. The <paramref name="state" />
            parameter will contain any values populated when <see cref="M:Sandbox.IHotloadManaged.Destroyed(System.Collections.Generic.Dictionary{System.String,System.Object})" /> was called
            on the old instance that was replaced.
            </summary>
      <param name="state">Dictionary containing values written by the old instance.</param>
    </member>
    <member name="M:Sandbox.IHotloadManaged.Persisted">
      <summary>
            Called when this instance is about to be processed, but not replaced.
            </summary>
    </member>
    <member name="M:Sandbox.IHotloadManaged.Failed">
      <summary>
            Called when this instance could not be upgraded during a hotload, and any references
            to it have been replaced with null. This is a good time to clean up any unmanaged resources
            related to this instance.
            </summary>
    </member>
    <member name="T:Sandbox.InputAttribute">
      <summary>
            Makes this method available as a Map Logic Input, for use in the Hammer Editor. This is only applicable to entities.
            </summary>
    </member>
    <member name="P:Sandbox.InputAttribute.Name">
      <summary>
            Desired name of this input. If not set, the method's name will be used.
            </summary>
    </member>
    <member name="T:Sandbox.ButtonAttribute">
      <summary>
            When added to a method - the inspector will show a button for it.
            </summary>
    </member>
    <member name="T:Sandbox.RequireComponentAttribute">
      <summary>
            When added to a property on a Component, we'll try to make that component value non null.
            We will first look on the GameObject for the component type. If it's not found, we'll create one.
            </summary>
    </member>
    <member name="T:Sandbox.ITypeAttribute">
      <summary>
            When applied to an attribute, which is then applied to a type..
            This will make <see cref="P:Sandbox.ITypeAttribute.TargetType" /> set on the attribute upon load.
            <para>This provides a convenient way to know which type the attribute was attached to.</para></summary>
    </member>
    <member name="P:Sandbox.ITypeAttribute.TargetType">
      <summary>
            The type this attribute was attached to.
            </summary>
    </member>
    <member name="M:Sandbox.ITypeAttribute.TypeRegister">
      <summary>
            Called when a class with this attribute is registered via the TypeLibrary.
            </summary>
    </member>
    <member name="M:Sandbox.ITypeAttribute.TypeUnregister">
      <summary>
            Called when a class with this attribute is unregistered via the TypeLibrary.
            </summary>
    </member>
    <member name="T:Sandbox.JsonUpgraderAttribute">
      <summary>
            An attribute that describes a version update for a JSON object.
            </summary>
    </member>
    <member name="P:Sandbox.JsonUpgraderAttribute.Version">
      <summary>
            The version of this upgrade.
            </summary>
    </member>
    <member name="P:Sandbox.JsonUpgraderAttribute.Type">
      <summary>
            The type we're targeting for this upgrade.
            </summary>
    </member>
    <member name="P:Sandbox.LibraryAttribute.Name">
      <summary>
            This is the name that will be used to create this class.
            If you don't set it via the attribute constructor it will be set
            to the name of the class it's attached to
            </summary>
    </member>
    <member name="P:Sandbox.LibraryAttribute.FullName">
      <summary>
            The full class name
            </summary>
    </member>
    <member name="P:Sandbox.LibraryAttribute.Title">
      <summary>
            A nice presentable name to show
            </summary>
    </member>
    <member name="P:Sandbox.LibraryAttribute.Description">
      <summary>
            We use this to provide a nice description in the editor
            </summary>
    </member>
    <member name="P:Sandbox.LibraryAttribute.Group">
      <summary>
            We use this to organize groups of entities in the editor
            </summary>
    </member>
    <member name="P:Sandbox.LibraryAttribute.Editable">
      <summary>
            We use this to filter entities to show in the entity list in the editor
            </summary>
    </member>
    <member name="T:Sandbox.MethodArgumentsAttribute">
      <summary>
            Specify the types of arguments a method should have. Typically used with event attributes to throw an exception
            if an event attribute is added to a method with incorrect arguments.
            </summary>
    </member>
    <member name="P:Sandbox.PropertyAttribute.Name">
      <summary>
            The internal name of this property. This should be lowercase with no spaces. If unset the lowercased C# variable name is used.
            </summary>
    </member>
    <member name="P:Sandbox.PropertyAttribute.Title">
      <summary>
            The user friendly name of this property. If unset, it will be auto generated from C# variable name.
            </summary>
    </member>
    <member name="M:Sandbox.PropertyAttribute.#ctor(System.String)">
      <param name="internal_name">The internal name of this property. This should be lowercase with no spaces.</param>
    </member>
    <member name="T:Sandbox.KeyPropertyAttribute">
      <summary>
            Mark this property as the key property - which means that it can represent the whole object in a single line, while
            usually offering an advanced mode to view the entire object.
            </summary>
    </member>
    <member name="T:Sandbox.InlineEditorAttribute">
      <summary>
            Tell the editor to try to display inline editing for this property, rather than hiding it behind a popup etc.
            </summary>
    </member>
    <member name="T:Sandbox.RangeAttribute">
      <summary>
            Mark this property as a ranged float/int. In inspector we'll be able to create a slider
            instead of a text entry.
            TODO: Replace this with the System.ComponentModel.DataAnnotations.Range one - move step and clamped to their own attributes
            </summary>
    </member>
    <member name="T:Sandbox.StringLiteralOnlyAttribute">
      <summary>
            Ask codegen to shit itself if the parameter isn't passed in as a string literal
            </summary>
    </member>
    <member name="T:Sandbox.HideAttribute">
      <summary>
            Hide this in tools/editors.
            </summary>
    </member>
    <member name="T:Sandbox.CodeGeneratorAttribute">
      <summary>
            An attribute that can be added to a custom <see cref="T:System.Attribute" /> class for special code generation behavior.
            They'll then be applied to methods and properties when they are decorated with <i>that</i> attribute.
            </summary>
    </member>
    <member name="P:Sandbox.CodeGeneratorAttribute.Priority">
      <summary>
            Attributes with a higher priority will wrap the target first. The default priority is 0.
            </summary>
    </member>
    <member name="P:Sandbox.CodeGeneratorAttribute.CallbackName">
      <summary>
            The name of the callback method. This can be a fully qualified static method callback or a simple callback to invoke
            on the target object if the method or property target is not static.
            </summary>
    </member>
    <member name="P:Sandbox.CodeGeneratorAttribute.Type">
      <summary>
            The type of code generation you want to do.
            You will need to specify whether it should apply to instance or static methods and properties using the <see cref="F:Sandbox.CodeGeneratorFlags.Instance" />
            and <see cref="F:Sandbox.CodeGeneratorFlags.Static" /> flags.
            </summary>
    </member>
    <member name="M:Sandbox.CodeGeneratorAttribute.#ctor(Sandbox.CodeGeneratorFlags,System.String,System.Int32)">
      <summary>
            Perform code generation for a method or property.
            </summary>
      <param name="type">
            The type of code generation you want to do.
            You will need to specify whether it should apply to instance or static methods and properties using the <see cref="F:Sandbox.CodeGeneratorFlags.Instance" />
            and <see cref="F:Sandbox.CodeGeneratorFlags.Static" /> flags.
            </param>
      <param name="callbackName">
            The name of the callback method. This can be a fully qualified static method callback or a simple callback to invoke
            on the target object if the method or property target is not static.
            </param>
      <param name="priority">
            Attributes with a higher priority will wrap the target first. The default priority is 0.
            </param>
    </member>
    <member name="T:Sandbox.CodeGeneratorFlags">
      <summary>
            Used to specify what type of code generation to perform.
            </summary>
    </member>
    <member name="F:Sandbox.CodeGeneratorFlags.WrapPropertyGet">
      <summary>
            Wrap the get accessor of a property.
            </summary>
    </member>
    <member name="F:Sandbox.CodeGeneratorFlags.WrapPropertySet">
      <summary>
            Wrap the set accessor of a property.
            </summary>
    </member>
    <member name="F:Sandbox.CodeGeneratorFlags.WrapMethod">
      <summary>
            Wrap a method call.
            </summary>
    </member>
    <member name="F:Sandbox.CodeGeneratorFlags.Static">
      <summary>
            Apply this to a static property or method.
            </summary>
    </member>
    <member name="F:Sandbox.CodeGeneratorFlags.Instance">
      <summary>
            Apply this to an instance property or method.
            </summary>
    </member>
    <member name="T:Sandbox.WrappedMethod">
      <summary>
            Provides data about a wrapped method in a <see cref="T:Sandbox.CodeGeneratorAttribute" /> callback.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedMethod.Resume">
      <summary>
            Invoke the original method.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedMethod.Object">
      <summary>
            The object whose method is being wrapped. This will be null if we're wrapping a static method.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedMethod.IsStatic">
      <summary>
            Is this a static method?
            </summary>
    </member>
    <member name="P:Sandbox.WrappedMethod.TypeName">
      <summary>
            The name of the type that the method belongs to.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedMethod.MethodName">
      <summary>
            The name of the original method.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedMethod.MethodIdentity">
      <summary>
            The Identity of the original method. This is an integer that each MethodDescription has to distinguish itself from other methods of the same class.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedMethod.Attributes">
      <summary>
            An array of all attributes decorated with <see cref="T:Sandbox.CodeGeneratorAttribute" /> on the original method.
            </summary>
    </member>
    <member name="M:Sandbox.WrappedMethod.GetAttribute``1">
      <summary>
            Get the attribute of type, or null if it doesn't exist
            </summary>
    </member>
    <member name="T:Sandbox.WrappedMethod`1">
      <summary>
            Provides data about a wrapped method in a <see cref="T:Sandbox.CodeGeneratorAttribute" /> callback.
            </summary>
      <typeparam name="T">The expected return type for the wrapped method.</typeparam>
    </member>
    <member name="P:Sandbox.WrappedMethod`1.Resume">
      <summary>
            Invoke the original method.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedMethod`1.Object">
      <summary>
            The object whose method is being wrapped. This will be null if we're wrapping a static method.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedMethod`1.IsStatic">
      <summary>
            Is this a static method?
            </summary>
    </member>
    <member name="P:Sandbox.WrappedMethod`1.TypeName">
      <summary>
            The name of the type that the method belongs to.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedMethod`1.MethodName">
      <summary>
            The name of the original method. If static, will return the full name including the type.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedMethod`1.MethodIdentity">
      <summary>
            The Identity of the original method. This is an integer that each MethodDescription has to distinguish itself from other methods of the same class.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedMethod`1.Attributes">
      <summary>
            An array of all attributes decorated with <see cref="T:Sandbox.CodeGeneratorAttribute" /> on the original method.
            </summary>
    </member>
    <member name="M:Sandbox.WrappedMethod`1.GetAttribute``1">
      <summary>
            Get the attribute of type, or null if it doesn't exist
            </summary>
    </member>
    <member name="T:Sandbox.WrappedPropertySet`1">
      <summary>
            Provides data about a wrapped property setter in a <see cref="T:Sandbox.CodeGeneratorAttribute" /> callback.
            </summary>
      <typeparam name="T">The expected type of the wrapped property.</typeparam>
    </member>
    <member name="P:Sandbox.WrappedPropertySet`1.Value">
      <summary>
            The value the property wants to be set to.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedPropertySet`1.Object">
      <summary>
            The object whose property is being wrapped. This will be null if we're wrapping a static property.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedPropertySet`1.Setter">
      <summary>
            Invoke the original setter with the provided value.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedPropertySet`1.Getter">
      <summary>
            Get the current value
            </summary>
    </member>
    <member name="P:Sandbox.WrappedPropertySet`1.IsStatic">
      <summary>
            Is this a static property?
            </summary>
    </member>
    <member name="P:Sandbox.WrappedPropertySet`1.TypeName">
      <summary>
            The name of the type that the property belongs to.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedPropertySet`1.PropertyName">
      <summary>
            The name of the original property. If static, will return the full name including the type.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedPropertySet`1.MemberIdent">
      <summary>
            The identity of the original property. Used by TypeLibrary as a unique identifier for the property.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedPropertySet`1.Attributes">
      <summary>
            An array of all attributes on the original property.
            </summary>
    </member>
    <member name="M:Sandbox.WrappedPropertySet`1.GetAttribute``1">
      <summary>
            Get the attribute of type, or null if it doesn't exist
            </summary>
    </member>
    <member name="T:Sandbox.WrappedPropertyGet`1">
      <summary>
            Provides data about a wrapped property getter in a <see cref="T:Sandbox.CodeGeneratorAttribute" /> callback.
            </summary>
      <typeparam name="T">The expected type of the wrapped property.</typeparam>
    </member>
    <member name="P:Sandbox.WrappedPropertyGet`1.Value">
      <summary>
            The value from the original getter.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedPropertyGet`1.Object">
      <summary>
            The object whose property is being wrapped. This will be null if we're wrapping a static property.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedPropertyGet`1.IsStatic">
      <summary>
            Is this a static property?
            </summary>
    </member>
    <member name="P:Sandbox.WrappedPropertyGet`1.TypeName">
      <summary>
            The name of the type that the property belongs to.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedPropertyGet`1.PropertyName">
      <summary>
            The name of the original property. If static, will return the full name including the type.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedPropertyGet`1.MemberIdent">
      <summary>
            The identity of the original property. Used by TypeLibrary as a unique identifier for the property.
            </summary>
    </member>
    <member name="P:Sandbox.WrappedPropertyGet`1.Attributes">
      <summary>
            An array of all attributes on the original property.
            </summary>
    </member>
    <member name="M:Sandbox.WrappedPropertyGet`1.GetAttribute``1">
      <summary>
            Get the attribute of type, or null if it doesn't exist
            </summary>
    </member>
    <member name="T:Sandbox.Utility.CircularBuffer`1">
      <summary>
            Circular buffer, push pop and index access is always O(1).
            </summary>
    </member>
    <member name="F:Sandbox.Utility.CircularBuffer`1._start">
      <summary>
            The _start. Index of the first element in buffer.
            </summary>
    </member>
    <member name="F:Sandbox.Utility.CircularBuffer`1._end">
      <summary>
            The _end. Index after the last element in the buffer.
            </summary>
    </member>
    <member name="F:Sandbox.Utility.CircularBuffer`1._size">
      <summary>
            The _size. Buffer size.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.CircularBuffer`1.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Sandbox.Utility.CircularBuffer`1" /> class.
            
            </summary>
      <param name="capacity">
            Buffer capacity. Must be positive.
            </param>
    </member>
    <member name="M:Sandbox.Utility.CircularBuffer`1.#ctor(System.Int32,`0[])">
      <summary>
            Initializes a new instance of the <see cref="T:Sandbox.Utility.CircularBuffer`1" /> class.
            
            </summary>
      <param name="capacity">
            Buffer capacity. Must be positive.
            </param>
      <param name="items">
            Items to fill buffer with. Items length must be less than capacity.
            Suggestion: use Skip(x).Take(y).ToArray() to build this argument from
            any enumerable.
            </param>
    </member>
    <member name="P:Sandbox.Utility.CircularBuffer`1.Capacity">
      <summary>
            Maximum capacity of the buffer. Elements pushed into the buffer after
            maximum capacity is reached (IsFull = true), will remove an element.
            </summary>
    </member>
    <member name="P:Sandbox.Utility.CircularBuffer`1.IsFull">
      <summary>
            Boolean indicating if Circular is at full capacity.
            Adding more elements when the buffer is full will
            cause elements to be removed from the other end
            of the buffer.
            </summary>
    </member>
    <member name="P:Sandbox.Utility.CircularBuffer`1.IsEmpty">
      <summary>
            True if has no elements.
            </summary>
    </member>
    <member name="P:Sandbox.Utility.CircularBuffer`1.Size">
      <summary>
            Current buffer size (the number of elements that the buffer has).
            </summary>
    </member>
    <member name="M:Sandbox.Utility.CircularBuffer`1.Front">
      <summary>
            Element at the front of the buffer - this[0].
            </summary>
      <returns>The value of the element of type T at the front of the buffer.</returns>
    </member>
    <member name="M:Sandbox.Utility.CircularBuffer`1.Back">
      <summary>
            Element at the back of the buffer - this[Size - 1].
            </summary>
      <returns>The value of the element of type T at the back of the buffer.</returns>
    </member>
    <member name="P:Sandbox.Utility.CircularBuffer`1.Item(System.Int32)">
      <summary>
            Index access to elements in buffer.
            Index does not loop around like when adding elements,
            valid interval is [0;Size[
            </summary>
      <param name="index">Index of element to access.</param>
      <exception cref="T:System.IndexOutOfRangeException">Thrown when index is outside of [; Size[ interval.</exception>
    </member>
    <member name="M:Sandbox.Utility.CircularBuffer`1.PushBack(`0)">
      <summary>
            Pushes a new element to the back of the buffer. Back()/this[Size-1]
            will now return this element.
            
            When the buffer is full, the element at Front()/this[0] will be 
            popped to allow for this new element to fit.
            </summary>
      <param name="item">Item to push to the back of the buffer</param>
    </member>
    <member name="M:Sandbox.Utility.CircularBuffer`1.PushFront(`0)">
      <summary>
            Pushes a new element to the front of the buffer. Front()/this[0]
            will now return this element.
            
            When the buffer is full, the element at Back()/this[Size-1] will be 
            popped to allow for this new element to fit.
            </summary>
      <param name="item">Item to push to the front of the buffer</param>
    </member>
    <member name="M:Sandbox.Utility.CircularBuffer`1.PopBack">
      <summary>
            Removes the element at the back of the buffer. Decreasing the 
            Buffer size by 1.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.CircularBuffer`1.PopFront">
      <summary>
            Removes the element at the front of the buffer. Decreasing the 
            Buffer size by 1.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.CircularBuffer`1.Clear">
      <summary>
            Clears the contents of the array. Size = 0, Capacity is unchanged.
            </summary>
      <exception cref="T:System.NotImplementedException" />
    </member>
    <member name="M:Sandbox.Utility.CircularBuffer`1.ToArray">
      <summary>
            Copies the buffer contents to an array, according to the logical
            contents of the buffer (i.e. independent of the internal 
            order/contents)
            </summary>
      <returns>A new array with a copy of the buffer contents.</returns>
    </member>
    <member name="M:Sandbox.Utility.CircularBuffer`1.ToArraySegments">
      <summary>
             Get the contents of the buffer as 2 ArraySegments.
             Respects the logical contents of the buffer, where
             each segment and items in each segment are ordered
             according to insertion.
            
             Fast: does not copy the array elements.
             Useful for methods like <c>Send(IList&lt;ArraySegment&lt;Byte&gt;&gt;)</c>.
             
             <remarks>Segments may be empty.</remarks></summary>
      <returns>An IList with 2 segments corresponding to the buffer content.</returns>
    </member>
    <member name="M:Sandbox.Utility.CircularBuffer`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through this buffer.
            </summary>
      <returns>An enumerator that can be used to iterate this collection.</returns>
    </member>
    <member name="M:Sandbox.Utility.CircularBuffer`1.Increment(System.Int32@)">
      <summary>
            Increments the provided index variable by one, wrapping
            around if necessary.
            </summary>
      <param name="index" />
    </member>
    <member name="M:Sandbox.Utility.CircularBuffer`1.Decrement(System.Int32@)">
      <summary>
            Decrements the provided index variable by one, wrapping
            around if necessary.
            </summary>
      <param name="index" />
    </member>
    <member name="M:Sandbox.Utility.CircularBuffer`1.InternalIndex(System.Int32)">
      <summary>
            Converts the index in the argument to an index in <code>_buffer</code></summary>
      <returns>
            The transformed index.
            </returns>
      <param name="index">
            External index.
            </param>
    </member>
    <member name="M:Sandbox.Utility.HashSetEx`1.EnumerateLocked(System.Boolean)">
      <summary>
            Enumerates the list, increments iterating before and after. When we finished
            iterating, and nothing else is iterating, runs deferred actions.
            IMPORTANT: Don't expose this IEnumerable to users directly - because they might purposefully not dispose it?
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Noise">
      <summary>
             Provides access to coherent noise utilities.
            
             All of these functions should return between 0 and 1.
             </summary>
    </member>
    <member name="M:Sandbox.Utility.Noise.Perlin(System.Single,System.Single)">
      <summary>
            2D <a href="https://en.wikipedia.org/wiki/Perlin_noise">Perlin noise</a> function.
            For a thread-safe alternative with more options, use <see cref="M:Sandbox.Utility.Noise.PerlinField(Sandbox.Utility.Noise.Parameters)" />.
            </summary>
      <param name="x">Input on the X axis.</param>
      <param name="y">Input on the Y axis.</param>
      <returns>Resulting noise at given coordinates, in range of 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Noise.Perlin(System.Single,System.Single,System.Single)">
      <summary>
            3D <a href="https://en.wikipedia.org/wiki/Perlin_noise">Perlin noise</a> function.
            For a thread-safe alternative with more options, use <see cref="M:Sandbox.Utility.Noise.PerlinField(Sandbox.Utility.Noise.Parameters)" />.
            </summary>
      <param name="x">Input on the X axis.</param>
      <param name="y">Input on the Y axis.</param>
      <param name="z">Input on the Z axis.</param>
      <returns>Resulting noise at given coordinates, in range of 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Noise.Simplex(System.Single,System.Single)">
      <summary>
            2D <a href="https://en.wikipedia.org/wiki/Simplex_noise">Simplex noise</a> function.
            For a thread-safe alternative with more options, use <see cref="M:Sandbox.Utility.Noise.SimplexField(Sandbox.Utility.Noise.Parameters)" />.
            </summary>
      <param name="x">Input on the X axis.</param>
      <param name="y">Input on the Y axis.</param>
      <returns>Resulting noise at given coordinates, in range of 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Noise.Simplex(System.Single,System.Single,System.Single)">
      <summary>
            3D <a href="https://en.wikipedia.org/wiki/Simplex_noise">Simplex noise</a> function.
            For a thread-safe alternative with more options, use <see cref="M:Sandbox.Utility.Noise.SimplexField(Sandbox.Utility.Noise.Parameters)" />.
            </summary>
      <param name="x">Input on the X axis.</param>
      <param name="y">Input on the Y axis.</param>
      <param name="z">Input on the Z axis.</param>
      <returns>Resulting noise at given coordinates, in range of 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Noise.Fbm(System.Int32,System.Single,System.Single,System.Single)">
      <summary>
        <a href="https://en.wikipedia.org/wiki/Fractional_Brownian_motion">Fractional Brownian Motion</a> noise, a.k.a. Fractal Perlin noise.
            For a thread-safe alternative with more options, use <see cref="M:Sandbox.Utility.Noise.PerlinField(Sandbox.Utility.Noise.Parameters)" /> with <see cref="T:Sandbox.Utility.Noise.FractalParameters" />.
            </summary>
      <param name="octaves">Number of octaves for the noise. Higher values are slower but produce more detailed results. 3 is a good starting point.</param>
      <param name="x">Input on the X axis.</param>
      <param name="y">Input on the Y axis.</param>
      <param name="z">Input on the Z axis.</param>
      <returns>Resulting noise at given coordinates, in range of 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Noise.FbmVector(System.Int32,System.Single,System.Single)">
      <summary>
        <a href="https://en.wikipedia.org/wiki/Fractional_Brownian_motion">Fractional Brownian Motion</a> noise, a.k.a. Fractal Perlin noise.
            </summary>
      <param name="octaves">Number of octaves for the noise. Higher values are slower but produce more detailed results. 3 is a good starting point.</param>
      <param name="x">Input on the X axis.</param>
      <param name="y">Input on the Y axis.</param>
    </member>
    <member name="T:Sandbox.Utility.Noise.Parameters">
      <summary>
            Parameters for constructing a noise field. Use <see cref="T:Sandbox.Utility.Noise.FractalParameters" /> if you
            want a noise field made from multiple octaves.
            </summary>
      <param name="Seed">Seed state to initialize the field with.</param>
      <param name="Frequency">How quickly should samples change across space.</param>
    </member>
    <member name="M:Sandbox.Utility.Noise.Parameters.#ctor(System.Int32,System.Single)">
      <summary>
            Parameters for constructing a noise field. Use <see cref="T:Sandbox.Utility.Noise.FractalParameters" /> if you
            want a noise field made from multiple octaves.
            </summary>
      <param name="Seed">Seed state to initialize the field with.</param>
      <param name="Frequency">How quickly should samples change across space.</param>
    </member>
    <member name="P:Sandbox.Utility.Noise.Parameters.Seed">
      <summary>Seed state to initialize the field with.</summary>
    </member>
    <member name="P:Sandbox.Utility.Noise.Parameters.Frequency">
      <summary>How quickly should samples change across space.</summary>
    </member>
    <member name="T:Sandbox.Utility.Noise.FractalParameters">
      <summary>
            Parameters for constructing a <a href="https://en.wikipedia.org/wiki/Pink_noise">fractal</a>
            noise field, which layers multiple octaves of a noise function with increasing frequency
            and reducing amplitudes.
            </summary>
      <param name="Seed">Seed state to initialize the field with.</param>
      <param name="Frequency">How quickly should samples change across space.</param>
      <param name="Octaves">How many layers of noise to use.</param>
      <param name="Gain">How much to multiply the amplitude of each successive octave by.</param>
      <param name="Lacunarity">How much to multiply the frequency of each successive octave by.</param>
    </member>
    <member name="M:Sandbox.Utility.Noise.FractalParameters.#ctor(System.Int32,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
            Parameters for constructing a <a href="https://en.wikipedia.org/wiki/Pink_noise">fractal</a>
            noise field, which layers multiple octaves of a noise function with increasing frequency
            and reducing amplitudes.
            </summary>
      <param name="Seed">Seed state to initialize the field with.</param>
      <param name="Frequency">How quickly should samples change across space.</param>
      <param name="Octaves">How many layers of noise to use.</param>
      <param name="Gain">How much to multiply the amplitude of each successive octave by.</param>
      <param name="Lacunarity">How much to multiply the frequency of each successive octave by.</param>
    </member>
    <member name="P:Sandbox.Utility.Noise.FractalParameters.Octaves">
      <summary>How many layers of noise to use.</summary>
    </member>
    <member name="P:Sandbox.Utility.Noise.FractalParameters.Gain">
      <summary>How much to multiply the amplitude of each successive octave by.</summary>
    </member>
    <member name="P:Sandbox.Utility.Noise.FractalParameters.Lacunarity">
      <summary>How much to multiply the frequency of each successive octave by.</summary>
    </member>
    <member name="M:Sandbox.Utility.Noise.ValueField(Sandbox.Utility.Noise.Parameters)">
      <summary>
            Creates a <a href="https://en.wikipedia.org/wiki/Value_noise">Value noise</a> field,
            effectively smoothly sampled white noise. Use a <see cref="T:Sandbox.Utility.Noise.FractalParameters" /> for the
            field to have multiple octaves.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Noise.PerlinField(Sandbox.Utility.Noise.Parameters)">
      <summary>
            Creates a <a href="https://en.wikipedia.org/wiki/Perlin_noise">Perlin noise</a> field,
            which smoothly samples a grid of random gradients. Use a <see cref="T:Sandbox.Utility.Noise.FractalParameters" />
            for the field to have multiple octaves.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Noise.SimplexField(Sandbox.Utility.Noise.Parameters)">
      <summary>
            Creates a <a href="https://en.wikipedia.org/wiki/Simplex_noise">Simplex noise</a> field,
            a cheaper gradient noise function similar to <see cref="M:Sandbox.Utility.Noise.PerlinField(Sandbox.Utility.Noise.Parameters)" />. Use a
            <see cref="T:Sandbox.Utility.Noise.FractalParameters" /> for the field to have multiple octaves.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.INoiseField">
      <summary>
            A noise function that can be sampled at a 1-, 2-, or 3D position.
            Samples will be between <c>0</c> and <c>1</c>. Thread-safe.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.INoiseField.Sample(System.Single)">
      <summary>
            Sample at a 1D position.
            </summary>
      <returns>A noise value between <c>0</c> and <c>1</c>.</returns>
    </member>
    <member name="M:Sandbox.Utility.INoiseField.Sample(System.Single,System.Single)">
      <summary>
            Sample at a 2D position.
            </summary>
      <returns>A noise value between <c>0</c> and <c>1</c>.</returns>
    </member>
    <member name="M:Sandbox.Utility.INoiseField.Sample(System.Single,System.Single,System.Single)">
      <summary>
            Sample at a 3D position.
            </summary>
      <returns>A noise value between <c>0</c> and <c>1</c>.</returns>
    </member>
    <member name="M:Sandbox.Utility.INoiseField.Sample(Vector2)">
      <summary>
            Sample at a 2D position.
            </summary>
      <returns>A noise value between <c>0</c> and <c>1</c>.</returns>
    </member>
    <member name="M:Sandbox.Utility.INoiseField.Sample(Vector3)">
      <summary>
            Sample at a 3D position.
            </summary>
      <returns>A noise value between <c>0</c> and <c>1</c>.</returns>
    </member>
    <member name="P:Sandbox.Utility.CommandLine.Full">
      <summary>
            Returns the full command line, reconstructed from System.Environment.GetCommandLineArgs
            </summary>
    </member>
    <member name="P:Sandbox.Utility.CommandLine.CommandLineString">
      <summary>
            We can use this for unit tests to pass in a custom command line string.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.CommandLine.HasSwitch(System.String)">
      <summary>
            if ( HasSwitch( "-console" ) ) EnableConsole();
            </summary>
    </member>
    <member name="M:Sandbox.Utility.CommandLine.GetSwitches">
      <summary>
            Returns all command line values
            </summary>
      <returns />
    </member>
    <member name="T:Sandbox.Utility.Crc32">
      <summary>
            Generate 32-bit <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">Cyclic Redundancy Check</a> (CRC32) checksums.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Crc32.FromBytes(System.Collections.Generic.IEnumerable{System.Byte})">
      <summary>
            Generates a CRC32 checksum from a byte stream.
            </summary>
      <param name="byteStream">The input to generate a checksum for.</param>
      <returns>The generated CRC32.</returns>
    </member>
    <member name="M:Sandbox.Utility.Crc32.FromString(System.String)">
      <summary>
            Generates a CRC32 checksum from a string.
            </summary>
      <param name="str">The input to generate a checksum for.</param>
      <returns>The generated CRC32.</returns>
    </member>
    <member name="M:Sandbox.Utility.Crc32.FromStreamAsync(System.IO.Stream)">
      <summary>
            Generates a CRC32 checksum from a stream asynchronously.
            </summary>
      <param name="stream">The input to generate a checksum for.</param>
      <returns>The generated CRC32.</returns>
    </member>
    <member name="T:Sandbox.Utility.Crc64">
      <summary>
            Generate 64-bit <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">Cyclic Redundancy Check</a> (CRC64) checksums.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Crc64.FromBytes(System.Byte[],System.Int32,System.UInt64)">
      <summary>
            Compute the CRC64 of the input data using the Azure Storage CRC64 polynomial.
            </summary>
      <param name="src">The source data on which to compute the CRC64.</param>
      <param name="size" />
      <param name="uCrc" />
    </member>
    <member name="M:Sandbox.Utility.Crc64.FromString(System.String)">
      <summary>
            Generates a CRC64 checksum from a string.
            </summary>
      <param name="str">The input to generate a checksum for.</param>
      <returns>The generated CRC64.</returns>
    </member>
    <member name="M:Sandbox.Utility.Crc64.FromStreamAsync(System.IO.Stream)">
      <summary>
            Generates a CRC64 checksum from a stream asynchronously.
            </summary>
      <param name="stream">The input to generate a checksum for.</param>
      <returns>The generated CRC64.</returns>
    </member>
    <member name="M:Sandbox.Utility.Crc64.FromStream(System.IO.Stream)">
      <summary>
            Generates a CRC64 checksum from a stream.
            </summary>
      <param name="stream">The input to generate a checksum for.</param>
      <returns>The generated CRC64.</returns>
    </member>
    <member name="M:Sandbox.Utility.Crc64.FromBytes(System.Byte[])">
      <summary>
            Generates a CRC64 checksum from a byte array.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.DataProgress">
      <summary>
            For providing a callback to describe the progress of doing something with some kind of block of data
            </summary>
    </member>
    <member name="T:Sandbox.Utility.DataProgress.HttpContentStream">
      <summary>
            A httpContent stream that produces DataProgress outputs
            </summary>
    </member>
    <member name="T:Sandbox.Utility.DisposeAction">
      <summary>
            Creates an IDisposable that will simply run an action when disposed
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Easing">
      <summary>
            Easing functions used for transitions. See <a href="https://easings.net/">https://easings.net/</a> for examples.
            </summary>
    </member>
    <member name="T:Sandbox.Utility.Easing.Function">
      <summary>
            An easing function that transforms the linear input into non linear output.
            </summary>
      <param name="delta">A linear input value from 0 to 1</param>
      <returns>The resulting non linear output value, from 0 to 1</returns>
    </member>
    <member name="M:Sandbox.Utility.Easing.EaseInOut(System.Single)">
      <inheritdoc cref="M:Sandbox.Utility.Easing.ExpoInOut(System.Single)" />
    </member>
    <member name="M:Sandbox.Utility.Easing.EaseIn(System.Single)">
      <inheritdoc cref="M:Sandbox.Utility.Easing.QuadraticIn(System.Single)" />
    </member>
    <member name="M:Sandbox.Utility.Easing.EaseOut(System.Single)">
      <inheritdoc cref="M:Sandbox.Utility.Easing.QuadraticOut(System.Single)" />
    </member>
    <member name="M:Sandbox.Utility.Easing.Linear(System.Single)">
      <summary>
            Linear easing function, x=y.
            </summary>
      <param name="f">Input in range of 0 to 1.</param>
      <returns>Output in range 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Easing.QuadraticIn(System.Single)">
      <summary>
            Quadratic ease in.
            </summary>
      <param name="f">Input in range of 0 to 1.</param>
      <returns>Output in range 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Easing.QuadraticOut(System.Single)">
      <summary>
            Quadratic ease out.
            </summary>
      <param name="f">Input in range of 0 to 1.</param>
      <returns>Output in range 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Easing.QuadraticInOut(System.Single)">
      <summary>
            Quadratic ease in and out.
            </summary>
      <param name="f">Input in range of 0 to 1.</param>
      <returns>Output in range 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Easing.ExpoIn(System.Single)">
      <summary>
            Exponential ease in.
            </summary>
      <param name="f">Input in range of 0 to 1.</param>
      <returns>Output in range 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Easing.ExpoOut(System.Single)">
      <summary>
            Exponential ease out.
            </summary>
      <param name="f">Input in range of 0 to 1.</param>
      <returns>Output in range 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Easing.ExpoInOut(System.Single)">
      <summary>
            Exponential ease in and out.
            </summary>
      <param name="f">Input in range of 0 to 1.</param>
      <returns>Output in range 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Easing.BounceIn(System.Single)">
      <summary>
            Bouncy ease in.
            </summary>
      <param name="f">Input in range of 0 to 1.</param>
      <returns>Output in range 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Easing.BounceOut(System.Single)">
      <summary>
            Bouncy ease out.
            </summary>
      <param name="f">Input in range of 0 to 1.</param>
      <returns>Output in range 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Easing.BounceInOut(System.Single)">
      <summary>
            Bouncy ease in and out.
            </summary>
      <param name="f">Input in range of 0 to 1.</param>
      <returns>Output in range 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Easing.SineEaseIn(System.Single)">
      <summary>
            Sine ease in.
            </summary>
      <param name="f">Input in range of 0 to 1.</param>
      <returns>Output in range 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Easing.SineEaseOut(System.Single)">
      <summary>
            Sine ease out.
            </summary>
      <param name="f">Input in range of 0 to 1.</param>
      <returns>Output in range 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Easing.SineEaseInOut(System.Single)">
      <summary>
            Sine ease in and out.
            </summary>
      <param name="f">Input in range of 0 to 1.</param>
      <returns>Output in range 0 to 1.</returns>
    </member>
    <member name="M:Sandbox.Utility.Easing.AddFunction(System.String,Sandbox.Utility.Easing.Function)">
      <summary>
            Add an easing function.
            If the function already exists we silently return.
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Easing.GetFunction(System.String)">
      <summary>
            Get an easing function by name (ie, "ease-in").
            If the function doesn't exist we return QuadraticInOut
            </summary>
    </member>
    <member name="M:Sandbox.Utility.Easing.TryGetFunction(System.String,Sandbox.Utility.Easing.Function@)">
      <summary>
            Get an easing function by name (ie, "ease-in").
            If the function exists we return true, otherwise return false.
            </summary>
    </member>
    <member name="T:Sandbox.ConVarAttribute">
      <summary>
            Console variable
            </summary>
    </member>
    <member name="P:Sandbox.ConVarAttribute.Name">
      <summary>
            If unset the name will be set to the name of the method/property
            </summary>
    </member>
    <member name="P:Sandbox.ConVarAttribute.Help">
      <summary>
            Describes why this command exists
            </summary>
    </member>
    <member name="P:Sandbox.ConVarAttribute.Min">
      <summary>
            Minimum value for this command
            </summary>
    </member>
    <member name="P:Sandbox.ConVarAttribute.Max">
      <summary>
            Maximum value for this command
            </summary>
    </member>
    <member name="P:Sandbox.ConVarAttribute.Saved">
      <summary>
            If true this variable is saved
            </summary>
    </member>
    <member name="P:Sandbox.ConVarAttribute.Flags">
      <summary>
            Describes the kind of convar this is
            </summary>
    </member>
    <member name="P:Sandbox.ConVarAttribute.Context">
      <summary>
            If set to "menu" then this is a menu convar
            </summary>
    </member>
    <member name="F:Sandbox.ConVarFlags.Saved">
      <summary>
            Saved and restored between sessions
            </summary>
    </member>
    <member name="F:Sandbox.ConVarFlags.Replicated">
      <summary>
            The value of this is synced on a server. Only the server or server admins may change the value.
            </summary>
    </member>
    <member name="F:Sandbox.ConVarFlags.Cheat">
      <summary>
            This is a cheat command, don't run it unless cheats are enabled
            </summary>
    </member>
    <member name="F:Sandbox.ConVarFlags.UserInfo">
      <summary>
            Adds to userinfo - making it accessible via the connection class on other clients
            </summary>
    </member>
    <member name="F:Sandbox.ConVarFlags.Hidden">
      <summary>
            Hide in find and autocomplete
            </summary>
    </member>
    <member name="F:Sandbox.ConVarFlags.ChangeNotice">
      <summary>
            Tell clients when the value changes
            </summary>
    </member>
    <member name="F:Sandbox.ConVarFlags.Protected">
      <summary>
            Can't be accessed via game code (can be changed manually via console, or tools)
            </summary>
    </member>
    <member name="F:Sandbox.ConVarFlags.Server">
      <summary>
            This command will be run on the server in a multiplayer game
            </summary>
    </member>
    <member name="F:Sandbox.ConVarFlags.Admin">
      <summary>
            Only an admin of the server can run this command
            </summary>
    </member>
    <member name="F:Sandbox.ConVarFlags.GameSetting">
      <summary>
            A game setting that is exposed to the platform for UI editing
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.InvokeWithWarning(System.Action)">
      <summary>
            Call an action, swallow any exceptions with a warning
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.InvokeWithWarning``1(System.Action{``0},``0)">
      <summary>
            Call an action, swallow any exceptions with a warning
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToBase36``1(``0)">
      <summary>
            Encode the given number into a Base36 string
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.FromBase36(System.String)">
      <summary>
            Decode the Base36 Encoded string into a number
            </summary>
      <param name="input" />
      <returns />
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.GetEpoch(System.DateTime)">
      <summary>
            Returns the UNIX time stamp - number of seconds since 1st of January, 1970.
            </summary>
      <param name="d" />
      <returns />
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToDateTime(System.Int32)">
      <summary>
            Converts UNIX time stamp to a DateTime object.
            </summary>
      <param name="seconds">UNIX time stamp in seconds.</param>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToDateTime(System.Int64)">
      <inheritdoc cref="M:Sandbox.SandboxSystemExtensions.ToDateTime(System.Int32)" />
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Humanize(System.DateTime)">
      <summary>
            Convert date into a human readable relative time string.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Humanize(System.DateTimeOffset)">
      <summary>
            Convert date into a human readable relative time string.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Humanize(System.TimeOnly)">
      <summary>
            Convert date into a human readable relative time string.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Humanize(System.DateOnly)">
      <summary>
            Convert date into a human readable relative time string.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Humanize(System.TimeSpan,System.Int32)">
      <summary>
            Convert date into a human readable relative time string.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.GetOrCreate``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
      <summary>
            If the key doesn't exist it is created and returned
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Clone``2(System.Collections.Generic.Dictionary{``0,``1})">
      <summary>
            Clones the dictionary. Doesn't clone the values.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ForEachTaskAsync``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task},System.Int32,System.Threading.CancellationToken)">
      <summary>
            Runs each task on this thread but only execute a set amount at a time
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.GetCommonBaseType(System.Collections.Generic.IEnumerable{System.Type})">
      <summary>Finds the first common base type of the given types.</summary>
      <param name="types">The types.</param>
      <returns>The common base type.</returns>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.GetPropertyValue``1(System.Text.Json.Nodes.JsonObject,System.String,``0@)">
      <summary>
            Get a property value by name, from a JsonObject. Return defaultValue if it's not found.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.FormatBytes``1(``0,System.Boolean)">
      <summary>
            Given a number, will format as a memory value, ie 10gb, 4mb
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Clamp``1(``0,``0,``0)">
      <summary>
            Clamp a number between two values.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.FormatSeconds(System.Int64)">
      <summary>
            Formats the given value in format "1w2d3h4m5s". Will not display 0 values.
            </summary>
      <param name="secs">Time to format, in seconds.</param>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.FormatSeconds(System.UInt64)">
      <inheritdoc cref="M:Sandbox.SandboxSystemExtensions.FormatSeconds(System.Int64)" />
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.FormatSecondsLong(System.Int64)">
      <summary>
            Formats the given value in format "4 weeks, 3 days, 2 hours and 1 minutes".
            Will not display 0 values. Will not display seconds if value is more than 1 hour.
            </summary>
      <param name="secs">Time to format, in seconds.</param>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.FormatSecondsLong(System.UInt64)">
      <inheritdoc cref="M:Sandbox.SandboxSystemExtensions.FormatSecondsLong(System.Int64)" />
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.FormatNumberShort(System.Int64)">
      <summary>
            "1500" becomes "1,500", "15 000" becomes "15K", "15 000 000" becomes "15KK", etc.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.FormatNumberShort(System.UInt64)">
      <inheritdoc cref="M:Sandbox.SandboxSystemExtensions.FormatNumberShort(System.Int64)" />
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.UnsignedMod(System.Int32,System.Int32)">
      <summary>
            Does what you expected to happen when you did "a % b", that is, handles negative <paramref name="a" /> values by returning a positive number from the end.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.BitsSet(System.Int32)">
      <summary>
            Returns the number of bits set in an integer. This us usually used for flags to count
            the amount of flags set.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Plural(System.Int32,System.String,System.String)">
      <summary>
            Return single if 1 else plural
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.FormatWithSuffix(System.Int32)">
      <summary>
            Change 1 to 1st, 2 to 2nd etc
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.KiloFormat(System.Int32)">
      <summary>
            Format a large number into "1045M", "56K"
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.KiloFormat(System.Int64)">
      <summary>
            Format a large number into "1045M", "56K"
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Humanize(System.TimeSpan,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Humanize a timespan into "x hours", "x seconds"
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToMetric(System.Int32,System.Int32)">
      <summary>
            Convert 1100 to 1.1k
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.IsPowerOfTwo(System.Int32)">
      <summary>
            Return true if the number is a power of two (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, etc)
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToMetric(System.Int64,System.Int32)">
      <summary>
            Convert 1100 to 1.1k
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToMetric(System.Double,System.Int32)">
      <summary>
            Convert 1100 to 1.1k
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToMetric(System.Single,System.Int32)">
      <summary>
            Convert 1100 to 1.1k
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Double(System.Random,System.Double,System.Double)">
      <summary>
            Returns a double between min and max
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Float(System.Random)">
      <summary>
            Returns a random float between 0 and 1
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Float(System.Random,System.Single,System.Single)">
      <summary>
            Returns a random float between min and max
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Float(System.Random,System.Single)">
      <summary>
            Returns a random float between 0 and max (or 1)
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Double(System.Random,System.Double)">
      <summary>
            Returns a random double between 0 and max (or 1)
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Int(System.Random,System.Int32,System.Int32)">
      <summary>
            Returns a random int between min and max (inclusive)
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Int(System.Random,System.Int32)">
      <summary>
            Returns a random int between 0 and max (inclusive)
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Color(System.Random)">
      <summary>
            Returns a random Color
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Rotation(System.Random)">
      <summary>
            Returns a uniformly random rotation.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Angles(System.Random)">
      <summary>
            Returns the angles of a uniformly random rotation.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Gaussian(System.Random,System.Single,System.Single)">
      <summary>
            Sample from a Gaussian distribution with a given mean and standard deviation.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Gaussian2D(System.Random,System.Nullable{Vector2},System.Nullable{Vector2})">
      <summary>
            Sample from a 2D Gaussian distribution with a given mean and standard deviation.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Gaussian3D(System.Random,System.Nullable{Vector3},System.Nullable{Vector3})">
      <summary>
            Sample from a 3D Gaussian distribution with a given mean and standard deviation.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Gaussian4D(System.Random,System.Nullable{Vector4},System.Nullable{Vector4})">
      <summary>
            Sample from a 4D Gaussian distribution with a given mean and standard deviation.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.VectorInSquare(System.Random,System.Single)">
      <summary>
            Uniformly samples a 2D position from a square with coordinates in the range -<paramref name="extents" /> to +<paramref name="extents" />.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.VectorInCube(System.Random,System.Single)">
      <summary>
            Uniformly samples a 3D position from a cube with coordinates in the range -<paramref name="extents" /> to +<paramref name="extents" />.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.VectorInCube(System.Random,BBox@)">
      <summary>
            Uniformly samples a 3D position from a cube
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.VectorInCircle(System.Random,System.Single)">
      <summary>
            Uniformly samples a 2D position from all points with distance at most <paramref name="radius" /> from the origin.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.VectorInSphere(System.Random,System.Single)">
      <summary>
            Uniformly samples a 3D position from all points with distance at most <paramref name="radius" /> from the origin.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.FromArray``1(System.Random,``0[],``0)">
      <summary>
            Returns a random value in an array
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.FromList``1(System.Random,System.Collections.Generic.List{``0},``0)">
      <summary>
            Returns a random value in a list
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.HasAttribute(System.Reflection.MemberInfo,System.Type,System.Boolean)">
      <summary>
            Returns true if this member has this attribute
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.HasBaseType(System.Type,System.String)">
      <summary>
            Returns true if this type derives from a type named name
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.GetAttributeOfType``1(System.Enum)">
      <summary>
            Gets an attribute on an enum field value
            </summary>
      <typeparam name="T">The type of the attribute you want to retrieve</typeparam>
      <param name="enumVal">The enum value</param>
      <returns>The attribute of type T that exists on the enum value</returns>
      <example><![CDATA[string desc = myEnumVariable.GetAttributeOfType<DescriptionAttribute>().Description;]]></example>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.IsBasedOnGenericType(System.Type,System.Type)">
      <summary>
            Returns if this type is based on a given generic type.
            </summary>
      <param name="src">The type to test.</param>
      <param name="test">The type to test against. Typically this will be something like <code>typeof( MyType&lt;&gt; )</code></param>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.CheckValidationAttributes(System.Reflection.PropertyInfo,System.Object,System.String[]@,System.String)">
      <summary>
            Check all <see cref="T:System.ComponentModel.DataAnnotations.ValidationAttribute" />s on this property, and get the error messages if there are any.
            </summary>
      <param name="prop">The property whose arguments to test.</param>
      <param name="obj">Instance of the object this property is of.</param>
      <param name="errors">If returned false, these will be the error messages to display.</param>
      <param name="name">Override the property name in error messages.</param>
      <returns>Returns true if all checks have passed or there is no attributes to test, false if there were errors.</returns>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.IsInitOnly(System.Reflection.PropertyInfo)">
      <summary>
            Determine if this property is init-only.
            </summary>
      <param name="property">The property to test.</param>
      <returns>Returns true if the property is init-only, false otherwise.</returns>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToSimpleString(System.Type,System.Boolean)">
      <summary>
            Returns this type's name, with nicer formatting for generic types.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToSimpleString(System.Reflection.MemberInfo,System.Boolean)">
      <summary>
            Returns this member's name qualified by its declaring type, with nicer formatting for generics.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToSimpleString(System.Delegate,System.Boolean)">
      <summary>
            Returns a nice name for the given delegate, based on the method that implements it.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ReadNullTerminatedString(System.IO.Stream,System.Int64)">
      <summary>
            Read a null terminated string from the stream, at given offset.
            </summary>
      <param name="stream">The stream to read from.</param>
      <param name="offset">Offset where to start reading, from the beginning of the stream.</param>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.QuoteSafe(System.String,System.Boolean)">
      <summary>
            Puts quote marks around a string. Internal quotes are backslashed.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.HtmlEncode(System.String)">
      <inheritdoc cref="M:System.Net.WebUtility.HtmlEncode(System.String)" />
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.UrlEncode(System.String)">
      <inheritdoc cref="M:System.Net.WebUtility.UrlEncode(System.String)" />
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.CollapseWhiteSpaceRegex">
      <remarks>
            Pattern:<br /><code>\\s+</code><br />
            Explanation:<br /><code>
            ○ Match a whitespace character atomically at least once.<br /></code></remarks>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.CollapseWhiteSpace(System.String)">
      <summary>
            Collapse sequences of whitespace into a single whitespace
            </summary>
      <param name="str" />
      <returns />
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.CollapseSpacesAndTabsRegex">
      <remarks>
            Pattern:<br /><code>[ \t]+</code><br />
            Explanation:<br /><code>
            ○ Match a character in the set [\t ] atomically at least once.<br /></code></remarks>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.RemoveSpacesAroundLineBreaksRegex">
      <remarks>
            Pattern:<br /><code>(?&lt;=\\n|\\u2029)[ \\t]+|[ \\t]+(?=\\n|\\u2029)</code><br />
            Explanation:<br /><code>
            ○ Match with 2 alternative expressions, atomically.<br />
                ○ Match a sequence of expressions.<br />
                    ○ Zero-width positive lookbehind.<br />
                        ○ Match a character in the set [\n\u2029] right-to-left.<br />
                    ○ Match a character in the set [\t ] atomically at least once.<br />
                ○ Match a sequence of expressions.<br />
                    ○ Match a character in the set [\t ] atomically at least once.<br />
                    ○ Zero-width positive lookahead.<br />
                        ○ Match a character in the set [\n\u2029].<br /></code></remarks>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.CollapseSpacesAndPreserveLines(System.String)">
      <summary>
            Collapse sequences of spaces and tabs into a single space, preserving newlines
            </summary>
      <param name="str" />
      <returns />
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.NormalizeFilename(System.String,System.Boolean)">
      <summary>
            Puts a filename into the format /path/filename.ext (from path\FileName.EXT)
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.NormalizeFilename(System.String,System.Boolean,System.Boolean)">
      <summary>
            Puts a filename into the format /path/filename.ext (from path\FileName.EXT)
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.WithExtension(System.String,System.String)">
      <summary>
            Adds or replaces the extension of <paramref name="path" /> to <paramref name="ext" />.
            </summary>
      <param name="path">A file path with or without an extension.</param>
      <param name="ext">A file extension with or without a leading period.</param>
      <returns />
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.SimplifyPath(System.String)">
      <summary>
            Gets rid of ../'s (from /path/folder/../file.txt to /path/file.txt)
            </summary>
      <param name="str" />
      <returns />
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.SplitQuotesStrings(System.String)">
      <summary>
            in  : I am "splitting a" string "because it's fun "
            out : ["I", "am", "splitting a", "string", "because it's fun"]
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToFloat(System.String,System.Single)">
      <summary>
            Convert to <see cref="T:System.Single" />, if not then return <paramref name="Default" />.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToFloatEval(System.String,System.Single)">
      <summary>
            Convert to <see cref="T:System.Single" />. Might be a string formula. This is always going to be slower than a call to <see cref="M:Sandbox.SandboxSystemExtensions.ToFloat(System.String,System.Single)" />.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToDouble(System.String,System.Single)">
      <summary>
            Convert to <see cref="T:System.Double" />, if not then return <paramref name="Default" />.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToDoubleEval(System.String,System.Double)">
      <summary>
            Convert to <see cref="T:System.Double" />. Might be a string formula. This is always going to be slower than a call to <see cref="M:Sandbox.SandboxSystemExtensions.ToDouble(System.String,System.Single)" />.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToDecimal(System.String,System.Decimal)">
      <summary>
            128-bit data type that returns sane results for almost any input.
            All other numeric types can cast from this.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToUInt(System.String,System.Int32)">
      <summary>
            Convert to <see cref="T:System.UInt32" />, if not then return <paramref name="Default" />.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToInt(System.String,System.Int32)">
      <summary>
            Convert to <see cref="T:System.Int32" />, if not then return <paramref name="Default" />.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToIntEval(System.String,System.Int32)">
      <summary>
            Convert to <see cref="T:System.Int32" />. Might be a string formula. This is always going to be slower than a call to <see cref="M:Sandbox.SandboxSystemExtensions.ToInt(System.String,System.Int32)" />.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToULong(System.String,System.UInt64)">
      <summary>
            Convert to <see cref="T:System.UInt64" />, if not then return <paramref name="Default" />.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToLong(System.String,System.Int64)">
      <summary>
            Convert to <see cref="T:System.Int64" />, if not then return <paramref name="Default" />.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToLongEval(System.String,System.Int64)">
      <summary>
            Convert to <see cref="T:System.Int64" />. Might be a string formula. This is always going to be slower than a call to <see cref="M:Sandbox.SandboxSystemExtensions.ToLong(System.String,System.Int64)" />.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToBool(System.String)">
      <summary>
            Try to convert to bool. Inputs can be true, false, yes, no, 0, 1, null (caps insensitive)
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Truncate(System.String,System.Int32,System.String)">
      <summary>
            If the string is longer than this amount of characters then truncate it
            If appendage is defined, it will be appended to the end of truncated strings (ie, "..")
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.TruncateFilename(System.String,System.Int32,System.String)">
      <summary>
            If the string is longer than this amount of characters then truncate it
            If appendage is defined, it will be appended to the end of truncated strings (ie, "..")
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Contains(System.String,System.String,System.StringComparison)">
      <summary>
            An extended Contains which takes a StringComparison.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Snippet(System.String,System.String,System.Int32)">
      <summary>
            Given a large string, find all occurrences of a substring and return them with padding.
            This is useful in situations where you're searching for a word in a hug body of text, and
            want to show how it's used without displaying the whole text.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToTitleCase(System.String)">
      <summary>
            Convert a variable name to something more user friendly.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.RemoveBadCharacters(System.String)">
      <summary>
            Removes bad, invisible characters that are commonly used to exploit.
            https://en.wikipedia.org/wiki/Zero-width_non-joiner
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Base64Encode(System.String)">
      <summary>
            Convert to a base64 encoded string
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Base64Decode(System.String)">
      <summary>
            Convert from a base64 encoded string
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.ToType(System.String,System.Type)">
      <summary>
            Try to politely convert from a string to another type
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.TryToType(System.String,System.Type,System.Object@)">
      <summary>
            Try to politely convert from a string to another type
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.FastHash(System.String)">
      <summary>
            Generate FNV-1a hash from given string.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.MurmurHash2(System.String,System.Boolean,System.UInt32)">
      <summary>
            The seed is what the engine uses for STRINGTOKEN_MURMURHASH_SEED
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Columnize(System.String,System.Int32,System.Boolean)">
      <summary>
            convert "string" into "string       " or "      string"
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.WildcardMatch(System.String,System.String)">
      <summary>
            Returns true if this string matches a wildcard match. Check is case insensitive.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.TrimQuoted(System.String,System.Boolean)">
      <summary>
            The string might start and end in quotes ( ", ' ), remove those if that is the case.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.Distance(System.String,System.String)">
      <summary>
            Return the distance between two strings. Useful for ordering strings by similarity
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.IsValidTag(System.String)">
      <summary>
            Is this string a valid Tag. This is a way to check if a string is a valid tag, project wide. So our logic is always the same.
            
            - not null
            - between 1 and 32 chars
            - a-z
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.GetFilenameSafe(System.String)">
      <summary>
            Make the passed in string filename safe. This replaces any invalid characters with "_".
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.GetManagedSize(System.Type)">
      <summary>
            Get the managed size of a given type. This matches an IL-level sizeof(t), even if it cannot be determined normally in C#.
            Note that <c>sizeof(t) != Marshal.SizeOf(t)</c> when t is char or bool.
            </summary>
      <remarks>
            An IL-level <c>sizeof(t)</c> will return <c>sizeof(IntPtr)</c> for reference types, as it refers to the size on stack or in an object,
            not the size on heap.
            </remarks>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.IsPrivate(System.Uri)">
      <summary>
            Does this Uri resolve to a private range IP address?
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.IsPrivate(System.Net.IPAddress)">
      <summary>
            Returns true if the IP address is in a private range.<br />
            IPv4: Loopback, link local ("169.254.x.x"), class A ("10.x.x.x"), class B ("172.16.x.x" to "172.31.x.x") and class C ("192.168.x.x").<br />
            IPv6: Loopback, link local, site local, unique local and private IPv4 mapped to IPv6.<br /></summary>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.CatmullRomSpline(System.Collections.Generic.IEnumerable{Vector3},System.Int32)">
      <summary>
            Generates a Catmull-Rom spline from a collection of Vector3 points. Needs at least 3 points to create a spline.
            </summary>
      <param name="points">The collection of Vector3 points.</param>
      <param name="interpolation">The number of interpolated points to generate between each pair of input points.</param>
      <returns>An IEnumerable of Vector3 points representing the Catmull-Rom spline.</returns>
    </member>
    <member name="M:Sandbox.SandboxSystemExtensions.IsValid(Sandbox.IValid)">
      <summary>
            Returns false if <see cref="T:Sandbox.IValid" /> object is null or if <see cref="P:Sandbox.IValid.IsValid" /> returns false.
            </summary>
    </member>
    <member name="T:Sandbox.TextFlag">
      <summary>
            Flags dictating position of text (and other elements).
            Default alignment on each axis is Top, Left.
            Values for each axis can be combined into a single value, conflicting values have undefined behavior.
            </summary>
    </member>
    <member name="F:Sandbox.TextFlag.Left">
      <summary>
            Align to the left on the X axis.
            </summary>
    </member>
    <member name="F:Sandbox.TextFlag.Right">
      <summary>
            Align to the right on the X axis.
            </summary>
    </member>
    <member name="F:Sandbox.TextFlag.CenterHorizontally">
      <summary>
            Align in the center on the X axis.
            </summary>
    </member>
    <member name="F:Sandbox.TextFlag.Top">
      <summary>
            Anchor to the top on the Y axis.
            </summary>
    </member>
    <member name="F:Sandbox.TextFlag.Bottom">
      <summary>
            Anchor to the bottom on the Y axis.
            </summary>
    </member>
    <member name="F:Sandbox.TextFlag.CenterVertically">
      <summary>
            Align in the center on the Y axis.
            </summary>
    </member>
    <member name="F:Sandbox.TextFlag.LeftTop">
      <summary>
            Anchor to the top left corner.
            </summary>
    </member>
    <member name="F:Sandbox.TextFlag.LeftCenter">
      <summary>
            Anchor to the left side, center vertically.
            </summary>
    </member>
    <member name="F:Sandbox.TextFlag.LeftBottom">
      <summary>
            Anchor to the bottom left corner.
            </summary>
    </member>
    <member name="F:Sandbox.TextFlag.CenterTop">
      <summary>
            Anchor to the top side, center horizontally.
            </summary>
    </member>
    <member name="F:Sandbox.TextFlag.Center">
      <summary>
            Align in the center on both axises.
            </summary>
    </member>
    <member name="F:Sandbox.TextFlag.CenterBottom">
      <summary>
            Anchor to the bottom side, center horizontally.
            </summary>
    </member>
    <member name="F:Sandbox.TextFlag.RightTop">
      <summary>
            Anchor to the top right corner.
            </summary>
    </member>
    <member name="F:Sandbox.TextFlag.RightCenter">
      <summary>
            Anchor to the right side, center vertically.
            </summary>
    </member>
    <member name="F:Sandbox.TextFlag.RightBottom">
      <summary>
            Anchor to the bottom right corner.
            </summary>
    </member>
    <member name="F:Sandbox.TextFlag.SingleLine">
      <summary>
            Limit the text to a single line. Used in <c>Graphics.DrawText</c> and <c>Graphics.MeasureText</c>.
            </summary>
    </member>
    <member name="F:Sandbox.TextFlag.DontClip">
      <summary>
            Do not cutoff text beyond its bounds. Used in <c>Graphics.DrawText</c> and <c>Graphics.MeasureText</c>.
            </summary>
    </member>
    <member name="T:Sandbox.Html.Attribute">
      <summary>
            Represents an HTML attribute.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Attribute.Name">
      <summary>
            Gets the qualified name of the attribute.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Attribute.Value">
      <summary>
            Gets or sets the value of the attribute.
            </summary>
    </member>
    <member name="T:Sandbox.Html.Document">
      <summary>
            Represents a complete HTML document.
            </summary>
    </member>
    <member name="F:Sandbox.Html.Document.Text">
      <summary>The HtmlDocument Text. Careful if you modify it.</summary>
    </member>
    <member name="F:Sandbox.Html.Document.BackwardCompatibility">
      <summary>True to stay backward compatible with previous version of HAP. This option does not guarantee 100% compatibility.</summary>
    </member>
    <member name="F:Sandbox.Html.Document.OptionCheckSyntax">
      <summary>
            Defines if non closed nodes will be checked at the end of parsing. Default is true.
            </summary>
    </member>
    <member name="F:Sandbox.Html.Document.OptionExtractErrorSourceTextMaxLength">
      <summary>
            Defines the maximum length of source text or parse errors. Default is 100.
            </summary>
    </member>
    <member name="F:Sandbox.Html.Document.OptionMaxNestedChildNodes">
      <summary>
            The max number of nested child nodes.
            Added to prevent stackoverflow problem when a page has tens of thousands of opening html tags with no closing tags
            </summary>
    </member>
    <member name="M:Sandbox.Html.Document.#ctor">
      <summary>
            Creates an instance of an HTML document.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Document.ParsedText">
      <summary>Gets the parsed text.</summary>
      <value>The parsed text.</value>
    </member>
    <member name="P:Sandbox.Html.Document.MaxDepthLevel">
      <summary>
            Defines the max level we would go deep into the html document. If this depth level is exceeded, and exception is
            thrown.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Document.DocumentNode">
      <summary>
            Gets the root node of the document.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Document.ParseErrors">
      <summary>
            Gets a list of parse errors found in the document.
            </summary>
    </member>
    <member name="M:Sandbox.Html.Document.IsWhiteSpace(System.Int32)">
      <summary>
            Determines if the specified character is considered as a whitespace character.
            </summary>
      <param name="c">The character to check.</param>
      <returns>true if the specified character is considered as a whitespace character.</returns>
    </member>
    <member name="M:Sandbox.Html.Document.Load(System.IO.TextReader)">
      <summary>
            Loads the HTML document from the specified TextReader.
            </summary>
      <param name="reader">The TextReader used to feed the HTML data into the document. May not be null.</param>
    </member>
    <member name="M:Sandbox.Html.Document.LoadHtml(System.String)">
      <summary>
            Loads the HTML document from the specified string.
            </summary>
      <param name="html">String containing the HTML document to load. May not be null.</param>
    </member>
    <member name="T:Sandbox.Html.Node">
      <summary>
            Represents an HTML node.
            </summary>
    </member>
    <member name="F:Sandbox.Html.Node.HtmlNodeTypeNameComment">
      <summary>
            Gets the name of a comment node. It is actually defined as '#comment'.
            </summary>
    </member>
    <member name="F:Sandbox.Html.Node.HtmlNodeTypeNameDocument">
      <summary>
            Gets the name of the document node. It is actually defined as '#document'.
            </summary>
    </member>
    <member name="F:Sandbox.Html.Node.HtmlNodeTypeNameText">
      <summary>
            Gets the name of a text node. It is actually defined as '#text'.
            </summary>
    </member>
    <member name="M:Sandbox.Html.Node.#ctor(Sandbox.Html.NodeType,Sandbox.Html.Document,System.Int32)">
      <summary>
            Initializes HtmlNode, providing type, owner and where it exists in a collection
            </summary>
      <param name="type" />
      <param name="ownerdocument" />
      <param name="index" />
    </member>
    <member name="P:Sandbox.Html.Node.IsElement">
      <summary>
            Returns true if this is a html element (ie, not a comment or text)
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.IsComment">
      <summary>
            Returns true if this is a comment
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.IsText">
      <summary>
            Returns true if this is text
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.IsDocument">
      <summary>
            Returns true if this is the root document
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.Attributes">
      <summary>
            Gets the collection of HTML attributes for this node. May not be null.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.ChildNodes">
      <summary>
            Gets all the children of the node.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.Closed">
      <summary>
            Gets a value indicating if this node has been closed or not.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.HasAttributes">
      <summary>
            Gets a value indicating whether the current node has any attributes.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.HasChildNodes">
      <summary>
            Gets a value indicating whether this node has any child nodes.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.InnerHtml">
      <summary>
            Gets or Sets the HTML between the start and end tags of the object.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.Line">
      <summary>
            Gets the line number of this node in the document.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.LinePosition">
      <summary>
            Gets the column number of this node in the document.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.InnerStartIndex">
      <summary>
            Gets the stream position of the area between the opening and closing tag of the node, relative to the start of the document.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.Name">
      <summary>
            Gets or sets this node's name.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.NodeType">
      <summary>
            Gets the type of this node.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.OuterHtml">
      <summary>
            Gets or Sets the object and its content in HTML.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.OwnerDocument">
      <summary>
            Gets the <see cref="T:Sandbox.Html.Document" /> to which this node belongs.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.ParentNode">
      <summary>
            Gets the parent of this node (for nodes that can have parents).
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.PreviousSibling">
      <summary>
            Gets the node immediately preceding this node.
            </summary>
    </member>
    <member name="P:Sandbox.Html.Node.Depth">
      <summary>
            The depth of the node relative to the opening root html element. This value is used to determine if a document has to many nested html nodes which can cause stack overflows
            </summary>
    </member>
    <member name="M:Sandbox.Html.Node.Ancestors">
      <summary>
            Returns a collection of all ancestor nodes of this element.
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.Html.Node.Ancestors(System.String)">
      <summary>
            Get Ancestors with matching name
            </summary>
      <param name="name" />
      <returns />
    </member>
    <member name="M:Sandbox.Html.Node.AncestorsAndSelf">
      <summary>
            Returns a collection of all ancestor nodes of this element.
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.Html.Node.AncestorsAndSelf(System.String)">
      <summary>
            Gets all ancestor nodes and the current node
            </summary>
      <param name="name" />
      <returns />
    </member>
    <member name="M:Sandbox.Html.Node.AppendChild(Sandbox.Html.Node)">
      <summary>
            Adds the specified node to the end of the list of children of this node.
            </summary>
      <param name="newChild">The node to add. May not be null.</param>
      <returns>The node added.</returns>
    </member>
    <member name="M:Sandbox.Html.Node.SetChildNodesId(Sandbox.Html.Node)">
      <summary>Sets child nodes identifier.</summary>
      <param name="childNode">The child node.</param>
    </member>
    <member name="M:Sandbox.Html.Node.Descendants">
      <summary>
            Gets all Descendant nodes in enumerated list
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.Html.Node.Descendants(System.Int32)">
      <summary>
            Gets all Descendant nodes in enumerated list
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.Html.Node.Descendants(System.String)">
      <summary>
            Get all descendant nodes with matching name
            </summary>
      <param name="name" />
      <returns />
    </member>
    <member name="M:Sandbox.Html.Node.DescendantsAndSelf">
      <summary>
            Returns a collection of all descendant nodes of this element, in document order
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.Html.Node.DescendantsAndSelf(System.String)">
      <summary>
            Gets all descendant nodes including this node
            </summary>
      <param name="name" />
      <returns />
    </member>
    <member name="M:Sandbox.Html.Node.Element(System.String)">
      <summary>
            Gets first generation child node matching name
            </summary>
      <param name="name" />
      <returns />
    </member>
    <member name="M:Sandbox.Html.Node.Elements(System.String)">
      <summary>
            Gets matching first generation child nodes matching name
            </summary>
      <param name="name" />
      <returns />
    </member>
    <member name="M:Sandbox.Html.Node.GetAttribute(System.String,System.String)">
      <summary>
            Helper method to get the value of an attribute of this node. If the attribute is not found, the default value will be returned.
            </summary>
      <param name="name">The name of the attribute to get. May not be <c>null</c>.</param>
      <param name="def">The default value to return if not found.</param>
      <returns>The value of the attribute if found, the default value if not found.</returns>
    </member>
    <member name="M:Sandbox.Html.Node.RemoveAllIDforNode(Sandbox.Html.Node)">
      <summary>Removes all id for node described by node.</summary>
      <param name="node">The node.</param>
    </member>
    <member name="M:Sandbox.Html.Node.RemoveChild(Sandbox.Html.Node)">
      <summary>
            Removes the specified child node.
            </summary>
      <param name="oldChild">The node being removed. May not be <c>null</c>.</param>
      <returns>The node removed.</returns>
    </member>
    <member name="M:Sandbox.Html.Node.SetParent(Sandbox.Html.Node)">
      <summary>
            Sets the parent Html node and properly determines the current node's depth using the parent node's depth.
            </summary>
    </member>
    <member name="T:Sandbox.Html.NodeType">
      <summary>
            Represents the type of a node.
            </summary>
    </member>
    <member name="F:Sandbox.Html.NodeType.Document">
      <summary>
            The root of a document.
            </summary>
    </member>
    <member name="F:Sandbox.Html.NodeType.Element">
      <summary>
            An HTML element.
            </summary>
    </member>
    <member name="F:Sandbox.Html.NodeType.Comment">
      <summary>
            An HTML comment.
            </summary>
    </member>
    <member name="F:Sandbox.Html.NodeType.Text">
      <summary>
            A text node is always the child of an element or a document node.
            </summary>
    </member>
    <member name="T:Sandbox.Html.ParseError">
      <summary>
            Represents a parsing error found during document parsing.
            </summary>
    </member>
    <member name="P:Sandbox.Html.ParseError.Code">
      <summary>
            Gets the type of error.
            </summary>
    </member>
    <member name="P:Sandbox.Html.ParseError.Line">
      <summary>
            Gets the line number of this error in the document.
            </summary>
    </member>
    <member name="P:Sandbox.Html.ParseError.LinePosition">
      <summary>
            Gets the column number of this error in the document.
            </summary>
    </member>
    <member name="P:Sandbox.Html.ParseError.Reason">
      <summary>
            Gets a description for the error.
            </summary>
    </member>
    <member name="P:Sandbox.Html.ParseError.SourceText">
      <summary>
            Gets the full text of the line containing the error.
            </summary>
    </member>
    <member name="P:Sandbox.Html.ParseError.StreamPosition">
      <summary>
            Gets the absolute stream position of this error in the document, relative to the start of the document.
            </summary>
    </member>
    <member name="T:Sandbox.Html.ParseErrorCode">
      <summary>
            Represents the type of parsing error.
            </summary>
    </member>
    <member name="F:Sandbox.Html.ParseErrorCode.TagNotClosed">
      <summary>
            A tag was not closed.
            </summary>
    </member>
    <member name="F:Sandbox.Html.ParseErrorCode.TagNotOpened">
      <summary>
            A tag was not opened.
            </summary>
    </member>
    <member name="F:Sandbox.Html.ParseErrorCode.CharsetMismatch">
      <summary>
            There is a charset mismatch between stream and declared (META) encoding.
            </summary>
    </member>
    <member name="F:Sandbox.Html.ParseErrorCode.EndTagNotRequired">
      <summary>
            An end tag was not required.
            </summary>
    </member>
    <member name="F:Sandbox.Html.ParseErrorCode.EndTagInvalidHere">
      <summary>
            An end tag is invalid at this position.
            </summary>
    </member>
    <member name="T:Sandbox.Html.TextNode">
      <summary>
            Represents an HTML text node.
            </summary>
    </member>
    <member name="P:Sandbox.Html.TextNode.InnerHtml">
      <summary>
            Gets or Sets the HTML between the start and end tags of the object. In the case of a text node, it is equals to OuterHtml.
            </summary>
    </member>
    <member name="P:Sandbox.Html.TextNode.OuterHtml">
      <summary>
            Gets or Sets the object and its content in HTML.
            </summary>
    </member>
    <member name="T:Sandbox.UI.IStyleTarget">
      <summary>
            Everything the style system needs to work out a style
            </summary>
    </member>
    <member name="T:Sandbox.UI.Length">
      <summary>
            A variable unit based length. ie, could be a percentage or a pixel length. This is commonly used to express the size of things in UI space, usually coming from style sheets.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Length.Value">
      <summary>
            The meaning of the value is dependent on <see cref="F:Sandbox.UI.Length.Unit" />.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Length.Unit">
      <summary>
            How to determine the final length. Commonly used with Pixel or Percentage.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Length.RootSize">
      <summary>
            The current root panel size. This is required for vh, vw, vmin and vmax. This is set during PreLayout, Layout and PostLayout.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Length.RootFontSize">
      <summary>
            The current root panel font size. This is required for rem. This is set during PreLayout, Layout and PostLayout.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Length.CurrentFontSize">
      <summary>
            The current panel font size. This is required for em. This is set during PreLayout.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Length._expression">
      <summary>
            If the length unit is Expression, this will represent the calc() expression parsed
            </summary>
    </member>
    <member name="M:Sandbox.UI.Length.GetPixels(System.Single)">
      <summary>
            Convert to a pixel value. Use the dimension to work out percentage values.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Length.GetPixels(System.Single,System.Single)">
      <summary>
            Get the pixel size but also evaluate content size to support use Start, End, Center
            </summary>
    </member>
    <member name="M:Sandbox.UI.Length.Lerp(Sandbox.UI.Length,Sandbox.UI.Length,System.Single,System.Single)">
      <summary>
            Lerp from one length to another.
            </summary>
      <param name="a">Length at delta 0</param>
      <param name="b">Length at delta 1</param>
      <param name="delta">The interpolation stage</param>
      <param name="dimension">The width or height of the parent to use when working out percentage lengths</param>
      <returns>The interpolated Length</returns>
    </member>
    <member name="M:Sandbox.UI.Length.Lerp(Sandbox.UI.Length,Sandbox.UI.Length,System.Single,System.Single,System.Single)">
      <summary>
            Lerp from one length to another.
            </summary>
      <param name="a">Length at delta 0</param>
      <param name="b">Length at delta 1</param>
      <param name="delta">The interpolation stage</param>
      <param name="dimension">The width or height of the parent to use when working out percentage lengths</param>
      <param name="contentSize">Evaluate content size to support use Start, End, Center</param>
      <returns>The interpolated Length</returns>
    </member>
    <member name="M:Sandbox.UI.Length.Lerp(Sandbox.UI.Length,Sandbox.UI.Length,System.Single)">
      <summary>
            Lerp from one length to another.
            </summary>
      <param name="a">Length at delta 0</param>
      <param name="b">Length at delta 1</param>
      <param name="delta">The interpolation stage</param>
      <returns>The interpolated Length</returns>
    </member>
    <member name="M:Sandbox.UI.Length.Pixels(System.Single)">
      <summary>
            Create a length in pixels
            </summary>
      <param name="pixels">The amount of pixels for this length</param>
      <returns>A new length</returns>
    </member>
    <member name="M:Sandbox.UI.Length.Percent(System.Single)">
      <summary>
            Create a length in percents
            </summary>
      <param name="percent">The amount of percent for this (0-100)</param>
      <returns>A new length</returns>
    </member>
    <member name="M:Sandbox.UI.Length.ViewHeight(System.Single)">
      <summary>
            Create a length based on the view height
            </summary>
      <param name="percentage">The amount of percent for this (0-100)</param>
      <returns>A new length</returns>
    </member>
    <member name="M:Sandbox.UI.Length.ViewWidth(System.Single)">
      <summary>
            Create a length based on the view width
            </summary>
      <param name="percentage">The amount of percent for this (0-100)</param>
      <returns>A new length</returns>
    </member>
    <member name="M:Sandbox.UI.Length.ViewMax(System.Single)">
      <summary>
            Create a length based on the longest edge of the screen size
            </summary>
      <param name="percentage">The amount of percent for this (0-100)</param>
      <returns>A new length</returns>
    </member>
    <member name="M:Sandbox.UI.Length.ViewMin(System.Single)">
      <summary>
            Create a length based on the shortest edge of the screen size
            </summary>
      <param name="percentage">The amount of percent for this (0-100)</param>
      <returns>A new length</returns>
    </member>
    <member name="M:Sandbox.UI.Length.Fraction(System.Single)">
      <summary>
            Create a length in percents
            </summary>
      <param name="fraction">The fraction of a percent (0 = 0%, 1 = 100%)</param>
      <returns>A new length</returns>
    </member>
    <member name="M:Sandbox.UI.Length.Calc(System.String)">
      <summary>
            Create a length based on a css calc expression
            </summary>
    </member>
    <member name="M:Sandbox.UI.Length.Rem(System.Single)">
      <summary>
            Create a length based on the font size of the root element.
            </summary>
      <param name="value">Value in rem</param>
      <returns>A new length</returns>
    </member>
    <member name="M:Sandbox.UI.Length.Em(System.Single)">
      <summary>
            Create a length based on the font size of the current element.
            </summary>
      <param name="value">Value in em</param>
      <returns>A new length</returns>
    </member>
    <member name="P:Sandbox.UI.Length.Auto">
      <summary>
            Quickly create a Length with Unit set to LengthUnit.Auto
            </summary>
    </member>
    <member name="P:Sandbox.UI.Length.Contain">
      <summary>
            Quickly create a Length with Unit set to LengthUnit.Contain
            </summary>
    </member>
    <member name="P:Sandbox.UI.Length.Cover">
      <summary>
            Quickly create a Length with Unit set to LengthUnit.Cover
            </summary>
    </member>
    <member name="M:Sandbox.UI.Length.Parse(System.String)">
      <summary>
            Parse a length. This is used by the stylesheet parsing system.
            </summary>
      <param name="value">A length represented by a string</param>
      <example>Length.Parse( "100px" )</example>
      <example>Length.Parse( "56%" )</example>
      <returns />
    </member>
    <member name="M:Sandbox.UI.Length.GetFraction(System.Single)">
      <summary>
            If it's a %, will return 0-1. If not it'll return its value.
            </summary>
    </member>
    <member name="T:Sandbox.UI.LengthUnit">
      <summary>
            Possible units for various CSS properties that require length, used by <see cref="T:Sandbox.UI.Length" /> struct.
            </summary>
    </member>
    <member name="F:Sandbox.UI.LengthUnit.Auto">
      <summary>
            The layout engine will calculate and select a width for the specified element.
            </summary>
    </member>
    <member name="F:Sandbox.UI.LengthUnit.Pixels">
      <summary>
            The length is in pixels.
            </summary>
    </member>
    <member name="F:Sandbox.UI.LengthUnit.Percentage">
      <summary>
            The length is a percentage (0-100) of the parent's length. (typically)
            </summary>
    </member>
    <member name="F:Sandbox.UI.LengthUnit.ViewHeight">
      <summary>
            The length is a percentage (0-100) of the viewport's height.
            </summary>
    </member>
    <member name="F:Sandbox.UI.LengthUnit.ViewWidth">
      <summary>
            The length is a percentage (0-100) of the viewport's width.
            </summary>
    </member>
    <member name="F:Sandbox.UI.LengthUnit.ViewMin">
      <summary>
            The length is a percentage (0-100) of the viewport's smallest side/edge.
            </summary>
    </member>
    <member name="F:Sandbox.UI.LengthUnit.ViewMax">
      <summary>
            The length is a percentage (0-100) of the viewport's largest side/edge.
            </summary>
    </member>
    <member name="F:Sandbox.UI.LengthUnit.Start">
      <summary>
            Start of the parent at the appropriate axis.
            </summary>
    </member>
    <member name="F:Sandbox.UI.LengthUnit.Cover">
      <summary>
            For background images, cover the entire element with the image, stretcing and cropping as necessary.
            </summary>
    </member>
    <member name="F:Sandbox.UI.LengthUnit.Contain">
      <summary>
            For background images, contain the image within the element bounds.
            </summary>
    </member>
    <member name="F:Sandbox.UI.LengthUnit.End">
      <summary>
            End of the parent at the appropriate axis.
            </summary>
    </member>
    <member name="F:Sandbox.UI.LengthUnit.Center">
      <summary>
            In the middle of the parent at the appropriate axis.
            </summary>
    </member>
    <member name="F:Sandbox.UI.LengthUnit.Undefined">
      <summary>
            Similar to CSS 'unset', basically means we don't have a value; should only really be used under certain
            circumstances (e.g. to handle background sizing properly).
            </summary>
    </member>
    <member name="F:Sandbox.UI.LengthUnit.Expression">
      <summary>
            Represents a calc( ... ) expression
            </summary>
    </member>
    <member name="F:Sandbox.UI.LengthUnit.RootEm">
      <summary>
            Font size of the root element.
            </summary>
    </member>
    <member name="F:Sandbox.UI.LengthUnit.Em">
      <summary>
            Font size of the current element.
            </summary>
    </member>
    <member name="M:Sandbox.UI.LengthUnitExtension.IsDynamic(Sandbox.UI.LengthUnit)">
      <summary>
            Determine whether this unit type is dynamic (ie. should be updated regularly) or whether it's constant
            </summary>
    </member>
    <member name="T:Sandbox.UI.Margin">
      <summary>
            Represents a <see cref="T:Sandbox.Rect">Rect</see> where each side is the thickness of an edge/padding/margin/border, rather than positions.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Margin.Width">
      <summary>
            Width of the inner square contained within the margin.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Margin.Height">
      <summary>
            Height of the inner square contained within the margin.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Margin.Left">
      <summary>
            Thickness of the left side margin.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Margin.Top">
      <summary>
            Thickness of the top margin.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Margin.Right">
      <summary>
            Thickness of the right side margin.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Margin.Bottom">
      <summary>
            Thickness of the bottom margin.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Margin.Position">
      <summary>
            Position of the inner top left corder of the margin/border.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Margin.Size">
      <summary>
            Size of the inner square contained within the margin.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Margin.GetEdges(Vector2@,System.Nullable{Sandbox.UI.Length}@,System.Nullable{Sandbox.UI.Length}@,System.Nullable{Sandbox.UI.Length}@,System.Nullable{Sandbox.UI.Length}@)">
      <summary>
            Returns a Rect where left right top bottom describe the size of an edge.
            This is used for things like margin, padding, border size.
            </summary>
    </member>
    <member name="P:Sandbox.UI.Margin.EdgeSize">
      <summary>
            When the Rect describes edges, this returns the total size of the edges in each direction
            </summary>
    </member>
    <member name="M:Sandbox.UI.Margin.EdgeAdd(Sandbox.UI.Margin)">
      <summary>
            Where padding is an edge type rect, will return this rect expanded with those edges.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Margin.EdgeSubtract(Sandbox.UI.Margin)">
      <summary>
            Where padding is an edge type rect, will return this rect expanded with those edges.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Margin.IsNearlyZero(System.Double)">
      <summary>
            Returns true if margin is practically zero
            </summary>
    </member>
    <member name="M:Sandbox.UI.Calc.HasHigherPrecedence(Sandbox.UI.Calc.TokenType,Sandbox.UI.Calc.TokenType)">
      <summary>
            Determine which token has higher precedence over another
            </summary>
    </member>
    <member name="M:Sandbox.UI.Calc.ProcessOperation(System.Collections.Generic.Stack{Sandbox.UI.Calc.TreeNode},Sandbox.UI.Calc.TokenType,System.Single)">
      <summary>
            Process a bunch of tree nodes
            </summary>
    </member>
    <member name="M:Sandbox.UI.Calc.Evaluate(System.String,System.Single)">
      <summary>
            Evaluate a full CSS calc expression and return the calculated value.
            </summary>
    </member>
    <member name="T:Sandbox.UI.CascadingParameterAttribute">
      <summary>
            A panel's property will be inherited from its parent.
            </summary>
    </member>
    <member name="T:Sandbox.UI.IStyleBlock">
      <summary>
            A CSS rule - ie ".chin { width: 100%; height: 100%; }"
            </summary>
    </member>
    <member name="P:Sandbox.UI.IStyleBlock.FileName">
      <summary>
            The filename of the file containing this style block (or null if none)
            </summary>
    </member>
    <member name="P:Sandbox.UI.IStyleBlock.AbsolutePath">
      <summary>
            The absolute on disk filename for this style block (or null if not on disk)
            </summary>
    </member>
    <member name="P:Sandbox.UI.IStyleBlock.FileLine">
      <summary>
            The line in the file containing this style block
            </summary>
    </member>
    <member name="P:Sandbox.UI.IStyleBlock.SelectorStrings">
      <summary>
            A list of selectors
            </summary>
    </member>
    <member name="M:Sandbox.UI.IStyleBlock.GetRawValues">
      <summary>
            Get the list of raw style values
            </summary>
    </member>
    <member name="M:Sandbox.UI.IStyleBlock.SetRawValue(System.String,System.String,System.String)">
      <summary>
            Update a raw style value
            </summary>
    </member>
    <member name="P:Sandbox.UI.IStyleBlock.StyleProperty.Name">
      <summary>
            Name of the property, ie "color" or "width"
            </summary>
    </member>
    <member name="P:Sandbox.UI.IStyleBlock.StyleProperty.Value">
      <summary>
            Current value of the property (which is being rendered)
            </summary>
    </member>
    <member name="P:Sandbox.UI.IStyleBlock.StyleProperty.OriginalValue">
      <summary>
            The value that was loaded from the .scss file
            </summary>
    </member>
    <member name="P:Sandbox.UI.IStyleBlock.StyleProperty.Line">
      <summary>
            The line in the file containing this value
            </summary>
    </member>
    <member name="P:Sandbox.UI.IStyleBlock.StyleProperty.IsValid">
      <summary>
            If parsing this property was successful or failed
            </summary>
    </member>
    <member name="T:Sandbox.UI.PseudoClass">
      <summary>
            List of CSS pseudo-classes used by the styling system for hover, active, etc.
            This acts as a bit-flag.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PseudoClass.None">
      <summary>
            No pseudo-class.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PseudoClass.Unknown">
      <summary>
            Unused.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PseudoClass.Hover">
      <summary>
        <c>:hover</c> - Any element with the mouse cursor hovering over it.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PseudoClass.Active">
      <summary>
        <c>:active</c> - A button that is being pressed down.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PseudoClass.Focus">
      <summary>
        <c>:focus</c> - An element with input focus.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PseudoClass.Intro">
      <summary>
        <c>:intro</c> - Present on all elements for their first frame. Useful to start CSS transitions on creation.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PseudoClass.Outro">
      <summary>
        <c>:outro</c> - The element has been marked for deletion, and will be deleted once all CSS transitions on it has stopped.<br />
            Transitions can be started here to gracefully remove the element visually.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PseudoClass.Empty">
      <summary>
        <c>:empty</c> - Any element that has no children.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PseudoClass.FirstChild">
      <summary>
        <c>:first-child</c> - The element is the first element among a group of sibling elements.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PseudoClass.LastChild">
      <summary>
        <c>:last-child</c> - The element is the last element among a group of sibling elements.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PseudoClass.OnlyChild">
      <summary>
        <c>:only-child</c> - The element is the only child of their parent element.
            </summary>
    </member>
    <member name="T:Sandbox.UI.RenderState">
      <summary>
            Describes panel's position and size for rendering operations.
            </summary>
    </member>
    <member name="P:Sandbox.UI.RenderState.X">
      <summary>
            Position of the panel on the X axis. This can be a negative value!
            </summary>
    </member>
    <member name="P:Sandbox.UI.RenderState.Y">
      <summary>
            Position of the panel on the Y axis. This can be a negative value!
            </summary>
    </member>
    <member name="P:Sandbox.UI.RenderState.Width">
      <summary>
            Width of the panel.
            </summary>
    </member>
    <member name="P:Sandbox.UI.RenderState.Height">
      <summary>
            Height of the panel.
            </summary>
    </member>
    <member name="P:Sandbox.UI.RenderState.RenderOpacity">
      <summary>
            Render Opacity Overrides
            </summary>
    </member>
    <member name="M:Sandbox.UI.RenderState.op_Implicit(Sandbox.UI.RenderState)~Sandbox.Rect">
      <summary>
            Allows easy cast to a <see cref="T:Sandbox.Rect" /> for usage in rendering functions.
            </summary>
    </member>
    <member name="T:Sandbox.UI.StyleSheetAttribute">
      <summary>
            Will automatically apply the named stylesheet to the Panel.
            </summary>
    </member>
    <member name="F:Sandbox.UI.StyleSheetAttribute.Name">
      <summary>
            File name of the style sheet file.
            </summary>
    </member>
    <member name="M:Sandbox.UI.PanelTransform.IsEmpty">
      <summary>
            Returns true if this is empty.
            </summary>
    </member>
    <member name="T:Sandbox.UI.Shadow">
      <summary>
            Shadow style settings
            </summary>
    </member>
    <member name="F:Sandbox.UI.Shadow.OffsetX">
      <summary>
            Shadow offset on the X axis.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Shadow.OffsetY">
      <summary>
            Shadow offset on the Y axis.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Shadow.Blur">
      <summary>
            Amount of blurring for the shadow.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Shadow.Spread">
      <summary>
            Increases the box size by this much before starting shadow blur.
            Box shadows only.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Shadow.Inset">
      <summary>
            Whether or not this shadow is inset.
            Box shadows only.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Shadow.Color">
      <summary>
            Color of the shadow.
            </summary>
    </member>
    <member name="M:Sandbox.UI.Shadow.Scale(System.Single)">
      <summary>
            Scale all variables by given scalar.
            </summary>
      <param name="f">How much to scale the shadow parameters by. 1 is no change, 2 is double the sizes, etc.</param>
      <returns>The scaled shadow.</returns>
    </member>
    <member name="M:Sandbox.UI.Shadow.LerpTo(Sandbox.UI.Shadow,System.Single)">
      <summary>
            Perform linear interpolation between 2 shadows.
            </summary>
      <param name="shadow">The target shadow to morph into.</param>
      <param name="delta">Progress of the transformation. 0 = original shadow, 1 = fully target shadow.</param>
      <returns>The interpolated shadow.</returns>
    </member>
    <member name="T:Sandbox.UI.ShadowList">
      <summary>
            A list of shadows 
            </summary>
    </member>
    <member name="F:Sandbox.UI.ShadowList.IsNone">
      <summary>
            Whether there are no shadows at all.
            </summary>
    </member>
    <member name="M:Sandbox.UI.ShadowList.AddFrom(Sandbox.UI.ShadowList)">
      <summary>
            Copy shadows from another list of shadows.
            </summary>
    </member>
    <member name="M:Sandbox.UI.ShadowList.SetFromLerp(Sandbox.UI.ShadowList,Sandbox.UI.ShadowList,System.Single)">
      <summary>
            Given 2 lists of shadows, perform linear interpolation on both lists and store the result in this list.
            Will work with mismatched shadow counts.
            </summary>
      <param name="a">The first list of shadows.</param>
      <param name="b">The second list of shadows.</param>
      <param name="frac">Fraction for the linear interpolation, in range of [0,1]</param>
      <exception cref="T:System.ArgumentException">Thrown when both inputs are equal.</exception>
    </member>
    <member name="T:Sandbox.UI.OverflowMode">
      <summary>
            Possible values for the "overflow" CSS rule, dictating what to do with content that is outside of a panels bounds.
            </summary>
    </member>
    <member name="F:Sandbox.UI.OverflowMode.Visible">
      <summary>
            Overflowing content is visible at all times.
            </summary>
    </member>
    <member name="F:Sandbox.UI.OverflowMode.Hidden">
      <summary>
            Overflowing contents are hidden at all times.
            </summary>
    </member>
    <member name="F:Sandbox.UI.OverflowMode.Scroll">
      <summary>
            Overflowing contents are hidden, but can be scrolled to.
            </summary>
    </member>
    <member name="T:Sandbox.UI.Align">
      <summary>
            Possible values for <c>align-items</c> CSS property.
            </summary>
    </member>
    <member name="T:Sandbox.UI.PositionMode">
      <summary>
            Possible values for <c>position</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PositionMode.Static">
      <summary>
            Default, the <c>top</c>, <c>right</c>, <c>bottom</c>, <c>left</c>, and <c>z-index</c> properties have no effect.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PositionMode.Relative">
      <summary>
            Enables <c>top</c>, <c>right</c>, <c>bottom</c>, <c>left</c>, and <c>z-index</c> to offset the element from its
            would-be position with <see cref="F:Sandbox.UI.PositionMode.Static" />.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PositionMode.Absolute">
      <summary>
            Same as <see cref="F:Sandbox.UI.PositionMode.Relative" />, but the elements size does not affect other elements at all.
            </summary>
    </member>
    <member name="T:Sandbox.UI.FlexDirection">
      <summary>
            Possible values for <c>flex-direction</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.FlexDirection.Column">
      <summary>
            A column, align items from top to bottom.
            </summary>
    </member>
    <member name="F:Sandbox.UI.FlexDirection.ColumnReverse">
      <summary>
            A reverse column, align items from bottom to top.
            </summary>
    </member>
    <member name="F:Sandbox.UI.FlexDirection.Row">
      <summary>
            A row, align items from left to right.
            </summary>
    </member>
    <member name="F:Sandbox.UI.FlexDirection.RowReverse">
      <summary>
            A reverse row, align items from right to left.
            </summary>
    </member>
    <member name="T:Sandbox.UI.Justify">
      <summary>
            Possible values for <c>justify-content</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Justify.FlexStart">
      <summary>
            [OOOO            ]
            </summary>
    </member>
    <member name="F:Sandbox.UI.Justify.Center">
      <summary>
            [      OOOO      ]
            </summary>
    </member>
    <member name="F:Sandbox.UI.Justify.FlexEnd">
      <summary>
            [            OOOO]
            </summary>
    </member>
    <member name="F:Sandbox.UI.Justify.SpaceBetween">
      <summary>
            [O    O    O    O]
            </summary>
    </member>
    <member name="F:Sandbox.UI.Justify.SpaceAround">
      <summary>
            [ O   O   O   O ]
            </summary>
    </member>
    <member name="F:Sandbox.UI.Justify.SpaceEvenly">
      <summary>
            [  O  O  O  O  ]
            </summary>
    </member>
    <member name="T:Sandbox.UI.DisplayMode">
      <summary>
            Possible values for <c>display</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.DisplayMode.Flex">
      <summary>
            Display via CSS flexbox.
            </summary>
    </member>
    <member name="F:Sandbox.UI.DisplayMode.None">
      <summary>
            Do not display at all.
            </summary>
    </member>
    <member name="F:Sandbox.UI.DisplayMode.Contents">
      <summary>
            Causes an element's children to appear as if they were direct children of the element's parent, ignoring the element itself. This can be useful when a wrapper element should be ignored.
            </summary>
    </member>
    <member name="T:Sandbox.UI.PointerEvents">
      <summary>
            Possible values for <c>pointer-events</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PointerEvents.All">
      <summary>
            Accept all events in all cases.
            </summary>
    </member>
    <member name="F:Sandbox.UI.PointerEvents.None">
      <summary>
            Do not accept any pointer events.
            </summary>
    </member>
    <member name="T:Sandbox.UI.Wrap">
      <summary>
            Possible values for <c>flex-wrap</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Wrap.NoWrap">
      <summary>
            Elements will be laid out in a single line.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Wrap.Wrap">
      <summary>
            Elements will be moved to subsequent lines on overflow.
            </summary>
    </member>
    <member name="F:Sandbox.UI.Wrap.WrapReverse">
      <summary>
            Same as <see cref="F:Sandbox.UI.Wrap.Wrap" />, but the line order will be reversed, i.e. if one item overflows the width,
            it will be placed on the first line, and the others will be placed on the second line.
            </summary>
    </member>
    <member name="T:Sandbox.UI.TextAlign">
      <summary>
            Possible values for <c>text-align</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextAlign.Auto">
      <summary>
            Unused.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextAlign.Left">
      <summary>
            Align the text to the left.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextAlign.Center">
      <summary>
            Align the text to the horizontal center.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextAlign.Right">
      <summary>
            Align the text to the right.
            </summary>
    </member>
    <member name="T:Sandbox.UI.TextOverflow">
      <summary>
            Possible values for <c>text-overflow</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextOverflow.None">
      <summary>
            Display overflown text.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextOverflow.Ellipsis">
      <summary>
            Replace part of the text near the overflow point with ellipsis, and cut off the rest.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextOverflow.Clip">
      <summary>
            Visually cut off the overflowing text.
            </summary>
    </member>
    <member name="T:Sandbox.UI.WordBreak">
      <summary>
            Possible values for <c>word-break</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.WordBreak.Normal">
      <summary>
            Break overflowing lines at the closest word.
            </summary>
    </member>
    <member name="F:Sandbox.UI.WordBreak.BreakAll">
      <summary>
            Break overflowing lines at the closest character.
            </summary>
    </member>
    <member name="T:Sandbox.UI.TextTransform">
      <summary>
            Possible values for <c>text-transform</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextTransform.None">
      <summary>
            No change, default.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextTransform.Capitalize">
      <summary>
            Capitalize each word.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextTransform.Uppercase">
      <summary>
            Make every character capital.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextTransform.Lowercase">
      <summary>
            Make every character lowercase.
            </summary>
    </member>
    <member name="T:Sandbox.UI.TextSkipInk">
      <summary>
            Possible values for <c>text-decoration-skip-ink</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextSkipInk.All">
      <summary>
            Don't overlap any glyphs.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextSkipInk.None">
      <summary>
            Overlap all glyphs.
            </summary>
    </member>
    <member name="T:Sandbox.UI.TextDecorationStyle">
      <summary>
            Possible values for <c>text-decoration-style</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextDecorationStyle.Solid">
      <summary>
            Draw a single solid line.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextDecorationStyle.Double">
      <summary>
            Draw two solid lines.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextDecorationStyle.Dotted">
      <summary>
            Draw a dotted line.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextDecorationStyle.Dashed">
      <summary>
            Draw a dashed line.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextDecorationStyle.Wavy">
      <summary>
            Draw a wavy/squiggly line.
            </summary>
    </member>
    <member name="T:Sandbox.UI.TextDecoration">
      <summary>
            Possible values for <c>text-decoration</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextDecoration.None">
      <summary>
            No decoration, default.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextDecoration.Underline">
      <summary>
            Underline the text.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextDecoration.LineThrough">
      <summary>
            Strike through, a line in the middle of the text.
            </summary>
    </member>
    <member name="F:Sandbox.UI.TextDecoration.Overline">
      <summary>
            A line above the text.
            </summary>
    </member>
    <member name="T:Sandbox.UI.WhiteSpace">
      <summary>
            Possible values for <c>white-space</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.WhiteSpace.Normal">
      <summary>
            Sequences of white spaces are collapsed, text will wrap when necessary.  Default.
            </summary>
    </member>
    <member name="F:Sandbox.UI.WhiteSpace.NoWrap">
      <summary>
            Sequences of white spaces are collapsed and linebreaks are suppressed.
            </summary>
    </member>
    <member name="F:Sandbox.UI.WhiteSpace.PreLine">
      <summary>
            Sequences of white spaces are collapsed, text will wrap when necessary, linebreaks are preserved.
            </summary>
    </member>
    <member name="F:Sandbox.UI.WhiteSpace.Pre">
      <summary>
            Sequences of white space are preserved, lines are only broken at newline characters in the source.
            </summary>
    </member>
    <member name="T:Sandbox.UI.FontStyle">
      <summary>
            Possible values for <c>font-style</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.FontStyle.None">
      <summary>
            No font styling, default.
            </summary>
    </member>
    <member name="F:Sandbox.UI.FontStyle.Italic">
      <summary>
            Italic/cursive slanted text.
            </summary>
    </member>
    <member name="F:Sandbox.UI.FontStyle.Oblique">
      <summary>
            Non cursive slanted text, if the font supports it, italic otherwise.
            </summary>
    </member>
    <member name="T:Sandbox.UI.ImageRendering">
      <summary>
            Possible values for <c>image-rendering</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.ImageRendering.Anisotropic">
      <summary>
        <a href="https://en.wikipedia.org/wiki/Anisotropic_filtering">Anisotropic</a> filtering.
            </summary>
    </member>
    <member name="F:Sandbox.UI.ImageRendering.Bilinear">
      <summary>
        <a href="https://en.wikipedia.org/wiki/Bilinear_interpolation">Anisotropic</a> interpolation/filtering.
            </summary>
    </member>
    <member name="F:Sandbox.UI.ImageRendering.Trilinear">
      <summary>
        <a href="https://en.wikipedia.org/wiki/Trilinear_filtering">Trilinear</a> filtering.
            </summary>
    </member>
    <member name="F:Sandbox.UI.ImageRendering.Point">
      <summary>
            No filtering.
            </summary>
    </member>
    <member name="T:Sandbox.UI.BorderImageFill">
      <summary>
            State of <c>fill</c> setting of <c>border-image-slice</c> (<c>border-image</c>) CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.BorderImageFill.Unfilled">
      <summary>
            Do not fill the middle of the container with the border's background image.
            </summary>
    </member>
    <member name="F:Sandbox.UI.BorderImageFill.Filled">
      <summary>
            Do fill the middle of the container with the border's background image.
            </summary>
    </member>
    <member name="T:Sandbox.UI.BorderImageRepeat">
      <summary>
            Possible values for <c>border-image-repeat</c> (<c>border-image</c>) CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.BorderImageRepeat.Stretch">
      <summary>
            The source image's edge regions are stretched to fill the gap between each border.
            </summary>
    </member>
    <member name="F:Sandbox.UI.BorderImageRepeat.Round">
      <summary>
            The source image's edge regions are tiled (repeated) to fill the gap between each border. Tiles may be stretched to achieve the proper fit.
            </summary>
    </member>
    <member name="T:Sandbox.UI.BackgroundRepeat">
      <summary>
            Possible values for <c>background-repeat</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.BackgroundRepeat.Repeat">
      <summary>
            Repeat the background image on X and Y axises.
            </summary>
    </member>
    <member name="F:Sandbox.UI.BackgroundRepeat.RepeatX">
      <summary>
            Repeat the background image on X axis.
            </summary>
    </member>
    <member name="F:Sandbox.UI.BackgroundRepeat.RepeatY">
      <summary>
            Repeat the background image on Y axis.
            </summary>
    </member>
    <member name="F:Sandbox.UI.BackgroundRepeat.NoRepeat">
      <summary>
            Do not repeat the background image.
            </summary>
    </member>
    <member name="F:Sandbox.UI.BackgroundRepeat.Clamp">
      <summary>
            Stretch the edges of the image to fill empty space.
            </summary>
    </member>
    <member name="T:Sandbox.UI.MaskMode">
      <summary>
            Possible values for <c>mask-mode</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.MaskMode.MatchSource">
      <summary>
            If the mask-image property is of type 'mask-source', the luminance values of the mask layer image should be used as the mask values.
            If it is of type 'image', the alpha values of the mask layer image should be used as the mask values.
            </summary>
    </member>
    <member name="F:Sandbox.UI.MaskMode.Alpha">
      <summary>
            The alpha channel values of the mask layer image should be used as the mask values.
            </summary>
    </member>
    <member name="F:Sandbox.UI.MaskMode.Luminance">
      <summary>
            The luminance values of the mask layer image should be used as the mask values.
            </summary>
    </member>
    <member name="T:Sandbox.UI.MaskScope">
      <summary>
            Possible values for <c>mask-scope</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.MaskScope.Default">
      <summary>
            Standard mask.
            </summary>
    </member>
    <member name="F:Sandbox.UI.MaskScope.Filter">
      <summary>
            Mask used for filters.
            </summary>
    </member>
    <member name="T:Sandbox.UI.FontSmooth">
      <summary>
            Possible values for <c>font-smooth</c> CSS property.
            </summary>
    </member>
    <member name="F:Sandbox.UI.FontSmooth.Auto">
      <summary>
            Let us decide (we'll anti-alias where available)
            </summary>
    </member>
    <member name="F:Sandbox.UI.FontSmooth.Never">
      <summary>
            Turn font smoothing off
            </summary>
    </member>
    <member name="F:Sandbox.UI.FontSmooth.Always">
      <summary>
            Always anti-alias
            </summary>
    </member>
    <member name="F:Sandbox.UI.ObjectFit.Fill">
      <summary>
            The content is sized to fill the element's content box. This does not preserve aspect ratio.
            </summary>
    </member>
    <member name="F:Sandbox.UI.ObjectFit.Contain">
      <summary>
            The content is scaled to maintain its aspect ratio while fitting within the element's content box
            </summary>
    </member>
    <member name="F:Sandbox.UI.ObjectFit.Cover">
      <summary>
            The content is sized to maintain its aspect ratio while filling the element's entire content box
            </summary>
    </member>
    <member name="F:Sandbox.UI.ObjectFit.None">
      <summary>
            The content is not resized
            </summary>
    </member>
    <member name="T:Sandbox.Localization.Languages">
      <summary>
            A list of supported languages and metadata surrounding them
            </summary>
    </member>
    <member name="P:Sandbox.Localization.Languages.List">
      <summary>
            Enumerate all languages, in no particular order
            </summary>
    </member>
    <member name="M:Sandbox.Localization.Languages.Find(System.String)">
      <summary>
            Find a language by shortname, or full name
            </summary>
    </member>
    <member name="P:Sandbox.Localization.LanguageInformation.Title">
      <summary>
            Title of the localization language.
            </summary>
    </member>
    <member name="P:Sandbox.Localization.LanguageInformation.Abbreviation">
      <summary>
            ISO 639-1 code of the language, with optional ISO 3166-1 alpha-2 country specifiers. (for example "en-GB" for British English)
            </summary>
    </member>
    <member name="P:Sandbox.Localization.LanguageInformation.Parent">
      <summary>
            If set, the <see cref="P:Sandbox.Localization.LanguageInformation.Abbreviation" /> of the parent language. For example, Pirate English is based on English.
            </summary>
    </member>
    <member name="P:Sandbox.Localization.LanguageInformation.RightToLeft">
      <summary>
            Whether the language is typed right to left, such as the Arabic language.
            </summary>
    </member>
    <member name="T:Sandbox.Localization.Phrase">
      <summary>
            A translated string. ie "Hello World".
            It might also have variables, ie "Hello {PlayerName}".
            Todo support for conditionals and plurals
            </summary>
    </member>
    <member name="M:Sandbox.Localization.Phrase.#ctor(System.String)">
      <summary>
            Create a SmartString from a phrase.
            </summary>
    </member>
    <member name="M:Sandbox.Localization.Phrase.Render">
      <summary>
            Render with no data - basically just returns Value
            </summary>
    </member>
    <member name="M:Sandbox.Localization.Phrase.Render(System.Collections.Generic.Dictionary{System.String,System.Object})">
      <summary>
            Render with variables
            </summary>
    </member>
    <member name="T:Sandbox.Localization.PhraseCollection">
      <summary>
            Holds a bunch of localized phrases
            </summary>
    </member>
    <member name="M:Sandbox.Localization.PhraseCollection.Set(System.String,System.String)">
      <summary>
            Add a phrase to the language
            </summary>
    </member>
    <member name="M:Sandbox.Localization.PhraseCollection.GetPhrase(System.String)">
      <summary>
            Get a simple phrase from the language
            </summary>
    </member>
    <member name="M:Sandbox.Localization.PhraseCollection.GetPhrase(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
      <summary>
            Get a simple phrase from the language
            </summary>
    </member>
    <member name="T:Sandbox.Curve">
      <summary>
            Describes a curve, which can have multiple key frames.
            </summary>
    </member>
    <member name="P:Sandbox.Curve.TimeRange">
      <summary>
            The range of this curve. This affects looping.
            </summary>
    </member>
    <member name="P:Sandbox.Curve.ValueRange">
      <summary>
            The value range. This should affect nothing but what it looks like in the editor.
            </summary>
    </member>
    <member name="F:Sandbox.Curve.Linear">
      <summary>
            A curve that linearly interpolates from 0 to 1
            </summary>
    </member>
    <member name="F:Sandbox.Curve.Ease">
      <summary>
            A curve that eases from 0 to 1
            </summary>
    </member>
    <member name="F:Sandbox.Curve.EaseIn">
      <summary>
            A curve that eases in from 0 to 1
            </summary>
    </member>
    <member name="F:Sandbox.Curve.EaseOut">
      <summary>
            A curve that eases out from 0 to 1
            </summary>
    </member>
    <member name="M:Sandbox.Curve.op_Implicit(System.Single)~Sandbox.Curve">
      <summary>
            A single float creates a flat curve
            </summary>
    </member>
    <member name="M:Sandbox.Curve.WithFrames(System.Collections.Immutable.ImmutableList{Sandbox.Curve.Frame})">
      <summary>
            Make a copy of this curve with changed keyframes
            </summary>
    </member>
    <member name="M:Sandbox.Curve.WithFrames(System.Collections.Immutable.ImmutableArray{Sandbox.Curve.Frame})">
      <summary>
            Make a copy of this curve with changed keyframes
            </summary>
    </member>
    <member name="M:Sandbox.Curve.WithFrames(System.Collections.Generic.IEnumerable{Sandbox.Curve.Frame})">
      <summary>
            Make a copy of this curve with changed keyframes
            </summary>
    </member>
    <member name="M:Sandbox.Curve.Reverse">
      <summary>
            Make a copy of this curve that is reversed (If input eases from 0 to 1 then output will ease from 1 to 0)
            </summary>
    </member>
    <member name="T:Sandbox.Curve.Frame">
      <summary>
            Keyframes times and values should range between 0 and 1
            </summary>
    </member>
    <member name="P:Sandbox.Curve.Frame.Time">
      <summary>
            The delta position on the time line (0-1)
            </summary>
    </member>
    <member name="P:Sandbox.Curve.Frame.Value">
      <summary>
            The delta position on the value line (0-1)
            </summary>
    </member>
    <member name="P:Sandbox.Curve.Frame.In">
      <summary>
            This is the slope of entry, formula is something like tan( angle )
            </summary>
    </member>
    <member name="P:Sandbox.Curve.Frame.Out">
      <summary>
            This is the slope of exit, formula is something like tan( angle )
            </summary>
    </member>
    <member name="P:Sandbox.Curve.Frame.Mode">
      <summary>
            How the line should behave when entering/leaving this frame
            </summary>
    </member>
    <member name="T:Sandbox.Curve.HandleMode">
      <summary>
            Describes how the line should behave when entering/leaving a frame
            </summary>
    </member>
    <member name="F:Sandbox.Curve.HandleMode.Mirrored">
      <summary>
            The In and Out are user set, but are joined (mirrored)
            </summary>
    </member>
    <member name="F:Sandbox.Curve.HandleMode.Split">
      <summary>
            The In and Out are user set and operate independently
            </summary>
    </member>
    <member name="F:Sandbox.Curve.HandleMode.Flat">
      <summary>
            Curves are generated automatically
            </summary>
    </member>
    <member name="F:Sandbox.Curve.HandleMode.Linear">
      <summary>
            No curves, linear interpolation from this handle to the next
            </summary>
    </member>
    <member name="F:Sandbox.Curve.HandleMode.Stepped">
      <summary>
            No interpolation use raw values
            </summary>
    </member>
    <member name="F:Sandbox.Curve.Frames">
      <summary>
            A list of keyframes or points on the curve.
            </summary>
    </member>
    <member name="P:Sandbox.Curve.Length">
      <summary>
            Amount of key frames or points on the curve.
            </summary>
    </member>
    <member name="M:Sandbox.Curve.AddPoint(System.Single,System.Single)">
      <summary>
            Add a new keyframe at given position to this curve.
            </summary>
      <param name="x">Position of the keyframe on the X axis.</param>
      <param name="y">Position of the keyframe on the Y axis.</param>
      <returns>The position of newly added keyframe in the <see cref="F:Sandbox.Curve.Frames" /> list.</returns>
    </member>
    <member name="M:Sandbox.Curve.AddPoint(Sandbox.Curve.Frame@)">
      <summary>
            Add given keyframe to this curve.
            </summary>
      <param name="keyframe">The keyframe to add.</param>
      <returns>The position of newly added keyframe in the <see cref="F:Sandbox.Curve.Frames" /> list.</returns>
    </member>
    <member name="M:Sandbox.Curve.RemoveAtTime(System.Single,System.Single)">
      <summary>
            Remove all of the frames at the current time
            </summary>
    </member>
    <member name="M:Sandbox.Curve.Sort">
      <summary>
            Make sure we're all sorted by time
            </summary>
    </member>
    <member name="M:Sandbox.Curve.AddOrReplacePoint(Sandbox.Curve.Frame@)">
      <summary>
            Add given keyframe to this curve.
            </summary>
      <returns>True if we added a new point. False if we just edited an existing point.</returns>
    </member>
    <member name="M:Sandbox.Curve.GetSurroundingFrames(System.Single)">
      <summary>
            Given a time, get the keyframes on either side of it, along with the delta of where we are between
            </summary>
    </member>
    <member name="M:Sandbox.Curve.Evaluate(System.Single,System.Boolean)">
      <summary>
            Returns the value on the curve at given time position.
            </summary>
      <param name="time">The time point (x axis) at which </param>
      <param name="angles">Is this an angle?</param>
      <returns>The absolute value at given time. (y axis)</returns>
    </member>
    <member name="M:Sandbox.Curve.Evaluate(System.Single)">
      <summary>
            Returns the value on the curve at given time position.
            </summary>
      <param name="time">The time point (x axis) at which </param>
      <returns>The absolute value at given time. (y axis)</returns>
    </member>
    <member name="M:Sandbox.Curve.EvaluateDelta(System.Single)">
      <summary>
            Like evaluate but takes a normalized time between 0 and 1 and returns a normalized value between 0 and 1
            </summary>
    </member>
    <member name="M:Sandbox.Curve.EvaluateDelta(System.Single,System.Boolean)">
      <summary>
            Like evaluate but takes a normalized time between 0 and 1 and returns a normalized value between 0 and 1
            </summary>
    </member>
    <member name="M:Sandbox.Curve.Fix">
      <summary>
            If the curve is broken in some way, we can fix it here.
            Ensures correct time and value ranges, and that the curve has at least one point.
            </summary>
    </member>
    <member name="T:Sandbox.CurveRange">
      <summary>
            Two curves
            </summary>
    </member>
    <member name="T:Sandbox.Frustum">
      <summary>
            Represents a <a href="https://en.wikipedia.org/wiki/Frustum">frustum</a>.
            </summary>
    </member>
    <member name="F:Sandbox.Frustum.RightPlane">
      <summary>
            Right plane of the frustum, pointing inwards.
            </summary>
    </member>
    <member name="F:Sandbox.Frustum.LeftPlane">
      <summary>
            Left plane of the frustum, pointing inwards.
            </summary>
    </member>
    <member name="F:Sandbox.Frustum.TopPlane">
      <summary>
            Top plane of the frustum, pointing inwards.
            </summary>
    </member>
    <member name="F:Sandbox.Frustum.BottomPlane">
      <summary>
            Bottom plane of the frustum, pointing inwards.
            </summary>
    </member>
    <member name="F:Sandbox.Frustum.NearPlane">
      <summary>
            Near plane of the frustum, pointing inwards.
            </summary>
    </member>
    <member name="F:Sandbox.Frustum.FarPlane">
      <summary>
            Far plane of the frustum, pointing inwards.
            </summary>
    </member>
    <member name="M:Sandbox.Frustum.GetCorner(System.Int32)">
      <summary>
            Returns the corner point of one of the 8 corners.
            This may return null if i is &gt; 7 or the frustum is invalid.
            </summary>
    </member>
    <member name="M:Sandbox.Frustum.GetBBox">
      <summary>
            Returns the AABB of this frustum.
            </summary>
    </member>
    <member name="M:Sandbox.Frustum.IsInside(Vector3@)">
      <summary>
            Returns whether the given point is inside this frustum.
            </summary>
    </member>
    <member name="M:Sandbox.Frustum.IsInside(BBox@,System.Boolean)">
      <summary>
            Returns whether given AABB is inside this frustum.
            </summary>
      <param name="box">The AABB to test.</param>
      <param name="partially">Whether test for partial intersection, or complete encompassing of the AABB within this frustum.</param>
    </member>
    <member name="M:Sandbox.Frustum.FromCorners(Ray@,Ray@,Ray@,Ray@,System.Single,System.Single)">
      <summary>
            Create a frustum from four corner rays. These rays commonly come from SceneCamera.GetRay.
            </summary>
    </member>
    <member name="T:Sandbox.Gradient">
      <summary>
            Describes a gradient between multiple colors
            </summary>
    </member>
    <member name="P:Sandbox.Gradient.Blending">
      <summary>
            The blend mode
            </summary>
    </member>
    <member name="P:Sandbox.Gradient.Colors">
      <summary>
            A list of color stops, which should be ordered by time
            </summary>
    </member>
    <member name="P:Sandbox.Gradient.Alphas">
      <summary>
            A list of color stops, which should be ordered by time
            </summary>
    </member>
    <member name="M:Sandbox.Gradient.op_Implicit(Color)~Sandbox.Gradient">
      <summary>
            A single float creates a flat color
            </summary>
    </member>
    <member name="M:Sandbox.Gradient.WithFrames(System.Collections.Immutable.ImmutableList{Sandbox.Gradient.ColorFrame})">
      <summary>
            Make a copy of this with changed keyframes
            </summary>
    </member>
    <member name="T:Sandbox.Gradient.ColorFrame">
      <summary>
            Keyframes times and values should range between 0 and 1
            </summary>
    </member>
    <member name="T:Sandbox.Gradient.AlphaFrame">
      <summary>
            Keyframes times and values should range between 0 and 1
            </summary>
    </member>
    <member name="M:Sandbox.Gradient.AddColor(System.Single,Color@)">
      <summary>
            Add a color position
            </summary>
    </member>
    <member name="M:Sandbox.Gradient.AddAlpha(System.Single,System.Single)">
      <summary>
            Add an alpha position
            </summary>
    </member>
    <member name="M:Sandbox.Gradient.FixOrder">
      <summary>
            If the lists aren't in time order for some reason, this will fix them. This should really 
            just be called when serializing, and in every other situation we should assume they're
            okay.
            </summary>
    </member>
    <member name="M:Sandbox.Gradient.IsOrderedIncorrectly">
      <summary>
            Returns true if the lists are not in time order
            </summary>
    </member>
    <member name="M:Sandbox.Gradient.AddColor(Sandbox.Gradient.ColorFrame@)">
      <summary>
            Add given keyframe to this curve.
            </summary>
      <param name="keyframe">The keyframe to add.</param>
      <returns>The position of newly added keyframe in the <see cref="P:Sandbox.Gradient.Colors" /> list.</returns>
    </member>
    <member name="M:Sandbox.Gradient.GetSurroundingColors(System.Single)">
      <summary>
            Given a time, get the keyframes on either side of it, along with the delta of where we are between
            </summary>
    </member>
    <member name="M:Sandbox.Gradient.GetSurroundingAlphas(System.Single)">
      <summary>
            Given a time, get the keyframes on either side of it, along with the delta of where we are between
            </summary>
    </member>
    <member name="T:Sandbox.Gradient.BlendMode">
      <summary>
            Describes how the line should behave when entering/leaving a frame
            </summary>
    </member>
    <member name="F:Sandbox.Gradient.BlendMode.Linear">
      <summary>
            Linear interoplation between
            </summary>
    </member>
    <member name="F:Sandbox.Gradient.BlendMode.Stepped">
      <summary>
            No interpolation use last raw value
            </summary>
    </member>
    <member name="M:Sandbox.Gradient.Evaluate(System.Single)">
      <summary>
            Evaluate the blend using the time, which is generally between 0 and 1
            </summary>
    </member>
    <member name="T:Sandbox.Interpolation.IInterpolator`1">
      <summary>
            Implement this on a type to handle interpolation between two values.
            </summary>
      <typeparam name="T" />
    </member>
    <member name="T:Sandbox.Interpolation.InterpolationBuffer`1">
      <summary>
            Contains information in a buffer for interpolation.
            </summary>
    </member>
    <member name="P:Sandbox.Interpolation.InterpolationBuffer`1.IsEmpty">
      <summary>
            Is the buffer currently empty?
            </summary>
    </member>
    <member name="P:Sandbox.Interpolation.InterpolationBuffer`1.Count">
      <summary>
            How many entries are in the buffer?
            </summary>
    </member>
    <member name="P:Sandbox.Interpolation.InterpolationBuffer`1.First">
      <summary>
            The first entry in the buffer.
            </summary>
    </member>
    <member name="P:Sandbox.Interpolation.InterpolationBuffer`1.Last">
      <summary>
            The last entry in the buffer.
            </summary>
    </member>
    <member name="M:Sandbox.Interpolation.InterpolationBuffer`1.Query(System.Single,System.Single)">
      <summary>
            Query the interpolation buffer for a specific time.
            </summary>
      <param name="now">The time you want to query (usually now.)</param>
      <param name="interpolationTime">The time it should take to interpolate between each state.</param>
      <exception cref="T:System.InvalidOperationException">Throws if there are no snapshots in the interpolation buffer.</exception>
    </member>
    <member name="M:Sandbox.Interpolation.InterpolationBuffer`1.Add(`0,System.Single)">
      <summary>
            Add a new state to the buffer at the specified time.
            </summary>
    </member>
    <member name="M:Sandbox.Interpolation.InterpolationBuffer`1.Clear">
      <summary>
            Clear the interpolation buffer.
            </summary>
    </member>
    <member name="M:Sandbox.Interpolation.InterpolationBuffer`1.CullOlderThan(System.Single)">
      <summary>
            Cull entries in the buffer older than the specified time.
            </summary>
    </member>
    <member name="T:Sandbox.Interpolation.RotationState">
      <summary>
            State information about a <see cref="F:Sandbox.Interpolation.RotationState.Rotation" />. Used for interpolation buffer.
            </summary>
    </member>
    <member name="T:Sandbox.Interpolation.TransformState">
      <summary>
            State information about a transform. Used for interpolation buffer.
            </summary>
    </member>
    <member name="T:Sandbox.Interpolation.Vector3State">
      <summary>
            State information about a <see cref="T:Vector3" />. Used for interpolation buffer.
            </summary>
    </member>
    <member name="M:Sandbox.Line2D.Clip(Sandbox.Rect)">
      <summary>
            Returns this line, clamped within a rectangle. Null if line is fully
            outside the rectangle.
            </summary>
    </member>
    <member name="M:Sandbox.Line2D.Clip(Vector2,System.Single)">
      <summary>
            Returns this line, clamped on the positive side of a half-plane. Null if
            line is fully clipped.
            </summary>
    </member>
    <member name="M:Sandbox.Line2D.Remap(Sandbox.Rect,Sandbox.Rect)">
      <summary>
            Remaps from one range to another.
            </summary>
    </member>
    <member name="M:Sandbox.Line2D.RemapClip(Sandbox.Rect,Sandbox.Rect)">
      <summary>
            Remaps from one range to another, clipping along the way.
            </summary>
    </member>
    <member name="M:Sandbox.Line2D.ClosestPoint(Vector2)">
      <summary>
            Returns closest point on this line to the given point.
            </summary>
    </member>
    <member name="M:Sandbox.Line2D.Distance(Vector2)">
      <summary>
            Returns closest distance from this line to given point.
            </summary>
    </member>
    <member name="M:Sandbox.Line2D.Distance(Vector2,Vector2@)">
      <summary>
            Returns closest distance from this line to given point.
            </summary>
    </member>
    <member name="M:Sandbox.Line2D.WithLength(System.Single,System.Single)">
      <summary>
            Returns a line along the same tangent with the given length.
            </summary>
    </member>
    <member name="T:Sandbox.Plane">
      <summary>
            Represents a plane.
            </summary>
    </member>
    <member name="F:Sandbox.Plane.Normal">
      <summary>
            The direction of the plane.
            </summary>
    </member>
    <member name="F:Sandbox.Plane.Distance">
      <summary>
            Distance of the plane from world origin in the direction given by <see cref="F:Sandbox.Plane.Normal" />.
            </summary>
    </member>
    <member name="M:Sandbox.Plane.#ctor(Vector3@,Vector3@,Vector3@)">
      <summary>
            Creates a new plane from 3 given positions.
            </summary>
      <param name="origin">Origin of the plane.</param>
      <param name="posA">A position to calculate a normal with.</param>
      <param name="posB">Another position to calculate a normal with.</param>
    </member>
    <member name="P:Sandbox.Plane.Origin">
      <summary>
            Origin position of the plane, basically a vector <see cref="F:Sandbox.Plane.Distance" /> away from world origin in the direction given by <see cref="F:Sandbox.Plane.Normal" />.
            </summary>
    </member>
    <member name="P:Sandbox.Plane.Position">
      <summary>
            Origin position of the plane, basically a vector <see cref="F:Sandbox.Plane.Distance" /> away from world origin in the direction given by <see cref="F:Sandbox.Plane.Normal" />.
            </summary>
    </member>
    <member name="M:Sandbox.Plane.GetDistance(Vector3@)">
      <summary>
            Returns the distance from this plane to given point.
            </summary>
    </member>
    <member name="M:Sandbox.Plane.IsInFront(Vector3)">
      <summary>
            Returns true if given point is on the side of the plane where its normal is pointing.
            </summary>
    </member>
    <member name="M:Sandbox.Plane.IsInFront(BBox,System.Boolean)">
      <summary>
            Returns true if given bounding box is on the side of the plane where its normal is pointing.
            </summary>
    </member>
    <member name="M:Sandbox.Plane.SnapToPlane(Vector3@)">
      <summary>
            Returns closest point on the plane to given point.
            </summary>
    </member>
    <member name="M:Sandbox.Plane.TryTrace(Ray@,Vector3@,System.Boolean,System.Double)">
      <summary>
            Trace a Ray against this plane
            </summary>
    </member>
    <member name="M:Sandbox.Plane.Trace(Ray@,System.Boolean,System.Double)">
      <summary>
            Trace a Ray against this plane
            </summary>
      <param name="ray">The origin and direction to trace from</param>
      <param name="twosided">If true we'll trace against the underside of the plane too.</param>
      <param name="maxDistance">The maximum distance from the ray origin to trace</param>
      <returns>The hit position on the ray. Or null if we didn't hit.</returns>
    </member>
    <member name="M:Sandbox.Plane.GetIntersection(Sandbox.Plane@,Sandbox.Plane@,Sandbox.Plane@)">
      <summary>
            Gets the intersecting point of the three planes if it exists.
            If the planes don't all intersect will return null.
            </summary>
    </member>
    <member name="M:Sandbox.Plane.IntersectLine(Line)">
      <summary>
            Gets the intersecting point of a line segment.
            </summary>
    </member>
    <member name="M:Sandbox.Plane.IntersectLine(Vector3,Vector3)">
      <summary>
            Gets the intersecting point of a line segment.
            </summary>
    </member>
    <member name="T:Sandbox.Rect">
      <summary>
            Represents a rectangle.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.#ctor(System.Single@,System.Single@,System.Single@,System.Single@)">
      <summary>
            Initialize a Rect at given position and with given size.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.#ctor(Vector2@,Vector2@)">
      <summary>
            Initialize a Rect at given position and with given size.
            </summary>
    </member>
    <member name="P:Sandbox.Rect.Width">
      <summary>
            Width of the rect.
            </summary>
    </member>
    <member name="P:Sandbox.Rect.Height">
      <summary>
            Height of the rect.
            </summary>
    </member>
    <member name="P:Sandbox.Rect.Left">
      <summary>
            Position of rect's left edge relative to its parent, can also be interpreted as its position on the X axis.
            </summary>
    </member>
    <member name="P:Sandbox.Rect.Top">
      <summary>
            Position of rect's top edge relative to its parent, can also be interpreted as its position on the Y axis.
            </summary>
    </member>
    <member name="P:Sandbox.Rect.Right">
      <summary>
            Position of rect's right edge relative to its parent.
            </summary>
    </member>
    <member name="P:Sandbox.Rect.Bottom">
      <summary>
            Position of rect's bottom edge relative to its parent.
            </summary>
    </member>
    <member name="P:Sandbox.Rect.Position">
      <summary>
            Position of this rect.
            </summary>
    </member>
    <member name="P:Sandbox.Rect.Center">
      <summary>
            Center of this rect.
            </summary>
    </member>
    <member name="P:Sandbox.Rect.Size">
      <summary>
            Size of this rect.
            </summary>
    </member>
    <member name="P:Sandbox.Rect.WithoutPosition">
      <summary>
            Returns this rect with position set to 0 on both axes.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.IsInside(Sandbox.Rect@,System.Boolean)">
      <summary>
            Return true if the passed rect is partially or fully inside this rect.
            </summary>
      <param name="rect">The passed rect to test.</param>
      <param name="fullyInside">
        <see langword="true" /> to test if the given rect is completely inside this rect. <see langword="false" /> to test for an intersection.</param>
    </member>
    <member name="M:Sandbox.Rect.IsInside(Vector2@)">
      <summary>
            Return true if the passed point is inside this rect.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.Shrink(System.Single@,System.Single@,System.Single@,System.Single@)">
      <summary>
            Returns a Rect shrunk in every direction by given values.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.Shrink(Sandbox.UI.Margin@)">
      <summary>
            Returns a Rect shrunk in every direction by <see cref="T:Sandbox.UI.Margin">Margin</see>'s values.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.Shrink(System.Single@,System.Single@)">
      <summary>
            Returns a Rect shrunk in every direction by given values on each axis.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.Shrink(System.Single@)">
      <summary>
            Returns a Rect shrunk in every direction by given amount.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.Grow(System.Single@,System.Single@,System.Single@,System.Single@)">
      <summary>
            Returns a Rect grown in every direction by given amounts.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.Grow(Sandbox.UI.Margin)">
      <summary>
            Returns a Rect grown in every direction by <see cref="T:Sandbox.UI.Margin">Margin</see>'s values.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.Grow(System.Single@,System.Single@)">
      <summary>
            Returns a Rect grown in every direction by given values on each axis.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.Grow(System.Single@)">
      <summary>
            Returns a Rect grown in every direction by given amount.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.Floor">
      <summary>
            Returns a Rect with position and size rounded down.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.Round">
      <summary>
            Returns a Rect with position and size rounded to closest integer values.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.Ceiling">
      <summary>
            Returns a Rect with position and size rounded up.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.FromPoints(Vector2@,Vector2@)">
      <summary>
            Create a rect between two points. The order of the points doesn't matter.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.ToVector4">
      <summary>
            Returns this rect as a Vector4, where X/Y/Z/W are Left/Top/Right/Bottom respectively.
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.Rect.Add(Sandbox.Rect)">
      <summary>
            Expand this Rect to contain the other rect
            </summary>
    </member>
    <member name="M:Sandbox.Rect.Add(Vector2)">
      <summary>
            Expand this Rect to contain the point
            </summary>
    </member>
    <member name="M:Sandbox.Rect.AddPoint(Vector2)">
      <summary>
            Returns this rect expanded to include this point
            </summary>
    </member>
    <member name="M:Sandbox.Rect.ClosestPoint(Vector2@)">
      <summary>
            Returns the closest point on this rect to another point
            </summary>
    </member>
    <member name="P:Sandbox.Rect.BottomLeft">
      <summary>
            Position of the bottom left edge of this rect.
            </summary>
    </member>
    <member name="P:Sandbox.Rect.BottomRight">
      <summary>
            Position of the bottom right edge of this rect.
            </summary>
    </member>
    <member name="P:Sandbox.Rect.TopRight">
      <summary>
            Position of the top right edge of this rect.
            </summary>
    </member>
    <member name="P:Sandbox.Rect.TopLeft">
      <summary>
            Position of the top left edge of this rect.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.Align(Vector2@,Sandbox.TextFlag)">
      <summary>
            Align the smaller rect inside this rect.
            Default alignment on each axis is Top, Left.
            </summary>
    </member>
    <member name="M:Sandbox.Rect.SnapToGrid">
      <summary>
            Align to a grid
            </summary>
    </member>
    <member name="M:Sandbox.Rect.Contain(Vector2@,Sandbox.TextFlag,System.Boolean)">
      <summary>
            Contain a given rectangle (image) within this rectangle (frame), preserving aspect ratio.
            </summary>
      <param name="size">Size of the rectagle (image) to try to contain within this frame rectangle.</param>
      <param name="align">Where to align the given box within this rectangle.</param>
      <param name="stretch">Whether to stretch the given rectagle (image) should its size be smaller than largest rectagle (image) size possible within this rectangle (frame).</param>
      <returns>A rectangle with correct position and size to fit within the "parent" rectangle.</returns>
    </member>
    <member name="T:Sandbox.RectInt">
      <summary>
            Represents a rectangle but with whole numbers
            </summary>
    </member>
    <member name="M:Sandbox.RectInt.#ctor(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
      <summary>
            Initialize a Rect at given position and with given size.
            </summary>
    </member>
    <member name="M:Sandbox.RectInt.#ctor(Vector2Int@,Vector2Int@)">
      <summary>
            Initialize a Rect at given position and with given size.
            </summary>
    </member>
    <member name="P:Sandbox.RectInt.Width">
      <summary>
            Width of the rect.
            </summary>
    </member>
    <member name="P:Sandbox.RectInt.Height">
      <summary>
            Height of the rect.
            </summary>
    </member>
    <member name="P:Sandbox.RectInt.Left">
      <summary>
            Position of rect's left edge relative to its parent, can also be interpreted as its position on the X axis.
            </summary>
    </member>
    <member name="P:Sandbox.RectInt.Top">
      <summary>
            Position of rect's top edge relative to its parent, can also be interpreted as its position on the Y axis.
            </summary>
    </member>
    <member name="P:Sandbox.RectInt.Right">
      <summary>
            Position of rect's right edge relative to its parent.
            </summary>
    </member>
    <member name="P:Sandbox.RectInt.Bottom">
      <summary>
            Position of rect's bottom edge relative to its parent.
            </summary>
    </member>
    <member name="P:Sandbox.RectInt.Position">
      <summary>
            Position of this rect.
            </summary>
    </member>
    <member name="P:Sandbox.RectInt.Center">
      <summary>
            Center of this rect.
            </summary>
    </member>
    <member name="P:Sandbox.RectInt.Size">
      <summary>
            Size of this rect.
            </summary>
    </member>
    <member name="P:Sandbox.RectInt.WithoutPosition">
      <summary>
            Returns this rect with position set to 0 on both axes.
            </summary>
    </member>
    <member name="M:Sandbox.RectInt.IsInside(Sandbox.RectInt@,System.Boolean)">
      <summary>
            Return true if the passed rect is partially or fully inside this rect.
            </summary>
      <param name="rect">The passed rect to test.</param>
      <param name="fullyInside">
        <see langword="true" /> to test if the given rect is completely inside this rect. <see langword="false" /> to test for an intersection.</param>
    </member>
    <member name="M:Sandbox.RectInt.IsInside(Vector2Int@)">
      <summary>
            Return true if the passed point is inside this rect.
            </summary>
    </member>
    <member name="M:Sandbox.RectInt.Shrink(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
      <summary>
            Returns a Rect shrunk in every direction by given values.
            </summary>
    </member>
    <member name="M:Sandbox.RectInt.Shrink(System.Int32@,System.Int32@)">
      <summary>
            Returns a Rect shrunk in every direction by given values on each axis.
            </summary>
    </member>
    <member name="M:Sandbox.RectInt.Shrink(System.Int32@)">
      <summary>
            Returns a Rect shrunk in every direction by given amount.
            </summary>
    </member>
    <member name="M:Sandbox.RectInt.Grow(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
      <summary>
            Returns a Rect grown in every direction by given amounts.
            </summary>
    </member>
    <member name="M:Sandbox.RectInt.Grow(System.Int32@,System.Int32@)">
      <summary>
            Returns a Rect grown in every direction by given values on each axis.
            </summary>
    </member>
    <member name="M:Sandbox.RectInt.Grow(System.Int32@)">
      <summary>
            Returns a Rect grown in every direction by given amount.
            </summary>
    </member>
    <member name="M:Sandbox.RectInt.FromPoints(Vector2Int@,Vector2Int@)">
      <summary>
            Create a rect between two points. The order of the points doesn't matter.
            </summary>
    </member>
    <member name="M:Sandbox.RectInt.Add(Sandbox.RectInt)">
      <summary>
            Expand this Rect to contain the other rect
            </summary>
    </member>
    <member name="M:Sandbox.RectInt.Add(Vector2Int)">
      <summary>
            Expand this Rect to contain the point
            </summary>
    </member>
    <member name="M:Sandbox.RectInt.AddPoint(Vector2Int)">
      <summary>
            Returns this rect expanded to include this point
            </summary>
    </member>
    <member name="P:Sandbox.RectInt.BottomLeft">
      <summary>
            Position of the bottom left edge of this rect.
            </summary>
    </member>
    <member name="P:Sandbox.RectInt.BottomRight">
      <summary>
            Position of the bottom right edge of this rect.
            </summary>
    </member>
    <member name="P:Sandbox.RectInt.TopRight">
      <summary>
            Position of the top right edge of this rect.
            </summary>
    </member>
    <member name="P:Sandbox.RectInt.TopLeft">
      <summary>
            Position of the top left edge of this rect.
            </summary>
    </member>
    <member name="T:Sandbox.Sphere">
      <summary>
            Represents a sphere.
            </summary>
    </member>
    <member name="P:Sandbox.Sphere.Unit">
      <summary>
            A sphere centered at the origin, with radius 1.
            </summary>
    </member>
    <member name="F:Sandbox.Sphere.Center">
      <summary>
            Center of the sphere.
            </summary>
    </member>
    <member name="F:Sandbox.Sphere.Radius">
      <summary>
            Radius of the sphere.
            </summary>
    </member>
    <member name="M:Sandbox.Sphere.Trace(Ray,System.Single,System.Single@)">
      <summary>
            Performs an intersection test between this sphere and given ray.
            </summary>
    </member>
    <member name="M:Sandbox.Sphere.Trace(Ray,System.Single)">
      <summary>
            Performs an intersection test between this sphere and given ray.
            </summary>
    </member>
    <member name="M:Sandbox.Sphere.Contains(Vector3@)">
      <summary>
            Returns true if sphere contains point. False if the point falls outside the sphere.
            </summary>
    </member>
    <member name="P:Sandbox.Sphere.Volume">
      <summary>
            Volume of this sphere
            </summary>
    </member>
    <member name="M:Sandbox.Sphere.GetVolume">
      <summary>
            Get the volume of this sphere
            </summary>
    </member>
    <member name="P:Sandbox.Sphere.RandomPointInside">
      <summary>
            Returns a random point within this sphere.
            </summary>
    </member>
    <member name="P:Sandbox.Sphere.RandomPointOnEdge">
      <summary>
            Returns a random point on the edge of this sphere.
            </summary>
    </member>
    <member name="T:Sandbox.Spline">
      <summary>
            Collection of curves in 3D space.
            Shape and behavior of the curves are controled through points <see cref="T:Sandbox.Spline.Point" />, each with customizable handles, roll, scale, and up vectors.
            Two consecutive points define a segment/curve of the spline.
            <br /><br />
            By adjusting the handles both smooth and sharp corners can be created.
            The spline can also be turned into a loop, combined with linear tangents this can be used to create polygons.
            Splines can also be used used for animations, camera movements, marking areas, or procedural geometry generation.
            </summary>
    </member>
    <member name="T:Sandbox.Spline.Point">
      <summary>
            Point that defines part of the spline.
            Two consecutive points define a segment of the spline.
            The <see cref="F:Sandbox.Spline.Point.Position" />,  <see cref="F:Sandbox.Spline.Point.In" />/<see cref="F:Sandbox.Spline.Point.Out" /> Handles and <see cref="F:Sandbox.Spline.Point.Mode" /> / properties are used to define the shape of the spline.
            <code>
                             P1 (Position)                         
                  P1 (In)           ▼           P1 (Out)                      
                          o──────═══X═══──────o                    
                             ───/       \───                      
                          ──/               \──                   
                        -/                     \-                  
                       /                         \                 
                      |                           |
                  P0  X                           X  P2
            </code></summary>
    </member>
    <member name="F:Sandbox.Spline.Point.Position">
      <summary>
            The position of the spline point.
            </summary>
    </member>
    <member name="F:Sandbox.Spline.Point.In">
      <summary>
            Position of the In handle relative to the point position.
            </summary>
    </member>
    <member name="F:Sandbox.Spline.Point.Out">
      <summary>
            Position of the Out handle relative to the point position.
            </summary>
    </member>
    <member name="F:Sandbox.Spline.Point.Mode">
      <summary>
            Describes how the spline should behave when entering/leaving a point.
            The mmode and the handles In and Out position will determine the transition between segments.
            </summary>
    </member>
    <member name="F:Sandbox.Spline.Point.Roll">
      <summary>
            Roll/Twist around the tangent axis.
            </summary>
    </member>
    <member name="F:Sandbox.Spline.Point.Scale">
      <summary>
            X = Scale Length, Y = Scale Width, Z = Scale Height
            </summary>
    </member>
    <member name="F:Sandbox.Spline.Point.Up">
      <summary>
            Custom up vector at a spline point, can be used to calculate tangent frames (transforms) along the spline.
            This allows fine grained control over the orientation of objects following the spline.
            </summary>
    </member>
    <member name="T:Sandbox.Spline.HandleMode">
      <summary>
            Describes how the spline should behave when entering/leaving a point.
            </summary>
    </member>
    <member name="F:Sandbox.Spline.HandleMode.Auto">
      <summary>
            Handle positions are calculated automatically
            based on the location of adjacent points.
            </summary>
    </member>
    <member name="F:Sandbox.Spline.HandleMode.Linear">
      <summary>
            Handle positions are set to zero, leading to a sharp corner.
            </summary>
    </member>
    <member name="F:Sandbox.Spline.HandleMode.Mirrored">
      <summary>
            The In and Out handles are user set, but are linked (mirrored).
            </summary>
    </member>
    <member name="F:Sandbox.Spline.HandleMode.Split">
      <summary>
            The In and Out handle are user set and operate independently.
            </summary>
    </member>
    <member name="F:Sandbox.Spline.SplineChanged">
      <summary>
            Invoked everytime the spline shape or the properties of the spline change.
            </summary>
    </member>
    <member name="P:Sandbox.Spline.IsLoop">
      <summary>
            Whether the spline forms a loop.
            </summary>
    </member>
    <member name="T:Sandbox.Spline.Sample">
      <summary>
            Information about the spline at a specific distance.
            </summary>
    </member>
    <member name="M:Sandbox.Spline.SampleAtDistance(System.Single)">
      <summary>
            Calculates a bunch of information about the spline at a specific distance.
            </summary>
    </member>
    <member name="M:Sandbox.Spline.SampleAtClosestPosition(Vector3)">
      <summary>
            Calculates a bunch of information about the spline at the position closest to the specified position.
            </summary>
    </member>
    <member name="P:Sandbox.Spline.Length">
      <summary>
            Total length of the spline.
            </summary>
    </member>
    <member name="P:Sandbox.Spline.Bounds">
      <summary>
            Total bounds of the spline.
            </summary>
    </member>
    <member name="M:Sandbox.Spline.GetDistanceAtPoint(System.Int32)">
      <summary>
            Fetches how far along the spline a point is.
            </summary>
    </member>
    <member name="M:Sandbox.Spline.GetSegmentLength(System.Int32)">
      <summary>
            Fetches the length of an individual spline segment.
            </summary>
    </member>
    <member name="M:Sandbox.Spline.GetSegmentBounds(System.Int32)">
      <summary>
            Bounds of an individual spline segment.
            </summary>
    </member>
    <member name="M:Sandbox.Spline.GetPoint(System.Int32)">
      <summary>
            Access the information about a spline point.
            </summary>
    </member>
    <member name="P:Sandbox.Spline.PointCount">
      <summary>
            Number of points in the spline.
            </summary>
    </member>
    <member name="P:Sandbox.Spline.SegmentCount">
      <summary>
            Number of segments in the spline, a spline contains one less segment than points.
            </summary>
    </member>
    <member name="M:Sandbox.Spline.UpdatePoint(System.Int32,Sandbox.Spline.Point)">
      <summary>
            Update the information stored at a spline point.
            </summary>
    </member>
    <member name="M:Sandbox.Spline.InsertPoint(System.Int32,Sandbox.Spline.Point)">
      <summary>
            Adds a point at an index
            </summary>
    </member>
    <member name="M:Sandbox.Spline.AddPoint(Sandbox.Spline.Point)">
      <summary>
            Adds a point to the end of the spline.
            </summary>
    </member>
    <member name="M:Sandbox.Spline.AddPointAtDistance(System.Single,System.Boolean)">
      <summary>
            Adds a point at a specific distance along the spline.
            Returns the index of the added spline point.
            Tangents of the new point and adjacent points will be calculated so the spline shape remains the same.
            Unless inferTangentModes is set to true, in which case the tangent modes will be inferred from the adjacent points.
            </summary>
    </member>
    <member name="M:Sandbox.Spline.RemovePoint(System.Int32)">
      <summary>
            Removes the point at the specified index.
            </summary>
    </member>
    <member name="M:Sandbox.Spline.Clear">
      <summary>
            Removes all points from the spline.
            </summary>
    </member>
    <member name="M:Sandbox.Spline.FindDistanceClosestToPosition(Vector3)">
      <summary>
            Can be used to get information via GetPositionAtDistance and GetTangentAtDistance etc.
            </summary>
    </member>
    <member name="M:Sandbox.Spline.ConvertToPolyline(System.Collections.Generic.List{Vector3}@)">
      <summary>
            Converts the spline to a polyline, can pass in buffer as parameter to avoid reallocations.
            </summary>
    </member>
    <member name="M:Sandbox.Spline.ConvertToPolyline">
      <summary>
            Converts the spline to a polyline.
            </summary>
    </member>
    <member name="T:Sandbox.SpringDamper">
      <summary>
            Models a unit mass attached to a spring and a damper, with a particular
            <see cref="P:Sandbox.SpringDamper.Frequency" /> and <see cref="P:Sandbox.SpringDamper.DecayRate" />.
            </summary>
    </member>
    <member name="M:Sandbox.SpringDamper.FromDamping(System.Single,System.Single)">
      <summary>
            Create a model of a damped spring from a <paramref name="frequency" /> and <paramref name="damping" /> per oscillation.
            </summary>
      <param name="frequency">How many times the spring oscillates per second.</param>
      <param name="damping">How much damping to apply each oscillation, as with the legacy <see cref="M:Vector3.SpringDamp(Vector3@,Vector3@,Vector3@,System.Single,System.Single,System.Single,System.Single)" />.</param>
    </member>
    <member name="M:Sandbox.SpringDamper.FromSmoothingTime(System.Single)">
      <summary>
            Create a critically damped model with a given <paramref name="smoothingTime" />, for movement that doesn't oscillate but smoothly
            settles to the target value.
            </summary>
      <param name="smoothingTime">Time until the spring has settled.</param>
    </member>
    <member name="P:Sandbox.SpringDamper.Frequency">
      <summary>
            How many times the spring oscillates per second.
            </summary>
    </member>
    <member name="P:Sandbox.SpringDamper.DecayRate">
      <summary>
            Exponential decay constant λ, higher values decay faster.
            </summary>
    </member>
    <member name="F:Sandbox.SpringDamper._omega">
      <summary>
            Angular frequency (radians per second), with decay accounted for.
            </summary>
    </member>
    <member name="M:Sandbox.SpringDamper.#ctor(System.Single,System.Single)">
      <summary>
            Models a unit mass attached to a spring and a damper, with a particular
            <paramref name="frequency" /> and <paramref name="decayRate" />.
            </summary>
    </member>
    <member name="M:Sandbox.SpringDamper.Simulate(System.Single,System.Single,System.Single)">
      <summary>
            Simulate the evolution of a unit mass with given <paramref name="position" /> and <paramref name="velocity" />
            being affected by this system, <paramref name="deltaTime" /> seconds into the future.
            </summary>
      <param name="position">Current displacement of the mass from the spring rest position.</param>
      <param name="velocity">Current velocity of the mass.</param>
      <param name="deltaTime">How far to simulate into the future.</param>
    </member>
    <member name="M:Sandbox.SpringDamper.Simulate(Vector2,Vector2,System.Single)">
      <inheritdoc cref="M:Sandbox.SpringDamper.Simulate(System.Single,System.Single,System.Single)" />
    </member>
    <member name="M:Sandbox.SpringDamper.Simulate(Vector3,Vector3,System.Single)">
      <inheritdoc cref="M:Sandbox.SpringDamper.Simulate(System.Single,System.Single,System.Single)" />
    </member>
    <member name="T:Sandbox.SandboxSystem">
      <summary>
            Hidden random class. This is secretly used by Game.Random, but being here 
            allows all of our system functions to use the same Random instance.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxSystem.SetRandomSeed(System.Int32)">
      <summary>
            Sets the seed for these static classes
            </summary>
    </member>
    <member name="T:Sandbox.MultiSerializedObject">
      <summary>
            An object (or data) that can be accessed as an object
            </summary>
    </member>
    <member name="M:Sandbox.MultiSerializedObject.Add(Sandbox.SerializedObject)">
      <summary>
            Add an object. Don't forget to rebuild after editing!
            </summary>
    </member>
    <member name="M:Sandbox.MultiSerializedObject.Rebuild">
      <summary>
            Rebuild the object after modifying. This updates PropertyList.
            </summary>
    </member>
    <member name="P:Sandbox.MultiSerializedObject.IsMultipleTargets">
      <summary>
            True if the target is multiple objects
            </summary>
    </member>
    <member name="P:Sandbox.MultiSerializedObject.Targets">
      <summary>
            A list of actual target objects - if applicable
            </summary>
    </member>
    <member name="M:Sandbox.SerializedCollection.Create(System.Type)">
      <summary>
            Get a SerializedObject version of this object
            </summary>
    </member>
    <member name="M:Sandbox.SerializedCollection.NewKeyProperty">
      <summary>
            If this is a dictionary, this will create a property to easily create a key
            </summary>
    </member>
    <member name="M:Sandbox.SerializedDictionary.TryChangeKey(System.Object,System.Object)">
      <summary>
            Called when changing the key
            </summary>
    </member>
    <member name="M:Sandbox.SerializedDictionary.NewKeyProperty">
      <summary>
            If this is a dictionary, this will create a property to easily create a key
            </summary>
    </member>
    <member name="T:Sandbox.SerializedObject">
      <summary>
            An object (or data) that can be accessed as an object
            </summary>
    </member>
    <member name="M:Sandbox.SerializedObject.NoteChanged(Sandbox.SerializedProperty)">
      <summary>
            It's good manners for a changed SerializedProperty to tell its parent
            on set. That way the parent can cascade changes up the tree. This is 
            particularly important if the tree includes struct types - because those
            values will need to be re-set on any ParentProperty's.
            </summary>
    </member>
    <member name="M:Sandbox.SerializedObject.PrepareEnumerator">
      <summary>
            Called right before enumeration, to allow derivitives react to changes
            </summary>
    </member>
    <member name="P:Sandbox.SerializedObject.IsMultipleTargets">
      <summary>
            True if the target is multiple objects
            </summary>
    </member>
    <member name="P:Sandbox.SerializedObject.Targets">
      <summary>
            A list of actual target objects - if applicable
            </summary>
    </member>
    <member name="P:Sandbox.SerializedProperty.IsValid">
      <inheritdoc cref="P:Sandbox.IValid.IsValid" />
    </member>
    <member name="P:Sandbox.SerializedProperty.SourceFile">
      <summary>
            The source filename, if available
            </summary>
    </member>
    <member name="P:Sandbox.SerializedProperty.SourceLine">
      <summary>
            The line in the source file, if available
            </summary>
    </member>
    <member name="P:Sandbox.SerializedProperty.HasChanges">
      <summary>
            Returns true if the current set value differs from the actual value
            </summary>
    </member>
    <member name="M:Sandbox.SerializedProperty.GetDefault">
      <summary>
            Get the default value of a specific property type.
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.SerializedProperty.HasAttribute``1">
      <summary>
            Return true if the property has this attribute
            </summary>
    </member>
    <member name="M:Sandbox.SerializedProperty.HasAttribute(System.Type)">
      <summary>
            Return true if the property has this attribute
            </summary>
    </member>
    <member name="M:Sandbox.SerializedProperty.TryGetAttribute``1(``0@)">
      <summary>
            Try to get this attribute from the property. Return false on fail.
            </summary>
    </member>
    <member name="M:Sandbox.SerializedProperty.GetAttributes``1">
      <summary>
            Get all of these attributes from the property.
            </summary>
    </member>
    <member name="M:Sandbox.SerializedProperty.GetAttributes(System.Type)">
      <summary>
            Get all of these attributes from the property.
            </summary>
    </member>
    <member name="M:Sandbox.SerializedProperty.GetAttributes">
      <summary>
            Get all attributes from the property.
            </summary>
    </member>
    <member name="M:Sandbox.SerializedProperty.TryGetAsObject(Sandbox.SerializedObject@)">
      <summary>
            Try to convert this property into a serialized object for further editing and exploration
            </summary>
      <param name="obj" />
      <returns />
    </member>
    <member name="P:Sandbox.SerializedProperty.IsMultipleValues">
      <summary>
            True if this holds multiple values. That might all be the same.
            </summary>
    </member>
    <member name="P:Sandbox.SerializedProperty.IsMultipleDifferentValues">
      <summary>
            True if this holds multiple values, and they're all different.
            </summary>
    </member>
    <member name="P:Sandbox.SerializedProperty.MultipleProperties">
      <summary>
            Get all properties if this holds multiple values
            </summary>
    </member>
    <member name="M:Sandbox.SerializedProperty.NoteChanged">
      <summary>
            Our value has changed, maybe our parent would like to know
            </summary>
    </member>
    <member name="M:Sandbox.SerializedProperty.ValueToType``1(System.Object,``0)">
      <summary>
            Convert an object value to a T type 
            </summary>
    </member>
    <member name="M:Sandbox.SerializedProperty.GetKey">
      <summary>
            If this entry is a dictionary, we can get the key for it here
            </summary>
    </member>
    <member name="M:Sandbox.SerializedProperty.ShouldShow">
      <summary>
            Returns true if this property should be shown in the inspector
            </summary>
    </member>
    <member name="P:Sandbox.SerializedProperty.IsNullable">
      <summary>
            Return true if this is a nullable value type
            </summary>
    </member>
    <member name="P:Sandbox.SerializedProperty.NullableType">
      <summary>
            If this is a nullable type, this will return the nullable target type
            </summary>
    </member>
    <member name="P:Sandbox.SerializedProperty.IsNull">
      <summary>
            True if the value is null
            </summary>
    </member>
    <member name="M:Sandbox.SerializedProperty.SetNullState(System.Boolean)">
      <summary>
            If this is a nullable type, you can use this to toggle between it being null or the default value type
            </summary>
    </member>
    <member name="M:Sandbox.SerializedProperty.Invoke">
      <summary>
            If is method
            </summary>
    </member>
    <member name="T:Sandbox.SerializedProperty.Proxy">
      <summary>
            Allows easily creating SerializedProperty classes that wrap other properties.
            </summary>
    </member>
    <member name="M:Sandbox.SerializedProperty.Create``1(System.String,System.Func{``0},System.Action{``0},System.Attribute[])">
      <summary>
            Create a serialized property that uses a getter and setter
            </summary>
    </member>
    <member name="T:Sandbox.InspectorVisibilityAttribute">
      <summary>
            Hide a property if a condition matches.
            </summary>
    </member>
    <member name="T:Sandbox.RealTime">
      <summary>
            Access to time.
            </summary>
    </member>
    <member name="P:Sandbox.RealTime.Now">
      <summary>
            The time since game startup, in seconds.
            </summary>
    </member>
    <member name="P:Sandbox.RealTime.GlobalNow">
      <summary>
            The number of a seconds since a set point in time. This value should match between servers and clients. If they have their timezone set correctly.
            </summary>
    </member>
    <member name="P:Sandbox.RealTime.Delta">
      <summary>
            The time delta (in seconds) between the last frame and the current (for all intents and purposes)
            </summary>
    </member>
    <member name="P:Sandbox.RealTime.SmoothDelta">
      <summary>
            Like Delta but smoothed to avoid large disparities between deltas
            </summary>
    </member>
    <member name="T:Sandbox.RealTimeSince">
      <summary>
            A convenience struct to easily measure time since an event last happened, based on <see cref="P:Sandbox.RealTime.GlobalNow" />.<br /><br />
            Typical usage would see you assigning 0 to a variable of this type to reset the timer.
            Then the struct would return time since the last reset. i.e.:
            <code>
            RealTimeSince lastUsed = 0;
            if ( lastUsed &gt; 10 ) { /*Do something*/ }
            </code></summary>
    </member>
    <member name="P:Sandbox.RealTimeSince.Absolute">
      <summary>
            Time at which the timer reset happened, based on <see cref="P:Sandbox.RealTime.GlobalNow" />.
            </summary>
    </member>
    <member name="P:Sandbox.RealTimeSince.Relative">
      <summary>
            Time passed since last reset, in seconds.
            </summary>
    </member>
    <member name="T:Sandbox.RealTimeUntil">
      <summary>
            A convenience struct to easily manage a time countdown, based on <see cref="P:Sandbox.RealTime.GlobalNow" />.<br /><br />
            Typical usage would see you assigning to a variable of this type a necessary amount of seconds.
            Then the struct would return the time countdown, or can be used as a bool i.e.:
            <code>
            RealTimeUntil nextAttack = 10;
            if ( nextAttack ) { /*Do something*/ }
            </code></summary>
    </member>
    <member name="P:Sandbox.RealTimeUntil.Absolute">
      <summary>
            Time to which we are counting down to, based on <see cref="P:Sandbox.RealTime.GlobalNow" />.
            </summary>
    </member>
    <member name="P:Sandbox.RealTimeUntil.Relative">
      <summary>
            The actual countdown, in seconds.
            </summary>
    </member>
    <member name="P:Sandbox.RealTimeUntil.Passed">
      <summary>
            Amount of seconds passed since the countdown started.
            </summary>
    </member>
    <member name="P:Sandbox.RealTimeUntil.Fraction">
      <summary>
            The countdown, but as a fraction, i.e. a value from 0 (start of countdown) to 1 (end of countdown)
            </summary>
    </member>
    <member name="T:Sandbox.Translation">
      <summary>
            This isn't ideal, but it does what we want it to do. Kind of.
            </summary>
    </member>
    <member name="T:Sandbox.BytePack">
      <summary>
             A class that can serialize and deserialize whole objects to and from byte streams, 
             without needing to know the type beforehand.
             
             https://docs.facepunch.com/doc/bytepack-FdTR6ZUoOa
            
             </summary>
    </member>
    <member name="T:Sandbox.BytePack.ISerializer">
      <summary>
            Allows classes to specify how they are to be serialized and deserialized through BytePack.
            </summary>
    </member>
    <member name="M:Sandbox.BytePack.ISerializer.BytePackRead(Sandbox.ByteStream@,System.Type)">
      <summary>
            Read from a <see cref="T:Sandbox.ByteStream" /> and return an object.
            </summary>
      <param name="bs">The incoming byte stream.</param>
      <param name="targetType">The expected type.</param>
      <returns />
    </member>
    <member name="M:Sandbox.BytePack.ISerializer.BytePackWrite(System.Object,Sandbox.ByteStream@)">
      <summary>
            Write a value to an outgoing <see cref="T:Sandbox.ByteStream" />.
            </summary>
      <param name="value">The value to be serialized.</param>
      <param name="bs">The outgoing byte stream.</param>
    </member>
    <member name="T:Sandbox.BytePack.Identifier">
      <summary>
            A header before each variable
            </summary>
    </member>
    <member name="T:Sandbox.BytePack.PodPacker`1">
      <summary>
            Plain old data types. It's faster to have these as identifier types than
            have them each being a TypeLibrary lookup dynamic type, so anything quite
            common should be included here.
            </summary>
    </member>
    <member name="T:Sandbox.BytePack.ObjectArrayPacker">
      <summary>
            An object[] array. More expensive than a Value array because each type has to write its type
            </summary>
    </member>
    <member name="T:Sandbox.BytePack.ObjectPacker">
      <summary>
            Writes a type header and then the value
            </summary>
    </member>
    <member name="T:Sandbox.BytePack.ValueArrayPacker">
      <summary>
            A value array is useful because we only have to write the header once, and it's a single
            block of memory to read. Useful.
            </summary>
    </member>
    <member name="T:Sandbox.ByteStream">
      <summary>
            A result of SpeedTest.MemoryAlloc - to make it easy to use this instead of AllocHGlobal
            </summary>
    </member>
    <member name="P:Sandbox.ByteStream.Position">
      <summary>
            The current read or write position
            </summary>
    </member>
    <member name="P:Sandbox.ByteStream.Length">
      <summary>
            The total size of the data
            </summary>
    </member>
    <member name="M:Sandbox.ByteStream.Create(System.Int32)">
      <summary>
            Create a writable byte stream
            </summary>
    </member>
    <member name="M:Sandbox.ByteStream.CreateReader(System.ReadOnlySpan{System.Byte})">
      <summary>
            Create a writable byte stream
            </summary>
    </member>
    <member name="M:Sandbox.ByteStream.CreateReader(System.Void*,System.Int32)">
      <summary>
            Create a writable byte stream
            </summary>
    </member>
    <member name="M:Sandbox.ByteStream.WriteArray``1(System.ReadOnlySpan{``0})">
      <summary>
            Writing an array of unmanaged types
            </summary>
    </member>
    <member name="M:Sandbox.ByteStream.WriteArray``1(``0[],System.Boolean)">
      <summary>
            Writing an array of unmanaged types
            </summary>
    </member>
    <member name="M:Sandbox.ByteStream.Write(System.String)">
      <summary>
            Writing a string
            </summary>
    </member>
    <member name="M:Sandbox.ByteStream.ToArray">
      <summary>
            Get the data as an array of bytes
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.ByteStream.ToSpan">
      <summary>
            Get the data as a span
            </summary>
    </member>
    <member name="M:Sandbox.ByteStream.Base">
      <summary>
            Returns a pointer to the base of the data
            </summary>
    </member>
    <member name="M:Sandbox.ByteStream.Base(System.Int32)">
      <summary>
            Returns a pointer to the base of the data
            </summary>
    </member>
    <member name="M:Sandbox.ByteStream.Write``1(``0)">
      <summary>
            Writing an unmanaged type
            </summary>
    </member>
    <member name="M:Sandbox.ByteStream.TryRead``1(``0@)">
      <summary>
            Try to read variable, return false if not enough data
            </summary>
    </member>
    <member name="M:Sandbox.ByteStream.ReadByteStream(System.Int32)">
      <summary>
            Read a block of data
            </summary>
    </member>
    <member name="M:Sandbox.ByteStream.WriteValueArray(System.Array)">
      <summary>
            Write an Array, that we know is a Value array. We definitely know it's a value array.
            We're not exposing this to the public api because they don't know whether it's a value array.
            </summary>
    </member>
    <member name="M:Sandbox.ByteStream.ReadValueArray(System.Array)">
      <summary>
            Write an Array, that we know is a Value array. We definitely know it's a value array.
            We're not exposing this to the public api because they don't know whether it's a value array.
            </summary>
    </member>
    <member name="M:Sandbox.ByteStream.Read(System.Byte[],System.Int32,System.Int32)">
      <inheritdoc cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />
    </member>
    <member name="M:Sandbox.ByteStream.Read(System.Span{System.Byte})">
      <inheritdoc cref="M:System.IO.Stream.Read(System.Span{System.Byte})" />
    </member>
    <member name="T:Sandbox.IValid">
      <summary>
            This object can become invalid
            </summary>
    </member>
    <member name="P:Sandbox.IValid.IsValid">
      <summary>
            Whether this object is valid or not.
            </summary>
    </member>
    <member name="T:Sandbox.MathX">
      <summary>
            A class to add functionality to the math library that System.Math and System.MathF don't provide.
            A lot of these methods are also extensions, so you can use for example `int i = 1.0f.FloorToInt();`
            </summary>
    </member>
    <member name="M:Sandbox.MathX.DegreeToRadian(System.Single)">
      <summary>
             Convert degrees to radians.
            
             <para>180 degrees is <see cref="F:System.Math.PI" /> (roughly 3.14) radians, etc.</para></summary>
      <param name="deg">A value in degrees to convert.</param>
      <returns>The given value converted to radians.</returns>
    </member>
    <member name="M:Sandbox.MathX.RadianToDegree(System.Single)">
      <summary>
             Convert radians to degrees.
            
             <para>180 degrees is <see cref="F:System.Math.PI" /> (roughly 3.14) radians, etc.</para></summary>
      <param name="rad">A value in radians to convert.</param>
      <returns>The given value converted to degrees.</returns>
    </member>
    <member name="M:Sandbox.MathX.GradiansToDegrees(System.Single)">
      <summary>
             Convert gradians to degrees.
            
             <para>100 gradian is 90 degrees, 200 gradian is 180 degrees, etc.</para></summary>
      <param name="grad">A value in gradians to convert.</param>
      <returns>The given value converted to degrees.</returns>
    </member>
    <member name="M:Sandbox.MathX.GradiansToRadians(System.Single)">
      <summary>
             Convert gradians to radians.
            
             <para>200 gradian is <see cref="F:System.Math.PI" /> (roughly 3.14) radians, etc.</para></summary>
      <param name="grad">A value in gradians to convert.</param>
      <returns>The given value converted to radians.</returns>
    </member>
    <member name="M:Sandbox.MathX.MeterToInch(System.Single)">
      <summary>
            Convert meters to inches.
            </summary>
    </member>
    <member name="M:Sandbox.MathX.InchToMeter(System.Single)">
      <summary>
            Convert inches to meters.
            </summary>
    </member>
    <member name="M:Sandbox.MathX.InchToMillimeter(System.Single)">
      <summary>
            Convert inches to millimeters.
            </summary>
    </member>
    <member name="M:Sandbox.MathX.MillimeterToInch(System.Single)">
      <summary>
            Convert millimeters to inches.
            </summary>
    </member>
    <member name="M:Sandbox.MathX.SnapToGrid(System.Single,System.Single)">
      <summary>
            Snap number to grid
            </summary>
    </member>
    <member name="M:Sandbox.MathX.SnapToGrid(System.Int32,System.Int32)">
      <summary>
            Snap number to grid
            </summary>
    </member>
    <member name="M:Sandbox.MathX.FloorToInt(System.Single)">
      <summary>
            Remove the fractional part and return the float as an integer.
            </summary>
    </member>
    <member name="M:Sandbox.MathX.Floor(System.Single)">
      <summary>
            Remove the fractional part of given floating point number
            </summary>
    </member>
    <member name="M:Sandbox.MathX.CeilToInt(System.Single)">
      <summary>
            Rounds up given float to next integer value.
            </summary>
    </member>
    <member name="M:Sandbox.MathX.Order(System.Single@,System.Single@)">
      <summary>
            Orders the two given numbers so that a is less than b.
            </summary>
    </member>
    <member name="M:Sandbox.MathX.Clamp(System.Single,System.Single,System.Single)">
      <summary>
            Clamp a float between 2 given extremes.
            If given value is lower than the given minimum value, returns the minimum value, etc.
            </summary>
      <param name="v">The value to clamp.</param>
      <param name="min">Minimum return value.</param>
      <param name="max">Maximum return value.</param>
      <returns>The clamped float.</returns>
    </member>
    <member name="M:Sandbox.MathX.Lerp(System.Single,System.Single,System.Single,System.Boolean)">
      <summary>
            Performs linear interpolation on floating point numbers.
            </summary>
      <param name="from">The "starting value" of the interpolation.</param>
      <param name="to">The "final value" of the interpolation.</param>
      <param name="frac">The fraction in range of 0 (will return value of <paramref name="from" />) to 1 (will return value of <paramref name="to" />).</param>
      <param name="clamp">Whether to clamp the fraction between 0 and 1, and therefore the output value between <paramref name="from" /> and <paramref name="to" />.</param>
      <returns>The result of linear interpolation.</returns>
    </member>
    <member name="M:Sandbox.MathX.LerpTo(System.Single,System.Single,System.Single,System.Boolean)">
      <inheritdoc cref="M:Sandbox.MathX.Lerp(System.Single,System.Single,System.Single,System.Boolean)" />
    </member>
    <member name="M:Sandbox.MathX.LerpTo(System.Single[],System.Single[],System.Single,System.Boolean)">
      <summary>
            Performs multiple linear interpolations at the same time.
            </summary>
    </member>
    <member name="M:Sandbox.MathX.LerpDegrees(System.Single,System.Single,System.Single,System.Boolean)">
      <summary>
            Linearly interpolates between two angles in degrees, taking the shortest arc.
            </summary>
    </member>
    <member name="M:Sandbox.MathX.LerpDegreesTo(System.Single,System.Single,System.Single,System.Boolean)">
      <inheritdoc cref="M:Sandbox.MathX.LerpDegrees(System.Single,System.Single,System.Single,System.Boolean)" />
    </member>
    <member name="M:Sandbox.MathX.LerpRadians(System.Single,System.Single,System.Single,System.Boolean)">
      <summary>
            Linearly interpolates between two angles in radians, taking the shortest arc.
            </summary>
    </member>
    <member name="M:Sandbox.MathX.LerpRadiansTo(System.Single,System.Single,System.Single,System.Boolean)">
      <inheritdoc cref="M:Sandbox.MathX.LerpRadians(System.Single,System.Single,System.Single,System.Boolean)" />
    </member>
    <member name="M:Sandbox.MathX.LerpInverse(System.Single,System.Single,System.Single,System.Boolean)">
      <summary>
            Performs inverse of a linear interpolation, that is, the return value is the fraction of a linear interpolation.
            </summary>
      <param name="value">The value relative to <paramref name="from" /> and <paramref name="to" />.</param>
      <param name="from">The "starting value" of the interpolation. If <paramref name="value" /> is at this value or less, the function will return 0 or less.</param>
      <param name="to">The "final value" of the interpolation. If <paramref name="value" /> is at this value or greater, the function will return 1 or greater.</param>
      <param name="clamp">Whether the return value is allowed to exceed range of 0 - 1.</param>
      <returns>The resulting fraction.</returns>
    </member>
    <member name="M:Sandbox.MathX.Approach(System.Single,System.Single,System.Single)">
      <summary>
            Adds or subtracts given amount based on whether the input is smaller of bigger than the target.
            </summary>
    </member>
    <member name="M:Sandbox.MathX.AlmostEqual(System.Single,System.Single,System.Single)">
      <summary>
            Returns true if given value is close to given value within given tolerance.
            </summary>
    </member>
    <member name="M:Sandbox.MathX.UnsignedMod(System.Single,System.Single)">
      <summary>
            Does what you expected to happen when you did "a % b"
            </summary>
    </member>
    <member name="M:Sandbox.MathX.NormalizeDegrees(System.Single)">
      <summary>
            Convert angle to between 0 - 360
            </summary>
    </member>
    <member name="M:Sandbox.MathX.DeltaDegrees(System.Single,System.Single)">
      <summary>
            Difference between two angles in degrees. Will always be between -180 and +180.
            </summary>
    </member>
    <member name="M:Sandbox.MathX.DeltaRadians(System.Single,System.Single)">
      <summary>
            Difference between two angles in radians. Will always be between -PI and +PI.
            </summary>
    </member>
    <member name="M:Sandbox.MathX.Remap(System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Remap a float value from a one range to another. Clamps value between newLow and newHigh.
            </summary>
    </member>
    <member name="M:Sandbox.MathX.Remap(System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
      <summary>
            Remap a float value from a one range to another
            </summary>
    </member>
    <member name="M:Sandbox.MathX.Remap(System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Remap a double value from a one range to another
            </summary>
    </member>
    <member name="M:Sandbox.MathX.Remap(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Remap an integer value from a one range to another
            </summary>
    </member>
    <member name="M:Sandbox.MathX.SphereCameraDistance(System.Single,System.Single)">
      <summary>
            Given a sphere and a field of view, how far from the camera should we be to fully see the sphere?
            </summary>
      <param name="radius">The radius of the sphere</param>
      <param name="fieldOfView">The field of view in degrees</param>
      <returns>The optimal distance from the center of the sphere</returns>
    </member>
    <member name="M:Sandbox.MathX.SmoothDamp(System.Single,System.Single,System.Single@,System.Single,System.Single)">
      <summary>
            Smoothly move towards the target
            </summary>
    </member>
    <member name="M:Sandbox.MathX.SpringDamp(System.Single,System.Single,System.Single@,System.Single,System.Single,System.Single)">
      <summary>
            Smoothly move towards the target using a spring-like motion
            </summary>
    </member>
    <member name="M:Sandbox.MathX.SolveQuadratic(System.Single,System.Single,System.Single)">
      <summary>
            Finds the real solutions to a quadratic equation of the form
            <c>Ax² + Bx + C = 0</c>.
            Useful for determining where a parabolic curve intersects the x-axis.
            </summary>
      <returns>A list of real roots (solutions). The list may contain zero, one, or two real numbers.</returns>
    </member>
    <member name="M:Sandbox.MathX.SolveCubic(System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Finds the real solutions to a cubic equation of the form
            <c>Ax³ + Bx² + Cx + D = 0</c>.
            Useful for finding where a cubic curve crosses the x-axis.
            </summary>
      <returns>A list of real roots (solutions). The list may contain one, two, or three real numbers.</returns>
    </member>
    <member name="M:Sandbox.MathX.QuadraticRoots(System.Single,System.Single)">
      <summary>
            Calculates the real roots of a simplified quadratic equation
            in its normal form: <c>x² + Ax + B = 0</c>.
            This is a helper method used internally by <see cref="M:Sandbox.MathX.SolveQuadratic(System.Single,System.Single,System.Single)" />.
            </summary>
      <returns>A list of real roots. May contain zero, one, or two real numbers.</returns>
    </member>
    <member name="M:Sandbox.MathX.CubicRoots(System.Single,System.Single,System.Single)">
      <summary>
            Calculates the real roots of a simplified cubic equation
            in its normal form: <c>x³ + Ax² + Bx + C = 0</c>.
            This is a helper method used internally by <see cref="M:Sandbox.MathX.SolveCubic(System.Single,System.Single,System.Single,System.Single)" />.
            </summary>
      <returns>A list of real roots. May contain one, two, or three real numbers.</returns>
    </member>
    <member name="T:Sandbox.NativeMemoryBlock">
      <summary>
            A growable block of native memory - which will be handled and free'd safely
            </summary>
    </member>
    <member name="P:Sandbox.NativeMemoryBlock.Pointer">
      <summary>
            Pointer to the allocated data
            </summary>
    </member>
    <member name="P:Sandbox.NativeMemoryBlock.Size">
      <summary>
            The size of the allocated buffer
            </summary>
    </member>
    <member name="F:Sandbox.NativeMemoryBlock.InPool">
      <summary>
            True if this is currently in the shared pool
            </summary>
    </member>
    <member name="M:Sandbox.NativeMemoryBlock.Grow(System.Int32)">
      <summary>
            Grow the allocated buffer to this size. If we're already this size then do nothing.
            </summary>
    </member>
    <member name="M:Sandbox.Parse.ReadSentence">
      <summary>
            Reads a sentence until the next statement divided by ,
            Returns the sentence
            </summary>
    </member>
    <member name="M:Sandbox.Parse.TryReadPositionAndSize(Sandbox.UI.Length@,Sandbox.UI.Length@,Sandbox.UI.Length@,Sandbox.UI.Length@)">
      <summary>
        <para>
            Typically used to parse shorthand position &amp; size combinations, like those seen inside
            mask and background shorthands.
            <code>&lt;position&gt; [ / &lt;size&gt; ]</code></para>
      </summary>
    </member>
    <member name="M:Sandbox.Parse.Is(System.String,System.Int32,System.Boolean)">
      <summary>
            Return true if the string at the pointer is this
            </summary>
    </member>
    <member name="M:Sandbox.Parse.TrySkip(System.String,System.Int32,System.Boolean)">
      <summary>
            Skip this string if it exists
            </summary>
    </member>
    <member name="M:Sandbox.Parse.TrySkipCommaSeparation">
      <summary>
            Skip comma and then possible whitespace
            </summary>
    </member>
    <member name="M:Sandbox.Parse.Is(System.Char,System.Int32,System.Boolean)">
      <summary>
            Return true if the char at the pointer is this
            </summary>
    </member>
    <member name="P:Sandbox.Parse.CurrentLine">
      <summary>
            Get the line we're currently on
            </summary>
    </member>
    <member name="T:Sandbox.PooledArrayBuffer`1">
      <summary>
            A result of SpeedTest.MemoryAlloc - to make it easy to use this instead of AllocHGlobal
            </summary>
    </member>
    <member name="T:Sandbox.ReflectionCache`2">
      <summary>
            Lazily performs expensive reflection, caching the result.
            Clears itself during hotloads.
            </summary>
    </member>
    <member name="M:Sandbox.ReflectionCache`2.#ctor(System.Func{`0,`1})">
      <summary>
            Creates a <see cref="T:Sandbox.ReflectionCache`2" />, wrapping a function to get a <typeparamref name="TValue" />
            lazily from a <typeparamref name="TKey" />.
            </summary>
      <param name="getValue">Expensive reflection to lazily run once per <typeparamref name="TKey" />.</param>
    </member>
    <member name="P:Sandbox.ReflectionCache`2.Item(`0)">
      <summary>
            Gets a cached value for the given <paramref name="key" /> if it exists, otherwise
            runs the expensive function wrapped by this instance and stores it.
            </summary>
    </member>
    <member name="T:Sandbox.SteamId">
      <summary>
            Represents a SteamId, in the hope to avoid the "should it be a long or ulong" debate.
            </summary>
    </member>
    <member name="M:Sandbox.SteamId.op_Implicit(System.Int32)~Sandbox.SteamId">
      <summary>
            Should shouldn't be doing this
            </summary>
    </member>
    <member name="P:Sandbox.SteamId.AccountType">
      <summary>
            Return what type os SteamId this is
            </summary>
    </member>
    <member name="T:Sandbox.StringToken">
      <summary>
            Strings are commonly converted to tokens in engine, to save space and speed up things like comparisons.
            We wrap this functionality up in the StringToken struct, because we can apply a bunch of compile time 
            optimizations to speed up the conversion.
            </summary>
    </member>
    <member name="M:Sandbox.StringToken.FindOrCreate(System.String)">
      <summary>
            called by interop
            </summary>
    </member>
    <member name="M:Sandbox.StringToken.Literal(System.String,System.UInt32)">
      <summary>
            This is used by codegen. String literals are replaced by this function call, which
            avoids having to create or lookup the string token.
            </summary>
    </member>
    <member name="F:Sandbox.StringToken.defaults">
      <summary>
            A bunch of values we want to exist in the reverse lookup. 
            I don't know if this is still strictly needed, but we used to need these to deserialize entities propertly.
            </summary>
    </member>
    <member name="T:Sandbox.StringToken.ConvertAttribute">
      <summary>
            To allow redirecting in the case where a class has both a string and StringToken version of a method.
            We should be able to remove this when we're compiling on demand instead of keeping the string versions around for compatibility.
            </summary>
    </member>
    <member name="T:Sandbox.ThreadSafe">
      <summary>
            MainThread related functions.
            </summary>
    </member>
    <member name="P:Sandbox.ThreadSafe.CurrentThreadId">
      <summary>
            Return the current thread's Id (CurrentThread.ManagedThreadId)
            </summary>
    </member>
    <member name="P:Sandbox.ThreadSafe.CurrentThreadName">
      <summary>
            Return the current thread's name (CurrentThread.Name)
            </summary>
    </member>
    <member name="P:Sandbox.ThreadSafe.IsMainThread">
      <summary>
            Returns true if we're executing under the main thread
            </summary>
    </member>
    <member name="M:Sandbox.ThreadSafe.AssertIsMainThread(System.String)">
      <summary>
            Throws an exception if this is not called under the main thread
            </summary>
    </member>
    <member name="M:Sandbox.ThreadSafe.AssertIsNotMainThread">
      <summary>
            Throws an exception if this is the main thread
            </summary>
    </member>
    <member name="T:PlaceholderAttribute">
      <summary>
            Add placeholder text, typically displayed for string properties when the text entry field is empty.
            This info can then be retrieved via DisplayInfo library.
            </summary>
    </member>
    <member name="P:PlaceholderAttribute.Value">
      <inheritdoc cref="P:Sandbox.Internal.IPlaceholderProvider.Value" />
    </member>
    <member name="T:ClassNameAttribute">
      <summary>
            Set the class name for this type or member.
            This info can then be retrieved via DisplayInfo library.
            </summary>
    </member>
    <member name="P:ClassNameAttribute.Value">
      <inheritdoc cref="P:Sandbox.Internal.IClassNameProvider.Value" />
    </member>
    <member name="T:TitleAttribute">
      <summary>
            Sets the title or a "nice name" of a type or a type member.
            This info can then be retrieved via DisplayInfo library.
            </summary>
    </member>
    <member name="P:TitleAttribute.Value">
      <inheritdoc cref="P:Sandbox.Internal.ITitleProvider.Value" />
    </member>
    <member name="T:DescriptionAttribute">
      <summary>
            Sets the description of a type or a type member. This attribute is usually applied automatically by codegen based on the XML comment of the type or member.
            This info can then be retrieved via DisplayInfo library.
            </summary>
    </member>
    <member name="P:DescriptionAttribute.Value">
      <inheritdoc cref="P:Sandbox.Internal.IDescriptionProvider.Value" />
    </member>
    <member name="T:CategoryAttribute">
      <summary>
            Sets the category or the group of a type or a type member.
            This info can then be retrieved via DisplayInfo library.
            </summary>
    </member>
    <member name="P:CategoryAttribute.Value">
      <inheritdoc cref="P:Sandbox.Internal.ICategoryProvider.Value" />
    </member>
    <member name="T:GroupAttribute">
      <summary>
            Sets the category or the group of a type or a type member.
            This info can then be retrieved via DisplayInfo library.
            </summary>
    </member>
    <member name="P:GroupAttribute.Value">
      <inheritdoc cref="P:Sandbox.Internal.ICategoryProvider.Value" />
    </member>
    <member name="P:GroupAttribute.StartFolded">
      <summary>
            If true then the group should start closed
            </summary>
    </member>
    <member name="T:ToggleGroupAttribute">
      <summary>
            Very much like a GroupAttribute, except we're indicating that the group can be toggle on and off using the named property
            </summary>
    </member>
    <member name="T:IconAttribute">
      <summary>
            Sets the icon of a type or a type member. Colors are expected in HTML formats, like "rgb(255,255,255)" or "#FFFFFF".
            This info can then be retrieved via DisplayInfo library.
            </summary>
    </member>
    <member name="P:IconAttribute.Value">
      <inheritdoc cref="P:Sandbox.Internal.IIconProvider.Value" />
    </member>
    <member name="P:IconAttribute.BackgroundColor">
      <summary>
            The preferred background color for the icon.
            </summary>
    </member>
    <member name="P:IconAttribute.ForegroundColor">
      <summary>
            The preferred color of the icon itself.
            </summary>
    </member>
    <member name="T:OrderAttribute">
      <summary>
            Visual order of this member for UI purposes.
            This info can then be retrieved via DisplayInfo library.
            </summary>
    </member>
    <member name="P:OrderAttribute.Value">
      <summary>
            The visual order.
            </summary>
    </member>
    <member name="T:IUninheritable">
      <summary>
            If applied to an attribute on a class, it won't be inherited from its base classes.
            </summary>
    </member>
    <member name="T:TimeRangeAttribute">
      <summary>
            For use with Curves, allows you to define a custom range for the time
            </summary>
    </member>
    <member name="T:ValueRangeAttribute">
      <summary>
            For use with Curves, allows you to define a custom range for the value
            </summary>
    </member>
    <member name="T:TagAttribute">
      <summary>
            Adds a single or multiple tags for this type or member. Tags can then be retrieved via DisplayInfo library.
            </summary>
    </member>
    <member name="P:TagAttribute.Value">
      <summary>
            The tags to add for this type or member.
            </summary>
    </member>
    <member name="M:TagAttribute.EnumerateValues">
      <summary>
            Returns all the tags as an enumerable.
            </summary>
      <returns />
    </member>
    <member name="T:AliasAttribute">
      <summary>
            Alternate class name(s) for this type to the one specified via LibraryAttribute. This info can then be retrieved via DisplayInfo library.
            </summary>
    </member>
    <member name="P:AliasAttribute.Value">
      <summary>
            The aliases for this class.
            </summary>
    </member>
    <member name="T:EditorAttribute">
      <summary>
            Tell the tools or gameui property editor which editor we should be using for this property or type.
            </summary>
    </member>
    <member name="P:EditorAttribute.Value">
      <summary>
            The editor to use.
            </summary>
    </member>
    <member name="T:SpawnableAttribute">
      <summary>
            This entity is expected to be spawnable in-game, like from Sandbox's spawnmenu.
            </summary>
    </member>
    <member name="T:HideInEditorAttribute">
      <summary>
            Hide this in tools/editors.
            </summary>
    </member>
    <member name="T:MinMaxAttribute">
      <summary>
            Mark property as having a minimum and maximum value.
            </summary>
    </member>
    <member name="P:MinMaxAttribute.MinValue">
      <summary>
            The minimum value for this property.
            </summary>
    </member>
    <member name="P:MinMaxAttribute.MaxValue">
      <summary>
            The maximum value for this property.
            </summary>
    </member>
    <member name="T:EditorModelAttribute">
      <summary>
            Declare a model to represent this entity in editor. This is a common attribute so it's leaked out of the Editor namespace.
            </summary>
    </member>
    <member name="P:EditorModelAttribute.Model">
      <summary>
            The model to display in the editor.
            </summary>
    </member>
    <member name="P:EditorModelAttribute.CastShadows">
      <summary>
            Whether the model should cast shadows in the editor.
            </summary>
    </member>
    <member name="P:EditorModelAttribute.FixedBounds">
      <summary>
            Don't reorient bounds. This is used for things that have fixed bounds in the game, like info_player_start.
            </summary>
    </member>
    <member name="P:EditorModelAttribute.StaticColor">
      <summary>
            Tint color for this editor model instance when the entity it represents is static.
            </summary>
    </member>
    <member name="P:EditorModelAttribute.DynamicColor">
      <summary>
            Tint color for this editor model instance when the entity it represents is dynamic.
            </summary>
    </member>
    <member name="T:DefaultValueAttribute">
      <summary>
            Sometimes with CodeGen we want reflection to be able to get the original initial value
            of a property (which is set with {get;set;} = initialvalue;). For this reason sometimes
            we'll drop this attribute on that property.
            You might want to use this manually for instances where codegen can't define the default
            value. This will usually happen for structs like vector and color.. if the default value isn't
            defined as a number or string.
            </summary>
    </member>
    <member name="P:DefaultValueAttribute.Value">
      <summary>
            The default value.
            </summary>
    </member>
    <member name="T:TasksPersistOnContextResetAttribute">
      <summary>
            Allows any task defined in this assembly to continue after a sync context expires.
            Other tasks that await tasks in this assembly will still be cancelled if their assembly
            isn't also marked with this attribute.
            </summary>
    </member>
    <member name="T:System.Collections.ObjectModel.ObservableDictionary`2">
      <summary>
            A dictionary with callbacks for when changes occur.
            </summary>
    </member>
    <member name="P:System.Collections.ObjectModel.ObservableDictionary`2.Dictionary">
      <summary>
            The dictionary being observed.
            </summary>
    </member>
    <member name="E:System.Collections.ObjectModel.ObservableDictionary`2.CollectionChanged">
      <summary>
            Called when the dictionary's key-value pairs have changed.
            </summary>
    </member>
    <member name="E:System.Collections.ObjectModel.ObservableDictionary`2.PropertyChanged">
      <inheritdoc cref="M:System.Collections.ObjectModel.ObservableDictionary`2.OnPropertyChanged(System.String)" />
    </member>
    <member name="M:System.Collections.ObjectModel.ObservableDictionary`2.AddRange(System.Collections.Generic.IDictionary{`0,`1})">
      <summary>
            Merge given dictionary into this one.
            </summary>
      <param name="items">The items to add into this dictionary.</param>
      <exception cref="T:System.ArgumentNullException">Thrown when the input dictionary is null.</exception>
      <exception cref="T:System.ArgumentException">Thrown when this dictionary already has an element with same key as the input dictionary.</exception>
    </member>
    <member name="M:System.Collections.ObjectModel.ObservableDictionary`2.OnPropertyChanged(System.String)">
      <summary>
            Called when a property (such as element count) of the dictionary has changed.
            </summary>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0">
      <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex" />-derived type for the CollapseWhiteSpaceRegex method.</summary>
    </member>
    <member name="F:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0.Instance">
      <summary>Cached, thread-safe singleton instance.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0.#ctor">
      <summary>Initializes the instance.</summary>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0.RunnerFactory">
      <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner" /> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0.RunnerFactory.CreateInstance">
      <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner" /> used by methods on <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0.RunnerFactory.Runner">
      <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
      <summary>Scan the <paramref name="inputSpan" /> starting from base.runtextstart for the next match.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
      <summary>Search <paramref name="inputSpan" /> starting from base.runtextpos for the next location a match could possibly start.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
      <returns>true if a possible match was found; false if no more matches are possible.</returns>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.CollapseWhiteSpaceRegex_0.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
      <summary>Determine whether <paramref name="inputSpan" /> at base.runtextpos is a match for the regular expression.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
      <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1">
      <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex" />-derived type for the CollapseSpacesAndTabsRegex method.</summary>
    </member>
    <member name="F:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1.Instance">
      <summary>Cached, thread-safe singleton instance.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1.#ctor">
      <summary>Initializes the instance.</summary>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1.RunnerFactory">
      <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner" /> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1.RunnerFactory.CreateInstance">
      <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner" /> used by methods on <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1.RunnerFactory.Runner">
      <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
      <summary>Scan the <paramref name="inputSpan" /> starting from base.runtextstart for the next match.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
      <summary>Search <paramref name="inputSpan" /> starting from base.runtextpos for the next location a match could possibly start.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
      <returns>true if a possible match was found; false if no more matches are possible.</returns>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.CollapseSpacesAndTabsRegex_1.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
      <summary>Determine whether <paramref name="inputSpan" /> at base.runtextpos is a match for the regular expression.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
      <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2">
      <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex" />-derived type for the RemoveSpacesAroundLineBreaksRegex method.</summary>
    </member>
    <member name="F:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2.Instance">
      <summary>Cached, thread-safe singleton instance.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2.#ctor">
      <summary>Initializes the instance.</summary>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2.RunnerFactory">
      <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner" /> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2.RunnerFactory.CreateInstance">
      <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner" /> used by methods on <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2.RunnerFactory.Runner">
      <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
      <summary>Scan the <paramref name="inputSpan" /> starting from base.runtextstart for the next match.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
      <summary>Search <paramref name="inputSpan" /> starting from base.runtextpos for the next location a match could possibly start.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
      <returns>true if a possible match was found; false if no more matches are possible.</returns>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.RemoveSpacesAroundLineBreaksRegex_2.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
      <summary>Determine whether <paramref name="inputSpan" /> at base.runtextpos is a match for the regular expression.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
      <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.Pattern_3">
      <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex" />-derived type for the Pattern method.</summary>
    </member>
    <member name="F:System.Text.RegularExpressions.Generated.Pattern_3.Instance">
      <summary>Cached, thread-safe singleton instance.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.Pattern_3.#ctor">
      <summary>Initializes the instance.</summary>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.Pattern_3.RunnerFactory">
      <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner" /> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.Pattern_3.RunnerFactory.CreateInstance">
      <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner" /> used by methods on <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.Pattern_3.RunnerFactory.Runner">
      <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.Pattern_3.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
      <summary>Scan the <paramref name="inputSpan" /> starting from base.runtextstart for the next match.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.Pattern_3.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
      <summary>Search <paramref name="inputSpan" /> starting from base.runtextpos for the next location a match could possibly start.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
      <returns>true if a possible match was found; false if no more matches are possible.</returns>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.Pattern_3.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
      <summary>Determine whether <paramref name="inputSpan" /> at base.runtextpos is a match for the regular expression.</summary>
      <param name="inputSpan">The text being scanned by the regular expression.</param>
      <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
    </member>
    <member name="T:System.Text.RegularExpressions.Generated.Utilities">
      <summary>Helper methods used by generated <see cref="T:System.Text.RegularExpressions.Regex" />-derived implementations.</summary>
    </member>
    <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout">
      <summary>Default timeout value set in <see cref="T:System.AppContext" />, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> if none was set.</summary>
    </member>
    <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_hasTimeout">
      <summary>Whether <see cref="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout" /> is non-infinite.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPop(System.Int32[],System.Int32@,System.Int32@,System.Int32@)">
      <summary>Pops 2 values from the backtracking stack.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32)">
      <summary>Pushes 1 value onto the backtracking stack.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32,System.Int32)">
      <summary>Pushes 2 values onto the backtracking stack.</summary>
    </member>
    <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32,System.Int32,System.Int32)">
      <summary>Pushes 3 values onto the backtracking stack.</summary>
    </member>
    <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_whitespace">
      <summary>Supports searching for characters in or not in "\t\n\v\f\r \u0085             \u2028\u2029  　".</summary>
    </member>
    <member name="T:Color">
      <summary>
            Represents a color using 4 floats (rgba), with 0-1 range.
            </summary>
    </member>
    <member name="F:Color.r">
      <summary>
            The red color component, in range of 0-1, which <b>can be exceeded</b>.
            </summary>
    </member>
    <member name="F:Color.g">
      <summary>
            The green color component, in range of 0-1, which <b>can be exceeded</b>.
            </summary>
    </member>
    <member name="F:Color.b">
      <summary>
            The blue color component, in range of 0-1, which <b>can be exceeded</b>.
            </summary>
    </member>
    <member name="F:Color.a">
      <summary>
            The alpha/transparency color component, in range of 0 (fully transparent) to 1 (fully opaque), which <b>can be exceeded</b>.
            </summary>
    </member>
    <member name="M:Color.#ctor(System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Initialize a color with each component set to given values, in range [0,1]
            </summary>
    </member>
    <member name="M:Color.#ctor(System.Single@,System.Single@)">
      <summary>
            Initialize a color with the same value for each color, but a different value for alpha
            </summary>
    </member>
    <member name="M:Color.#ctor(System.Single)">
      <summary>
            Initialize a color with each component set to given value, even alpha.
            </summary>
      <param name="all">A number in range [0-1]</param>
    </member>
    <member name="M:Color.#ctor(System.UInt32)">
      <summary>
            Initialize from an integer of the form 0xAABBGGRR.
            </summary>
      <param name="raw">Packed integer of the form 0xAABBGGRR.</param>
    </member>
    <member name="M:Color.#ctor(System.Int32)">
      <summary>
            Initialize from an integer of the form 0xAABBGGRR.
            </summary>
      <param name="raw">Packed integer of the form 0xAABBGGRR.</param>
    </member>
    <member name="M:Color.WithAlpha(System.Single)">
      <summary>
            Returns this color with its alpha value changed
            </summary>
      <param name="alpha">The required alpha value, usually between 0-1</param>
    </member>
    <member name="M:Color.WithAlphaMultiplied(System.Single)">
      <summary>
            Similar to <see cref="M:Color.WithAlpha(System.Single)" /> but multiplies the alpha instead of replacing.
            </summary>
    </member>
    <member name="M:Color.WithRed(System.Single)">
      <summary>
            Returns this color with its red value changed
            </summary>
    </member>
    <member name="M:Color.WithGreen(System.Single)">
      <summary>
            Returns this color with its green value changed
            </summary>
    </member>
    <member name="M:Color.WithBlue(System.Single)">
      <summary>
            Returns this color with its blue value changed
            </summary>
    </member>
    <member name="M:Color.ToHsv">
      <summary>
            Converts this color to a HSV format.
            </summary>
      <returns>The HSV color.</returns>
    </member>
    <member name="M:Color.ToColor32(System.Boolean)">
      <summary>
            Convert to a Color32 (a 32 bit color value)
            </summary>
      <param name="srgb">If true we'll convert to the srgb color space</param>
    </member>
    <member name="M:Color.Min(Color@,Color@)">
      <summary>
            Returns a new color with each component being the minimum of the 2 given colors.
            </summary>
      <param name="a">Color A</param>
      <param name="b">Color B</param>
      <returns>The new color with minimum values.</returns>
    </member>
    <member name="M:Color.Max(Color@,Color@)">
      <summary>
            Returns a new color with each component being the maximum of the 2 given colors.
            </summary>
      <param name="a">Color A</param>
      <param name="b">Color B</param>
      <returns>The new color with maximum values.</returns>
    </member>
    <member name="P:Color.Luminance">
      <summary>
            Returns the luminance of the color, basically it's grayscale value or "black and white version".
            </summary>
    </member>
    <member name="P:Color.IsRepresentableInHex">
      <summary>
            Returns true if this color can be represented in hexadecimal format (#RRGGBB[AA]).
            This may not be the case if the color components are outside of [0,1] range.
            </summary>
    </member>
    <member name="P:Color.IsSdr">
      <summary>
            Returns true if all components are between 0 and 1
            </summary>
    </member>
    <member name="P:Color.IsHdr">
      <summary>
            Returns true if any component exceeds 1
            </summary>
    </member>
    <member name="F:Color.White">
      <summary>
            Fully opaque white color.
            </summary>
    </member>
    <member name="F:Color.Gray">
      <summary>
            Fully opaque gray color, right between white and black.
            </summary>
    </member>
    <member name="F:Color.Black">
      <summary>
            Fully opaque black color.
            </summary>
    </member>
    <member name="F:Color.Red">
      <summary>
            Fully opaque pure red color.
            </summary>
    </member>
    <member name="F:Color.Green">
      <summary>
            Fully opaque pure green color.
            </summary>
    </member>
    <member name="F:Color.Blue">
      <summary>
            Fully opaque pure blue color.
            </summary>
    </member>
    <member name="F:Color.Yellow">
      <summary>
            Fully opaque yellow color.
            </summary>
    </member>
    <member name="F:Color.Orange">
      <summary>
            Fully opaque orange color.
            </summary>
    </member>
    <member name="F:Color.Cyan">
      <summary>
            Fully opaque cyan color.
            </summary>
    </member>
    <member name="F:Color.Magenta">
      <summary>
            Fully opaque magenta color.
            </summary>
    </member>
    <member name="F:Color.Transparent">
      <summary>
            Fully transparent color.
            </summary>
    </member>
    <member name="P:Color.Hex">
      <summary>
            String representation of the form "#RRGGBB[AA]".
            </summary>
    </member>
    <member name="P:Color.Rgba">
      <summary>
            String representation in the form of <see href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgba">rgba</see>( r, g, b, a )
            css function notation.
            </summary>
    </member>
    <member name="P:Color.Rgb">
      <summary>
            String representation in the form of <see href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgb">rgb</see>( r, g, b )
            css function notation.
            </summary>
    </member>
    <member name="P:Color.RgbaInt">
      <summary>
            Integer representation of the form 0xRRGGBBAA.
            </summary>
    </member>
    <member name="P:Color.RgbInt">
      <summary>
            Integer representation of the form 0xRRGGBB.
            </summary>
    </member>
    <member name="P:Color.RawInt">
      <summary>
            Integer representation of the form 0xAABBGGRR as used by native code.
            </summary>
    </member>
    <member name="P:Color.Random">
      <summary>
            Returns a random color out of 8 preset colors.
            </summary>
    </member>
    <member name="M:Color.ToString(System.Boolean,System.Boolean)">
      <summary>
            Converts the color to a string with given parameters.
            </summary>
      <param name="hex">Convert to Hex string if possible.</param>
      <param name="rgba">Convert to CSS rgba function</param>
      <returns>The string representation of this color.</returns>
    </member>
    <member name="M:Color.Average(Color[])">
      <summary>
            Returns a color whose components are averaged of all given colors.
            </summary>
      <param name="values">The colors to get average of.</param>
      <returns>The average color.</returns>
    </member>
    <member name="M:Color.Lerp(Color@,Color@,System.Single,System.Boolean)">
      <summary>
            Performs linear interpolation between two colors.
            </summary>
      <param name="a">The source color.</param>
      <param name="b">The target color.</param>
      <param name="frac">Fraction to the target color. 0 will return source color, 1 will return target color, 0.5 will "mix" the 2 colors equally.</param>
      <param name="clamped">Clamp fraction to range of [0,1]. If not clamped, the color will be extrapolated.</param>
      <returns>The interpolated color.</returns>
    </member>
    <member name="M:Color.LerpTo(Color@,System.Single,System.Boolean)">
      <summary>
            Performs linear interpolation between this and given colors.
            </summary>
      <param name="target">Color B</param>
      <param name="frac">Fraction, where 0 would return this, 0.5 would return a point between this and given colors, and 1 would return the given color.</param>
      <param name="clamp">Whether to clamp the fraction argument between [0,1]</param>
      <returns />
    </member>
    <member name="M:Color.FromBytes(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a color from 0-255 range inputs, converting them to 0-1 range.
            </summary>
      <param name="r">The red component.</param>
      <param name="g">The green component.</param>
      <param name="b">The blue component.</param>
      <param name="a">The alpha/transparency component.</param>
      <returns />
    </member>
    <member name="M:Color.FromRgb(System.UInt32)">
      <summary>
            Converts an integer of the form 0xRRGGBB into the color #RRGGBB with 100% alpha.
            </summary>
      <param name="rgb">Integer between 0x000000 and 0xffffff representing a color.</param>
    </member>
    <member name="M:Color.FromRgba(System.UInt32)">
      <summary>
            Converts an integer of the form 0xRRGGBBAA into the color #RRGGBBAA.
            </summary>
      <param name="rgba">Integer between 0x00000000 and 0xffffffff representing a color with alpha.</param>
    </member>
    <member name="M:Color.AdjustHue(System.Single)">
      <summary>
            Increases or decreases this color's hue
            </summary>
      <param name="amount">A number between -360 and 360 to add to the color's hue</param>
      <returns>The adjusted color</returns>
    </member>
    <member name="M:Color.Darken(System.Single)">
      <summary>
            Darkens the color by given amount.
            </summary>
      <param name="fraction">How much to darken the color by, in range of 0 (not at all) to 1 (fully black). Negative values will lighten the color.</param>
      <returns>The darkened color.</returns>
    </member>
    <member name="M:Color.Lighten(System.Single)">
      <summary>
            Lightens the color by given amount.
            </summary>
      <param name="fraction">How much to lighten the color by, in range of 0 (not at all) to 1 (double the color). Negative values will darken the color.</param>
      <returns>The lightened color.</returns>
    </member>
    <member name="M:Color.Invert">
      <summary>
            Returns inverted color. Alpha is unchanged.
            </summary>
      <returns>The inverted color.</returns>
    </member>
    <member name="M:Color.Desaturate(System.Single)">
      <summary>
            Desaturates the color by given amount.
            </summary>
      <param name="fraction">How much to desaturate the color by, in range of 0 (not at all) to 1 (no saturation, i.e. fully white). Negative values will saturate the color.</param>
      <returns>The desaturated color.</returns>
    </member>
    <member name="M:Color.Saturate(System.Single)">
      <summary>
            Saturates the color by given amount.
            </summary>
      <param name="fraction">How much to saturate the color by, in range of 0 (not at all) to 1 (double the saturation). Negative values will desaturate the color.</param>
      <returns>The saturated color.</returns>
    </member>
    <member name="M:Color.ComponentCountChangedBetweenColors(Color)">
      <summary>
            Returns how many color components would be changed between this color and another color
            </summary>
    </member>
    <member name="F:Color.WebColours">
      <summary>
            All the web colors by name that can be used in style sheets.
            </summary>
    </member>
    <member name="M:Color.Parse(System.String)">
      <summary>
            Parse the color from a string. Many common formats are supported.
            </summary>
      <param name="value">The string to parse.</param>
      <returns>The parsed color if operation completed successfully.</returns>
    </member>
    <member name="M:Color.TryParse(System.String,Color@)">
      <summary>
            Try to parse the color. Returns true on success
            </summary>
    </member>
    <member name="M:Color.op_Multiply(Color@,System.Single)">
      <summary>
            Multiply each component of this color by given value.
            </summary>
      <param name="c1">Color to multiply.</param>
      <param name="f">Scalar value to multiply each color component by.</param>
      <returns>The multiplication result.</returns>
    </member>
    <member name="P:Color.Item(System.Int32)">
      <summary>
            Get color components by numerical index.
            </summary>
      <param name="index">Index of the color component to request, 0-3 being RGBA</param>
      <returns>The requested color component</returns>
      <exception cref="T:System.IndexOutOfRangeException">Thrown when requested index is out of range of [0,3]</exception>
    </member>
    <member name="F:Color.Rgba16.r">
      <summary>
            The red color component
            </summary>
    </member>
    <member name="F:Color.Rgba16.g">
      <summary>
            The green color component
            </summary>
    </member>
    <member name="F:Color.Rgba16.b">
      <summary>
            The blue color component
            </summary>
    </member>
    <member name="F:Color.Rgba16.a">
      <summary>
            The alpha/transparency color component, in range of 0 (fully transparent) to 255 (fully opaque).
            </summary>
    </member>
    <member name="M:Color.Rgba16.ToColor">
      <summary>
            Convert this object to <see cref="T:Color" />.
            </summary>
      <returns>The converted color struct.</returns>
    </member>
    <member name="T:Color32">
      <summary>
             A 32bit color, commonly used by things like vertex buffers.
            
             The functionality on this is purposely left minimal so we're encouraged to use the regular <see cref="T:Color" /> struct.
             </summary>
    </member>
    <member name="F:Color32.r">
      <summary>
            The red color component, in range of 0-255.
            </summary>
    </member>
    <member name="F:Color32.g">
      <summary>
            The green color component, in range of 0-255.
            </summary>
    </member>
    <member name="F:Color32.b">
      <summary>
            The blue color component, in range of 0-255.
            </summary>
    </member>
    <member name="F:Color32.a">
      <summary>
            The alpha/transparency color component, in range of 0 (fully transparent) to 255 (fully opaque).
            </summary>
    </member>
    <member name="M:Color32.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
      <summary>
            Initialize a color with each component set to given values, in range [0,255]
            </summary>
    </member>
    <member name="M:Color32.#ctor(System.Byte)">
      <summary>
            Initialize a color with each component set to given value, even alpha.
            </summary>
      <param name="all">A number in range [0-255]</param>
    </member>
    <member name="M:Color32.#ctor(System.UInt32)">
      <summary>
            Initialize from an integer of the form 0xAABBGGRR.
            </summary>
      <param name="raw">Packed integer of the form 0xAABBGGRR.</param>
    </member>
    <member name="M:Color32.#ctor(System.Int32)">
      <summary>
            Initialize from an integer of the form 0xAABBGGRR.
            </summary>
      <param name="raw">Packed integer of the form 0xAABBGGRR.</param>
    </member>
    <member name="P:Color32.White">
      <summary>
            A constant representing a fully opaque color white.
            </summary>
    </member>
    <member name="P:Color32.Black">
      <summary>
            A constant representing a fully opaque color black.
            </summary>
    </member>
    <member name="P:Color32.Transparent">
      <summary>
            A constant representing a fully transparent color.
            </summary>
    </member>
    <member name="M:Color32.FromRgb(System.UInt32)">
      <summary>
            Converts an integer of the form 0xRRGGBB into the color #RRGGBB with 100% alpha.
            </summary>
      <param name="rgb">Integer between 0x000000 and 0xffffff representing a color.</param>
    </member>
    <member name="M:Color32.FromRgba(System.UInt32)">
      <summary>
            Converts an integer of the form 0xRRGGBBAA into the color #RRGGBBAA.
            </summary>
      <param name="rgba">Integer between 0x00000000 and 0xffffffff representing a color with alpha.</param>
    </member>
    <member name="M:Color32.ToColor">
      <summary>
            Convert this object to <see cref="T:Color" />.
            </summary>
      <returns>The converted color struct.</returns>
    </member>
    <member name="M:Color32.ToColor(System.Boolean)">
      <summary>
            Convert this object to <see cref="T:Color" />.
            </summary>
      <param name="srgb">If true we'll convert from the srgb color space to linear</param>
      <returns>The converted color struct.</returns>
    </member>
    <member name="M:Color32.Min(Color32,Color32)">
      <summary>
            Returns a new color with each component being the minimum of the 2 given colors.
            </summary>
      <param name="a">Color A</param>
      <param name="b">Color B</param>
      <returns>The new color with minimum values.</returns>
    </member>
    <member name="M:Color32.Max(Color32,Color32)">
      <summary>
            Returns a new color with each component being the maximum of the 2 given colors.
            </summary>
      <param name="a">Color A</param>
      <param name="b">Color B</param>
      <returns>The new color with maximum values.</returns>
    </member>
    <member name="P:Color32.Hex">
      <summary>
            String representation of the form "#RRGGBB[AA]".
            </summary>
    </member>
    <member name="P:Color32.Rgba">
      <summary>
            String representation in the form of <see href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgba">rgba</see>( r, g, b, a )
            css function notation.
            </summary>
    </member>
    <member name="P:Color32.Rgb">
      <summary>
            String representation in the form of <see href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgb">rgb</see>( r, g, b )
            css function notation.
            </summary>
    </member>
    <member name="P:Color32.RgbaInt">
      <summary>
            Integer representation of the form 0xRRGGBBAA.
            </summary>
    </member>
    <member name="P:Color32.RgbInt">
      <summary>
            Integer representation of the form 0xRRGGBB.
            </summary>
    </member>
    <member name="P:Color32.RawInt">
      <summary>
            Integer representation of the form 0xAABBGGRR as used by native code.
            </summary>
    </member>
    <member name="M:Color32.Write(System.IO.BinaryWriter)">
      <summary>
            Write this color to a binary writer.
            </summary>
      <param name="writer">Writer to write to.</param>
    </member>
    <member name="M:Color32.Read(System.IO.BinaryReader)">
      <summary>
            Read a color from binary reader.
            </summary>
      <param name="reader">Reader to read from.</param>
      <returns>The read color.</returns>
    </member>
    <member name="M:Color32.Parse(System.String)">
      <summary>
            Parse a string to a color, in format "255 255 255 255" or "255,255,255". Alpha is optional.
            </summary>
      <param name="value">The value to parse.</param>
      <returns>The color parsed from the string, or null if we failed to do so.</returns>
    </member>
    <member name="T:ColorHsv">
      <summary>
            A color in <a href="https://upload.wikimedia.org/wikipedia/commons/a/a0/Hsl-hsv_models.svg">Hue-Saturation-Value/Brightness</a> format.
            </summary>
    </member>
    <member name="P:ColorHsv.Hue">
      <summary>
            Hue component of this color in range 0 to 360.
            </summary>
    </member>
    <member name="P:ColorHsv.Saturation">
      <summary>
            Saturation of this color in range 0 (white) to 1 (full color).
            </summary>
    </member>
    <member name="P:ColorHsv.Value">
      <summary>
            Brightness of this color in range 0 (black) to 1 (full color).
            </summary>
    </member>
    <member name="P:ColorHsv.Alpha">
      <summary>
            Transparency of this color in range 0 (fully transparent) to 1 (fully opaque).
            </summary>
    </member>
    <member name="M:ColorHsv.#ctor(System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Initializes a new HSV/HSB color. Hue is in the range of [0-360] and all other values are in range [0,1]
            </summary>
      <param name="h">The hue color component.</param>
      <param name="s">Saturation of the color.</param>
      <param name="v">Brightness of the color.</param>
      <param name="a">Alpha of the color.</param>
    </member>
    <member name="M:ColorHsv.ToColor">
      <summary>
            Convert this object to <see cref="T:Color" />.
            </summary>
      <returns>The converted color struct.</returns>
    </member>
    <member name="M:ColorHsv.WithHue(System.Single)">
      <summary>
            Returns a copy of this color with given Hue value.
            </summary>
      <param name="hue">The Hue override.</param>
      <returns>The new color.</returns>
    </member>
    <member name="M:ColorHsv.WithSaturation(System.Single)">
      <summary>
            Returns a copy of this color with given Saturation value.
            </summary>
      <param name="saturation">The Saturation override.</param>
      <returns>The new color.</returns>
    </member>
    <member name="M:ColorHsv.WithValue(System.Single)">
      <summary>
            Returns a copy of this color with given Brightness value.
            </summary>
      <param name="value">The Brightness override.</param>
      <returns>The new color.</returns>
    </member>
    <member name="M:ColorHsv.WithAlpha(System.Single)">
      <summary>
            Returns a copy of this color with given alpha value.
            </summary>
      <param name="alpha">The alpha override.</param>
      <returns>The new color.</returns>
    </member>
    <member name="T:Angles">
      <summary>
            Euler angles. Unlike a <see cref="T:Rotation">Rotation</see>, Euler angles can represent multiple revolutions (rotations) around an axis,
            but suffer from issues like gimbal lock and lack of a defined "up" vector. Use <see cref="T:Rotation">Rotation</see> for most cases.
            </summary>
    </member>
    <member name="F:Angles.pitch">
      <summary>
            The pitch component, typically up/down.
            </summary>
    </member>
    <member name="F:Angles.yaw">
      <summary>
            The yaw component, typically left/right.
            </summary>
    </member>
    <member name="F:Angles.roll">
      <summary>
            The roll component, basically rotation around the axis.
            </summary>
    </member>
    <member name="M:Angles.#ctor(System.Single,System.Single,System.Single)">
      <summary>
            Initializes the angles object with given components.
            </summary>
      <param name="pitch">The Pitch component.</param>
      <param name="yaw">The Yaw component.</param>
      <param name="roll">The roll component.</param>
    </member>
    <member name="M:Angles.#ctor(Angles)">
      <summary>
            Copies values of given angles object.
            </summary>
    </member>
    <member name="M:Angles.#ctor(Vector3)">
      <summary>
            Where x, y and z represent the pitch, yaw and roll respectively.
            </summary>
    </member>
    <member name="M:Angles.#ctor(System.Single)">
      <summary>
            Initializes the angles object with all components set to given value.
            </summary>
    </member>
    <member name="M:Angles.ToRotation">
      <summary>
            Converts these Euler angles to a rotation. The angles will be normalized.
            </summary>
      <returns />
    </member>
    <member name="M:Angles.AsVector3">
      <summary>
            Return as a Vector3, where x = pitch etc
            </summary>
    </member>
    <member name="F:Angles.Zero">
      <summary>
            An angle constant that has all its values set to 0. Use this instead of making a static 0,0,0 object yourself.
            </summary>
    </member>
    <member name="P:Angles.Random">
      <summary>
            Returns the angles of a uniformly random rotation.
            </summary>
    </member>
    <member name="M:Angles.IsNearlyZero(System.Double)">
      <summary>
            Returns true if this angles object's components are all nearly zero with given tolerance.
            </summary>
    </member>
    <member name="M:Angles.WithPitch(System.Single)">
      <summary>
            Returns this angles object with given pitch component.
            </summary>
    </member>
    <member name="M:Angles.WithYaw(System.Single)">
      <summary>
            Returns this angles object with given yaw component.
            </summary>
    </member>
    <member name="M:Angles.WithRoll(System.Single)">
      <summary>
            Returns this angles object with given roll component.
            </summary>
    </member>
    <member name="M:Angles.Parse(System.String)">
      <summary>
            Given a string, try to convert this into an angles object. The format is "p,y,r".
            </summary>
    </member>
    <member name="M:Angles.Parse(System.String,System.IFormatProvider)">
      <inheritdoc cref="M:Angles.Parse(System.String)" />
    </member>
    <member name="M:Angles.TryParse(System.String,Angles@)">
      <inheritdoc cref="M:Angles.Parse(System.String)" />
    </member>
    <member name="M:Angles.TryParse(System.String,System.IFormatProvider,Angles@)">
      <inheritdoc cref="M:Angles.Parse(System.String)" />
    </member>
    <member name="M:Angles.Clamped">
      <summary>
            Returns clamped version of this object, meaning the angle on each axis is transformed to range of [0,360).
            </summary>
    </member>
    <member name="P:Angles.Normal">
      <summary>
            Returns normalized version of this object, meaning the angle on each axis is normalized to range of (-180,180].
            </summary>
    </member>
    <member name="M:Angles.ClampAngle(System.Single)">
      <summary>
            Clamps the angle to range of [0, 360)
            </summary>
    </member>
    <member name="M:Angles.NormalizeAngle(System.Single)">
      <summary>
            Normalizes the angle to range of (-180, 180]
            </summary>
    </member>
    <member name="M:Angles.Lerp(Angles@,Angles@,System.Single)">
      <summary>
            Performs linear interpolation on the two given angle objects.
            </summary>
      <param name="source">Angle A</param>
      <param name="target">Angle B</param>
      <param name="frac">Fraction in range [0,1] between the 2 angle objects to use for interpolation.</param>
    </member>
    <member name="M:Angles.LerpTo(Angles,System.Single)">
      <summary>
            Performs linear interpolation on the two given angle objects.
            </summary>
      <param name="target">Angle B</param>
      <param name="frac">Fraction in range [0,1] between the 2 angle objects to use for interpolation.</param>
    </member>
    <member name="M:Angles.AngleVector(Angles)">
      <summary>
            Converts an angle to a forward vector.
            </summary>
    </member>
    <member name="P:Angles.Forward">
      <summary>
            The forward direction vector for this angle.
            </summary>
    </member>
    <member name="M:Angles.SnapToGrid(System.Single,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Snap to grid
            </summary>
    </member>
    <member name="T:BBox">
      <summary>
            An <a href="https://en.wikipedia.org/wiki/Minimum_bounding_box">Axis Aligned Bounding Box</a>.
            </summary>
    </member>
    <member name="F:BBox.Mins">
      <summary>
            The minimum corner extents of the AABB. Values on each axis should be mathematically smaller than values on the same axis of <see cref="F:BBox.Maxs" />. See <see cref="M:Vector3.Sort(Vector3@,Vector3@)" /></summary>
    </member>
    <member name="F:BBox.Maxs">
      <summary>
            The maximum corner extents of the AABB. Values on each axis should be mathematically larger than values on the same axis of <see cref="F:BBox.Mins" />. See <see cref="M:Vector3.Sort(Vector3@,Vector3@)" /></summary>
    </member>
    <member name="M:BBox.#ctor(Vector3,Vector3)">
      <summary>
            Initialize an AABB with given mins and maxs corners. See <see cref="M:Vector3.Sort(Vector3@,Vector3@)" />.
            </summary>
    </member>
    <member name="M:BBox.#ctor(Vector3,System.Single)">
      <summary>
            Initializes a zero sized BBox with given center. This is useful if you intend to use AddPoint to expand the box later.
            </summary>
    </member>
    <member name="P:BBox.Corners">
      <summary>
            An enumerable that contains all corners of this AABB.
            </summary>
    </member>
    <member name="P:BBox.Center">
      <summary>
            Calculated center of the AABB.
            </summary>
    </member>
    <member name="P:BBox.Size">
      <summary>
            Calculated size of the AABB on each axis.
            </summary>
    </member>
    <member name="P:BBox.Extents">
      <summary>
            The extents of the bbox. This is half the size.
            </summary>
    </member>
    <member name="M:BBox.Translate(Vector3@)">
      <summary>
            Move this box by this amount and return
            </summary>
    </member>
    <member name="M:BBox.Rotate(Rotation@)">
      <summary>
            Rotate this box by this amount and return
            </summary>
    </member>
    <member name="M:BBox.Transform(Transform@)">
      <summary>
            Transform this box by this amount and return
            </summary>
    </member>
    <member name="M:BBox.Scale(Vector3@)">
      <summary>
            Scale this box by this amount and return
            </summary>
    </member>
    <member name="P:BBox.RandomPointInside">
      <summary>
            Returns a random point within this AABB.
            </summary>
    </member>
    <member name="P:BBox.RandomPointOnEdge">
      <summary>
            Returns a random point within this AABB.
            </summary>
    </member>
    <member name="P:BBox.Volume">
      <summary>
            Returns the physical volume of this AABB.
            </summary>
    </member>
    <member name="M:BBox.Contains(BBox@)">
      <summary>
            Returns true if this AABB completely contains given AABB
            </summary>
    </member>
    <member name="M:BBox.Contains(Vector3@)">
      <summary>
            Returns true if this AABB contains given point
            </summary>
    </member>
    <member name="M:BBox.Overlaps(BBox@)">
      <summary>
            Returns true if this AABB somewhat overlaps given AABB
            </summary>
    </member>
    <member name="M:BBox.AddPoint(Vector3@)">
      <summary>
            Returns this bbox but stretched to include given point
            </summary>
    </member>
    <member name="M:BBox.AddBBox(BBox@)">
      <summary>
            Returns this bbox but stretched to include given bbox
            </summary>
    </member>
    <member name="M:BBox.Grow(System.Single@)">
      <summary>
            Return a slightly bigger box
            </summary>
    </member>
    <member name="M:BBox.ClosestPoint(Vector3@)">
      <summary>
            Returns the closest point on this AABB to another point
            </summary>
    </member>
    <member name="M:BBox.FromHeightAndRadius(System.Single,System.Single)">
      <summary>
            Creates an AABB of <paramref name="radius" /> length and depth, and given <paramref name="height" /></summary>
    </member>
    <member name="M:BBox.FromPositionAndSize(Vector3@,System.Single)">
      <summary>
            Creates an AABB at given position <paramref name="center" /> and given <paramref name="size" /> which acts as a <b>diameter</b> of a sphere contained within the AABB.
            </summary>
    </member>
    <member name="M:BBox.FromPositionAndSize(Vector3,Vector3)">
      <summary>
            Creates an AABB at given position <paramref name="center" /> and given <paramref name="size" /> a.k.a. "extents".
            </summary>
    </member>
    <member name="M:BBox.FromBoxes(System.Collections.Generic.IEnumerable{BBox})">
      <summary>
            Create a bounding box from an arbituary number of other boxes
            </summary>
    </member>
    <member name="M:BBox.FromPoints(System.Collections.Generic.IEnumerable{Vector3},System.Single)">
      <summary>
            Create a bounding box from an arbituary number of points
            </summary>
    </member>
    <member name="M:BBox.Trace(Ray@,System.Single,System.Single@)">
      <summary>
            Trace a ray against this box. If hit then return the distance.
            </summary>
    </member>
    <member name="M:BBox.ToString">
      <summary>
            Formats this AABB into a string "mins x,y,z, maxs x,y,z"
            </summary>
    </member>
    <member name="M:BBox.GetVolume">
      <summary>
            Get the volume of this AABB
            </summary>
    </member>
    <member name="M:BBox.Snap(System.Single)">
      <summary>
            Snap this AABB to a grid
            </summary>
    </member>
    <member name="T:Capsule">
      <summary>
            A capsule object, defined by 2 points and a radius. A capsule is a cylinder with round ends (inset half spheres on each end).
            </summary>
    </member>
    <member name="F:Capsule.CenterA">
      <summary>
            Position of point A.
            </summary>
    </member>
    <member name="F:Capsule.CenterB">
      <summary>
            Position of point B.
            </summary>
    </member>
    <member name="F:Capsule.Radius">
      <summary>
            Radius of a capsule.
            </summary>
    </member>
    <member name="M:Capsule.FromHeightAndRadius(System.Single,System.Single)">
      <summary>
            Creates a capsule where Point A is radius units above the ground and Point B is height minus radius units above the ground.
            </summary>
    </member>
    <member name="P:Capsule.RandomPointInside">
      <summary>
            Returns a random point within this capsule.
            </summary>
    </member>
    <member name="P:Capsule.RandomPointOnEdge">
      <summary>
            Returns a random point on the edge of this capsule.
            </summary>
    </member>
    <member name="T:Line">
      <summary>
            Represents a line in 3D space.
            </summary>
    </member>
    <member name="P:Line.Start">
      <summary>
            Start position of the line.
            </summary>
    </member>
    <member name="P:Line.End">
      <summary>
            End position of the line.
            </summary>
    </member>
    <member name="P:Line.Delta">
      <summary>
            Returns the result of b - a
            </summary>
    </member>
    <member name="P:Line.Center">
      <summary>
            Returns the midpoint between a and b
            </summary>
    </member>
    <member name="M:Line.Trace(Ray@,System.Single,System.Single)">
      <summary>
            Perform a "trace" between this line and given ray. If the 2 lines intersect, returns true.
            </summary>
      <param name="ray">The ray to test against.</param>
      <param name="radius">Radius of this line, which essentially makes this a capsule, since direct line-to-line intersections are very improbable. Must be above 0.</param>
      <param name="maxDistance">Maximum allowed distance from the origin of the ray to the intersection.</param>
      <returns>Whether there was an intersection or not.</returns>
    </member>
    <member name="M:Line.ClosestPoint(Vector3@)">
      <summary>
            Returns closest point on this line to the given point.
            </summary>
    </member>
    <member name="M:Line.ClosestPoint(Ray@,Vector3@)">
      <summary>
            Returns closest point on this line to the given ray.
            </summary>
    </member>
    <member name="M:Line.ClosestPoint(Ray@,Vector3@,Vector3@)">
      <summary>
            Returns closest point on this line to the given ray.
            </summary>
    </member>
    <member name="M:Line.Distance(Vector3)">
      <summary>
            Returns closest distance from this line to given point.
            </summary>
    </member>
    <member name="M:Line.Distance(Vector3,Vector3@)">
      <summary>
            Returns closest distance from this line to given point.
            </summary>
    </member>
    <member name="M:Line.Clip(Sandbox.Plane)">
      <summary>
            Returns this line, clamped on the positive side of a plane. Null if
            line is fully clipped.
            </summary>
    </member>
    <member name="M:Line.SqrDistance(Vector3)">
      <summary>
            Returns closest squared distance from this line to given point.
            </summary>
    </member>
    <member name="T:Matrix">
      <summary>
            Represents a 4x4 matrix.
            </summary>
    </member>
    <member name="P:Matrix.Identity">
      <summary>
            Returns the multiplicative identity matrix.
            </summary>
    </member>
    <member name="P:Matrix.Inverted">
      <summary>
            Returns inverse of this matrix.
            </summary>
    </member>
    <member name="M:Matrix.Lerp(Matrix,Matrix,System.Single)">
      <summary>
            Performs linear interpolation from one matrix to another.
            </summary>
    </member>
    <member name="M:Matrix.Slerp(Matrix,Matrix,System.Single)">
      <summary>
            Performs spherical interpolation from one matrix to another.
            </summary>
    </member>
    <member name="M:Matrix.ToString">
      <summary>
            Formats the matrix and returns it as a string.
            </summary>
      <returns />
    </member>
    <member name="M:Matrix.Transpose">
      <summary>
            Returns transposed version of this matrix, meaning columns in this matrix become rows in the returned matrix and rows in this matrix become columns in the returned one.
            </summary>
      <returns />
    </member>
    <member name="M:Matrix.Transform(Vector3)">
      <summary>
            Transforms a vector by a 4x4 matrix
            </summary>
    </member>
    <member name="M:Matrix.TransformNormal(Vector3)">
      <summary>
            Transforms a normal vector by a specified 4x4 matrix
            </summary>
    </member>
    <member name="P:Matrix.ToSteamVrCoordinateSystem">
      <summary>
            Converts a <see cref="T:Matrix" /> from Source to SteamVr coordinate system and scale
            </summary>
      <remarks>
            Source: X=forwards, Y=left, Z=up, scale = inches.
            SteamVr: X=right, Y=up, Z=backwards, scale = meters.
            </remarks>
    </member>
    <member name="T:QRectF">
      <summary>
            You're not seeing things, QT uses fucking doubles
            </summary>
    </member>
    <member name="T:RangedFloat">
      <summary>
            A float between two values, which can be randomized or fixed.
            </summary>
    </member>
    <member name="P:RangedFloat.Min">
      <summary>
            The minimum value of the float range.
            </summary>
    </member>
    <member name="P:RangedFloat.Max">
      <summary>
            The maximum value of the float range. For <see cref="F:RangedFloat.RangeType.Fixed" />,
            this will be the same as <see cref="P:RangedFloat.Min" />.
            </summary>
    </member>
    <member name="P:RangedFloat.FixedValue">
      <summary>
            The fixed value. Setting this will convert us to a fixed value
            </summary>
    </member>
    <member name="P:RangedFloat.RangeValue">
      <summary>
            The range value. Setting this will convert us to a range value
            </summary>
    </member>
    <member name="T:RangedFloat.RangeType">
      <summary>
            Range type of <see cref="T:RangedFloat" />.
            </summary>
    </member>
    <member name="F:RangedFloat.RangeType.Fixed">
      <summary>
            Single value, both minimum and maximum value.
            </summary>
    </member>
    <member name="F:RangedFloat.RangeType.Between">
      <summary>
            Random value between given minimum and maximum.
            </summary>
    </member>
    <member name="P:RangedFloat.Range">
      <summary>
            Range type of this float.
            </summary>
    </member>
    <member name="M:RangedFloat.#ctor(System.Single)">
      <summary>
            Initialize the float as a fixed value.
            </summary>
    </member>
    <member name="M:RangedFloat.#ctor(System.Single,System.Single)">
      <summary>
            Initialize the float as a random value between given min and max.
            </summary>
      <param name="min">The minimum possible value for this float.</param>
      <param name="max">The maximum possible value for this float.</param>
    </member>
    <member name="M:RangedFloat.GetValue">
      <summary>
            Returns the final value of this ranged float, randomizing between min and max values.
            </summary>
    </member>
    <member name="M:RangedFloat.Pattern">
      <remarks>
            Pattern:<br /><code>^[\\[\\]\\s"]*(?&lt;min&gt;-?\\d+(?:\\.\\d+)?)(?:[\\s,;]+(?&lt;max&gt;-?\\d+(?:\\.\\d+)?))?(?:[\\s,;]+(?&lt;format&gt;\\d+))?[\\[\\]\\s"]*$</code><br />
            Explanation:<br /><code>
            ○ Match if at the beginning of the string.<br />
            ○ Match a character in the set ["[]\s] greedily any number of times.<br />
            ○ "min" capture group.<br />
                ○ Match '-' atomically, optionally.<br />
                ○ Match a Unicode digit greedily at least once.<br />
                ○ Optional (greedy).<br />
                    ○ Match '.'.<br />
                    ○ Match a Unicode digit greedily at least once.<br />
            ○ Optional (greedy).<br />
                ○ Match a character in the set [,;\s] greedily at least once.<br />
                ○ "max" capture group.<br />
                    ○ Match '-' atomically, optionally.<br />
                    ○ Match a Unicode digit greedily at least once.<br />
                    ○ Optional (greedy).<br />
                        ○ Match '.'.<br />
                        ○ Match a Unicode digit greedily at least once.<br />
            ○ Optional (greedy).<br />
                ○ Match a character in the set [,;\s] greedily at least once.<br />
                ○ "format" capture group.<br />
                    ○ Match a Unicode digit greedily at least once.<br />
            ○ Match a character in the set ["[]\s] greedily any number of times.<br />
            ○ Match if at the end of the string or if before an ending newline.<br /></code></remarks>
    </member>
    <member name="M:RangedFloat.Parse(System.String)">
      <summary>
            Parse a ranged float from a string. Format is <c>"min[ max]"</c>.
            </summary>
    </member>
    <member name="M:RangedFloat.ToString">
      <summary>
            Returns a string representation of this range, that can be passed to <see cref="M:RangedFloat.Parse(System.String)" /> to re-create this range.
            Format is <c>"min[ max]"</c>.
            </summary>
    </member>
    <member name="T:Ray">
      <summary>
            A struct describing an origin and direction
            </summary>
    </member>
    <member name="P:Ray.Position">
      <summary>
            Origin of the ray.
            </summary>
    </member>
    <member name="P:Ray.Forward">
      <summary>
            Direction of the ray.
            </summary>
    </member>
    <member name="M:Ray.ToLocal(Transform@)">
      <summary>
            Convert a ray to be local to this transform
            </summary>
    </member>
    <member name="M:Ray.ToWorld(Transform@)">
      <summary>
            Convert a ray from being local to this transform
            </summary>
    </member>
    <member name="M:Ray.Project(System.Single)">
      <summary>
            Returns a point on the ray at given distance.
            </summary>
      <param name="distance">How far from the <see cref="P:Ray.Position" /> the point should be.</param>
      <returns>The point at given distance.</returns>
    </member>
    <member name="T:Rect3D">
      <summary>
            Generally used to describe the size of textures
            </summary>
    </member>
    <member name="T:Rotation">
      <summary>
            Represents a Quaternion rotation. Can be interpreted as a direction unit vector (x,y,z) + rotation around the direction vector (w) which represents the up direction.
            Unlike <see cref="T:Angles" />, this cannot store multiple revolutions around an axis.
            </summary>
    </member>
    <member name="P:Rotation.x">
      <summary>
            The X component of this rotation.
            </summary>
    </member>
    <member name="P:Rotation.y">
      <summary>
            The Y component of this rotation.
            </summary>
    </member>
    <member name="P:Rotation.z">
      <summary>
            The Z component of this rotation.
            </summary>
    </member>
    <member name="P:Rotation.w">
      <summary>
            The W component of this rotation (rotation around the normal defined by X,Y,Z components).
            </summary>
    </member>
    <member name="M:Rotation.#ctor">
      <summary>
            Initializes this rotation to identity.
            </summary>
    </member>
    <member name="M:Rotation.#ctor(System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Initializes the rotation from given components.
            </summary>
      <param name="x">The X component.</param>
      <param name="y">The Y component.</param>
      <param name="z">The Z component.</param>
      <param name="w">The W component.</param>
    </member>
    <member name="M:Rotation.#ctor(Vector3,System.Single)">
      <summary>
            Initializes the rotation from a normal vector + rotation around it.
            </summary>
      <param name="v">The normal vector.</param>
      <param name="w">The W component, aka rotation around the normal vector.</param>
    </member>
    <member name="P:Rotation.Forward">
      <summary>
            The forwards direction of this rotation.
            </summary>
    </member>
    <member name="P:Rotation.Backward">
      <summary>
            The backwards direction of this rotation.
            </summary>
    </member>
    <member name="P:Rotation.Right">
      <summary>
            The right hand direction of this rotation.
            </summary>
    </member>
    <member name="P:Rotation.Left">
      <summary>
            The left hand direction of this rotation.
            </summary>
    </member>
    <member name="P:Rotation.Up">
      <summary>
            The upwards direction of this rotation.
            </summary>
    </member>
    <member name="P:Rotation.Down">
      <summary>
            The downwards direction of this rotation.
            </summary>
    </member>
    <member name="P:Rotation.Inverse">
      <summary>
            Returns the inverse of this rotation.
            </summary>
    </member>
    <member name="P:Rotation.Normal">
      <summary>
            Divides each component of the rotation by its length, normalizing the rotation.
            </summary>
    </member>
    <member name="P:Rotation.Conjugate">
      <summary>
            Returns conjugate of this rotation, meaning the X Y and Z components are negated.
            </summary>
    </member>
    <member name="P:Rotation.Random">
      <summary>
            Returns a uniformly random rotation.
            </summary>
    </member>
    <member name="M:Rotation.FromAxis(Vector3,System.Single)">
      <summary>
            Create from angle and an axis
            </summary>
      <remarks>
        <paramref name="axis" /> vector must be normalized before calling this method or the resulting <see cref="T:Rotation" /> will be incorrect.</remarks>
    </member>
    <member name="M:Rotation.From(Angles)">
      <summary>
            Create a Rotation (quaternion) from Angles
            </summary>
    </member>
    <member name="M:Rotation.From(System.Single,System.Single,System.Single)">
      <summary>
            Create a Rotation (quaternion) from pitch yaw roll (degrees)
            </summary>
    </member>
    <member name="M:Rotation.FromPitch(System.Single)">
      <summary>
            Create a Rotation (quaternion) from pitch (degrees)
            </summary>
    </member>
    <member name="M:Rotation.FromYaw(System.Single)">
      <summary>
            Create a Rotation (quaternion) from yaw (degrees)
            </summary>
    </member>
    <member name="M:Rotation.FromRoll(System.Single)">
      <summary>
            Create a Rotation (quaternion) from roll (degrees)
            </summary>
    </member>
    <member name="M:Rotation.LookAt(Vector3,Vector3)">
      <summary>
            Create a Rotation (quaternion) from a forward and up vector
            </summary>
    </member>
    <member name="M:Rotation.LookAt(Vector3)">
      <summary>
            Create a Rotation (quaternion) from a forward vector, using <see cref="F:Vector3.Up" /> as
            an up vector. This won't give nice results if <paramref name="forward" /> is very close to straight
            up or down, if that can happen you should use <see cref="M:Rotation.LookAt(Vector3,Vector3)" />.
            </summary>
    </member>
    <member name="F:Rotation.Identity">
      <summary>
            A rotation that represents no rotation.
            </summary>
    </member>
    <member name="M:Rotation.Difference(Rotation,Rotation)">
      <summary>
            Returns the difference between two rotations, as a rotation
            </summary>
    </member>
    <member name="M:Rotation.Distance(Rotation)">
      <summary>
            The degree angular distance between this rotation and the target
            </summary>
    </member>
    <member name="M:Rotation.Angle">
      <summary>
            Returns the turn length of this rotation (from identity) in degrees
            </summary>
    </member>
    <member name="M:Rotation.Angles">
      <summary>
            Return this Rotation as pitch, yaw, roll angles
            </summary>
    </member>
    <member name="M:Rotation.Pitch">
      <summary>
            Return this Rotation pitch
            </summary>
    </member>
    <member name="M:Rotation.Yaw">
      <summary>
            Return this Rotation yaw
            </summary>
    </member>
    <member name="M:Rotation.Roll">
      <summary>
            Return this Rotation roll
            </summary>
    </member>
    <member name="M:Rotation.Lerp(Rotation,Rotation,System.Single,System.Boolean)">
      <summary>
            Perform a linear interpolation from a to b by given amount.
            </summary>
    </member>
    <member name="M:Rotation.Slerp(Rotation,Rotation,System.Single,System.Boolean)">
      <summary>
            Perform a spherical interpolation from a to b by given amount.
            </summary>
    </member>
    <member name="M:Rotation.LerpTo(Rotation,System.Single,System.Boolean)">
      <summary>
            Perform a linear interpolation from this rotation to a target rotation by given amount.
            </summary>
    </member>
    <member name="M:Rotation.SlerpTo(Rotation,System.Single,System.Boolean)">
      <summary>
            Perform a spherical interpolation from this rotation to a target rotation by given amount.
            </summary>
    </member>
    <member name="M:Rotation.Clamp(Rotation,System.Single)">
      <summary>
            Clamp to within degrees of passed rotation
            </summary>
    </member>
    <member name="M:Rotation.Clamp(Rotation,System.Single,System.Single@)">
      <summary>
            Clamp to within degrees of passed rotation. Also pases out the change in degrees, if any.
            </summary>
    </member>
    <member name="M:Rotation.RotateAroundAxis(Vector3,System.Single)">
      <summary>
            A convenience function that rotates this rotation around a given axis given amount of degrees
            </summary>
      <remarks>
        <paramref name="axis" /> vector must be normalized before calling this method or the resulting <see cref="T:Rotation" /> will be incorrect.</remarks>
    </member>
    <member name="M:Rotation.SmoothDamp(Rotation,Rotation@,Vector3@,System.Single,System.Single)">
      <summary>
            Smoothly move towards the target rotation
            </summary>
    </member>
    <member name="M:Rotation.ClosestAxis(Vector3)">
      <summary>
            Will give you the axis most aligned with the given normal
            </summary>
    </member>
    <member name="M:Rotation.FromToRotation(Vector3@,Vector3@)">
      <summary>
            Returns a Rotation that rotates from one direction to another.
            </summary>
    </member>
    <member name="M:Rotation.Parse(System.String)">
      <summary>
            Given a string, try to convert this into a quaternion rotation. The format is "x,y,z,w"
            </summary>
    </member>
    <member name="M:Rotation.Parse(System.String,System.IFormatProvider)">
      <inheritdoc cref="M:Rotation.Parse(System.String)" />
    </member>
    <member name="M:Rotation.TryParse(System.String,Rotation@)">
      <inheritdoc cref="M:Rotation.Parse(System.String)" />
    </member>
    <member name="M:Rotation.TryParse(System.String,System.IFormatProvider,Rotation@)">
      <inheritdoc cref="M:Rotation.Parse(System.String)" />
    </member>
    <member name="M:Rotation.AlmostEqual(Rotation@,System.Single)">
      <summary>
            Returns true if we're nearly equal to the passed rotation.
            </summary>
      <param name="r">The value to compare with</param>
      <param name="delta">The max difference between component values</param>
      <returns>True if nearly equal</returns>
    </member>
    <member name="T:Transform">
      <summary>
            A struct containing a position, rotation and scale. This is commonly used in engine to describe
            entity position, bone position and scene object position.
            </summary>
    </member>
    <member name="F:Transform.Zero">
      <summary>
            Represents a zero transform, that being, a transform with scale of 1, position of <see cref="F:Vector3.Zero" /> and rotation of <see cref="F:Rotation.Identity" />.
            </summary>
    </member>
    <member name="F:Transform.Position">
      <summary>
            Position of the transform.
            </summary>
    </member>
    <member name="F:Transform.Scale">
      <summary>
            Scale of the transform. Does not itself scale <see cref="F:Transform.Position" /> or <see cref="F:Transform.Rotation" />.
            </summary>
    </member>
    <member name="P:Transform.UniformScale">
      <summary>
            A uniform scale component. Generally the scale is uniform, and we'll just access the .x component.
            </summary>
    </member>
    <member name="F:Transform.Rotation">
      <summary>
            Rotation of this transform.
            </summary>
    </member>
    <member name="P:Transform.SafeScale">
      <summary>
            This scale can be used if you need to divide by scale without resulting in infinity or NaN values.
            </summary>
    </member>
    <member name="P:Transform.IsValid">
      <summary>
            Returns true if position, scale and rotation are valid
            </summary>
    </member>
    <member name="M:Transform.PointToLocal(Vector3@)">
      <summary>
            Convert a point in world space to a point in this transform's local space
            </summary>
    </member>
    <member name="M:Transform.NormalToLocal(Vector3@)">
      <summary>
            Convert a world normal to a local normal
            </summary>
    </member>
    <member name="M:Transform.RotationToLocal(Rotation@)">
      <summary>
            Convert a world rotation to a local rotation
            </summary>
    </member>
    <member name="M:Transform.PointToWorld(Vector3@)">
      <summary>
            Convert a point in this transform's local space to a point in world space
            </summary>
    </member>
    <member name="M:Transform.NormalToWorld(Vector3@)">
      <summary>
            Convert a local normal to a world normal
            </summary>
    </member>
    <member name="M:Transform.RotationToWorld(Rotation@)">
      <summary>
            Convert a local rotation to a world rotation
            </summary>
    </member>
    <member name="M:Transform.ToLocal(Transform@)">
      <summary>
            Convert child transform from the world to a local transform
            </summary>
    </member>
    <member name="M:Transform.ToWorld(Transform@)">
      <summary>
            Convert child transform from local to the world
            </summary>
    </member>
    <member name="M:Transform.Lerp(Transform@,Transform@,System.Single,System.Boolean)">
      <summary>
            Perform linear interpolation from one transform to another.
            </summary>
    </member>
    <member name="M:Transform.LerpTo(Transform@,System.Single,System.Boolean)">
      <summary>
            Linearly interpolate from this transform to given transform.
            </summary>
    </member>
    <member name="M:Transform.Add(Vector3@,System.Boolean)">
      <summary>
            Add a position to this transform and return the result.
            </summary>
    </member>
    <member name="M:Transform.WithPosition(Vector3@)">
      <summary>
            Return this transform with a new position.
            </summary>
    </member>
    <member name="M:Transform.WithPosition(Vector3@,Rotation@)">
      <summary>
            Return this transform with a new position and rotation
            </summary>
    </member>
    <member name="M:Transform.WithRotation(Rotation@)">
      <summary>
            Return this transform with a new rotation.
            </summary>
    </member>
    <member name="M:Transform.WithScale(System.Single)">
      <summary>
            Return this transform with a new scale.
            </summary>
    </member>
    <member name="M:Transform.WithScale(Vector3@)">
      <summary>
            Return this transform with a new scale.
            </summary>
    </member>
    <member name="P:Transform.ForwardRay">
      <summary>
            Return a ray from this transform, which goes from the center along the Forward
            </summary>
    </member>
    <member name="M:Transform.RotateAround(Vector3@,Rotation@)">
      <summary>
            Rotate this transform around given point by given rotation and return the result.
            </summary>
      <param name="center">Point to rotate around.</param>
      <param name="rot">How much to rotate by. <see cref="M:Rotation.FromAxis(Vector3,System.Single)" /> can be useful.</param>
      <returns>The rotated transform.</returns>
    </member>
    <member name="M:Transform.Concat(Transform,Transform)">
      <summary>
            Concatenate (add together) the 2 given transforms and return a new resulting transform.
            </summary>
    </member>
    <member name="M:Transform.Parse(System.String)">
      <summary>
            Given a string, try to convert this into a transform. The format is <c>"px,py,pz,rx,ry,rz,rw"</c>.
            </summary>
    </member>
    <member name="M:Transform.ToString">
      <summary>
            Formats the Transform into a string "pos, rot, scale"
            </summary>
    </member>
    <member name="M:Transform.AlmostEqual(Transform@,System.Single)">
      <summary>
            Returns true if we're nearly equal to the passed transform.
            </summary>
      <param name="tx">The value to compare with</param>
      <param name="delta">The max difference between component values</param>
      <returns>True if nearly equal</returns>
    </member>
    <member name="T:Vector2">
      <summary>
            A 2-dimensional vector. Typically represents a position or size in 2D space.
            </summary>
    </member>
    <member name="P:Vector2.x">
      <summary>
            X component of this Vector.
            </summary>
    </member>
    <member name="P:Vector2.y">
      <summary>
            Y component of this Vector.
            </summary>
    </member>
    <member name="M:Vector2.#ctor(System.Single,System.Single)">
      <summary>
            Initializes a 2D vector with given components.
            </summary>
      <param name="x">The X component.</param>
      <param name="y">The Y component.</param>
    </member>
    <member name="M:Vector2.#ctor(System.Single)">
      <summary>
            Initializes the vector with all components set to the given value.
            </summary>
    </member>
    <member name="M:Vector2.#ctor(Vector3)">
      <summary>
            Initializes the 2D vector with components from given 3D vector, discarding the Z component.
            </summary>
    </member>
    <member name="P:Vector2.One">
      <summary>
            Returns a 2D vector with every component set to 1
            </summary>
    </member>
    <member name="P:Vector2.Zero">
      <summary>
            Returns a 2D vector with every component set to 0
            </summary>
    </member>
    <member name="P:Vector2.Up">
      <summary>
            Returns a 2D vector with Y set to 1. This represents the upwards direction in 2D space.
            </summary>
    </member>
    <member name="P:Vector2.Down">
      <summary>
            Returns a 2D vector with Y set to -1. This represents the downwards direction in 2D space.
            </summary>
    </member>
    <member name="P:Vector2.Left">
      <summary>
            Returns a 2D vector with X set to 1. This represents the left hand direction in 2D space.
            </summary>
    </member>
    <member name="P:Vector2.Right">
      <summary>
            Returns a 2D vector with X set to -1. This represents the right hand direction in 2D space.
            </summary>
    </member>
    <member name="P:Vector2.Random">
      <summary>
            Uniformly samples a 2D position from all points with distance at most 1 from the origin.
            </summary>
    </member>
    <member name="P:Vector2.Length">
      <summary>
            Returns the magnitude of the vector
            </summary>
    </member>
    <member name="P:Vector2.LengthSquared">
      <summary>
            This is faster than Length, so is better to use in certain circumstances
            </summary>
    </member>
    <member name="P:Vector2.Perpendicular">
      <summary>
            Returns a vector that runs perpendicular to this one
            </summary>
    </member>
    <member name="P:Vector2.IsNearZeroLength">
      <summary>
            Returns true if the squared length is less than 1e-8 (which is really near zero)
            </summary>
    </member>
    <member name="P:Vector2.Normal">
      <summary>
            Return the same vector but with a length of one
            </summary>
    </member>
    <member name="P:Vector2.Degrees">
      <summary>
            Return the angle of this vector in degrees, always between 0 and 360
            </summary>
    </member>
    <member name="M:Vector2.FromRadians(System.Single)">
      <summary>
            Returns a point on a circle at given rotation from X axis, counter clockwise.
            </summary>
    </member>
    <member name="M:Vector2.FromDegrees(System.Single)">
      <summary>
            Returns a point on a circle at given rotation from X axis, counter clockwise.
            </summary>
    </member>
    <member name="M:Vector2.DistanceBetween(Vector2,Vector2)">
      <summary>
            Returns distance between the 2 given vectors.
            </summary>
    </member>
    <member name="M:Vector2.Distance(Vector2@,Vector2@)">
      <summary>
            Returns distance between the 2 given vectors.
            </summary>
    </member>
    <member name="M:Vector2.Distance(Vector2)">
      <summary>
            Returns distance between this and given vectors.
            </summary>
    </member>
    <member name="M:Vector2.DistanceBetweenSquared(Vector2,Vector2)">
      <summary>
            Returns squared distance between the 2 given vectors. This is faster than <see cref="M:Vector2.DistanceBetween(Vector2,Vector2)">DistanceBetween</see>,
            and can be used for things like comparing distances, as long as only squared values are used.
            </summary>
    </member>
    <member name="M:Vector2.DistanceSquared(Vector2@,Vector2@)">
      <summary>
            Returns squared distance between the 2 given vectors. This is faster than <see cref="M:Vector2.DistanceBetween(Vector2,Vector2)">DistanceBetween</see>,
            and can be used for things like comparing distances, as long as only squared values are used.
            </summary>
    </member>
    <member name="M:Vector2.DistanceSquared(Vector2)">
      <summary>
            Returns squared distance between the 2 given vectors. This is faster than <see cref="M:Vector2.Distance(Vector2)">Distance</see>,
            and can be used for things like comparing distances, as long as only squared values are used.
            </summary>
    </member>
    <member name="M:Vector2.Dot(Vector2,Vector2)">
      <summary>
            Returns dot product between the 2 given vectors.
            </summary>
    </member>
    <member name="M:Vector2.AlmostEqual(Vector2,System.Single)">
      <summary>
            Returns true if we're nearly equal to the passed vector.
            </summary>
      <param name="v">The value to compare with</param>
      <param name="delta">The max difference between component values</param>
      <returns>True if nearly equal</returns>
    </member>
    <member name="M:Vector2.SnapToGrid(System.Single,System.Boolean,System.Boolean)">
      <summary>
            Snap to grid along all 3 axes.
            </summary>
    </member>
    <member name="M:Vector2.WithX(System.Single)">
      <summary>
            Return this vector with given X.
            </summary>
    </member>
    <member name="M:Vector2.WithY(System.Single)">
      <summary>
            Return this vector with given Y.
            </summary>
    </member>
    <member name="M:Vector2.Lerp(Vector2,Vector2,System.Single,System.Boolean)">
      <summary>
            Linearly interpolate from point a to point b.
            </summary>
    </member>
    <member name="M:Vector2.LerpTo(Vector2,System.Single,System.Boolean)">
      <summary>
            Linearly interpolate from this vector to given vector.
            </summary>
    </member>
    <member name="M:Vector2.Lerp(Vector2,Vector2,Vector2,System.Boolean)">
      <summary>
            Linearly interpolate from point a to point b with separate fraction for each axis.
            </summary>
    </member>
    <member name="M:Vector2.LerpTo(Vector2,Vector2,System.Boolean)">
      <summary>
            Linearly interpolate from this vector to given vector with separate fraction for each axis.
            </summary>
    </member>
    <member name="M:Vector2.Clamp(Vector2,Vector2)">
      <summary>
            Returns a vector each axis of which is clamped to between the 2 given vectors. Basically clamps a point to a square.
            </summary>
      <param name="otherMin">The mins vector. Values on each axis should be smaller than those of the maxs vector.</param>
      <param name="otherMax">The maxs vector. Values on each axis should be bigger than those of the mins vector.</param>
    </member>
    <member name="M:Vector2.Clamp(System.Single,System.Single)">
      <summary>
            Returns a vector each axis of which is clamped to given min and max values.
            </summary>
      <param name="min">Minimum value for each axis.</param>
      <param name="max">Maximum value for each axis.</param>
    </member>
    <member name="M:Vector2.Remap(Sandbox.Rect,Sandbox.Rect,System.Boolean)">
      <summary>
            Remaps from one range to another.
            </summary>
    </member>
    <member name="M:Vector2.ComponentMin(Vector2)">
      <summary>
            Returns a vector that has the minimum values on each axis between this vector and given vector.
            </summary>
    </member>
    <member name="M:Vector2.Min(Vector2,Vector2)">
      <summary>
            Returns a vector that has the minimum values on each axis between the 2 given vectors.
            </summary>
    </member>
    <member name="M:Vector2.ComponentMax(Vector2)">
      <summary>
            Returns a vector that has the maximum values on each axis between this vector and given vector.
            </summary>
    </member>
    <member name="M:Vector2.Max(Vector2,Vector2)">
      <summary>
            Returns a vector that has the maximum values on each axis between the 2 given vectors.
            </summary>
    </member>
    <member name="M:Vector2.Abs">
      <summary>
            Returns a new vector with all values positive. -5 becomes 5, etc.
            </summary>
    </member>
    <member name="M:Vector2.Direction(Vector2@,Vector2@)">
      <summary>
            Calculates the normalized direction vector from one point to another in 2D space.
            </summary>
      <param name="from" />
      <param name="to" />
      <returns />
    </member>
    <member name="M:Vector2.Parse(System.String)">
      <summary>
            Given a string, try to convert this into a Vector2. Example formatting is "x,y", "[x,y]", "x y", etc.
            </summary>
    </member>
    <member name="M:Vector2.TryParse(System.String,Vector2@)">
      <inheritdoc cref="M:Vector2.Parse(System.String)" />
    </member>
    <member name="M:Vector2.Parse(System.String,System.IFormatProvider)">
      <inheritdoc cref="M:Vector2.Parse(System.String)" />
    </member>
    <member name="M:Vector2.TryParse(System.String,System.IFormatProvider,Vector2@)">
      <inheritdoc cref="M:Vector2.Parse(System.String)" />
    </member>
    <member name="F:Vector2Int.x">
      <summary>
            The X component of this integer vector.
            </summary>
    </member>
    <member name="F:Vector2Int.y">
      <summary>
            The Y component of this integer vector.
            </summary>
    </member>
    <member name="M:Vector2Int.#ctor(System.Int32,System.Int32)">
      <summary>
            Initializes an integer vector with given components.
            </summary>
      <param name="x">The X component.</param>
      <param name="y">The Y component.</param>
    </member>
    <member name="M:Vector2Int.#ctor(System.Int32)">
      <summary>
            Initializes an integer vector with all components set to the same value.
            </summary>
      <param name="all">The value of the X and Y components.</param>
    </member>
    <member name="M:Vector2Int.#ctor(Vector2Int)">
      <summary>
            Initializes an integer vector with given components from another integer vector.
            </summary>
    </member>
    <member name="M:Vector2Int.#ctor(Vector3Int)">
      <summary>
            Initializes an integer vector with given components from another integer vector, discarding the Z component.
            </summary>
    </member>
    <member name="F:Vector2Int.One">
      <summary>
            An integer vector with all components set to 1.
            </summary>
    </member>
    <member name="F:Vector2Int.Zero">
      <summary>
            An integer vector with all components set to 0.
            </summary>
    </member>
    <member name="F:Vector2Int.Right">
      <summary>
            An integer vector with X set to 1. This represents the right direction.
            </summary>
    </member>
    <member name="F:Vector2Int.Left">
      <summary>
            An integer vector with X set to -1. This represents the left direction.
            </summary>
    </member>
    <member name="F:Vector2Int.Up">
      <summary>
            An integer vector with Y set to 1. This represents the up direction.
            </summary>
    </member>
    <member name="F:Vector2Int.Down">
      <summary>
            An integer vector with Y set to -1. This represents the down direction.
            </summary>
    </member>
    <member name="M:Vector2Int.ToString">
      <summary>
            Formats the integer vector as a string "x,y".
            </summary>
      <returns />
    </member>
    <member name="P:Vector2Int.Normal">
      <summary>
             Returns a unit version of this vector. Keep in mind this returns a Vector2 and not a Vector2Int.
            </summary>
    </member>
    <member name="P:Vector2Int.Degrees">
      <summary>
            Return the angle of this vector in degrees, always between 0 and 360.
            </summary>
    </member>
    <member name="P:Vector2Int.Length">
      <summary>
            Length (or magnitude) of the integer vector (Distance from 0,0)
            </summary>
    </member>
    <member name="P:Vector2Int.LengthSquared">
      <summary>
            Squared length of the integer vector. This is faster than <see cref="P:Vector2Int.Length">Length</see>, and can be used for things like comparing distances, as long as only squared values are used."/&gt;
            </summary>
    </member>
    <member name="P:Vector2Int.Perpendicular">
      <summary>
            Returns an integer vector that runs perpendicular to this one.
            </summary>
    </member>
    <member name="P:Vector2Int.IsZeroLength">
      <summary>
            Whether the length of this vector is zero or not.
            </summary>
    </member>
    <member name="M:Vector2Int.IsNearlyZero(System.Int32)">
      <summary>
            Returns true if value on every axis is less than or equal to tolerance
            </summary>
    </member>
    <member name="M:Vector2Int.ComponentMin(Vector2Int)">
      <summary>
            Returns an integer vector that has the minimum values on each axis of the two input vectors.
            </summary>
    </member>
    <member name="M:Vector2Int.ComponentMax(Vector2Int)">
      <summary>
            Returns an integer vector that has the maximum values on each axis of the two input vectors.
            </summary>
    </member>
    <member name="M:Vector2Int.Distance(Vector2Int)">
      <summary>
            Returns the distance between this vector and another.
            </summary>
    </member>
    <member name="M:Vector2Int.Distance(Vector2)">
      <summary>
            Returns the distance between this vector and another.
            </summary>
    </member>
    <member name="M:Vector2Int.SnapToGrid(System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Snap to grid along any of the 2 axes.
            </summary>
    </member>
    <member name="M:Vector2Int.Min(Vector2Int,Vector2Int)">
      <summary>
            Returns an integer vector that has the minimum values on each axis between 2 given vectors.
            </summary>
    </member>
    <member name="M:Vector2Int.Max(Vector2Int,Vector2Int)">
      <summary>
            Returns an integer vector that has the maximum values on each axis between 2 given vectors.
            </summary>
    </member>
    <member name="M:Vector2Int.Abs">
      <summary>
            Returns a new integer vector with all values positive. -5 becomes 5, ect.
            </summary>
    </member>
    <member name="M:Vector2Int.WithX(System.Int32)">
      <summary>
            Returns this integer vector with given X component.
            </summary>
    </member>
    <member name="M:Vector2Int.WithY(System.Int32)">
      <summary>
            Returns this integer vector with given Y component.
            </summary>
    </member>
    <member name="M:Vector2Int.Parse(System.String)">
      <summary>
            Given a string, try to convert this into a Vector2Int. Example formatting is "x,y", "[x,y]", "x y", etc.
            </summary>
    </member>
    <member name="M:Vector2Int.Parse(System.String,System.IFormatProvider)">
      <inheritdoc cref="M:Vector2Int.Parse(System.String)" />
    </member>
    <member name="M:Vector2Int.TryParse(System.String,System.IFormatProvider,Vector2Int@)">
      <inheritdoc cref="M:Vector2Int.Parse(System.String)" />
    </member>
    <member name="T:Vector3">
      <summary>
            A point in 3D space.
            </summary>
    </member>
    <member name="P:Vector3.x">
      <summary>
            The X component of this Vector.
            </summary>
    </member>
    <member name="P:Vector3.y">
      <summary>
            The Y component of this Vector.
            </summary>
    </member>
    <member name="P:Vector3.z">
      <summary>
            The Z component of this Vector.
            </summary>
    </member>
    <member name="M:Vector3.#ctor(System.Single,System.Single,System.Single)">
      <summary>
            Initializes a vector with given components.
            </summary>
      <param name="x">The X component.</param>
      <param name="y">The Y component.</param>
      <param name="z">The Z component.</param>
    </member>
    <member name="M:Vector3.#ctor(System.Single,System.Single)">
      <summary>
            Initializes a vector with given components and Z set to 0.
            </summary>
      <param name="x">The X component.</param>
      <param name="y">The Y component.</param>
    </member>
    <member name="M:Vector3.#ctor(Vector3@)">
      <summary>
            Initializes a vector3 from a given vector3, i.e. a copy.
            </summary>
    </member>
    <member name="M:Vector3.#ctor(Vector2@,System.Single)">
      <summary>
            Initializes a vector3 from given vector2 and the given Z component.
            </summary>
    </member>
    <member name="M:Vector3.#ctor(System.Single)">
      <summary>
            Initializes the vector with all components set to given value.
            </summary>
    </member>
    <member name="F:Vector3.One">
      <summary>
            A vector with all components set to 1.
            </summary>
    </member>
    <member name="F:Vector3.Zero">
      <summary>
            A vector with all components set to 0.
            </summary>
    </member>
    <member name="F:Vector3.Forward">
      <summary>
            A vector with X set to 1. This represents the forwards direction.
            </summary>
    </member>
    <member name="F:Vector3.Backward">
      <summary>
            A vector with X set to -1. This represents the backwards direction.
            </summary>
    </member>
    <member name="F:Vector3.Up">
      <summary>
            A vector with Z set to 1. This represents the upwards direction.
            </summary>
    </member>
    <member name="F:Vector3.Down">
      <summary>
            A vector with Z set to -1. This represents the downwards direction.
            </summary>
    </member>
    <member name="F:Vector3.Right">
      <summary>
            A vector with Y set to -1. This represents the right hand direction.
            </summary>
    </member>
    <member name="F:Vector3.Left">
      <summary>
            A vector with Y set to 1. This represents the left hand direction.
            </summary>
    </member>
    <member name="M:Vector3.ToString">
      <summary>
            Formats the Vector into a string "x,y,z"
            </summary>
      <returns />
    </member>
    <member name="P:Vector3.Normal">
      <summary>
            Returns a unit version of this vector. A unit vector has length of 1.
            </summary>
    </member>
    <member name="P:Vector3.Random">
      <summary>
            Uniformly samples a 3D position from all points with distance at most 1 from the origin.
            </summary>
    </member>
    <member name="P:Vector3.IsNaN">
      <summary>
            Returns true if x, y or z are NaN
            </summary>
    </member>
    <member name="P:Vector3.IsInfinity">
      <summary>
            Returns true if x, y or z are infinity
            </summary>
    </member>
    <member name="M:Vector3.WithX(System.Single)">
      <summary>
            Returns this vector with given X component.
            </summary>
      <param name="x">The override for X component.</param>
      <returns>The new vector.</returns>
    </member>
    <member name="M:Vector3.WithY(System.Single)">
      <summary>
            Returns this vector with given Y component.
            </summary>
      <param name="y">The override for Y component.</param>
      <returns>The new vector.</returns>
    </member>
    <member name="M:Vector3.WithZ(System.Single)">
      <summary>
            Returns this vector with given Z component.
            </summary>
      <param name="z">The override for Z component.</param>
      <returns>The new vector.</returns>
    </member>
    <member name="P:Vector3.Length">
      <summary>
            Length (or magnitude) of the vector (Distance from 0,0,0).
            </summary>
    </member>
    <member name="P:Vector3.LengthSquared">
      <summary>
            Squared length of the vector. This is faster than <see cref="P:Vector3.Length">Length</see>, and can be used for things like comparing distances, as long as only squared values are used.
            </summary>
    </member>
    <member name="P:Vector3.IsNearZeroLength">
      <summary>
            Whether length of this vector is nearly zero.
            </summary>
    </member>
    <member name="M:Vector3.IsNearlyZero(System.Single)">
      <summary>
            Returns true if value on every axis is less than tolerance away from zero
            </summary>
    </member>
    <member name="M:Vector3.ClampLength(System.Single)">
      <summary>
            Returns a vector whose length is limited to given maximum.
            </summary>
    </member>
    <member name="M:Vector3.ClampLength(System.Single,System.Single)">
      <summary>
            Returns a vector whose length is limited between given minimum and maximum.
            </summary>
    </member>
    <member name="M:Vector3.Clamp(Vector3,Vector3)">
      <summary>
            Returns a vector each axis of which is clamped to between the 2 given vectors. Basically clamps a point to an Axis Aligned Bounding Box (AABB).
            </summary>
      <param name="otherMin">The mins vector. Values on each axis should be smaller than those of the maxs vector. See <see cref="M:Vector3.Sort(Vector3@,Vector3@)">Vector3.Sort</see>.</param>
      <param name="otherMax">The maxs vector. Values on each axis should be bigger than those of the mins vector. See <see cref="M:Vector3.Sort(Vector3@,Vector3@)">Vector3.Sort</see>.</param>
    </member>
    <member name="M:Vector3.Clamp(System.Single,System.Single)">
      <summary>
            Returns a vector each axis of which is clamped to given min and max values.
            </summary>
      <param name="min">Minimum value for each axis.</param>
      <param name="max">Maximum value for each axis.</param>
    </member>
    <member name="M:Vector3.Clamp(Vector3@,Vector3@,Vector3@)">
      <summary>
            Restricts a vector between a minimum and a maximum value.
            </summary>
      <param name="value">The vector to restrict.</param>
      <param name="min">The mins vector. Values on each axis should be smaller than those of the maxs vector. See <see cref="M:Vector3.Sort(Vector3@,Vector3@)">Vector3.Sort</see>.</param>
      <param name="max">The maxs vector. Values on each axis should be bigger than those of the mins vector. See <see cref="M:Vector3.Sort(Vector3@,Vector3@)">Vector3.Sort</see>.</param>
    </member>
    <member name="M:Vector3.ComponentMin(Vector3@)">
      <summary>
            Returns a vector that has the minimum values on each axis between this vector and given vector.
            </summary>
    </member>
    <member name="M:Vector3.Min(Vector3@,Vector3@)">
      <summary>
            Returns a vector that has the minimum values on each axis between the 2 given vectors.
            </summary>
    </member>
    <member name="M:Vector3.ComponentMax(Vector3@)">
      <summary>
            Returns a vector that has the maximum values on each axis between this vector and given vector.
            </summary>
    </member>
    <member name="M:Vector3.Max(Vector3@,Vector3@)">
      <summary>
            Returns a vector that has the maximum values on each axis between the 2 given vectors.
            </summary>
    </member>
    <member name="M:Vector3.Lerp(Vector3,Vector3,System.Single,System.Boolean)">
      <summary>
            Performs linear interpolation between 2 given vectors.
            </summary>
      <param name="a">Vector A</param>
      <param name="b">Vector B</param>
      <param name="frac">Fraction, where 0 would return Vector A, 0.5 would return a point between the 2 vectors, and 1 would return Vector B.</param>
      <param name="clamp">Whether to clamp the fraction argument between [0,1]</param>
      <returns />
    </member>
    <member name="M:Vector3.LerpTo(Vector3@,System.Single,System.Boolean)">
      <summary>
            Performs linear interpolation between this and given vectors.
            </summary>
      <param name="target">Vector B</param>
      <param name="frac">Fraction, where 0 would return this, 0.5 would return a point between this and given vectors, and 1 would return the given vector.</param>
      <param name="clamp">Whether to clamp the fraction argument between [0,1]</param>
      <returns />
    </member>
    <member name="M:Vector3.Lerp(Vector3@,Vector3@,Vector3,System.Boolean)">
      <summary>
            Performs linear interpolation between 2 given vectors, with separate fraction for each vector component.
            </summary>
      <param name="a">Vector A</param>
      <param name="b">Vector B</param>
      <param name="frac">Fraction for each axis, where 0 would return Vector A, 0.5 would return a point between the 2 vectors, and 1 would return Vector B.</param>
      <param name="clamp">Whether to clamp the fraction argument between [0,1] on each axis</param>
      <returns />
    </member>
    <member name="M:Vector3.LerpTo(Vector3@,Vector3@,System.Boolean)">
      <summary>
            Performs linear interpolation between this and given vectors, with separate fraction for each vector component.
            </summary>
      <param name="target">Vector B</param>
      <param name="frac">Fraction for each axis, where 0 would return this, 0.5 would return a point between this and given vectors, and 1 would return the given vector.</param>
      <param name="clamp">Whether to clamp the fraction argument between [0,1] on each axis</param>
      <returns />
    </member>
    <member name="M:Vector3.Slerp(Vector3,Vector3,System.Single,System.Boolean)">
      <summary>
            Performs spherical linear interpolation (Slerp) between two vectors.
            </summary>
      <param name="a">Starting vector (A).</param>
      <param name="b">Target vector (B).</param>
      <param name="frac">Interpolation fraction: 0 returns A, 1 returns B, and values in between provide intermediate results along the spherical path.</param>
      <param name="clamp">If true, clamps the fraction between 0 and 1.</param>
      <returns>Interpolated vector along the spherical path.</returns>
    </member>
    <member name="M:Vector3.SlerpTo(Vector3@,System.Single,System.Boolean)">
      <summary>
            Performs spherical linear interpolation (Slerp) between this vector and a target vector.
            </summary>
      <param name="target">The target vector to interpolate towards.</param>
      <param name="frac">Interpolation fraction: 0 returns this vector, 1 returns the target vector, and values in between provide intermediate results along the spherical path.</param>
      <param name="clamp">If true, clamps the fraction between 0 and 1.</param>
      <returns>Interpolated vector along the spherical path.</returns>
    </member>
    <member name="M:Vector3.InverseLerp(Vector3,Vector3,Vector3,System.Boolean)">
      <summary>
            Given a position, and two other positions, calculate the inverse lerp position between those
            </summary>
    </member>
    <member name="M:Vector3.Cross(Vector3@,Vector3@)">
      <summary>
            Returns the cross product of the 2 given vectors.
            If the given vectors are linearly independent, the resulting vector is perpendicular to them both, also known as a normal of a plane.
            </summary>
    </member>
    <member name="M:Vector3.Cross(Vector3@)">
      <summary>
            Returns the cross product of this and the given vector.
            If this and the given vectors are linearly independent, the resulting vector is perpendicular to them both, also known as a normal of a plane.
            </summary>
    </member>
    <member name="M:Vector3.Dot(Vector3@,Vector3@)">
      <summary>
            Returns the scalar/dot product of the 2 given vectors.
            </summary>
    </member>
    <member name="M:Vector3.Dot(Vector3@)">
      <summary>
            Returns the scalar/dot product of this and the given vectors.
            </summary>
    </member>
    <member name="M:Vector3.DistanceBetween(Vector3@,Vector3@)">
      <summary>
            Returns distance between the 2 given vectors.
            </summary>
    </member>
    <member name="M:Vector3.Distance(Vector3@)">
      <summary>
            Returns distance between this vector to given vector.
            </summary>
    </member>
    <member name="M:Vector3.DistanceBetweenSquared(Vector3@,Vector3@)">
      <summary>
            Returns squared distance between the 2 given vectors. This is faster than <see cref="M:Vector3.DistanceBetween(Vector3@,Vector3@)">DistanceBetween</see>,
            and can be used for things like comparing distances, as long as only squared values are used.
            </summary>
    </member>
    <member name="M:Vector3.DistanceSquared(Vector3@)">
      <summary>
            Returns squared distance between this vector to given vector. This is faster than <see cref="M:Vector3.Distance(Vector3@)">Distance</see>,
            and can be used for things like comparing distances, as long as only squared values are used.
            </summary>
    </member>
    <member name="M:Vector3.Approach(System.Single,System.Single)">
      <summary>
            Returns a new vector whose length is closer to given target length by given amount.
            </summary>
      <param name="length">Target length.</param>
      <param name="amount">How much to subtract or add.</param>
    </member>
    <member name="M:Vector3.Abs">
      <summary>
            Returns a new vector with all values positive. -5 becomes 5, etc.
            </summary>
    </member>
    <member name="M:Vector3.Abs(Vector3@)">
      <summary>
            Returns a new vector with all values positive. -5 becomes 5, etc.
            </summary>
    </member>
    <member name="M:Vector3.Reflect(Vector3@,Vector3@)">
      <summary>
            Returns a reflected vector based on incoming direction and plane normal. Like a ray reflecting off of a mirror.
            </summary>
    </member>
    <member name="M:Vector3.VectorPlaneProject(Vector3@,Vector3@)">
      <summary>
        <a href="https://en.wikipedia.org/wiki/Vector_projection">Projects given vector</a> on a plane defined by <paramref name="planeNormal" />.
            </summary>
      <param name="v">The vector to project.</param>
      <param name="planeNormal">Normal of a plane to project onto.</param>
      <returns>The projected vector.</returns>
    </member>
    <member name="M:Vector3.ProjectOnNormal(Vector3@)">
      <summary>
        <a href="https://en.wikipedia.org/wiki/Vector_projection">Projects this vector</a> onto another vector.
            
             Basically extends the given normal/unit vector to be as long as necessary to make a right triangle (a triangle which has a 90 degree corner)
             between (0,0,0), this vector and the projected vector.
             </summary>
      <param name="normal" />
      <returns>The projected vector.</returns>
    </member>
    <member name="M:Vector3.Sort(Vector3@,Vector3@)">
      <summary>
            Sort these two vectors into min and max. This doesn't just swap the vectors, it sorts each component.
            So that min will come out containing the minimum x, y and z values.
            </summary>
    </member>
    <member name="M:Vector3.AlmostEqual(Vector3@,System.Single)">
      <summary>
            Returns true if we're nearly equal to the passed vector.
            </summary>
      <param name="v">The value to compare with</param>
      <param name="delta">The max difference between component values</param>
      <returns>True if nearly equal</returns>
    </member>
    <member name="M:Vector3.CubicBezier(Vector3@,Vector3@,Vector3@,Vector3@,System.Single)">
      <summary>
            Calculates position of a point on a cubic beizer curve at given fraction.
            </summary>
      <param name="source">Point A of the curve in world space.</param>
      <param name="target">Point B of the curve in world space.</param>
      <param name="sourceTangent">Tangent for the Point A in world space.</param>
      <param name="targetTangent">Tangent for the Point B in world space.</param>
      <param name="t">How far along the path to get a point on. Range is 0 to 1, inclusive.</param>
      <returns>The point on the curve</returns>
    </member>
    <member name="M:Vector3.Direction(Vector3@,Vector3@)">
      <summary>
            Calculates the normalized direction vector from one point to another in 3D space.
            </summary>
      <param name="from" />
      <param name="to" />
      <returns />
    </member>
    <member name="M:Vector3.SubtractDirection(Vector3@,System.Single)">
      <summary>
            Given a vector like 1,1,1 and direction 1,0,0, will return 0,1,1.
            This is useful for velocity collision type events, where you want to
            cancel out velocity based on a normal.
            For this to work properly, direction should be a normal, but you can scale
            how much you want to subtract by scaling the direction. Ie, passing in a direction
            with a length of 0.5 will remove half the direction.
            </summary>
    </member>
    <member name="M:Vector3.SnapToGrid(System.Single,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Snap to grid along any of the 3 axes.
            </summary>
    </member>
    <member name="M:Vector3.GetAngle(Vector3@,Vector3@)">
      <summary>
            Return the distance between the two direction vectors in degrees.
            </summary>
    </member>
    <member name="M:Vector3.Angle(Vector3@)">
      <summary>
            Return the distance between the two direction vectors in degrees.
            </summary>
    </member>
    <member name="M:Vector3.VectorAngle(Vector3@)">
      <summary>
            Converts a direction vector to an angle.
            </summary>
    </member>
    <member name="P:Vector3.EulerAngles">
      <summary>
            The Euler angles of this direction vector.
            </summary>
    </member>
    <member name="P:Vector3.Inverse">
      <summary>
            Returns the inverse of this vector, which us useful for scaling vectors.
            </summary>
    </member>
    <member name="M:Vector3.AddClamped(Vector3@,System.Single)">
      <summary>
            Try to add to this vector. If we're already over max then don't add.
            If we're over max when we add, clamp in that direction so we're not.
            </summary>
    </member>
    <member name="M:Vector3.RotateAround(Vector3@,Rotation@)">
      <summary>
            Rotate this vector around given point by given rotation and return the result as a new vector.<br />
            See <see cref="M:Transform.RotateAround(Vector3@,Rotation@)" /> for similar method that also transforms rotation.
            </summary>
      <param name="center">Point to rotate around.</param>
      <param name="rot">How much to rotate by. <see cref="M:Rotation.FromAxis(Vector3,System.Single)" /> can be useful.</param>
      <returns>The rotated vector.</returns>
    </member>
    <member name="M:Vector3.Parse(System.String,System.IFormatProvider)">
      <inheritdoc cref="M:Vector3.Parse(System.String)" />
    </member>
    <member name="M:Vector3.Parse(System.String)">
      <inheritdoc cref="M:Vector3.Parse(System.String)" />
    </member>
    <member name="M:Vector3.TryParse(System.String,Vector3@)">
      <inheritdoc cref="M:Vector3.Parse(System.String)" />
    </member>
    <member name="M:Vector3.TryParse(System.String,System.IFormatProvider,Vector3@)">
      <summary>
             Given a string, try to convert this into a vector. Example input formats that work would be "1,1,1", "1;1;1", "[1 1 1]".
            
             This handles a bunch of different separators ( ' ', ',', ';', '\n', '\r' ).
            
             It also trims surrounding characters ('[', ']', ' ', '\n', '\r', '\t', '"').
             </summary>
    </member>
    <member name="M:Vector3.WithAcceleration(Vector3,System.Single)">
      <summary>
            Move to the target vector, by amount acceleration 
            </summary>
    </member>
    <member name="M:Vector3.WithFriction(System.Single,System.Single)">
      <summary>
            Apply an amount of friction to the current velocity.
            </summary>
    </member>
    <member name="M:Vector3.CatmullRomSpline(Vector3@,Vector3@,Vector3@,Vector3@,System.Single)">
      <summary>
            Calculates a point on a Catmull-Rom spline given four control points and a parameter t.
            </summary>
    </member>
    <member name="M:Vector3.TcbSpline(Vector3@,Vector3@,Vector3@,Vector3@,System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Calculates an interpolated point using the Kochanek-Bartels spline (TCB spline).
            </summary>
      <param name="p0" />
      <param name="p1" />
      <param name="p2" />
      <param name="p3" />
      <param name="tension">Tension parameter which affects the sharpness at the control point.
            Positive values make the curve tighter, negative values make it rounder.</param>
      <param name="continuity">Continuity parameter which affects the continuity between segments.
            Positive values create smoother transitions, negative values can create corners.</param>
      <param name="bias">Bias parameter which affects the direction of the curve as it passes through the control point.
            Positive values bias the curve towards the next point, negative values towards the previous.</param>
      <param name="u">The interpolation parameter between 0 and 1, where 0 is the start of the segment and 1 is the end.</param>
      <returns>The interpolated point on the curve.</returns>
    </member>
    <member name="M:Vector3.SmoothDamp(Vector3@,Vector3@,Vector3@,System.Single,System.Single)">
      <summary>
            Smoothly move towards the target vector
            </summary>
    </member>
    <member name="M:Vector3.SpringDamp(Vector3@,Vector3@,Vector3@,System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Springly move towards the target vector
            </summary>
    </member>
    <member name="T:Vector3.SmoothDamped">
      <summary>
            Everything you need to smooth damp a Vector3. Just call Update every frame.
            </summary>
    </member>
    <member name="M:Vector3.SmoothDamped.#ctor(Vector3,Vector3,System.Single)">
      <summary>
            Everything you need to smooth damp a Vector3. Just call Update every frame.
            </summary>
    </member>
    <member name="T:Vector3.SpringDamped">
      <summary>
            Everything you need to create a springy Vector3
            </summary>
    </member>
    <member name="M:Vector3.SpringDamped.#ctor(Vector3,Vector3,System.Single,System.Single,System.Single)">
      <summary>
            Everything you need to create a springy Vector3
            </summary>
    </member>
    <member name="F:Vector3Int.x">
      <summary>
            The X component of this integer vector.
            </summary>
    </member>
    <member name="F:Vector3Int.y">
      <summary>
            The Y component of this integer vector.
            </summary>
    </member>
    <member name="F:Vector3Int.z">
      <summary>
            The Z component of this integer vector.
            </summary>
    </member>
    <member name="M:Vector3Int.#ctor(System.Int32,System.Int32,System.Int32)">
      <summary>
            Initializes an integer vector with given components.
            </summary>
      <param name="x">The X component.</param>
      <param name="y">The Y component.</param>
      <param name="z">The Z component.</param>
    </member>
    <member name="M:Vector3Int.#ctor(System.Int32)">
      <summary>
            Initializes an integer vector with all components set to the same value.
            </summary>
      <param name="all">The value of the X, Y, and Z components.</param>
    </member>
    <member name="M:Vector3Int.#ctor(Vector3Int)">
      <summary>
            Initializes an integer vector with given components from another integer vector
            </summary>
      <param name="vector3Int" />
    </member>
    <member name="F:Vector3Int.One">
      <summary>
            An integer vector with all components set to 1.
            </summary>
    </member>
    <member name="F:Vector3Int.Zero">
      <summary>
            An integer vector with all components set to 0.
            </summary>
    </member>
    <member name="F:Vector3Int.Forward">
      <summary>
            An integer vector with X set to 1. This represents the forward direction.
            </summary>
    </member>
    <member name="F:Vector3Int.Backward">
      <summary>
            An integer vector with X set to -1. This represents the backward direction.
            </summary>
    </member>
    <member name="F:Vector3Int.Up">
      <summary>
            An integer vector with Z set to 1. This represents the up direction.
            </summary>
    </member>
    <member name="F:Vector3Int.Down">
      <summary>
            An integer vector with Z set to -1. This represents the down direction.
            </summary>
    </member>
    <member name="F:Vector3Int.Right">
      <summary>
            An integer vector with Y set to 1. This represents the right direction.
            </summary>
    </member>
    <member name="F:Vector3Int.Left">
      <summary>
            An integer vector with Y set to -1. This represents the left direction.
            </summary>
    </member>
    <member name="F:Vector3Int.OneX">
      <summary>
            An integer vector with X set to 1.
            </summary>
    </member>
    <member name="F:Vector3Int.OneY">
      <summary>
            An integer vector with Y set to 1.
            </summary>
    </member>
    <member name="F:Vector3Int.OneZ">
      <summary>
            An integer vector with Z set to 1.
            </summary>
    </member>
    <member name="M:Vector3Int.ToString">
      <summary>
            Formats the integer vector into a string "x,y,z"
            </summary>
      <returns />
    </member>
    <member name="P:Vector3Int.Normal">
      <summary>
            Returns a unit version of this vector. Keep in mind this returns a Vector3 and not a Vector3Int.
            </summary>
    </member>
    <member name="P:Vector3Int.EulerAngles">
      <summary>
            The Euler angles of this direction vector.
            </summary>
    </member>
    <member name="P:Vector3Int.Inverse">
      <summary>
            Returns the inverse of this vector, which is useful for scaling vectors. Keep in mind this returns a Vector3 and not a Vector3Int.
            </summary>
    </member>
    <member name="P:Vector3Int.Length">
      <summary>
            Length (or magnitude) of the integer vector (Distance from 0,0,0)
            </summary>
    </member>
    <member name="P:Vector3Int.LengthSquared">
      <summary>
            Squared length of the integer vector. This is faster than <see cref="P:Vector3Int.Length">Length</see>, and can be used for things like comparing distances, as long as only squared values are used.
            </summary>
    </member>
    <member name="P:Vector3Int.IsZeroLength">
      <summary>
            Whether the length of this vector is zero or not.
            </summary>
    </member>
    <member name="M:Vector3Int.IsNearlyZero(System.Int32)">
      <summary>
            Returns true if value on every axis is less than or equal to tolerance.
            </summary>
    </member>
    <member name="M:Vector3Int.ComponentMin(Vector3Int)">
      <summary>
            Returns an integer vector that has the minimum values on each axis between this vector and a given vector.
            </summary>
    </member>
    <member name="M:Vector3Int.ComponentMax(Vector3Int)">
      <summary>
            Returns an integer vector that has the maximum values on each axis between this vector and a given vector.
            </summary>
    </member>
    <member name="M:Vector3Int.Cross(Vector3Int@,Vector3Int@)">
      <summary>
            Returns the cross product of this and the given integer vector.
            If this and the given vectors are linearly independent, the resulting vector is perpendicular to them both, also known as a normal of a plane.
            </summary>
    </member>
    <member name="M:Vector3Int.Dot(Vector3Int@,Vector3Int@)">
      <summary>
            Returns the scalar/dot product of the 2 given integer vectors.
            </summary>
    </member>
    <member name="M:Vector3Int.Dot(Vector3Int@,Vector3@)">
      <summary>
            Returns the scalar/dot product of the 2 given vectors.
            </summary>
    </member>
    <member name="M:Vector3Int.Dot(Vector3Int@)">
      <summary>
            Returns the scalar/dot product of this and the given vector.
            </summary>
    </member>
    <member name="M:Vector3Int.Dot(Vector3@)">
      <summary>
            Returns the scalar/dot product of this and the given vector.
            </summary>
    </member>
    <member name="M:Vector3Int.Distance(Vector3Int)">
      <summary>
            Returns distance between this vector and another.
            </summary>
    </member>
    <member name="M:Vector3Int.Distance(Vector3)">
      <summary>
            Returns distance between this vector and another.
            </summary>
    </member>
    <member name="M:Vector3Int.SnapToGrid(System.Int32,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Snap to grid along any of the 3 axes.
            </summary>
    </member>
    <member name="M:Vector3Int.Min(Vector3Int,Vector3Int)">
      <summary>
            Returns an integer vector that has the minimum values on each axis between 2 given vectors.
            </summary>
    </member>
    <member name="M:Vector3Int.Max(Vector3Int,Vector3Int)">
      <summary>
            Returns an integer vector that has the maximum values on each axis between 2 given vectors.
            </summary>
    </member>
    <member name="M:Vector3Int.Abs">
      <summary>
            Returns a new integer vector with all values positive. -5 becomes 5, ect.
            </summary>
    </member>
    <member name="M:Vector3Int.WithX(System.Int32)">
      <summary>
            Returns this integer vector with given X component.
            </summary>
    </member>
    <member name="M:Vector3Int.WithY(System.Int32)">
      <summary>
            Returns this integer vector with given Y component.
            </summary>
    </member>
    <member name="M:Vector3Int.WithZ(System.Int32)">
      <summary>
            Returns this integer vector with given Z component.
            </summary>
    </member>
    <member name="M:Vector3Int.Parse(System.String)">
      <summary>
            Given a string, try to convert this into a Vector3Int. Example formatting is "x,y,z", "[x,y,z]", "x y z", etc.
            </summary>
    </member>
    <member name="M:Vector3Int.Parse(System.String,System.IFormatProvider)">
      <inheritdoc cref="M:Vector3Int.Parse(System.String)" />
    </member>
    <member name="M:Vector3Int.TryParse(System.String,System.IFormatProvider,Vector3Int@)">
      <inheritdoc cref="M:Vector3Int.Parse(System.String)" />
    </member>
    <member name="T:Vector4">
      <summary>
            A 4-dimensional vector/point.
            </summary>
    </member>
    <member name="F:Vector4.Zero">
      <summary>
            A 4D vector with all components set to 0.
            </summary>
    </member>
    <member name="F:Vector4.One">
      <summary>
            A 4D vector with all components set to 1.
            </summary>
    </member>
    <member name="P:Vector4.x">
      <summary>
            The X component of this Vector.
            </summary>
    </member>
    <member name="P:Vector4.y">
      <summary>
            The Y component of this Vector.
            </summary>
    </member>
    <member name="P:Vector4.z">
      <summary>
            The Z component of this Vector.
            </summary>
    </member>
    <member name="P:Vector4.w">
      <summary>
            The W component of this Vector.
            </summary>
    </member>
    <member name="M:Vector4.#ctor(System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Initializes a vector4 with given components.
            </summary>
      <param name="x">The X component.</param>
      <param name="y">The Y component.</param>
      <param name="z">The Z component.</param>
      <param name="w">The W component.</param>
    </member>
    <member name="M:Vector4.#ctor(Vector3@,System.Single)">
      <summary>
            Initializes a 4D vector from given #D vector and the given W component.
            </summary>
    </member>
    <member name="M:Vector4.#ctor(System.Single)">
      <summary>
            Initializes the 4D vector with all components set to given value.
            </summary>
    </member>
    <member name="M:Vector4.Lerp(Vector4,Vector4,System.Single,System.Boolean)">
      <summary>
            Performs linear interpolation between 2 given vectors.
            </summary>
      <param name="a">Vector A</param>
      <param name="b">Vector B</param>
      <param name="frac">Fraction, where 0 would return Vector A, 0.5 would return a point between the 2 vectors, and 1 would return Vector B.</param>
      <param name="clamp">Whether to clamp the fraction argument between [0,1]</param>
      <returns />
    </member>
    <member name="M:Vector4.LerpTo(Vector4,System.Single,System.Boolean)">
      <summary>
            Performs linear interpolation between this and given vectors.
            </summary>
      <param name="target">Vector B</param>
      <param name="frac">Fraction, where 0 would return Vector A, 0.5 would return a point between the 2 vectors, and 1 would return Vector B.</param>
      <param name="clamp">Whether to clamp the fraction argument between [0,1]</param>
      <returns />
    </member>
    <member name="M:Vector4.ToString">
      <summary>
            Formats the Vector into a string "x,y,z,w"
            </summary>
      <returns />
    </member>
    <member name="P:Vector4.Length">
      <summary>
            The length of this vector object
            </summary>
    </member>
    <member name="P:Vector4.LengthSquared">
      <summary>
            The squared length of this vector object
            </summary>
    </member>
    <member name="P:Vector4.IsNearZeroLength">
      <summary>
            Whether length of this vector is nearly zero.
            </summary>
    </member>
    <member name="M:Vector4.Parse(System.String)">
      <summary>
            Given a string, try to convert this into a vector4. The format is "x,y,z,w".
            </summary>
    </member>
    <member name="M:Vector4.Parse(System.String,System.IFormatProvider)">
      <inheritdoc cref="M:Vector4.Parse(System.String)" />
    </member>
    <member name="M:Vector4.TryParse(System.String,Vector4@)">
      <inheritdoc cref="M:Vector4.Parse(System.String)" />
    </member>
    <member name="M:Vector4.TryParse(System.String,System.IFormatProvider,Vector4@)">
      <inheritdoc cref="M:Vector4.Parse(System.String)" />
    </member>
    <member name="T:AssemblyOrderer">
      <summary>
            Takes a bunch of assemblies and works out the proper loading order for them.
            </summary>
    </member>
    <member name="M:ContextLocal.GameScope">
      <summary>
            Should rarely have to get called, game scope is implicit
            </summary>
    </member>
    <member name="M:ContextLocal.MenuScope">
      <summary>
            Should only be called at a really high level, when doing menu stuff
            </summary>
    </member>
    <member name="T:ContextLocal`1">
      <summary>
            Modelled on AsyncLocal. Allows making variables that are different depending on the context, which
            is either game or menu. Game is implicit, but we should push the scope using ContextLocal.MenuScope 
            any time we think we'll be accessing menu vars. This is generally only done in MenuDll.
            </summary>
    </member>
    <member name="M:SandboxedUnsafe.IsAcceptablePod(System.Type)">
      <summary>
            Return true if this is an acceptable Plain Old data
            </summary>
    </member>
  </members>
  <assembly>
    <name>Sandbox.Tools</name>
  </assembly>
  <members>
    <member name="T:Editor.AssemblyInitialize">
      <summary>
            Called before anything else. The only purpose of this is to load the native dlls
            and swap function pointers with them. We should not be doing anything else here.
            </summary>
    </member>
    <member name="T:Editor.Asset.AssetTags">
      <summary>
            Represents a collection of tags for an asset.
            This is only necessary so we can save tags as soon as they are added.
            </summary>
    </member>
    <member name="M:Editor.Asset.AssetTags.Clear">
      <summary>
            Remove all tags.
            </summary>
    </member>
    <member name="M:Editor.Asset.AssetTags.Add(System.String)">
      <summary>
            Add a single tag.
            </summary>
    </member>
    <member name="M:Editor.Asset.AssetTags.Add(System.String[])">
      <summary>
            Add multiple tags at once.
            </summary>
    </member>
    <member name="M:Editor.Asset.AssetTags.Remove(System.String)">
      <summary>
            Remove given tag from the asset.
            </summary>
    </member>
    <member name="M:Editor.Asset.AssetTags.Toggle(System.String)">
      <summary>
            Remove the tag if present, add if not.
            </summary>
    </member>
    <member name="M:Editor.Asset.AssetTags.Set(System.String,System.Boolean)">
      <summary>
            Set or remove the tag based on second argument.
            </summary>
    </member>
    <member name="M:Editor.Asset.AssetTags.Contains(System.String)">
      <summary>
            Returns whether this asset has given tag.
            </summary>
    </member>
    <member name="M:Editor.Asset.AssetTags.GetAll">
      <summary>
            Returns all tags of this asset.
            </summary>
    </member>
    <member name="P:Editor.Asset.Tags">
      <summary>
            Tags for this asset, for filtering purposes in the Asset Browser.
            </summary>
    </member>
    <member name="P:Editor.Asset.Name">
      <summary>
            Name of the asset, usually the filename.
            </summary>
    </member>
    <member name="P:Editor.Asset.Path">
      <summary>
            The relative path with the asset extension. ie .wav becomes .vsnd
            </summary>
    </member>
    <member name="P:Editor.Asset.RelativePath">
      <summary>
            The relative path as it is on disk (ie .wav not .vsnd)
            </summary>
    </member>
    <member name="P:Editor.Asset.AbsolutePath">
      <summary>
            The absolute path as it is on disk (ie .wav not .vsnd)
            </summary>
    </member>
    <member name="P:Editor.Asset.AbsoluteSourcePath">
      <summary>
            The absolute path as it is on disk. Should be null if we don't have source.
            </summary>
    </member>
    <member name="P:Editor.Asset.AbsoluteCompiledPath">
      <summary>
            The absolute path as it is on disk. Should be null if we don't have a compiled.
            </summary>
    </member>
    <member name="P:Editor.Asset.LastOpened">
      <summary>
            When the asset was last opened through the editor.
            </summary>
    </member>
    <member name="P:Editor.Asset.AssetType">
      <summary>
            The type of this asset.
            </summary>
    </member>
    <member name="P:Editor.Asset.Package">
      <summary>
            If this asset was downloaded from sbox.game then this will
            be the package from which this asset was downloaded. If not then
            it'll be null.
            </summary>
    </member>
    <member name="P:Editor.Asset.IsDeleted">
      <summary>
            Whether the asset is deleted or not.
            This can happen after <see cref="M:Editor.Asset.Delete" /> was called on it, or <see cref="P:Editor.Asset.AbsolutePath" /> is empty.
            </summary>
    </member>
    <member name="P:Editor.Asset.IsProcedural">
      <summary>
            If true then this asset is generated at runtime somehow. Possibly from a mount system.
            </summary>
    </member>
    <member name="P:Editor.Asset.IsTrivalChild">
      <summary>
            The asset was generated from another asset compile and has no source asset of its own. For example model break gibs .vmdl, .vtex files for materials, etc.
            </summary>
    </member>
    <member name="P:Editor.Asset.CanRecompile">
      <summary>
            Can this asset be recompiled?
            </summary>
    </member>
    <member name="M:Editor.Asset.Delete">
      <summary>
            Delete this asset. Will send the source and compiled files to the recycle bin.
            </summary>
    </member>
    <member name="M:Editor.Asset.GetCompiledFile(System.Boolean)">
      <summary>
            Returns the compiled file path, if the asset is compiled.
            </summary>
      <param name="absolute">Whether the path should be absolute or relative.</param>F
            <returns>The compiled file path, or null if the asset was not compiled.</returns></member>
    <member name="M:Editor.Asset.GetSourceFile(System.Boolean)">
      <summary>
            Returns the source file path, if the sources are present.
            </summary>
      <param name="absolute">Whether the path should be absolute or relative.</param>
      <returns>The source file path, or null if the source files are not present.</returns>
    </member>
    <member name="M:Editor.Asset.GetAssetThumb(System.Boolean)">
      <summary>
            Returns the asset preview thumbnail, with fallback to the asset type icon if there is no preview.
            </summary>
    </member>
    <member name="M:Editor.Asset.RebuildThumbnail(System.Boolean)">
      <summary>
            Delete existing cached thumbnail, optionally queuing for building a new one ASAP.
            </summary>
      <param name="startBuild">Queue building the new thumbnail ASAP, as opposed to waiting when it is actually needed and doing it then.</param>
    </member>
    <member name="M:Editor.Asset.OpenInEditor(System.String)">
      <summary>
            Try to open this asset in a supported editor.
            You can specify nativeEditor to open in a specific editor.
            </summary>
      <param name="nativeEditor">A native editor specified in enginetools.txt (e.g modeldoc_editor, hammer, pet..)</param>
    </member>
    <member name="M:Editor.Asset.GetReferences(System.Boolean)">
      <summary>
            Returns assets that this asset references/uses.
            </summary>
      <param name="deep">Whether to recurse. For example, will also include textures referenced by the materials used by this model asset, as opposed to returning just the materials.</param>
    </member>
    <member name="M:Editor.Asset.GetDependants(System.Boolean)">
      <summary>
            Returns assets that depend/use this asset.
            </summary>
      <param name="deep">Whether to recurse. For example, will also include maps that are using models which use this material asset, as opposed to returning just the models.</param>
    </member>
    <member name="M:Editor.Asset.GetAdditionalRelatedFiles">
      <summary>
            Gets additional related files. This includes like .rect files for materials, all .fbx and .lxo files for models, etc.
            </summary>
    </member>
    <member name="M:Editor.Asset.GetInputDependencies">
      <summary>
            Gets input dependencies for an asset. This'll be tga's for a texture and stuff like that.
            </summary>
    </member>
    <member name="M:Editor.Asset.GetUnrecognizedReferencePaths">
      <summary>
            Unrecognized reference paths listed by the data that could not be resolved into Asset*s
            </summary>
    </member>
    <member name="M:Editor.Asset.Compile(System.Boolean)">
      <summary>
            Forcibly recompile the asset.
            </summary>
      <param name="full">TODO</param>
    </member>
    <member name="P:Editor.Asset.MetaData">
      <summary>
            Asset type specific key-value based data storage.
            </summary>
    </member>
    <member name="M:Editor.Asset.DumpThumbnail">
      <summary>
            Renders the thumbnail and then saves it to disk.
            </summary>
    </member>
    <member name="M:Editor.Asset.RenderThumb">
      <summary>
            Immediately render a preview thumbnail for this asset, and return it.
            </summary>
      <returns>The rendered preview thumbnail, or null if asset type does not support previews.</returns>
    </member>
    <member name="M:Editor.Asset.GetPreviewModel">
      <summary>
            Try to create a preview model if we're fbx, obj, etc
            </summary>
    </member>
    <member name="M:Editor.Asset.LoadResource">
      <summary>
            Try to load this asset as an automatically determined resource type.
            </summary>
      <returns />
    </member>
    <member name="M:Editor.Asset.LoadResource``1">
      <summary>
            Try to load this asset as a <see cref="T:Sandbox.Resource" /> of given type.
            </summary>
      <typeparam name="T">The type of resource to try to load.</typeparam>
      <returns>The loaded <see cref="T:Sandbox.Resource" /> instance of given type, or null on failure.</returns>
    </member>
    <member name="M:Editor.Asset.LoadResource(System.Type)">
      <summary>
            Try to load this asset as a <see cref="T:Sandbox.Resource" /> of given type.
            </summary>
      <returns>The loaded <see cref="T:Sandbox.Resource" /> instance of given type, or null on failure.</returns>
    </member>
    <member name="M:Editor.Asset.TryLoadResource``1(``0@)">
      <summary>
            Try to load this asset as a <see cref="T:Sandbox.Resource" /> of given type.
            </summary>
      <typeparam name="T">The type of resource to try to load.</typeparam>
      <param name="obj">Output resource on success, null on failure.</param>
      <returns>true if <paramref name="obj" /> was successfully set.</returns>
    </member>
    <member name="M:Editor.Asset.ReadJson">
      <summary>
            Try to get the raw Json string, for a managed asset type (a GameResource)
            </summary>
    </member>
    <member name="M:Editor.Asset.SaveToDisk(Sandbox.GameResource)">
      <summary>
            Save a game resource instance to disk. This is used internally by asset inspector and for asset creation.
            </summary>
      <param name="obj">The instance data to save.</param>
      <returns>Whether the instance was successfully saved or not.</returns>
    </member>
    <member name="M:Editor.Asset.RecordOpened">
      <summary>
            Tell asset system that this asset was opened. Sticks it on the recent opened list.
            </summary>
    </member>
    <member name="P:Editor.Asset.IsCompiled">
      <summary>
            Whether the asset is compiled.
            </summary>
    </member>
    <member name="P:Editor.Asset.IsCompiledAndUpToDate">
      <summary>
            Whether the asset is compiled and all dependencies are up to date. (Slower than IsCompiled)
            </summary>
    </member>
    <member name="P:Editor.Asset.IsCompileFailed">
      <summary>
            Whether the asset failed to compile.
            </summary>
    </member>
    <member name="M:Editor.Asset.CompileIfNeededAsync(System.Single)">
      <summary>
            Returns a task that will resolve when the asset is compiled. If the asset is already compiled, do nothing. Does not support maps.
            </summary>
      <returns>true if the compile was needed, and was successful.</returns>
    </member>
    <member name="M:Editor.Asset.OverrideThumbnail(Editor.Pixmap)">
      <summary>
            Override the Assets thumbnail with given one.
            </summary>
    </member>
    <member name="P:Editor.Asset.HasSourceFile">
      <summary>
            True if we have a source file, and aren't just a _c file
            </summary>
    </member>
    <member name="P:Editor.Asset.HasCompiledFile">
      <summary>
            True if we have a compiled file, and aren't just a source file
            </summary>
    </member>
    <member name="P:Editor.Asset.HasUnsavedChanges">
      <summary>
            A free-use variable for the editor to use to portray that this asset
            somehow has changes that need to be saved to disk.
            </summary>
    </member>
    <member name="M:Editor.Asset.SetInMemoryReplacement(System.String)">
      <summary>
            Set data for this asset which will be compiled in memory. This is used to preview
            asset changes (like materials) before committing to disk.
            </summary>
    </member>
    <member name="M:Editor.Asset.ClearInMemoryReplacement">
      <summary>
            Reverse the changes of SetInMemoryReplacement
            </summary>
    </member>
    <member name="P:Editor.Asset.Publishing">
      <summary>
            Access the asset publisher config.
            </summary>
    </member>
    <member name="M:Editor.Asset.GetPublishSettings(System.Boolean)">
      <summary>
            Fetches and caches ProjectSettings, optionally sets one up, prefer using <seealso cref="P:Editor.Asset.Publishing" /></summary>
    </member>
    <member name="T:Editor.Asset.PublishSettings">
      <summary>
            This is data that is saved in an asset's meta file under "publish" to configure
            its project for uploading. 
            </summary>
    </member>
    <member name="P:Editor.Asset.PublishSettings.Enabled">
      <summary>
            Whether the asset should be published or not.
            </summary>
    </member>
    <member name="P:Editor.Asset.PublishSettings.ProjectConfig">
      <summary>
            Project configuration information
            </summary>
    </member>
    <member name="M:Editor.Asset.PublishSettings.CreateTemporaryProject">
      <summary>
            Create a Project usually with the intention of editing and publishing a single asset.
            The project isn't stored or listed anywhere, so is considered a transient that you can load
            up, edit, save and then throw away.
            </summary>
    </member>
    <member name="T:Editor.Asset.ThumbnailRendererAttribute">
      <summary>
            Should target a static method like 
            `public static Pixmap RenderThumbnail( Asset thumbnail )`
            where the method returns a thumbnail for that asset type. 
            This kind of sucks I don't like it.
            </summary>
    </member>
    <member name="P:Editor.Asset.ThumbnailRendererAttribute.Priority">
      <summary>
            The priority of this callback. Higher gets called first.
            </summary>
    </member>
    <member name="T:Editor.EditorForAssetTypeAttribute">
      <summary>
            Used in conjunction with IAssetEditor to declare a window that can edit an asset type
            </summary>
    </member>
    <member name="T:Editor.AssetSystem">
      <summary>
            The asset system, provides access to all the assets.
            </summary>
    </member>
    <member name="M:Editor.AssetSystem.InstallAsync(System.String,System.Boolean,System.Action{System.Single},System.Threading.CancellationToken)">
      <inheritdoc cref="M:Editor.AssetSystem.InstallAsync(Sandbox.Package,System.Boolean,System.Action{System.Single},System.Threading.CancellationToken)" />
    </member>
    <member name="M:Editor.AssetSystem.InstallAsync(Sandbox.Package,System.Boolean,System.Action{System.Single},System.Threading.CancellationToken)">
      <summary>
            Install a cloud package. Will return the primary asset on completion (if it has one)
            </summary>
      <param name="package" />
      <param name="skipIfInstalled">Skip downloading the remote package if any version of this package is already installed.</param>
      <param name="loading" />
      <param name="token" />
    </member>
    <member name="M:Editor.AssetSystem.RemoveReferences(Sandbox.Package)">
      <summary>
            Removes any refs to <paramref name="package" /></summary>
    </member>
    <member name="M:Editor.AssetSystem.ReplaceReferences(System.Collections.Generic.IEnumerable{Editor.Asset},Sandbox.Package,Sandbox.Package)">
      <summary>
            Replaces any references in <paramref name="assets" /> to <paramref name="fromPackage" /> with a reference to <paramref name="toPackage" />
            (does a replace by ident to avoid having to open the map etc)
            </summary>
    </member>
    <member name="M:Editor.AssetSystem.GetInstalledRevision(System.String)">
      <summary>
            Gets the locally installed package revision by ident
            </summary>
    </member>
    <member name="M:Editor.AssetSystem.IsCloudInstalled(System.String)">
      <summary>
            Is this package installed in our cloud directory?
            </summary>
    </member>
    <member name="M:Editor.AssetSystem.IsCloudInstalled(Sandbox.Package,System.Boolean)">
      <summary>
            Is a version this package installed in our cloud directory?
            </summary>
    </member>
    <member name="M:Editor.AssetSystem.CanCloudInstall(Sandbox.Package)">
      <summary>
            Is this package type something we can install?
            </summary>
    </member>
    <member name="M:Editor.AssetSystem.DownloadCloudFiles(Sandbox.Package,System.Action{System.Single},System.Threading.CancellationToken)">
      <summary>
            Initialize the files from the
            </summary>
    </member>
    <member name="M:Editor.AssetSystem.CompileResource(System.String,System.String)">
      <summary>
            Compile a resource from text.
            </summary>
    </member>
    <member name="M:Editor.AssetSystem.CompileResource(System.String,System.ReadOnlySpan{System.Byte})">
      <summary>
            Compile a resource from binary data.
            </summary>
    </member>
    <member name="P:Editor.AssetSystem.All">
      <summary>
            All the assets that are being tracked by the asset system. Does not include deleted assets.
            </summary>
    </member>
    <member name="M:Editor.AssetSystem.PreInitialize">
      <summary>
            Called after the asset types have been loaded from
            </summary>
    </member>
    <member name="M:Editor.AssetSystem.AssetRemoved(System.UInt32)">
      <summary>
            This is only called on startup. The cache is loaded, so a bunch of assets are known,
            then it does a bit of research and sees that the asset is removed, and it can remove it now.
            This is the only point where an Asset is actually destroyed, during the mainloop the asset
            is just marked as deleted but never destroyed.
            </summary>
    </member>
    <member name="M:Editor.AssetSystem.FindByPath(System.String)">
      <summary>
            Find an asset by path.
            </summary>
      <param name="path">The file path to an asset. Can be absolute or relative.</param>
    </member>
    <member name="M:Editor.AssetSystem.RegisterFile(System.String)">
      <summary>
            If you just created an asset, you probably want to immediately register it
            </summary>
    </member>
    <member name="M:Editor.AssetSystem.DeleteOrphans">
      <summary>
            Delete orphaned trivial children. These are things that are generated for
            usage by an asset, but aren't referenced by anything, so are useless.
            </summary>
    </member>
    <member name="M:Editor.AssetSystem.CreateResource(System.String,System.String)">
      <summary>
            Create an empty <see cref="T:Sandbox.GameResource" />.
            </summary>
      <param name="type">Asset type extension for our new <see cref="T:Sandbox.GameResource" /> instance.</param>
      <param name="absoluteFilename">Where to save the new <see cref="T:Sandbox.GameResource" /> instance. For example from <see cref="T:Editor.FileDialog" />.</param>
      <returns>The new asset, or null if creation failed.</returns>
    </member>
    <member name="T:Editor.AssetSystem.AssetPickerParameters">
      <summary>
            Passed parameters for the AssetPicker going from engine to addon code
            </summary>
    </member>
    <member name="M:Editor.AssetSystem.OpenPicker(Native.QWidget,NativeEngine.CUtlVectorAssetType,IAssetPickerListener,System.Int32,IAsset,System.String,System.Boolean,System.String)">
      <summary>
            Called from native to open our managed AssetPicker
            </summary>
    </member>
    <member name="T:Editor.AssetTagSystem">
      <summary>
            Handles asset tags.
            </summary>
    </member>
    <member name="M:Editor.AssetTagSystem.GetTagIcon(System.String)">
      <summary>
            Get an auto generated icon for given tag.
            </summary>
    </member>
    <member name="P:Editor.AssetTagSystem.All">
      <summary>
            List of all registered tags.
            </summary>
    </member>
    <member name="M:Editor.AssetTagSystem.RegisterAssetTag(System.String,System.String,System.String,System.String,Editor.AssetTagSystem.AssetAutoTagFilter)">
      <summary>
            Register a new asset tag.
            </summary>
    </member>
    <member name="M:Editor.AssetTagSystem.EnsureRegistered(System.String)">
      <summary>
            Ensure a user-defined tag is registered, for display in UI.
            </summary>
    </member>
    <member name="M:Editor.AssetTagSystem.IsAutoTag(System.String)">
      <summary>
            Return true if this tag is automatically applied
            </summary>
    </member>
    <member name="P:Editor.AssetType.All">
      <summary>
            All currently registered asset types, including the base types such as models, etc.
            </summary>
    </member>
    <member name="P:Editor.AssetType.Model">
      <summary>
            Model (.vmdl) asset type.
            </summary>
    </member>
    <member name="P:Editor.AssetType.Animation">
      <summary>
            Animation (.vanim) asset type.
            </summary>
    </member>
    <member name="P:Editor.AssetType.AnimationGraph">
      <summary>
            Animation Graph (.vanmgrph) asset type.
            </summary>
    </member>
    <member name="P:Editor.AssetType.Texture">
      <summary>
            Texture (.vtex) asset type.
            </summary>
    </member>
    <member name="P:Editor.AssetType.Material">
      <summary>
            Material (.vmat) asset type.
            </summary>
    </member>
    <member name="P:Editor.AssetType.SoundFile">
      <summary>
            Sound (.wav, .ogg or .mp3) asset type.
            </summary>
    </member>
    <member name="P:Editor.AssetType.SoundEvent">
      <summary>
            A sound event
            </summary>
    </member>
    <member name="P:Editor.AssetType.Soundscape">
      <summary>
            A soundscape
            </summary>
    </member>
    <member name="P:Editor.AssetType.ImageFile">
      <summary>
            Image source (.png or .jpg) asset type.
            </summary>
    </member>
    <member name="P:Editor.AssetType.Shader">
      <summary>
            Shader (.shader) asset type.
            </summary>
    </member>
    <member name="P:Editor.AssetType.ParticleSystem">
      <summary>
            Particle System (.vpcf) asset type.
            </summary>
    </member>
    <member name="P:Editor.AssetType.MapFile">
      <summary>
            A map (.vmap) asset type.
            </summary>
    </member>
    <member name="P:Editor.AssetType.FriendlyName">
      <summary>
            Name of the asset type for UI purposes.
            </summary>
    </member>
    <member name="P:Editor.AssetType.FileExtension">
      <summary>
            Primary file extension for this asset type.
            </summary>
    </member>
    <member name="P:Editor.AssetType.FileExtensions">
      <summary>
            All file extensions for this asset type.
            </summary>
    </member>
    <member name="P:Editor.AssetType.HiddenByDefault">
      <summary>
            This asset type is hidden by default from asset browser, etc.
            </summary>
    </member>
    <member name="P:Editor.AssetType.IsSimpleAsset">
      <summary>
            A simple asset is used by something else. It never exists in the game on its own.
            </summary>
    </member>
    <member name="P:Editor.AssetType.HasDependencies">
      <summary>
            This asset type can have dependencies
            </summary>
    </member>
    <member name="P:Editor.AssetType.PrefersIconThumbnail">
      <summary>
            Use asset type icon, over any preview image.
            </summary>
    </member>
    <member name="P:Editor.AssetType.Icon16">
      <summary>
            16x16 icon for this asset type.
            </summary>
    </member>
    <member name="P:Editor.AssetType.Icon64">
      <summary>
            64x64 icon for this asset type.
            </summary>
    </member>
    <member name="P:Editor.AssetType.Icon128">
      <summary>
            128x128 icon for this asset type.
            </summary>
    </member>
    <member name="P:Editor.AssetType.Icon256">
      <summary>
            256x256 icon for this asset type.
            </summary>
    </member>
    <member name="P:Editor.AssetType.IsGameResource">
      <summary>
            Whether this asset type is a custom game resource or not.
            </summary>
    </member>
    <member name="P:Editor.AssetType.ResourceType">
      <summary>
            Type that will be returned by <see cref="M:Editor.Asset.LoadResource" />.
            </summary>
    </member>
    <member name="P:Editor.AssetType.Category">
      <summary>
            Category of this asset type, for grouping in UI.
            </summary>
    </member>
    <member name="P:Editor.AssetType.Color">
      <summary>
            Color that represents this asset, for use in the asset browser.
            </summary>
    </member>
    <member name="M:Editor.AssetType.HasExtension(System.String)">
      <summary>
            Return true if this extension matches
            </summary>
    </member>
    <member name="M:Editor.AssetType.Find(System.String,System.Boolean)">
      <summary>
            Find an asset type by name or extension match.
            </summary>
      <param name="name">Name or extension of an asset type to search for.</param>
      <param name="allowPartials">Whether partial matches for the name are allowed.</param>
    </member>
    <member name="M:Editor.AssetType.UpdateCustomTypes">
      <summary>
            Called to insert the asset types for types defined in Engine/Game
            </summary>
    </member>
    <member name="M:Editor.AssetType.FromType(System.Type)">
      <summary>
            For a type (ie Texture, Material, Surface) return the appropriate AssetType.
            Returns null if can't resolve.
            </summary>
    </member>
    <member name="M:Editor.AssetType.ResolveFromPath(System.String)">
      <summary>
            Tries its hardest to resolve an asset type from a file path
            </summary>
    </member>
    <member name="T:Editor.CloudAssetDirectory">
      <summary>
            There are a bunch of loose files in the source2/cloud folder. This is a directory
            of where those files are from, so we can backwards lookup which asset they're from.
            </summary>
    </member>
    <member name="M:Editor.CloudAssetDirectory.AddPackage(Sandbox.Package)">
      <summary>
            Remember this package, our cloud assets are using it.
            </summary>
    </member>
    <member name="M:Editor.CloudAssetDirectory.RemovePackage(Sandbox.Package)">
      <summary>
            Remove this package and it's files from our database
            </summary>
    </member>
    <member name="M:Editor.CloudAssetDirectory.AddFile(System.String,System.String,System.Int64,System.String,System.Int64)">
      <summary>
            Start tracking this path, associate it with this package.
            </summary>
    </member>
    <member name="M:Editor.CloudAssetDirectory.FindPackage(System.String)">
      <summary>
            Given an ident, find the saved package. This doesn't access the internet, it looks it up
            in the database of packages that we've previously downloaded.
            </summary>
    </member>
    <member name="M:Editor.CloudAssetDirectory.ValidatePackage(Sandbox.Package)">
      <summary>
            Validate that the files in this package are all present and correct. This is 
            done once when retriving the package.
            </summary>
    </member>
    <member name="M:Editor.CloudAssetDirectory.FindPackage(System.String,System.String)">
      <summary>
            Used by the Asset to determine its package. We pass in abs and relative path because
            it gives us a shortcut for a fast reject - and the strings are already prepared for us.
            </summary>
    </member>
    <member name="T:Editor.GameResourceProcessor">
      <summary>
            When saving a game resource, we inject information about packages used into it. We do that 
            here in this special callback because GameResource is in engine.dll, so we can't do it in Serialize()
            </summary>
    </member>
    <member name="T:Editor.IAssetEditor">
      <summary>
            A widget (usually window) implementing this will be able to edit assets via the asset browser.
            The widget should be marked with the attribute of the asset's extension, like this <c>[CanEdit( "asset:vsndstck" )]</c></summary>
    </member>
    <member name="F:Editor.IAssetEditor.OpenMultiAssetEditors">
      <summary>
            A list of open editors that support multiple assets at once.
            </summary>
    </member>
    <member name="F:Editor.IAssetEditor.OpenSingleEditors">
      <summary>
            A list of open editors for individual assets.
            </summary>
    </member>
    <member name="M:Editor.IAssetEditor.OpenInEditor(Editor.Asset,Editor.IAssetEditor@)">
      <summary>
            Open given asset in a new asset editor window. Will reuse already open editors for same asset type if the editor supports it. (<see cref="P:Editor.IAssetEditor.CanOpenMultipleAssets" />)
            </summary>
      <returns>Whether an asset editor was found for given asset.</returns>
    </member>
    <member name="P:Editor.IAssetEditor.CanOpenMultipleAssets">
      <summary>
            If this editor is able to edit multiple assets at the same time then return true
            and we'll try to create only one version of that editor and AssetOpen will be called multiple times.
            </summary>
    </member>
    <member name="M:Editor.IAssetEditor.AssetOpen(Editor.Asset)">
      <summary>
            Open the asset in this editor.
            </summary>
    </member>
    <member name="T:Editor.MetaData">
      <summary>
            A class to CRUD json files. This should probably be a generic class since it seems
            like we might want to do this with stuff other than meta files. But there's no need for
            that right now, so lets leave it simple.
            </summary>
    </member>
    <member name="P:Editor.MetaData.FilePath">
      <summary>
            File path to the metadata file.
            </summary>
    </member>
    <member name="M:Editor.MetaData.Read">
      <summary>
            Note - not caching anything here, and reading the whole json file
            every time. Lets see how this turns out.
            </summary>
    </member>
    <member name="M:Editor.MetaData.StartWrite">
      <summary>
            Note - not caching anything here, and reading the whole json file
            every time. Lets see how this turns out.
            </summary>
    </member>
    <member name="M:Editor.MetaData.Set``1(System.String,``0)">
      <summary>
            Set a value in the metadata file. If the value is null, the key will be removed.
            </summary>
    </member>
    <member name="P:Editor.MountAsset.IsProcedural">
      <summary>
            Everything in Mount assets is procedural
            </summary>
    </member>
    <member name="M:Editor.MountAsset.SetInMemoryReplacement(System.String)">
      <summary>
            Set data for this asset which will be compiled in memory. This is used to preview
            asset changes (like materials) before committing to disk.
            </summary>
    </member>
    <member name="M:Editor.MountAsset.ClearInMemoryReplacement">
      <summary>
            Reverse the changes of SetInMemoryReplacement
            </summary>
    </member>
    <member name="P:Editor.NativeAsset.CanRecompile">
      <summary>
            Can this asset be recompiled?
            </summary>
    </member>
    <member name="M:Editor.NativeAsset.GetCompiledFile(System.Boolean)">
      <summary>
            Returns the compiled file path, if the asset is compiled.
            </summary>
      <param name="absolute">Whether the path should be absolute or relative.</param>F
            <returns>The compiled file path, or null if the asset was not compiled.</returns></member>
    <member name="M:Editor.NativeAsset.GetSourceFile(System.Boolean)">
      <summary>
            Returns the source file path, if the sources are present.
            </summary>
      <param name="absolute">Whether the path should be absolute or relative.</param>
      <returns>The source file path, or null if the source files are not present.</returns>
    </member>
    <member name="M:Editor.NativeAsset.OpenInEditor(System.String)">
      <summary>
            Try to open this asset in a supported editor.
            You can specify nativeEditor to open in a specific editor.
            </summary>
      <param name="nativeEditor">A native editor specified in enginetools.txt (e.g modeldoc_editor, hammer, pet..)</param>
    </member>
    <member name="M:Editor.NativeAsset.GetReferences(System.Boolean)">
      <summary>
            Returns assets that this asset references/uses.
            </summary>
      <param name="deep">Whether to recurse. For example, will also include textures referenced by the materials used by this model asset, as opposed to returning just the materials.</param>
    </member>
    <member name="M:Editor.NativeAsset.GetDependants(System.Boolean)">
      <summary>
            Returns assets that depend/use this asset.
            </summary>
      <param name="deep">Whether to recurse. For example, will also include maps that are using models which use this material asset, as opposed to returning just the models.</param>
    </member>
    <member name="M:Editor.NativeAsset.GetAdditionalRelatedFiles">
      <summary>
            Gets additional related files. This includes like .rect files for materials, all .fbx and .lxo files for models, etc.
            </summary>
    </member>
    <member name="M:Editor.NativeAsset.GetInputDependencies">
      <summary>
            Gets input dependencies for an asset. This'll be tga's for a texture and stuff like that.
            </summary>
    </member>
    <member name="M:Editor.NativeAsset.GetUnrecognizedReferencePaths">
      <summary>
            Unrecognized reference paths listed by the data that could not be resolved into Asset*s
            </summary>
    </member>
    <member name="M:Editor.NativeAsset.Compile(System.Boolean)">
      <summary>
            Forcibly recompile the asset.
            </summary>
      <param name="full">TODO</param>
    </member>
    <member name="M:Editor.NativeAsset.GetPreviewModel">
      <summary>
            Try to create a preview model if we're fbx, obj, etc
            </summary>
    </member>
    <member name="M:Editor.NativeAsset.RecordOpened">
      <summary>
            Tell asset system that this asset was opened. Sticks it on the recent opened list.
            </summary>
    </member>
    <member name="P:Editor.NativeAsset.IsCompiled">
      <summary>
            Whether the asset is compiled.
            </summary>
    </member>
    <member name="P:Editor.NativeAsset.IsCompiledAndUpToDate">
      <summary>
            Whether the asset is compiled and all dependencies are up to date. (Slower than IsCompiled)
            </summary>
    </member>
    <member name="P:Editor.NativeAsset.IsCompileFailed">
      <summary>
            Whether the asset failed to compile.
            </summary>
    </member>
    <member name="M:Editor.NativeAsset.CompileIfNeededAsync(System.Single)">
      <summary>
            Returns a task that will resolve when the asset is compiled. If the asset is already compiled, do nothing. Does not support maps.
            </summary>
      <returns>true if the compile was needed, and was successful.</returns>
    </member>
    <member name="P:Editor.NativeAsset.HasSourceFile">
      <summary>
            True if we have a source file, and aren't just a _c file
            </summary>
    </member>
    <member name="P:Editor.NativeAsset.HasCompiledFile">
      <summary>
            True if we have a compiled file, and aren't just a source file
            </summary>
    </member>
    <member name="M:Editor.NativeAsset.SetInMemoryReplacement(System.String)">
      <summary>
            Set data for this asset which will be compiled in memory. This is used to preview
            asset changes (like materials) before committing to disk.
            </summary>
    </member>
    <member name="M:Editor.NativeAsset.ClearInMemoryReplacement">
      <summary>
            Reverse the changes of SetInMemoryReplacement
            </summary>
    </member>
    <member name="P:Editor.ResourceCompileContextImp.ResourceVersion">
      <summary>
            The resource version can be important
            </summary>
    </member>
    <member name="M:Editor.ResourceCompileContextImp.AddCompileReference(System.String)">
      <summary>
            Add a reference that is needed to compile this resource, but isn't actually needed once compiled.
            </summary>
    </member>
    <member name="M:Editor.ResourceCompileContextImp.CreateChild(System.String)">
      <summary>
            Create a child resource
            </summary>
    </member>
    <member name="M:Editor.ResourceCompileContextImp.ReadSource">
      <summary>
            Read the source, either from in memory, or from disk
            </summary>
    </member>
    <member name="M:Editor.ResourceCompileContextImp.ScanJson(System.String)">
      <summary>
            Load the json and scan it for paths or any embedded resources.
            Returns modified Json, which your compiler should use instead.
            </summary>
    </member>
    <member name="M:Editor.ResourceCompileContextImp.DataStreamImp.Write(System.Byte[])">
      <summary>
            Write data to the resource
            </summary>
    </member>
    <member name="M:Editor.TextureResourceCompiler.CompileEmbedded(Sandbox.Resources.EmbeddedResource@)">
      <summary>
            We found an embedded resource definition.
            1. Find the TextureGenerator
            2. Create a child texture resource with a deterministic name
            3. Put the provided compile data in that and let it compile
            4. Store a reference to the compiled version in the json
            </summary>
    </member>
    <member name="T:Editor.ICodeEditor">
      <summary>
             Interface for editors to open code files.
             Any class that implements this interface is automatically added to the list.
             An editor is only enabled if <see cref="M:Editor.ICodeEditor.IsInstalled" /> returns true.
            
             Decorate your implementation with a <see cref="T:TitleAttribute" />.
             </summary>
    </member>
    <member name="M:Editor.ICodeEditor.OpenFile(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32})">
      <summary>
            Opens a file in the editor, optionally at a line and column.
            </summary>
    </member>
    <member name="M:Editor.ICodeEditor.OpenSolution">
      <summary>
            Open the solution of all sandbox projects
            </summary>
    </member>
    <member name="M:Editor.ICodeEditor.OpenAddon(Sandbox.Project)">
      <summary>
            Open given addon in the editor.
            </summary>
    </member>
    <member name="M:Editor.ICodeEditor.IsInstalled">
      <summary>
            Whether or not this editor is installed.
            </summary>
    </member>
    <member name="T:Editor.CodeEditor">
      <summary>
            For opening source code files in whatever code editor the user has selected.
            </summary>
    </member>
    <member name="P:Editor.CodeEditor.Current">
      <summary>
            The current code editor we're using.
            </summary>
    </member>
    <member name="M:Editor.CodeEditor.GetEditorDescription(System.String)">
      <summary>
            Tries to find an editor type with a matching name, and checks to see if it's installed on our system.
            </summary>
      <param name="editorName" />
      <returns />
    </member>
    <member name="M:Editor.CodeEditor.GetDefault">
      <summary>
            Decides on a default code editor to use, defaults to Visual Studio or Visual Studio Code if not installed.
            Since code editors are made in addon space, we don't have their types ready to use.
            </summary>
      <returns />
    </member>
    <member name="P:Editor.CodeEditor.Title">
      <summary>
            Friendly name for our current code editor.
            </summary>
    </member>
    <member name="M:Editor.CodeEditor.OpenFile(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32})">
      <summary>
            Opens a file in the current editor, optionally at a line and column.
            </summary>
    </member>
    <member name="M:Editor.CodeEditor.CanOpenFile(System.String)">
      <summary>
            Returns true if the file exists and can be opened by the current code editor.
            </summary>
      <param name="path" />
      <returns />
    </member>
    <member name="M:Editor.CodeEditor.OpenSolution">
      <summary>
            Open the solution of all s&amp;box projects
            </summary>
    </member>
    <member name="M:Editor.CodeEditor.FindSolutionFromPath(System.String)">
      <summary>
            Finds a .sln this path belongs to, this is pretty much entirely for internal usage to open engine slns
            </summary>
    </member>
    <member name="M:Editor.ConsoleSystem.SetValue(System.String,System.Object)">
      <summary>
            Try to set a console variable. You will only be able to set variables that you have permission to set.
            </summary>
    </member>
    <member name="M:Editor.ConsoleSystem.GetValue(System.String,System.String)">
      <summary>
            Get a convar value as a string
            </summary>
    </member>
    <member name="M:Editor.ConsoleSystem.GetValueInt(System.String,System.Int32)">
      <summary>
            Get a convar value as an integer if possible.
            </summary>
    </member>
    <member name="M:Editor.ConsoleSystem.GetValueFloat(System.String,System.Single)">
      <summary>
            Get a convar value as an float if possible.
            </summary>
    </member>
    <member name="M:Editor.ConsoleSystem.Run(System.String)">
      <summary>
            Run this command. This should be a single command.
            </summary>
    </member>
    <member name="T:Editor.ControlWidget">
      <summary>
            A control widget is used to edit the value of a single SerializedProperty.
            </summary>
    </member>
    <member name="P:Editor.ControlWidget.CellAlignment">
      <summary>
            If none, when in a grid, the control will fill the entire cell
            </summary>
    </member>
    <member name="M:Editor.ControlWidget.StartEditing">
      <summary>
            Selects this widget and starts editing. Used when we want to focus on the widget in the
            inspector, like when double-clicking on something in a graph editor that maps to this widget.
            </summary>
    </member>
    <member name="P:Editor.ControlWidget.IsWideMode">
      <summary>
            If true we prefer to be full inspector width
            with the label above us
            </summary>
    </member>
    <member name="P:Editor.ControlWidget.IncludeLabel">
      <summary>
            If true (default) we'll include a label next to the control
            </summary>
    </member>
    <member name="M:Editor.ControlWidget.Prime">
      <summary>
            Should get called right after creation
            </summary>
    </member>
    <member name="M:Editor.ControlWidget.PushSerializationOptions">
      <summary>
            ActionGraph serializer needs hints about the GameObject that contains this property.
            </summary>
    </member>
    <member name="T:Editor.MissingSerializedPropertyWidget">
      <summary>
            Used when there's no defined ControlWidget
            </summary>
    </member>
    <member name="T:Editor.InvalidPropertyControlWidget">
      <summary>
            Used when there's no defined ControlWidget
            </summary>
    </member>
    <member name="T:Editor.MultiEditNotSupported">
      <summary>
            Used when there's no defined ControlWidget
            </summary>
    </member>
    <member name="P:Editor.EnumControlWidget.IsFlagsMode">
      <summary>
            If true, then this control is operating in flags mode (FlagsAttribute)
            </summary>
    </member>
    <member name="P:Editor.FloatControlWidget.HasRange">
      <summary>
            If true we can draw a slider
            </summary>
    </member>
    <member name="P:Editor.FloatControlWidget.Range">
      <summary>
            The range, min and max
            </summary>
    </member>
    <member name="P:Editor.FloatControlWidget.RangeStep">
      <summary>
            The step size between range
            </summary>
    </member>
    <member name="P:Editor.FloatControlWidget.RangeClamped">
      <summary>
            True if the range is clamped between min and max
            </summary>
    </member>
    <member name="P:Editor.StringControlWidget.RegexValidator">
      <summary>
            Allow overriding the regex validator on <see cref="F:Editor.StringControlWidget.LineEdit" />.
            </summary>
    </member>
    <member name="M:Editor.StringControlWidget.OnMultipleDifferentValues(System.Boolean)">
      <summary>
            Change text to pink if we're editing multiple values, and they differ
            </summary>
    </member>
    <member name="M:Editor.TextAreaControlWidget.OnMultipleDifferentValues(System.Boolean)">
      <summary>
            Change text to pink if we're editing multiple values, and they differ
            </summary>
    </member>
    <member name="T:Editor.TextureResidencyInfo">
      <summary>
            Provides information about currently resident textures on the GPU
            </summary>
    </member>
    <member name="M:Editor.TextureResidencyInfo.GetAll">
      <summary>
            Get info about all resident textures
            </summary>
    </member>
    <member name="P:Editor.EditorPreferences.ErrorNotificationTimeout">
      <summary>
            The amount of seconds to keep a notification open if it's an error
            </summary>
    </member>
    <member name="P:Editor.EditorPreferences.CameraFieldOfView">
      <summary>
            Camera field of view
            </summary>
    </member>
    <member name="P:Editor.EditorPreferences.CameraZNear">
      <summary>
            The closest thing to render
            </summary>
    </member>
    <member name="P:Editor.EditorPreferences.CameraZFar">
      <summary>
            The furthest thing to render
            </summary>
    </member>
    <member name="P:Editor.EditorPreferences.CameraMovementSmoothing">
      <summary>
            Should we smooth the movement of the camera. This is the smooth time, in seconds. No smoothing
            feels pretty jarring, but a bit feels nice. Once you get over half a second it makes everything feel
            slow and horrible.
            </summary>
    </member>
    <member name="P:Editor.EditorPreferences.CameraSpeed">
      <summary>
            How fast should the camera move
            </summary>
    </member>
    <member name="P:Editor.EditorPreferences.InvertOrbitZoom">
      <summary>
            Should the orbit camera zoom be inverted?
            <list type="bullet"><item>Inverted: mouse up/left zooms in, mouse down/right zooms out</item><item>Standard: mouse down/right zooms in, mouse up/left zooms out</item></list></summary>
    </member>
    <member name="P:Editor.EditorPreferences.OrbitZoomSpeed">
      <summary>
            How fast should the orbit camera zoom?
            </summary>
    </member>
    <member name="P:Editor.EditorPreferences.CameraInvertPan">
      <summary>
            Should the camera panning be inverted?
            </summary>
    </member>
    <member name="P:Editor.EditorPreferences.HideRotateCursor">
      <summary>
            Should we hide the eye cursor when rotating the scene camera?
            </summary>
    </member>
    <member name="P:Editor.EditorPreferences.HidePanCursor">
      <summary>
            Should we hide the eye cursor when panning scene camera?
            </summary>
    </member>
    <member name="P:Editor.EditorPreferences.HideOrbitCursor">
      <summary>
            Should we hide the eye cursor when orbiting scene camera?
            </summary>
    </member>
    <member name="P:Editor.EditorPreferences.BackfaceSelection">
      <summary>
            Should we hit the back faces when tracing meshes
            </summary>
    </member>
    <member name="P:Editor.EditorPreferences.BoundsPlacement">
      <summary>
            Use bounds when dragging in objects
            </summary>
    </member>
    <member name="P:Editor.EditorPreferences.ShortcutOverrides">
      <summary>
            Overrides for any Editor shortcuts.
            </summary>
    </member>
    <member name="P:Editor.EditorPreferences.WindowedLocalInstances">
      <summary>
            Whether new game instances spawned by the editor are in windowed mode.
            </summary>
    </member>
    <member name="P:Editor.EditorPreferences.NewInstanceCommandLineArgs">
      <summary>
            Command-line arguments for new game instances spawned by the editor.
            </summary>
    </member>
    <member name="P:Editor.EditorPreferences.DedicatedServerCommandLineArgs">
      <summary>
            Command-line arguments for new game instances spawned by the editor.
            </summary>
    </member>
    <member name="M:Editor.EditorShortcuts.GetKeys(System.String)">
      <summary>
            Returns the keybind for a given identifier
            </summary>
      <param name="identifier">The identifier of the shortcut</param>
    </member>
    <member name="M:Editor.EditorShortcuts.GetDisplayKeys(System.String)">
      <summary>
            Returns the pretty key hint for a given identifier
            </summary>
      <param name="identifier">The identifier of the shortcut</param>
    </member>
    <member name="M:Editor.EditorShortcuts.GetDefaultKeys(System.String)">
      <summary>
            Returns the default keybind for a given identifier
            </summary>
      <param name="identifier">The identifier of the shortcut</param>
    </member>
    <member name="M:Editor.EditorShortcuts.IsDown(System.String)">
      <summary>
            Returns whether a given shortcut is currently being held down
            </summary>
      <param name="identifier">The identifier of the shortcut</param>
    </member>
    <member name="M:Editor.ConsoleWidget.SetLogEvent(Sandbox.LogEvent)">
      <summary>
            Shows a stack trace on right side of the console window
            </summary>
      <param name="ev" />
    </member>
    <member name="M:Editor.ConsoleWidget.ClearDiagnosticLogs">
      <summary>
            Finds console output logs that are diagnostics and removes them.
            </summary>
    </member>
    <member name="M:Editor.ConsoleWidget.RaiseConsole">
      <summary>
            Raises the console dock so it's visible and in focus.
            </summary>
    </member>
    <member name="M:Editor.EditorMainWindow.OnDockLayoutLoaded">
      <summary>
            Called when the layout is loaded. We want to force all the scene views to be visible!
            </summary>
    </member>
    <member name="M:Editor.EditorMainWindow.ConsoleFocus">
      <summary>
            Called when the console key is pressed while the game is focused. Should
            do everything possible to switch to the actual console.
            </summary>
    </member>
    <member name="M:Editor.EditorMainWindow.Startup">
      <summary>
            Called once to create the editor
            </summary>
    </member>
    <member name="M:Editor.EditorMainWindow.IsFullscreen(Editor.Widget)">
      <summary>
            Is a widget currently the fullscreen widget
            </summary>
    </member>
    <member name="M:Editor.EditorMainWindow.SetFullscreen(Editor.Widget)">
      <summary>
            Sets a widget as the fullscreen widget
            </summary>
      <param name="widget" />
      <returns>whether or not the widget is now fullscreen</returns>
    </member>
    <member name="M:Editor.EditorMainWindow.UpdateEditMenu(Editor.Option,Editor.Option)">
      <summary>
            Updates Undo/Redo states and text
            </summary>
    </member>
    <member name="T:Editor.FullScreenManager">
      <summary>
            A class that handles the fullscreen behavior for the main editor window.
            </summary>
    </member>
    <member name="P:Editor.FullScreenManager.Widget">
      <summary>
            The current fullscreen widget
            </summary>
    </member>
    <member name="P:Editor.FullScreenManager.PreviousParent">
      <summary>
            A reference to the previous parent, when killing fullscreen we want to restore the widget 
            </summary>
    </member>
    <member name="M:Editor.FullScreenManager.Clear">
      <summary>
            Removes the current widget as the full screen widget
            </summary>
    </member>
    <member name="M:Editor.FullScreenManager.SetWidget(Editor.Widget)">
      <summary>
            Sets a widget as the fullscreen widget
            </summary>
      <param name="widget" />
    </member>
    <member name="T:Editor.GameScenePicker">
      <summary>
            Opens an invisible popup above the game screen which allows you to left click once on the scene.
            This is great for things like selecting something from the game scene.
            </summary>
    </member>
    <member name="P:Editor.LibrarySystem.All">
      <summary>
            Get all active libraries
            </summary>
    </member>
    <member name="M:Editor.LibrarySystem.InitializeFromProject(Sandbox.Project)">
      <summary>
            Scan this project's Libraries folder and add all of the library projects from it.
            </summary>
    </member>
    <member name="M:Editor.LibrarySystem.AddFromFolder(System.String)">
      <summary>
            Add a library project from a specific folder
            </summary>
    </member>
    <member name="M:Editor.LibrarySystem.Add(System.String,System.Threading.CancellationToken)">
      <summary>
            Add a library from this folder
            </summary>
    </member>
    <member name="M:Editor.LibrarySystem.Install(System.String,System.Int64,System.Threading.CancellationToken)">
      <summary>
            Install a library from a package. This will download the package and install it in the project's Library folder.
            </summary>
    </member>
    <member name="M:Editor.LibraryProject.ReadVersionFromFile">
      <summary>
            Try to read the library version from /.version
            </summary>
    </member>
    <member name="M:Editor.LibraryProject.RemoveAndDelete">
      <summary>
            Remove and delete this library, and folder
            </summary>
    </member>
    <member name="T:Editor.StackLineHandlerAttribute">
      <summary>
            Marks a method as a custom handler for stack trace lines matching a certain pattern.
            The method must take in a <see cref="T:System.Text.RegularExpressions.Match" /> parameter, and return
            a <see cref="T:Editor.StackRow" /> (or null).
            </summary>
    </member>
    <member name="P:Editor.EngineTools.All">
      <summary>
            Accessor to get tools available on this machine.
            </summary>
    </member>
    <member name="T:Editor.EditorEvent.FrameAttribute">
      <summary>
            Called every frame for tools
            </summary>
    </member>
    <member name="M:Editor.EditorEvent.UnregisterAssembly(System.Reflection.Assembly)">
      <summary>
            Register an assembly. If old assembly is valid, we try to remove all of the old event hooks
            from this assembly, while retaining a list of objects.
            </summary>
    </member>
    <member name="M:Editor.EditorEvent.RegisterAssembly(System.Reflection.Assembly)">
      <summary>
            Register an assembly. If old assembly is valid, we try to remove all of the old event hooks
            from this assembly, while retaining a list of objects.
            </summary>
    </member>
    <member name="M:Editor.EditorEvent.Register(System.Object)">
      <summary>
            Register an object, start receiving events
            </summary>
    </member>
    <member name="M:Editor.EditorEvent.Unregister(System.Object)">
      <summary>
            Unregister an object, stop receiving events
            </summary>
    </member>
    <member name="M:Editor.EditorEvent.Run(System.String)">
      <summary>
            Run an event.
            </summary>
    </member>
    <member name="M:Editor.EditorEvent.Run``1(System.String,``0)">
      <summary>
            Run an event with an argument of arbitrary type.
            </summary>
      <typeparam name="T">Arbitrary type for the argument.</typeparam>
      <param name="name">Name of the event to run.</param>
      <param name="arg0">Argument to pass down to event handlers.</param>
    </member>
    <member name="M:Editor.EditorEvent.Run``2(System.String,``0,``1)">
      <summary>
            Run an event with 2 arguments of arbitrary type.
            </summary>
      <typeparam name="T">Arbitrary type for the first argument.</typeparam>
      <typeparam name="U">Arbitrary type for the second argument.</typeparam>
      <param name="name">Name of the event to run.</param>
      <param name="arg0">First argument to pass down to event handlers.</param>
      <param name="arg1">Second argument to pass down to event handlers.</param>
    </member>
    <member name="M:Editor.EditorEvent.RunInterface``1(System.Action{``0})">
      <summary>
            Run an interface based event
            </summary>
    </member>
    <member name="M:Editor.EditorEvent.Run``3(System.String,``0,``1,``2)">
      <summary>
            Run an event with 3 arguments of arbitrary type.
            </summary>
      <typeparam name="T">Arbitrary type for the first argument.</typeparam>
      <typeparam name="U">Arbitrary type for the second argument.</typeparam>
      <typeparam name="V">Arbitrary type for the third argument.</typeparam>
      <param name="name">Name of the event to run.</param>
      <param name="arg0">First argument to pass down to event handlers.</param>
      <param name="arg1">Second argument to pass down to event handlers.</param>
      <param name="arg2">Third argument to pass down to event handlers.</param>
    </member>
    <member name="M:Editor.EditorEvent.ISceneEdited.GameObjectPreEdited(Sandbox.GameObject,System.String)">
      <summary>
            Called when a property on a <see cref="T:Sandbox.GameObject" /> is about to be edited, so the old value can be inspected.
            </summary>
    </member>
    <member name="M:Editor.EditorEvent.ISceneEdited.GameObjectEdited(Sandbox.GameObject,System.String)">
      <summary>
            Called when a <see cref="T:Sandbox.GameObject" /> has been edited, so the new value can be inspected.
            </summary>
    </member>
    <member name="M:Editor.EditorEvent.ISceneEdited.ComponentPreEdited(Sandbox.Component,System.String)">
      <summary>
            Called when a property on a <see cref="T:Sandbox.Component" /> is about to be edited, so the old value can be inspected.
            </summary>
    </member>
    <member name="M:Editor.EditorEvent.ISceneEdited.ComponentEdited(Sandbox.Component,System.String)">
      <summary>
            Called when a <see cref="T:Sandbox.Component" /> has been edited, so the new value can be inspected.
            </summary>
    </member>
    <member name="T:Editor.EditorEvent.ISceneView">
      <summary>
            Allows tools to inject behaviour in the scene editor.
            </summary>
    </member>
    <member name="M:Editor.EditorEvent.ISceneView.DrawGizmos(Sandbox.Scene)">
      <summary>
            Called when a scene editor viewport is drawing gizmos.
            </summary>
      <param name="scene">Scene that gizmos are being drawn for.</param>
    </member>
    <member name="T:Editor.EditorEvent.MapEditor">
      <summary>
            Events that happen within the map editor.
            </summary>
    </member>
    <member name="T:Editor.EditorEvent.MapEditor.SelectionChanged">
      <summary>
            Called when the user selects / deselects any object in the map and <see cref="P:Editor.MapEditor.Selection.All" /> is changed.
            </summary>
    </member>
    <member name="T:Editor.EditorEvent.MapEditor.MapViewContextMenu">
      <summary>
            Called when the map view is right clicked, <see cref="T:Editor.Menu" /> is passed.
            </summary>
    </member>
    <member name="T:Editor.FileSystem">
      <summary>
            A filesystem that can be accessed by the game.
            </summary>
    </member>
    <member name="P:Editor.FileSystem.Mounted">
      <summary>
            Paths from tool addons which are mounted.
            </summary>
    </member>
    <member name="P:Editor.FileSystem.Root">
      <summary>
            Root of the game's folder.
            </summary>
    </member>
    <member name="P:Editor.FileSystem.Temporary">
      <summary>
            The engine /game/.source2/ folder for temporary files and caches.
            </summary>
    </member>
    <member name="P:Editor.FileSystem.Config">
      <summary>
            The engine /game/config/ folder
            </summary>
    </member>
    <member name="P:Editor.FileSystem.WebCache">
      <summary>
            The engine /game/.source2/http/ folder.
            </summary>
    </member>
    <member name="P:Editor.FileSystem.ProjectTemporary">
      <summary>
            The current project's .sbox/ folder for temporary files and caches.
            </summary>
    </member>
    <member name="P:Editor.FileSystem.Cloud">
      <summary>
            The current project's .sbox/cloud/ folder. We download files from sbox.game right into this filesystem.
            </summary>
    </member>
    <member name="P:Editor.FileSystem.Transient">
      <summary>
            The current project's .sbox/transient/ folder. This is where assets are created at runtime. These are assets
            that are created by another asset,that don't need to be stored in source control or anything - because they
            can get re-created at will.
            </summary>
    </member>
    <member name="P:Editor.FileSystem.Content">
      <summary>
            Content from active addons (and content paths)
            </summary>
    </member>
    <member name="P:Editor.FileSystem.ProjectSettings">
      <summary>
            The current project's ProjectSettings folder
            </summary>
    </member>
    <member name="P:Editor.FileSystem.Libraries">
      <summary>
            The current project's Libraries folder
            </summary>
    </member>
    <member name="P:Editor.FileSystem.Localization">
      <summary>
            The current project's Localization folder
            </summary>
    </member>
    <member name="M:Editor.FileSystem.RebuildContentPath">
      <summary>
            Should be called on startup and whenever the mounted local addons have changed
            </summary>
    </member>
    <member name="M:Editor.FileSystem.OnContentFileChanged(System.String)">
      <summary>
            Called when a file has changed on the <see cref="P:Editor.FileSystem.Content" /> path.
            </summary>
    </member>
    <member name="M:Editor.FileSystem.SuppressNextHotload">
      <summary>
            Stop the game from triggering a hotload for this file - because presumably you have
            already reloaded it.
            </summary>
    </member>
    <member name="M:Editor.FileSystem.InitializeFromProject(Sandbox.Project)">
      <summary>
            Initialize the editor filesytems from this project, which is assumably the main game project.
            </summary>
    </member>
    <member name="M:Editor.EntityParser.ParseProperties(System.Type,Editor.MapClass)">
      <summary>
            Parses the properties of an entity type and adds them to the GDclass
            </summary>
    </member>
    <member name="T:Editor.GameData">
      <summary>
            Lets all native and managed tools know about any engine / game entities.
            </summary>
      <summary>
            Lets all native and managed tools know about any engine / game entities.
            </summary>
    </member>
    <member name="P:Editor.GameData.GameDataDirty">
      <summary>
            This gets set when the assemblies are changed, which means we have fresh game data... maybe.
            This ultimately triggers a tools.gamedata.refresh on the next frame.
            </summary>
    </member>
    <member name="M:Editor.GameData.AddAssembly(System.Reflection.Assembly)">
      <summary>
            Add this assembly to the console library, which will scan it for console commands and make them available.
            </summary>
    </member>
    <member name="M:Editor.GameData.RemoveAssembly(System.Reflection.Assembly)">
      <summary>
            Remove this assembly and its console commands.
            </summary>
    </member>
    <member name="P:Editor.GameData.EntityClasses">
      <summary>
            A list of all entity classes exposed to tools.
            </summary>
    </member>
    <member name="M:Editor.GameData.Initialize(Native.CGameData)">
      <summary>
             This is called one time only when tools are first initialized.
             The passed CGameData is kept around for the entirety of the application session and is accessible
             across all tools.
            
             This is called just after the native engine loads whatever is left in .fgd files.
             We copy them to C# so we can access them from managed.
             </summary>
    </member>
    <member name="M:Editor.GameData.CopyNativeEntities">
      <summary>
            Copies the native gamedata for access from C#.
            </summary>
    </member>
    <member name="P:Editor.GameData.LoadedPackages">
      <summary>
            All loaded sbox.game packages for this session to load entities for tools from.
            </summary>
    </member>
    <member name="M:Editor.GameData.LoadEntitiesFromPackage(Sandbox.Package)">
      <summary>
            Loads the entity classes from a remote sbox.game game or addon into Hammer.
            </summary>
    </member>
    <member name="T:Editor.InputOutputBase">
      <summary>
            Represents a variable
            </summary>
    </member>
    <member name="T:Editor.MapClass">
      <summary>
            Represents an entity class used by the map editor
            </summary>
    </member>
    <member name="P:Editor.MapClass.Name">
      <summary>
            Class name e.g prop_physics
            </summary>
    </member>
    <member name="P:Editor.MapClass.DisplayName">
      <summary>
            Display name e.g Physics Prop
            </summary>
    </member>
    <member name="P:Editor.MapClass.Description">
      <summary>
            Human readable name e.g Physics Prop
            </summary>
    </member>
    <member name="P:Editor.MapClass.Icon">
      <summary>
            Icon ( Material )
            </summary>
    </member>
    <member name="P:Editor.MapClass.Category">
      <summary>
            Category
            </summary>
    </member>
    <member name="P:Editor.MapClass.Type">
      <summary>
            C# Type of this class
            </summary>
    </member>
    <member name="P:Editor.MapClass.ClassType">
      <summary>
            Point, Solid, etc..
            </summary>
    </member>
    <member name="P:Editor.MapClass.IsPointClass">
      <summary>
            A point entity, i.e. a model entity, etc.
            </summary>
    </member>
    <member name="P:Editor.MapClass.IsSolidClass">
      <summary>
            A solid class entity, triggers, etc., entities that are tied to from a mesh in Hammer
            </summary>
    </member>
    <member name="P:Editor.MapClass.IsPathClass">
      <summary>
            A path entity, will appear in the Path Tool.
            </summary>
    </member>
    <member name="P:Editor.MapClass.IsCableClass">
      <summary>
            A cable entity, will appear in the Path Tool.
            </summary>
    </member>
    <member name="P:Editor.MapClass.Variables">
      <summary>
            List of properties exposed to tools for this class.
            </summary>
    </member>
    <member name="P:Editor.MapClass.Inputs">
      <summary>
            List of inputs for this class.
            </summary>
    </member>
    <member name="P:Editor.MapClass.Outputs">
      <summary>
            List of outputs for this class.
            </summary>
    </member>
    <member name="P:Editor.MapClass.Tags">
      <summary>
            General purpose tags, some with special meanings within Hammer and map compilers.
            </summary>
    </member>
    <member name="P:Editor.MapClass.EditorHelpers">
      <summary>
            In-editor helpers for this class, such as box visualizers for certain properties, etc.
            </summary>
    </member>
    <member name="P:Editor.MapClass.Metadata">
      <summary>
            General purpose key-value store to alter functionality of UI, map compilation, editor helpers, etc.
            </summary>
    </member>
    <member name="P:Editor.MapClass.GameIdent">
      <summary>
            What game does this belong to? ( TODO: Might not be best place for this? )
            </summary>
    </member>
    <member name="P:Editor.MapClass.Package">
      <summary>
            What package did this entity come from?
            </summary>
    </member>
    <member name="P:Editor.MapClass.Assembly">
      <summary>
            What Assembly did this entity come from?
            </summary>
    </member>
    <member name="T:Editor.MapClassVariable">
      <summary>
            Represents a variable.
            </summary>
    </member>
    <member name="P:Editor.MapClassVariable.Name">
      <summary>
            The internal name.
            </summary>
    </member>
    <member name="P:Editor.MapClassVariable.LongName">
      <summary>
            The user friendly name for UI.
            </summary>
    </member>
    <member name="P:Editor.MapClassVariable.Description">
      <summary>
            Description for this variable.
            </summary>
    </member>
    <member name="P:Editor.MapClassVariable.GroupName">
      <summary>
            Category or group for this variable.
            </summary>
    </member>
    <member name="P:Editor.MapClassVariable.PropertyType">
      <summary>
            Data type for this variable.
            </summary>
    </member>
    <member name="P:Editor.MapClassVariable.DefaultValue">
      <summary>
            Default value for this variable.
            </summary>
    </member>
    <member name="P:Editor.MapClassVariable.PropertyTypeOverride">
      <summary>
            Internal, used to override the type to one the tools understand.
            </summary>
    </member>
    <member name="P:Editor.MapClassVariable.Metadata">
      <summary>
            General purpose key-value store to alter functionality of UI, map compilation, editor helpers, etc.
            </summary>
    </member>
    <member name="M:Editor.MapClassVariable.SerializedType(System.Type)">
      <summary>
            Translates our C# type to a type mapdoc understands.
            I doubt we actually need to use a string here for it, but it does make things easier.
            e.g an array
            </summary>
    </member>
    <member name="F:Editor.CanEditAttribute.EditorAttributeTypes">
      <summary>
            List of attribute types that are generic argument in IEditorAttribute
            </summary>
    </member>
    <member name="F:Editor.CanEditAttribute.EditorAttributes">
      <summary>
            List of the generic IEditorAttribute class types itself
            </summary>
    </member>
    <member name="M:Editor.CanEditAttribute.IsActionDelegateType(System.Type)">
      <summary>
            Is <paramref name="t" /> a delegate type that returns void or a plain Task?
            </summary>
    </member>
    <member name="T:Editor.ComponentEditorWidget">
      <summary>
            A control widget is used to edit the value of a single SerializedProperty.
            </summary>
    </member>
    <member name="T:Editor.IEditorAttribute`1">
      <summary>
            Allows an editor widget to provide an attribute that it can use. Editors with attributes are chosen
            over editors without when the target property has the provided attribute.
            </summary>
    </member>
    <member name="P:Editor.ManagedTools.AssembliesDirty">
      <summary>
            This gets set when the assemblies are changed, which means we may have new tools and menu options.
            This ultimately triggers a tools.refresh on the next frame.
            </summary>
    </member>
    <member name="F:Editor.ManagedTools.AccountLoginTask">
      <summary>
            On startup we start logging in. We can continue to log in during startup, in the background.
            But we really want to have been logged in by the time we start accessing the API properly.
            </summary>
    </member>
    <member name="M:Editor.ManagedTools.OnQtHeartbeat">
      <summary>
            Attempted to be called every 16ms, even when Qt is blocking
            </summary>
    </member>
    <member name="M:Editor.MapEditor.CanDropAttribute.#ctor(System.String)">
      <summary>
            Can drop a package or asset extension of this type.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.IMapViewDropTarget">
      <summary>
            Provides an interface for dragging and dropping <see cref="T:Editor.Asset" /> or <see cref="T:Sandbox.Package" /> on a map view.
            Use with <see cref="T:Editor.MapEditor.CanDropAttribute" /> to register your drop target for a <see cref="T:Sandbox.Package.Type" /> or <see cref="T:Sandbox.GameResource" /> type.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.IMapViewDropTarget.DragEnter(Editor.Asset,Editor.MapEditor.MapView)">
      <summary>
            An asset started being dragged over a Hammer view..
            </summary>
    </member>
    <member name="M:Editor.MapEditor.IMapViewDropTarget.DragEnter(Sandbox.Package,Editor.MapEditor.MapView)">
      <summary>
            An sbox.game package started being dragged over a Hammer view..
            </summary>
    </member>
    <member name="M:Editor.MapEditor.IMapViewDropTarget.DragMove(Editor.MapEditor.MapView)">
      <summary>
            Called when the mouse cursor moves over a Hammer view while dragging an asset or a package.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.IMapViewDropTarget.DragDropped(Editor.MapEditor.MapView)">
      <summary>
            Called when a dragged an asset or a package gets finally dropped on a Hammer view.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.IMapViewDropTarget.DragLeave(Editor.MapEditor.MapView)">
      <summary>
            Called when a dragged an asset or a package gets dragged outside of a Hammer view.
            This is a good spot to clean up any created nodes.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.MapViewDropTarget">
      <summary>
            Provides drop targets for Hammer's map views.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.MapViewDropTarget.OnDragEnter(QDragEnterEvent,Editor.MapEditor.MapView)">
      <summary>
            Called from native when something is dragged into the map view.
            Returning true lets native know we're handling it, false lets native handle it.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.MapViewDropTarget.OnDragMove(QDragMoveEvent,Editor.MapEditor.MapView)">
      <summary>
            Called from native each time the user moves their mouse whilst dragging something over a map view.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.MapViewDropTarget.OnDrop(QDropEvent,Editor.MapEditor.MapView)">
      <summary>
            Called from native when the user drops something onto a map view.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.MapViewDropTarget.OnDragLeave(Editor.MapEditor.MapView)">
      <summary>
            Called from native when the user cancels a drag operation.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.MapViewDropTarget.GetDragAndDropActive">
      <summary>
            Queried by native Hammer to know if we're currently dragging something. Kinda shit.
            But this is used to stop switching modes whilst drag dropping.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.MaterialDropTarget.DeriveOverlayAnglesFromNormal(Vector3)">
      <summary>
            Calculate the angles required to align the entity to the plane perpendicular to the given normal
            Now rotate the angle 90 degrees so that it matches the orientation of the texture as it is authored
            </summary>
    </member>
    <member name="T:Editor.MapEditor.ModelDropTarget">
      <summary>
            Create prop_static entities from a Package model.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.ModelDropTarget.SetEntityToPackageModelAsync(Editor.MapDoc.MapEntity,System.String)">
      <summary>
            Installs the package and sets the model on the entity when that's done
            </summary>
    </member>
    <member name="P:Editor.MapEditor.Hammer.ActiveMap">
      <summary>
            The active editor session's map document.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.Hammer.Open">
      <summary>
            If the Hammer app has been opened.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.Hammer.Window">
      <summary>
            The Hammer app's window.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.Hammer.CurrentMaterial">
      <summary>
            Current Material - you can set this programmatically with <see cref="M:Editor.MapEditor.Hammer.SetCurrentMaterial(Editor.Asset)" /></summary>
    </member>
    <member name="M:Editor.MapEditor.Hammer.Init(NativeHammer.CHammerApp)">
      <summary>
            Called once when Hammer is opened.
            Does not get called again if Hammer is closed and reopened.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Hammer.ReloadFromFile">
      <summary>
            Reloads the active editor session from file with user prompt
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Hammer.RenderMapViewHUD(Editor.MapEditor.MapView,CToolRenderContext)">
      <summary>
            Screenspace rendering context called for each map view.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Hammer.UpdateActiveMaterial(NativeEngine.IMaterial)">
      <summary>
            Called from native Hammer whenever the active material is changed.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Hammer.SetCurrentMaterial(Editor.Asset)">
      <summary>
            Sets the currently used material to the specified asset.
            </summary>
      <remarks>
            I'd happily merge together this into a get setter, but it's a mix of a Material and an Asset
            </remarks>
    </member>
    <member name="M:Editor.MapEditor.Hammer.OnMapViewOpenContextMenu(Editor.MapEditor.MapView,Native.QMenu)">
      <summary>
            Called from native when the map view is right clicked
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Hammer.RefreshGameData">
      <summary>
            Refreshes GameData on map nodes
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Hammer.PreSaveMap(Editor.MapDoc.MapDocument)">
      <summary>
            Called just before anything is saved to a map file.
            This is the ideal place to manipulate the map document just before save.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Hammer.MapAssetSaved(System.Int32,Editor.MapDoc.MapDocument)">
      <summary>
            Called after the map has been successfully written to disk.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Hammer.GetUsedPackages(Editor.MapDoc.MapDocument)">
      <summary>
            Get a list of packages used in this map, based primarily on the entities used.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Hammer.PostLoadMap(Editor.MapDoc.MapDocument)">
      <summary>
            Called after loading a map file from disk, after the MapDoc is created but before the world is loaded.
            This makes it the perfect place to resolve any dependent assets or game data, but not the place
            to interact with the world in any meaningful way.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Hammer.SelectObjectsUsingAsset(Editor.Asset)">
      <summary>
            Selects all map nodes using the asset, appending them to the current selection.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Hammer.SelectFacesUsingMaterial(Editor.Asset)">
      <summary>
            Selects all faces using the asset, forces <see cref="P:Editor.MapEditor.Selection.SelectMode" /> to <see cref="F:Editor.MapEditor.SelectMode.Faces" /></summary>
    </member>
    <member name="M:Editor.MapEditor.Hammer.AssignAssetToSelection(Editor.Asset)">
      <summary>
            Assigns the asset to the current selection.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Hammer.ShowEntityReportForAsset(Editor.Asset)">
      <summary>
            Opens a Entity Report dialog showing all entities using this asset.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.CapsuleLightEntity">
      <summary>
            An omni-directional light entity.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.RectangleLightEntity">
      <summary>
            An omni-directional light entity.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.CommentEntity">
      <summary>
            A place to leave notes
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.CubemapBox">
      <summary>
            An env_cubemap with box projection.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.Cubemap">
      <summary>
            Cubemap for sampling indirect specular reflection.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.Cubemap.Radius">
      <summary>
            The radius of influence for this cubemap
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.BaseCubemap.CubemapTexture">
      <summary>
            Name of the cubemap texture
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.BaseCubemap.Priority">
      <summary>
            If multiple volumes contain an object, the highest priority volume takes precedence.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.BaseCubemap.BakeNearZ">
      <summary>
            Near clip plane used for the camera when baking the cube map
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.BaseCubemap.BakeFarZ">
      <summary>
            Far clip plane used for the camera when baking the cube map
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.BaseCubemap.LightGroup">
      <summary>
            Semicolon-delimited list of light groups to affect.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.BaseCubemap.BoxProjectMins">
      <summary>
            Minimum bounding box for the cubemap
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.BaseCubemap.BoxProjectMaxs">
      <summary>
            Maximum bounding box for the cubemap
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.BaseCubemap.Feathering">
      <summary>
            Amount of feathering to apply to the cubemap edges to blend with other envmaps
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.BaseCubemap.ArrayIndex">
      <summary>
            Index into the cubemap texture array
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.BaseCubemap.Handshake">
      <summary>
            Static objects find the cubemap to use with a baked handshake.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.BaseCubemap.CustomTexture">
      <summary>
            User provided a custom cubemap texture.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.HammerCubemapFog">
      <summary>
            Specifies fog based on an material.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.HammerCubemapFog.CubemapMaterial">
      <summary>
            Cubemap material to use for the fog.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.HammerCubemapFog.LodBias">
      <summary>
            Adjust how quickly the cubemap blurs out at closer distances. A value of 0.0 always uses the lowest resolution MIP over the entire range, while a value of 1.0 uses the highest.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.HammerCubemapFog.StartDistance">
      <summary>
            The distance from the player at which the fog will start to fade in.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.HammerCubemapFog.EndDistance">
      <summary>
            The distance from the player at which the fog will be at full strength.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.HammerCubemapFog.FalloffExponent">
      <summary>
            Exponent for distance falloff. For example, 2.0 is proportional to square of distance.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.HammerCubemapFog.HeightWidth">
      <summary>
            The distance between the start of the height fog and where it is fully opaque. Setting this to 0 will disable height based blending.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.HammerCubemapFog.HeightStart">
      <summary>
            The absolute height in the map at which the height fog will start to fade in.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.HammerCubemapFog.HeightExponent">
      <summary>
            Exponent for height falloff. For example, 2.0 is proportional to square of distance.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.EnvironmentLightEntity">
      <summary>
            An environment light entity. This acts as the sun.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.EnvironmentLightEntity.Enabled">
      <summary>
            Whether this light is enabled or not.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.EnvironmentLightEntity.Color">
      <summary>
            Color of this light.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.EnvironmentLightEntity.Brightness">
      <summary>
            Brightness of this light.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.EnvironmentLightEntity.DynamicShadows">
      <summary>
            Whether this light should cast dynamic shadows.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.EnvironmentLightEntity.FogStrength">
      <summary>
            Overrides how much the light affects the fog. (if enabled)
            </summary>
    </member>
    <member name="M:Editor.MapEditor.EntityDefinitions.EnvironmentLightEntity.UseNoFog">
      <summary>
            Disable volumetric fog.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.EntityDefinitions.EnvironmentLightEntity.UseFog">
      <summary>
            Enable dynamic volumetric fog.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.EntityDefinitions.EnvironmentLightEntity.UseFogNoShadows">
      <summary>
            Enable dynamic volumetric fog without shadows.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.EnvironmentLightEntity.SkyColor">
      <summary>
            Ambient light color outside of all light probes.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.EnvironmentLightEntity.SkyIntensity">
      <summary>
            Ambient light intensity outside of all light probes.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.EnvironmentLightEntity.AmbientColor">
      <summary>
            Ambient light color
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.FuncBrushEntity">
      <summary>
            A generic brush/mesh that can toggle its visibility and collisions, and can be broken.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.GradientFogEntity">
      <summary>
            Specifies fog based on a color gradient
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.GradientFogEntity.FogEnabled">
      <summary>
            Whether the fog is enabled or not.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.GradientFogEntity.FogStartDistance">
      <summary>
            For start distance.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.GradientFogEntity.FogEndDistance">
      <summary>
            Fog end distance.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.GradientFogEntity.FogStartHeight">
      <summary>
            Fog start height.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.GradientFogEntity.FogEndHeight">
      <summary>
            Fog end height.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.GradientFogEntity.FogMaximumOpacity">
      <summary>
            Set the maximum opacity at the base of the gradient fog.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.GradientFogEntity.FogColor">
      <summary>
            Set the gradient fog color.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.GradientFogEntity.FogStrength">
      <summary>
            Fog strength.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.GradientFogEntity.FogDistanceFalloffExponent">
      <summary>
            Exponent for distance falloff.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.GradientFogEntity.FogVerticalFalloffExponent">
      <summary>
            "Exponent for vertical falloff."
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.GradientFogEntity.FogFadeTime">
      <summary>
            How much time it takes to fade in new values.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.HammerEntityDefinition">
      <summary>
            Defines a dumb old Hammer entity, this is pretty much only for the hard coded shit
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.InfoCullTrianglesEntity">
      <summary>
            A static (compile-time) volume that will delete geometry inside it as part of map compile.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.InfoOverlayEntity">
      <summary>
            An entity that places an overlay on the world
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.LightProbe">
      <summary>
            A grid of precomputed light probes.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.LightProbe.Texture">
      <summary>
            Name of the light probe texture
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.LightProbe.BoxMins">
      <summary>
            Minimum bounding box for the cubemap
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.LightProbe.BoxMaxs">
      <summary>
            Maximum bounding box for the cubemap
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.LightProbe.VoxelSize">
      <summary>
            Volume resolution.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.LightProbe.Priority">
      <summary>
            If multiple volumes contain an object, the highest priority volume takes precedence.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.LightProbe.FloodFill">
      <summary>
            Ignore Unreachable Space.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.LightProbe.Voxelize">
      <summary>
            Ignore Voxelized Solid Space.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.LightProbe.FromCubemap">
      <summary>
            Calculate Diffuse Lighting Using Cubemap.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.LightProbe.LightGroup">
      <summary>
            Semicolon-delimited list of light groups to affect.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.LightProbe.Storage">
      <summary>
            How the light probe texture is stored.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.LightProbe.Handshake">
      <summary>
            Static objects find the light probe to use with a baked handshake.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.CombinedLightProbe">
      <summary>
            Combination of an env_cubemap_box and an env_light_probe_volume.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.CombinedLightProbe.CubemapTexture">
      <summary>
            Name of the cubemap texture
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.CombinedLightProbe.Priority">
      <summary>
            If multiple volumes contain an object, the highest priority volume takes precedence.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.CombinedLightProbe.BakeNearZ">
      <summary>
            Near clip plane used for the camera when baking the cube map
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.CombinedLightProbe.BakeFarZ">
      <summary>
            Far clip plane used for the camera when baking the cube map
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.CombinedLightProbe.LightGroup">
      <summary>
            Semicolon-delimited list of light groups to affect.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.CombinedLightProbe.BoxMins">
      <summary>
            Minimum bounding box for the cubemap
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.CombinedLightProbe.BoxMaxs">
      <summary>
            Maximum bounding box for the cubemap
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.CombinedLightProbe.Feathering">
      <summary>
            Amount of feathering to apply to the cubemap edges to blend with other envmaps
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.CombinedLightProbe.ArrayIndex">
      <summary>
            Index into the cubemap texture array
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.CombinedLightProbe.Handshake">
      <summary>
            Static objects find the cubemap to use with a baked handshake.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.CombinedLightProbe.Texture">
      <summary>
            Name of the light probe texture
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.CombinedLightProbe.VoxelSize">
      <summary>
            Volume resolution.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.CombinedLightProbe.FloodFill">
      <summary>
            Ignore Unreachable Space.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.CombinedLightProbe.Voxelize">
      <summary>
            Ignore Voxelized Solid Space.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.CombinedLightProbe.FromCubemap">
      <summary>
            Calculate Diffuse Lighting Using Cubemap.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.CombinedLightProbe.Storage">
      <summary>
            How the light probe texture is stored.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.CombinedLightProbe.CustomTexture">
      <summary>
            User provided a custom cubemap texture.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.OrthoLightEntity">
      <summary>
            A directional, orthographic light entity.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.OrthoLightEntity.Enabled">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Enabled" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.OrthoLightEntity.Color">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Color" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.OrthoLightEntity.Brightness">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Brightness" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.OrthoLightEntity.BrightnessMultiplier">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.BrightnessMultiplier" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.OrthoLightEntity.Range">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Range" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.OrthoLightEntity.Falloff">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Falloff" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.OrthoLightEntity.OrthoLightWidth">
      <summary>
            Orthographic light rectangle width.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.OrthoLightEntity.OrthoLightHeight">
      <summary>
            Orthographic light rectangle height.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.OrthoLightEntity.LightCookie">
      <summary>
            The light cookie texture for this light. A light cookie is like a filter or a mask for the emitted light.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.OrthoLightEntity.Flicker">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Flicker" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.OrthoLightEntity.FogStrength">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.FogStrength" />
    </member>
    <member name="M:Editor.MapEditor.EntityDefinitions.OrthoLightEntity.UseNoFog">
      <inheritdoc cref="M:Editor.MapEditor.EntityDefinitions.PointLightEntity.UseNoFog" />
    </member>
    <member name="M:Editor.MapEditor.EntityDefinitions.OrthoLightEntity.UseFog">
      <inheritdoc cref="M:Editor.MapEditor.EntityDefinitions.PointLightEntity.UseFog" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.OrthoLightEntity.FadeDistanceMin">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.FadeDistanceMin" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.OrthoLightEntity.FadeDistanceMax">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.FadeDistanceMax" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.OrthoLightEntity.DynamicShadows">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.DynamicShadows" />
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.PointLightEntity">
      <summary>
            An omni-directional light entity.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Enabled">
      <summary>
            Whether this light is enabled or not.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Color">
      <summary>
            Color of this light.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Brightness">
      <summary>
            Brightness of this light.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.BrightnessMultiplier">
      <summary>
            Brightness multiplier.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Range">
      <summary>
            Distance range for light. 0=infinite
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Falloff">
      <summary>
            Angular falloff exponent. Does not work with light cookies. Does not work with dynamic lighting.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Flicker">
      <summary>
            Flicker the light 8 times a second.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.DynamicShadows">
      <summary>
            Enable or disable dynamic shadow casting.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.FogStrength">
      <summary>
            Overrides how much the light affects the fog. (if enabled)
            </summary>
    </member>
    <member name="M:Editor.MapEditor.EntityDefinitions.PointLightEntity.UseNoFog">
      <summary>
            Disable volumetric fog.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.EntityDefinitions.PointLightEntity.UseFog">
      <summary>
            Enable dynamic volumetric fog.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.EntityDefinitions.PointLightEntity.UseFogNoShadows">
      <summary>
            Enable dynamic volumetric fog without shadows.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.FadeDistanceMin">
      <summary>
            Distance at which the light starts to fade. (less than 0 = use 'Fade Distance Max')
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.FadeDistanceMax">
      <summary>
            Maximum distance at which the light is visible. (0 = don't fade out)
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.ShadowFadeDistanceMin">
      <summary>
            Distance at which the shadow starts to fade. (less than 0 = use 'Shadow End Fade Dist')
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.ShadowFadeDistanceMax">
      <summary>
            Maximum distance at which the shadow is visible. (0 = don't fade out)
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.PropAnimated">
      <summary>
            A static prop that can play animations. If a door is wanted, please use the door entity.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropAnimated.DefaultAnimation">
      <summary>
            The name of the idle animation that this prop will revert to whenever it finishes a random or forced animation.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropAnimated.UseAnimationGraph">
      <summary>
            Allow this entity to use its animgraph
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropAnimated.HoldAnimation">
      <summary>
            If set, the prop will not loop its animation, but hold the last frame.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropAnimated.Collisions">
      <summary>
            Whether the animated prop should have collisions.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropAnimated.Breakable">
      <summary>
            If the model supports break pieces and has prop_data with health, this option can be used to allow the door to break like a normal prop would.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropAnimated.AnimationSpeed">
      <summary>
            Initial animation playback rate.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.PropPhysicsEntity">
      <summary>
            A prop that physically simulates as a single rigid body. It can be constrained to other physics objects using hinges
            or other constraints. It can also be configured to break when it takes enough damage.
            Note that the health of the object will be overridden by the health inside the model, to ensure consistent health game-wide.
            If the model used by the prop is configured to be used as a prop_animated (i.e. it should not be physically simulated) then it CANNOT be
            used as a prop_physics. Upon level load it will display a warning in the console and remove itself. Use a prop_animated instead.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropPhysicsEntity.Static">
      <summary>
            If set, the prop will spawn with motion disabled and will act as a navigation blocker until broken.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropPhysicsEntity.BoneTransforms">
      <summary>
            Set during map compile for multi physics body models based on Hammer physics simulation tool.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropPhysicsEntity.MassScale">
      <summary>
            Multiplier for the object's mass.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropPhysicsEntity.LinearDamping">
      <summary>
            Physics linear damping.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropPhysicsEntity.AngularDamping">
      <summary>
            Physics angular damping.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.PropStaticEntity">
      <summary>
            A static model. It will be embedded into the map on compile therefore cannot be manipulated in-game.
            It affects performance less than other model entities and can have baked lighting.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropStaticEntity.ScreenSpaceFade">
      <summary>
            The method by which the fading distance should be determined.
            If 'No', the fade distances is the distance from the player's view to the object, in inches.
            If 'Yes', the fade distance is the size of the object onscreen, in pixels.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropStaticEntity.Skin">
      <summary>
            Some models have multiple versions of their textures, called skins.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropStaticEntity.LodLevel">
      <summary>
            LOD level to be displayed in game. Set to Auto for standard automatic selection, or set to a specific level to always use that level.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropStaticEntity.FadeMaxDist">
      <summary>
            Maximum distance at which the prop is visible (0 = don't fade out).
            If 'Screen Space Fade' is selected, this represents the *minimum* number of pixels wide covered by the prop when it fades.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropStaticEntity.DetailGeometry">
      <summary>
            If true this geometry is not important for precomputed lighting.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropStaticEntity.VisOccluder">
      <summary>
            If true this geometry is used as an occluder for precomputed visibility.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropStaticEntity.BakeToWorld">
      <summary>
            If true this geometry will be baked into the world geometry of the map so that the model is not referenced at runtime.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropStaticEntity.DisableMeshMerging">
      <summary>
            If true this will not be merged with other geometry during map compile (reduces rendering efficiency).
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropStaticEntity.LightingOrigin">
      <summary>
            Select a an entity to specify a location to sample lighting from, instead of using this entity's bounding box center.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropStaticEntity.LightGroup">
      <summary>
            Will only be lit by lights affecting this group.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropStaticEntity.RenderToCubemaps">
      <summary>
            If true, this geometry renders into baked cube maps.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropStaticEntity.PrecomputeLightProbes">
      <summary>
            Pre-compute environment map and light probe volume used on this object.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropStaticEntity.DisableInLowQuality">
      <summary>
            Do not render this prop when using the lowest quality video settings, it is an non-essential detail.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropStaticEntity.LightmapScaleBias">
      <summary>
            Use to scale the resolution of the lightmap for this object.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.PropStaticEntity.RenderWithDynamic">
      <summary>
            Render this object with other dynamic objects.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.SkyCameraEntity">
      <summary>
            An entity used to control the 3D Skybox.
            Its origin is used to determine the 3D Skybox's position relative to the map.
            Place this entity, in the 3D Skybox, at the point where the origin of the map should be.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SkyCameraEntity.SkyboxScale">
      <summary>
            Scale of the skybox.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.SoundEventBoxEntity">
      <summary>
            Plays a sound event from a point, passes along the min and max positions of its AABB.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SoundEventBoxEntity.SoundName">
      <summary>
            Name of the sound to play.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SoundEventBoxEntity.StartOnSpawn">
      <summary>
            Start the sound on spawn
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SoundEventBoxEntity.StopOnNew">
      <summary>
            Stop the sound before starting to play it again
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SoundEventBoxEntity.OverrideSoundParams">
      <summary>
            Setting this to true will override default sound parameters
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SoundEventBoxEntity.SoundVolume">
      <summary>
            Set the volume of the sound
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SoundEventBoxEntity.SoundPitch">
      <summary>
            Set the pitch of the sound
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.SoundEventEntity">
      <summary>
            Plays a sound event from a point. The point can be this entity or a specified entity's position.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SoundEventEntity.SoundName">
      <summary>
            Name of the sound to play.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SoundEventEntity.SourceEntityName">
      <summary>
            The entity to use as the origin of the sound playback. If not set, will play from this snd_event_point.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SoundEventEntity.StartOnSpawn">
      <summary>
            Start the sound on spawn
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SoundEventEntity.StopOnNew">
      <summary>
            Stop the sound before starting to play it again
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SoundEventEntity.OverrideSoundParams">
      <summary>
            Setting this to true will override default sound parameters
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SoundEventEntity.SoundVolume">
      <summary>
            Set the volume of the sound
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SoundEventEntity.SoundPitch">
      <summary>
            Set the pitch of the sound
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.SoundScapeBoxEntity">
      <summary>
            Plays a soundscape when you enter the bounds.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SoundScapeBoxEntity.Soundscape">
      <summary>
            Name of the soundscape to play.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SoundScapeBoxEntity.Enabled">
      <summary>
            Is Enabled
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.SoundScapeEntity">
      <summary>
            Plays a soundscape when you enter the radius.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SoundScapeEntity.Soundscape">
      <summary>
            Name of the soundscape to play.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SoundScapeEntity.Enabled">
      <summary>
            Is Enabled
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.SpawnPointEntity">
      <summary>
            This entity defines the spawn point of the player in first person shooter gamemodes.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.SpotLightEntity">
      <summary>
            A directional spot light entity.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SpotLightEntity.Enabled">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Enabled" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SpotLightEntity.Color">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Color" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SpotLightEntity.Brightness">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Brightness" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SpotLightEntity.BrightnessMultiplier">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.BrightnessMultiplier" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SpotLightEntity.Range">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Range" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SpotLightEntity.Falloff">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Falloff" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SpotLightEntity.InnerConeAngle">
      <summary>
            Inner cone angle. No angular falloff within this cone.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SpotLightEntity.OuterConeAngle">
      <summary>
            Outer cone angle.
            </summary>
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SpotLightEntity.LightCookie">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.OrthoLightEntity.LightCookie" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SpotLightEntity.Flicker">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.Flicker" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SpotLightEntity.DynamicShadows">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.DynamicShadows" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SpotLightEntity.FogStrength">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.FogStrength" />
    </member>
    <member name="M:Editor.MapEditor.EntityDefinitions.SpotLightEntity.UseNoFog">
      <inheritdoc cref="M:Editor.MapEditor.EntityDefinitions.PointLightEntity.UseNoFog" />
    </member>
    <member name="M:Editor.MapEditor.EntityDefinitions.SpotLightEntity.UseFog">
      <inheritdoc cref="M:Editor.MapEditor.EntityDefinitions.PointLightEntity.UseFog" />
    </member>
    <member name="M:Editor.MapEditor.EntityDefinitions.SpotLightEntity.UseFogNoShadows">
      <inheritdoc cref="M:Editor.MapEditor.EntityDefinitions.PointLightEntity.UseFogNoShadows" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SpotLightEntity.FadeDistanceMin">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.FadeDistanceMin" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SpotLightEntity.FadeDistanceMax">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.FadeDistanceMax" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SpotLightEntity.ShadowFadeDistanceMin">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.ShadowFadeDistanceMin" />
    </member>
    <member name="P:Editor.MapEditor.EntityDefinitions.SpotLightEntity.ShadowFadeDistanceMax">
      <inheritdoc cref="P:Editor.MapEditor.EntityDefinitions.PointLightEntity.ShadowFadeDistanceMax" />
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.VolumetricFogController">
      <summary>
            Controller for volumetric fogging - bounds are extents of fog irradiance volume (for indirect)
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityDefinitions.HammerVolumetricFogVolume">
      <summary>
            Sets a user bounding volume for volumetric fog - if one of these are in the map then all fog will get clamped to these entities.
            Requires a env_volumetric_fog_controller present to work.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.HammerEvents">
      <summary>
            Events from hammerevents.h
            </summary>
    </member>
    <member name="T:Editor.MapEditor.HammerMainWindow">
      <summary>
            This is our CQHammerMainWnd
            </summary>
    </member>
    <member name="M:Editor.MapEditor.HammerMainWindow.AddNativeDock(System.String,System.String,System.IntPtr,System.IntPtr,Editor.DockArea,Editor.DockManager.DockProperty,System.Single)">
      <summary>
            Lets Hammer register its dock widgets with our DockManager
            </summary>
    </member>
    <member name="M:Editor.MapEditor.HammerManagedInspector.OnChange(Editor.MapDoc.MapGameObject,Sandbox.SerializedProperty)">
      <summary>
            Let Hammer know when shit changes so we can update misc stuff.
            We mark the map as edited in a few places, but this seems even more reliable.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.HammerSceneEditorSession.Resolve(System.String)">
      <summary>
            Resolve a map path name to an editor session.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.HammerSourceLocation">
      <summary>
            Source location for graphs created in a Hammer editor session.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.HammerSourceLocation.#ctor(Editor.MapEditor.HammerSceneEditorSession)">
      <summary>
            Source location for graphs created in a Hammer editor session.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.HammerSession">
      <summary>
            This is our CQHammerMainWnd
            </summary>
    </member>
    <member name="P:Editor.MapEditor.HammerSession.MapAsset">
      <summary>
            The map that this session is editing
            </summary>
    </member>
    <member name="P:Editor.MapEditor.HammerSession.CompiledMapPath">
      <summary>
            The absolute path to the .vpk generated by this map
            </summary>
    </member>
    <member name="M:Editor.MapEditor.HammerSession.Destroyed">
      <summary>
            Called when c++ destroys us
            </summary>
    </member>
    <member name="T:Editor.MapEditor.History">
      <summary>
            Undo/redo history for the current active mapdoc
            </summary>
    </member>
    <member name="M:Editor.MapEditor.History.MarkUndoPosition(System.String)">
      <summary>
            Mark new undo position
            </summary>
      <param name="name" />
    </member>
    <member name="M:Editor.MapEditor.History.Keep(Editor.MapDoc.MapNode)">
      <summary>
            Keeps a map node and all its children, so changes to it can be undone.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.History.KeepNew(Editor.MapDoc.MapNode)">
      <summary>
            Keeps a new object node and all of its children, so they can be deleted on an undo.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.Selection">
      <summary>
            Current selection set for the active map
            </summary>
      <remarks>
            Currently this only supports <see cref="T:Editor.MapDoc.MapNode" /> selections.
            There are selections of vertices, edges, faces too that would likely change this API
            </remarks>
    </member>
    <member name="E:Editor.MapEditor.Selection.OnChanged">
      <summary>
            Called when the selection in Hammer is changed
            </summary>
    </member>
    <member name="P:Editor.MapEditor.Selection.SelectMode">
      <summary>
            The current selection mode e.g Meshes or Objects
            </summary>
    </member>
    <member name="P:Editor.MapEditor.Selection.PivotPosition">
      <summary>
            The position of the selection's pivot
            </summary>
    </member>
    <member name="P:Editor.MapEditor.Selection.All">
      <summary>
            All the map nodes in the current selection set
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Selection.Add(Editor.MapDoc.MapNode)">
      <summary>
            Add the map node to the current set
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Selection.Set(Editor.MapDoc.MapNode)">
      <summary>
            Clear the current set, making the map node the only selected node
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Selection.Remove(Editor.MapDoc.MapNode)">
      <summary>
            Remove this map node from the current set if it exists
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Selection.Clear">
      <summary>
            Clear everything from the current selection set
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Selection.SelectAll">
      <summary>
            Add all to the current selection
            </summary>
    </member>
    <member name="M:Editor.MapEditor.Selection.InvertSelection">
      <summary>
            Invert the current selection
            </summary>
    </member>
    <member name="F:Editor.MapEditor.SelectMode.Groups">
      <summary>
            Select groups, ungrouped entities, and ungrouped solids
            </summary>
    </member>
    <member name="F:Editor.MapEditor.SelectMode.Objects">
      <summary>
            Select entities and solids not in entities
            </summary>
    </member>
    <member name="F:Editor.MapEditor.SelectMode.Meshes">
      <summary>
            Select point entities, solids in entities, solids
            </summary>
    </member>
    <member name="F:Editor.MapEditor.SelectMode.Verticies">
      <summary>
            Select vertices
            </summary>
    </member>
    <member name="F:Editor.MapEditor.SelectMode.Edges">
      <summary>
            Select edges
            </summary>
    </member>
    <member name="F:Editor.MapEditor.SelectMode.Faces">
      <summary>
            Select faces
            </summary>
    </member>
    <member name="F:Editor.MapEditor.SelectMode.Nav">
      <summary>
            Select nav mesh components
            </summary>
    </member>
    <member name="F:Editor.MapEditor.SelectMode.Tiles">
      <summary>
            Select the grid tiles
            </summary>
    </member>
    <member name="T:Editor.MapEditor.MapView">
      <summary>
             MapViews are owned by the MapViewMgr. They display the MapViewMgr's mapdoc.
            
             The MapView provides either a 2d or 3d view of the provided map doc. The rendering mode
             may be swapped between various 2d and 3d modes dynamically. In addition to basic display 
             functionality the view also provides movement implementation for moving a camera within a 3d view
             or panning a 2d view.
             </summary>
    </member>
    <member name="P:Editor.MapEditor.MapView.SceneCamera">
      <summary>
            Read-only SceneCamera set automatically during rendering
            </summary>
    </member>
    <member name="P:Editor.MapEditor.MapView.MousePosition">
      <summary />
    </member>
    <member name="M:Editor.MapEditor.MapView.BuildRay(Vector3@,Vector3@)">
      <summary>
            Builds a ray from the mouse cursor
            </summary>
    </member>
    <member name="M:Editor.MapEditor.MapView.PreRender(NativeEngine.ISceneView)">
      <summary>
            Called for each MapView right before rendering begins, this is where you'd give it the scene to render.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.MapViewRender.TraceManagedGizmos(Editor.MapEditor.MapView,Vector2,NativeHammer.HitInfo_t@)">
      <summary>
            Called from CMapView::ObjectsAt giving managed an opportunity to add a trace to the list.
            These then get sorted by distance and selected.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.IBlockTool">
      <summary>
            Interface for the addon layer to implement, this is called from native Hammer.
            </summary>
    </member>
    <member name="M:Editor.MapEditor.IBlockTool.UpdateTool">
      <summary>
            Tells the tool a parameter has changed and that we should redraw.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.BlockToolGlue">
      <summary>
            Methods called from native to glue the remaining native tool code to here.
            This will become redundant as the API matures.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.IEntityTool">
      <summary>
            Interface for the addon layer to implement, this is called from native Hammer.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.EntityToolGlue">
      <summary>
            Methods called from native to glue the remaining native tool code to here.
            This will become redundant as the API matures.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.IPathTool">
      <summary>
            Interface for the addon layer to implement, this is called from native Hammer.
            </summary>
    </member>
    <member name="T:Editor.MapEditor.PathToolGlue">
      <summary>
            Methods called from native to glue the remaining native tool code to here.
            This will become redundant as the API matures.
            </summary>
    </member>
    <member name="T:Editor.MapDoc.MapDocument">
      <summary>
            Represents an open map document. A document has a tree of <see cref="T:Editor.MapDoc.MapNode" /> that represent the world.
            </summary>
    </member>
    <member name="P:Editor.MapDoc.MapDocument.PathName">
      <summary>
            The map file name
            </summary>
    </member>
    <member name="P:Editor.MapDoc.MapDocument.World">
      <summary>
            The world
            </summary>
    </member>
    <member name="M:Editor.MapDoc.MapDocument.DeleteNode(Editor.MapDoc.MapNode)">
      <summary>
            Removes the node from the world, deletes all children too.
            </summary>
    </member>
    <member name="T:Editor.MapDoc.MapEntity">
      <summary>
            MapEntity in Hammer is a type of <see cref="T:Editor.MapDoc.MapNode" /> that has a set of key/value pairs.
            The keyvalues represent the authoritative state of the entity. 
            
            Entities may have helpers that enhance the presentation and sometimes modification of those keyvalues.
            The helpers may come and go; it should always be possible to recreate the helpers from
            the parent entity's keyvalues.
            
            Entities may also have zero or more <see cref="T:Editor.MapDoc.MapMesh" /> children.
            </summary>
    </member>
    <member name="P:Editor.MapDoc.MapEntity.ClassName">
      <summary>
            Entity class name like prop_physics
            </summary>
    </member>
    <member name="M:Editor.MapDoc.MapEntity.GetKeyValue(System.String)">
      <summary>
            Gets the value for the key, e.g "model" could return "models/props_c17/oildrum001_explosive.mdl"
            </summary>
    </member>
    <member name="M:Editor.MapDoc.MapEntity.SetKeyValue(System.String,System.String)">
      <summary>
            Sets the value for the key, e.g "model" could be set to "models/props_c17/oildrum001_explosive.mdl"
            </summary>
    </member>
    <member name="M:Editor.MapDoc.MapEntity.SetDefaultBounds(Vector3,Vector3)">
      <summary>
            Sets the default bounds of the entity if it doesn't have a model. By default this is 16x16x16.
            </summary>
      <remarks>
            Refactor out once we have managed helpers I think.
            </remarks>
    </member>
    <member name="M:Editor.MapDoc.MapGameObject.OnCopyFrom(Editor.MapDoc.MapNode,System.Int32)">
      <summary>
            Mapdoc creates a bunch of map nodes that live on the clipboard, undo system or just for transforming.
            These will almost never be part of a World until much later, so anything here should be treated as serialization only.
            And defer any actual logic until OnAddedToWorld.
            It's confusing, but it's how the entire datamodel works foundationally for Hammer and mapdoclib.
            </summary>
    </member>
    <member name="M:Editor.MapDoc.MapGameObject.OnMeshesTied">
      <summary>
            Called when meshes are tied to this GameObject
            </summary>
    </member>
    <member name="T:Editor.MapDoc.MapGroup">
      <summary>
            A map node which has the sole purpose of grouping other map nodes together.
            </summary>
    </member>
    <member name="T:Editor.MapDoc.MapInstance">
      <summary>
            A map node which allows a target group and its children to be placed with a new position
            and orientation in the world without creating a new copy.
            
            Multiple MapInstance classes may reference the same target allowing it to be placed in
            multiple locations, but allowing any edits to be applied to all instances.
            </summary>
    </member>
    <member name="P:Editor.MapDoc.MapInstance.Target">
      <summary>
            The target map node this MapInstance references to copy.
            </summary>
    </member>
    <member name="T:Editor.MapDoc.MapMesh">
      <summary>
            MapMesh is the Hammer map node which represents editable mesh geometry in a Hammer map.
            This is the map node that is created when using the hammer geometry editing tools.
            </summary>
    </member>
    <member name="M:Editor.MapDoc.MapMesh.SetMaterial(Sandbox.Material)">
      <summary>
            Assigns the specified material to the entire mesh
            </summary>
    </member>
    <member name="M:Editor.MapDoc.MapMesh.ConstructFromPolygons(Editor.MeshEditor.PrimitiveBuilder.PolygonMesh)">
      <summary>
            Constructs the mesh from the given <see cref="T:Editor.MeshEditor.PrimitiveBuilder.PolygonMesh" /> builder.
            </summary>
    </member>
    <member name="M:Editor.MapDoc.MapMesh.GetFaceMaterialAssets">
      <summary>
            Get all material assets used on this mesh
            </summary>
    </member>
    <member name="F:Editor.MapDoc.MapNodeGetRootDocument.MustBeLoaded">
      <summary>
            Will return null if the root document is still being loaded 
            </summary>
    </member>
    <member name="F:Editor.MapDoc.MapNodeGetRootDocument.MayBeLoading">
      <summary>
            Will return the root document even if it is not completely loaded
            </summary>
    </member>
    <member name="T:Editor.MapDoc.MapNode">
      <summary>
            A common class used for all objects in the world object tree.
            </summary>
    </member>
    <member name="M:Editor.MapDoc.MapNode.OnAddedToWorld(Editor.MapDoc.MapWorld)">
      <summary>
            A new node has been added to the world - does not happen when loaded from file
            </summary>
    </member>
    <member name="P:Editor.MapDoc.MapNode.Name">
      <summary>
            User specified name of this node
            </summary>
    </member>
    <member name="P:Editor.MapDoc.MapNode.TypeString">
      <summary>
            Native C++ type name for this map node (nice for debug, might disappear at some point)
            </summary>
    </member>
    <member name="P:Editor.MapDoc.MapNode.Position">
      <summary>
            World position of this map node.
            </summary>
    </member>
    <member name="P:Editor.MapDoc.MapNode.Angles">
      <summary>
            Euler angles of this map node. 
            </summary>
    </member>
    <member name="P:Editor.MapDoc.MapNode.Scale">
      <summary>
            Non-uniform scalar for this map node.
            </summary>
    </member>
    <member name="P:Editor.MapDoc.MapNode.Parent">
      <summary>
            The parent node, at the top level this will be the <see cref="T:Editor.MapDoc.MapWorld" /></summary>
    </member>
    <member name="P:Editor.MapDoc.MapNode.Children">
      <summary>
            Each MapNode can have many children. Children usually transform with their parents, etc.
            </summary>
    </member>
    <member name="P:Editor.MapDoc.MapNode.Visible">
      <summary>
            Visibility of this MapNode, e.g if it's been hidden by the user
            </summary>
    </member>
    <member name="P:Editor.MapDoc.MapNode.World">
      <summary>
            The world this map node belongs to.
            </summary>
    </member>
    <member name="M:Editor.MapDoc.MapNode.ToString">
      <summary>
            Map node types implement this to describe themselves and their children.
            e.g CMapEntity returns "Entity: entity_name" or CMapMesh returns "Mesh (2 faces)"
            </summary>
    </member>
    <member name="M:Editor.MapDoc.MapNode.Copy">
      <summary>
            Creates a copy of this map node.
            </summary>
    </member>
    <member name="P:Editor.MapDoc.MapNode.GeneratesEntityModelGeometry">
      <summary>
            Does this map node generate models to use?
            </summary>
    </member>
    <member name="T:Editor.MapDoc.MapPath">
      <summary>
            Path containing a bunch of <see cref="T:Editor.MapDoc.MapPathNode" /></summary>
    </member>
    <member name="T:Editor.MapDoc.MapPathNode">
      <summary>
            Nodes along a <see cref="T:Editor.MapDoc.MapPath" /></summary>
    </member>
    <member name="T:Editor.MapDoc.MapStaticOverlay">
      <summary>
            An overlay which is rendered using a mesh generated by projecting faces onto
            surrounding geometry. Baked during map compile so that there is no runtime component.
            Also supports being limited to specific targets.
            </summary>
    </member>
    <member name="T:Editor.MapDoc.MapWorld">
      <summary>
            MapWorld is the root node of a <see cref="T:Editor.MapDoc.MapDocument" />, however it can have multiple sub <see cref="T:Editor.MapDoc.MapWorld" /> of prefabs.
            </summary>
    </member>
    <member name="P:Editor.MapDoc.MapWorld.Children">
      <summary>
            All children nodes of this world.
            </summary>
      <remarks>
            This returns nested descendants currently, that might change?
            </remarks>
    </member>
    <member name="F:Editor.TraceResult.Hit">
      <summary>
            Whether the trace hit something or not
            </summary>
    </member>
    <member name="F:Editor.TraceResult.HitPosition">
      <summary>
            The hit position of the trace
            </summary>
    </member>
    <member name="F:Editor.TraceResult.Normal">
      <summary>
            The hit surface normal (direction vector)
            </summary>
    </member>
    <member name="F:Editor.TraceResult.MapNode">
      <summary>
            The map node that was hit, if any
            </summary>
    </member>
    <member name="T:Editor.Trace">
      <summary>
            Trace for tools, not to be confused with <see cref="T:Sandbox.SceneTrace" /></summary>
    </member>
    <member name="M:Editor.Trace.Ray(Vector3@,Vector3@)">
      <summary>
            Create a trace ray.
            </summary>
      <param name="from">Start position in world space.</param>
      <param name="to">End position in world space.</param>
    </member>
    <member name="M:Editor.Trace.MeshesOnly">
      <summary>
            Only trace against hammer mesh geometry ( CMapMesh nodes )
            </summary>
    </member>
    <member name="M:Editor.Trace.SkipToolsMaterials">
      <summary>
            Don't hit tools materials (materials with the <c>tools.toolsmaterial</c> attribute)
            </summary>
    </member>
    <member name="M:Editor.Trace.Run(Editor.MapDoc.MapWorld)">
      <summary>
            Runs a trace against given world.
            </summary>
    </member>
    <member name="T:Editor.MeshEditor.PrimitiveBuilder">
      <summary>
            Build primitives out of polygons.
            </summary>
    </member>
    <member name="T:Editor.MeshEditor.PrimitiveBuilder.PolygonMesh">
      <summary>
            A list of vertices and faces.
            </summary>
    </member>
    <member name="T:Editor.MeshEditor.PrimitiveBuilder.PolygonMesh.Face">
      <summary>
            A list of indices indexing into the <see cref="P:Editor.MeshEditor.PrimitiveBuilder.PolygonMesh.Vertices" /> list.
            </summary>
    </member>
    <member name="M:Editor.MeshEditor.PrimitiveBuilder.PolygonMesh.AddVertex(Vector3)">
      <summary>
            Adds a new vertex to the end of the <see cref="P:Editor.MeshEditor.PrimitiveBuilder.PolygonMesh.Vertices" /> list.
            </summary>
      <param name="position">Position of the vertex to add.</param>
      <returns>The index of the newly added vertex.</returns>
    </member>
    <member name="M:Editor.MeshEditor.PrimitiveBuilder.PolygonMesh.AddFace(System.Int32[])">
      <summary>
            Adds a new face to the end of the <see cref="P:Editor.MeshEditor.PrimitiveBuilder.PolygonMesh.Faces" /> list.
            </summary>
      <param name="indices">The vertex indices which define the face, ordered anticlockwise.</param>
      <returns>The newly added face.</returns>
    </member>
    <member name="M:Editor.MeshEditor.PrimitiveBuilder.PolygonMesh.AddFace(Vector3[])">
      <summary>
            Adds a new face to the end of the <see cref="P:Editor.MeshEditor.PrimitiveBuilder.PolygonMesh.Faces" /> list and it's vertices to the end of the <see cref="P:Editor.MeshEditor.PrimitiveBuilder.PolygonMesh.Vertices" /> list.
            </summary>
      <param name="positions">The vertex positions which define the face, ordered anticlockwise.</param>
      <returns>The newly added face.</returns>
    </member>
    <member name="M:Editor.MeshEditor.PrimitiveBuilder.Build(Editor.MeshEditor.PrimitiveBuilder.PolygonMesh)">
      <summary>
            Create the primitive in the mesh.
            </summary>
    </member>
    <member name="M:Editor.MeshEditor.PrimitiveBuilder.SetFromBox(BBox)">
      <summary>
            Setup properties from box.
            </summary>
    </member>
    <member name="P:Editor.MeshEditor.PrimitiveBuilder.Is2D">
      <summary>
            If this primitive is 2D the bounds box will be limited to have no depth.
            </summary>
    </member>
    <member name="P:Editor.MeshEditor.PrimitiveBuilder.Material">
      <summary>
            The material to use for this whole primitive.
            </summary>
    </member>
    <member name="M:Editor.ProjectList.Remove(Sandbox.Project)">
      <summary>
            Remove an item from the list. This doesn't save the changes.
            </summary>
    </member>
    <member name="M:Editor.ProjectList.TryAddFromFile(System.String)">
      <summary>
            Tries to add a project from a file. Returns true if it was added, or already existed.
            Project list is saved if it was added.
            </summary>
    </member>
    <member name="M:Editor.Application.SetStyles(System.String)">
      <inheritdoc cref="M:Editor.Widget.SetStyles(System.String)" />.
        </member>
    <member name="M:Editor.Application.Spin">
      <summary>
            Will process all of the UI events - allowing the UI to stay responsive during a blocking call.
            </summary>
    </member>
    <member name="P:Editor.Application.CursorPosition">
      <summary>
            Get/Set cursor position.
            </summary>
    </member>
    <member name="P:Editor.Application.UnscaledCursorPosition">
      <summary>
            The cursor position, not scaled for DPI
            </summary>
    </member>
    <member name="P:Editor.Application.CursorDelta">
      <summary>
            The cursor delta between this and previous frame.
            </summary>
    </member>
    <member name="P:Editor.Application.MouseWheelDelta">
      <summary>
            The mouse wheel delta between this and previous frame
            </summary>
    </member>
    <member name="P:Editor.Application.KeyboardModifiers">
      <summary>
            Returns which keyboard modified keys are held down right at this point.
            </summary>
    </member>
    <member name="P:Editor.Application.MouseButtons">
      <summary>
            Returns the current state of the mouse buttons.
            </summary>
    </member>
    <member name="M:Editor.Application.IsKeyDown(Editor.KeyCode)">
      <summary>
            Returns whether or not a key is currently being held down.
            </summary>
    </member>
    <member name="M:Editor.Application.KeyCodeToString(Editor.KeyCode)">
      <summary>
            Converts an editor keycode to a string used by the game
            Qt::Key -&gt; WindowsVirtualKey -&gt; ButtonCode_t -&gt; string
            </summary>
      <param name="code" />
      <returns />
    </member>
    <member name="P:Editor.Application.FocusWidget">
      <summary>
            The <see cref="T:Editor.Widget" /> that has the keyboard input focus, or <c>null</c>if no widget in this application has the focus.
            </summary>
    </member>
    <member name="P:Editor.Application.HoveredWidget">
      <summary>
            The Widget that is currently hovered
            </summary>
    </member>
    <member name="F:Editor.AutoComplete.OnBuildOptions">
      <summary>
            The text has changed - fill in the options
            </summary>
    </member>
    <member name="F:Editor.AutoComplete.OnOptionSelected">
      <summary>
            You should hook this up to change the text on your control
            </summary>
    </member>
    <member name="M:Editor.AutoComplete.AddOption(System.String,System.String,System.Action,System.String)">
      <summary>
            Add an option for this autocomplete
            </summary>
    </member>
    <member name="M:Editor.AutoComplete.OpenAbove(Vector2)">
      <summary>
            Open above this position
            </summary>
    </member>
    <member name="M:Editor.AutoComplete.OnParentKeyPress(Editor.KeyEvent)">
      <summary>
            You should call this from the parent when a key is pressed. Will forward
            the appropriate keys to us and accept the event.
            </summary>
    </member>
    <member name="M:Editor.AutoComplete.OnParentBlur">
      <summary>
            Call this when the widget that spawns this blurs, so we can hide ourself
            </summary>
    </member>
    <member name="M:Editor.AutoComplete.OnGlobalMousePressed">
      <summary>
            Called when the mouse is pressed. Will hide this window if we clicked on anything
            except ourselves or our parent control.
            </summary>
    </member>
    <member name="P:Editor.BaseScrollWidget.VerticalScrollbar">
      <summary>
            The vertical scroll bar.
            </summary>
    </member>
    <member name="P:Editor.BaseScrollWidget.HorizontalScrollbar">
      <summary>
            The horizontal scroll bar.
            </summary>
    </member>
    <member name="P:Editor.BaseScrollWidget.HorizontalScrollbarMode">
      <summary>
        <see cref="P:Editor.BaseScrollWidget.HorizontalScrollbar" /> mode.
            </summary>
    </member>
    <member name="P:Editor.BaseScrollWidget.VerticalScrollbarMode">
      <summary>
        <see cref="P:Editor.BaseScrollWidget.VerticalScrollbar" /> mode.
            </summary>
    </member>
    <member name="M:Editor.BaseScrollWidget.OnScrollChanged">
      <summary>
            Called when the scroll position has changed.
            </summary>
    </member>
    <member name="P:Editor.BaseScrollWidget.SmoothScrollTarget">
      <summary>
            The smooth scrolling wants to move by this amount
            </summary>
    </member>
    <member name="F:Editor.BaseScrollWidget.SmoothValue">
      <summary>
            We save off the scroll value to a float during smooth scroll so it can
            keep hold of fractions, that way we don't get chunky rounding errors.
            </summary>
    </member>
    <member name="T:Editor.Button">
      <summary>
            A simple button widget.
            </summary>
    </member>
    <member name="P:Editor.Button.Text">
      <summary>
            Text on the button.
            </summary>
    </member>
    <member name="P:Editor.Button.Tint">
      <summary>
            The tint of the button color
            </summary>
    </member>
    <member name="P:Editor.Button.IsChecked">
      <summary>
            Whether this button is checked. See <see cref="P:Editor.Button.IsToggle" />.
            </summary>
    </member>
    <member name="P:Editor.Button.IsToggle">
      <summary>
            Whether this button can be toggled on or off. See <see cref="P:Editor.Button.IsChecked" />.
            </summary>
    </member>
    <member name="P:Editor.Button.Icon">
      <summary>
            Sets an icon for the button via a filepath.
            </summary>
    </member>
    <member name="M:Editor.Button.SetIcon(Editor.Pixmap)">
      <summary>
            Sets an icon for the button via a raw image.
            </summary>
    </member>
    <member name="T:Editor.Button.Primary">
      <summary>
            A visually distinct button.
            </summary>
    </member>
    <member name="T:Editor.CheckState">
      <summary>
            Check state of a <see cref="T:Editor.Checkbox" />.
            </summary>
    </member>
    <member name="F:Editor.CheckState.Off">
      <summary>
            The checkbox is not checked.
            </summary>
    </member>
    <member name="F:Editor.CheckState.Partial">
      <summary>
            Partial. This is useful in cases when representing multiple objects,
            with a boolean value where some are set to true, and others to false.
            </summary>
    </member>
    <member name="F:Editor.CheckState.On">
      <summary>
            The checkbox is checked.
            </summary>
    </member>
    <member name="T:Editor.Checkbox">
      <summary>
            A generic checkbox widget.
            </summary>
    </member>
    <member name="F:Editor.Checkbox.Clicked">
      <inheritdoc cref="M:Editor.Checkbox.OnClicked" />
    </member>
    <member name="F:Editor.Checkbox.Pressed">
      <inheritdoc cref="M:Editor.Checkbox.OnPressed" />
    </member>
    <member name="F:Editor.Checkbox.Released">
      <inheritdoc cref="M:Editor.Checkbox.OnReleased" />
    </member>
    <member name="F:Editor.Checkbox.Toggled">
      <inheritdoc cref="M:Editor.Checkbox.OnToggled" />
    </member>
    <member name="F:Editor.Checkbox.StateChanged">
      <inheritdoc cref="M:Editor.Checkbox.OnStateChanged(Editor.CheckState)" />
    </member>
    <member name="P:Editor.Checkbox.Text">
      <summary>
            The checkbox label.
            </summary>
    </member>
    <member name="P:Editor.Checkbox.Value">
      <summary>
            Whether the checkbox is checked or not.
            </summary>
    </member>
    <member name="P:Editor.Checkbox.State">
      <summary>
            Current state of this checkbox.
            </summary>
    </member>
    <member name="P:Editor.Checkbox.TriState">
      <summary>
            Enable the third state, the half checked half not checked state.
            Disabled by default
            </summary>
    </member>
    <member name="M:Editor.Checkbox.OnClicked">
      <summary>
            Called when checkbox was clicked, on release.
            </summary>
    </member>
    <member name="M:Editor.Checkbox.OnPressed">
      <summary>
            Called when checkbox was pressed down.
            </summary>
    </member>
    <member name="M:Editor.Checkbox.OnReleased">
      <summary>
            Called when checkbox was released.
            </summary>
    </member>
    <member name="M:Editor.Checkbox.OnToggled">
      <summary>
            Called when checkbox gets toggled on or off.
            </summary>
    </member>
    <member name="M:Editor.Checkbox.OnStateChanged(Editor.CheckState)">
      <summary>
            Called when the <see cref="P:Editor.Checkbox.State" /> of the checkbox states.
            </summary>
    </member>
    <member name="P:Editor.Checkbox.Icon">
      <summary>
            Name of a material icon to be drawn in front of the checkbox label.
            </summary>
    </member>
    <member name="P:Editor.DockManager.OnLayoutLoaded">
      <summary>
            Called when the layout state is changed programatically. This is generally called when the default
            layout is loaded, or a saved layout is loaded.
            </summary>
    </member>
    <member name="T:Editor.DockManager.DockInfo">
      <summary>
            Description of a dock that is available to create by the backend.
            </summary>
    </member>
    <member name="P:Editor.DockManager.DockInfo.Title">
      <summary>
            This is what the dock will be shown as in the menu - but also what it will be referenced as internally.
            </summary>
    </member>
    <member name="P:Editor.DockManager.DockInfo.Icon">
      <summary>
            Icon to show in the menu.
            </summary>
    </member>
    <member name="P:Editor.DockManager.DockInfo.CreateAction">
      <summary>
            Called when the window wants to create this dock but it doesn't exist.
            </summary>
    </member>
    <member name="P:Editor.DockManager.DockInfo.DeleteOnClose">
      <summary>
            If true we'll delete the widget when it's closed. Otherwise it'll just be hidden.
            </summary>
    </member>
    <member name="P:Editor.DockManager.DockTypes">
      <summary>
            A list of dock types that are registered.
            </summary>
    </member>
    <member name="M:Editor.DockManager.RegisterDockType(System.String,System.String,System.Func{Editor.Widget},System.Boolean)">
      <summary>
            Register a type of dock for the backend to be able to create.
            </summary>
    </member>
    <member name="M:Editor.DockManager.UnregisterDockType(System.String)">
      <summary>
            Unregister a dock type.
            </summary>
    </member>
    <member name="M:Editor.DockManager.AddDock(Editor.Widget,Editor.Widget,Editor.DockArea,Editor.DockManager.DockProperty,System.Single)">
      <summary>
            Add a window next (or on top of) to the specified window.
            </summary>
    </member>
    <member name="M:Editor.DockManager.IsDockOpen(System.String)">
      <summary>
            Whether the given dock-able window is visible or not.
            </summary>
    </member>
    <member name="M:Editor.DockManager.IsDockOpen(Editor.Widget,System.Boolean)">
      <summary>
            Whether the given dock-able window is visible or not.
            </summary>
    </member>
    <member name="M:Editor.DockManager.GetDockWidget(System.String)">
      <summary>
            Get an active, created dock
            </summary>
    </member>
    <member name="M:Editor.DockManager.RaiseDock(System.String)">
      <summary>
            Raise this dock to the front of any tabs.
            </summary>
    </member>
    <member name="M:Editor.DockManager.RaiseDock(Editor.Widget)">
      <summary>
            Raise this dock to the front of any tabs.
            </summary>
    </member>
    <member name="M:Editor.DockManager.SetDockState(System.String,System.Boolean)">
      <summary>
            Set dock as visible, or hidden, by name.
            </summary>
    </member>
    <member name="M:Editor.DockManager.Create``1">
      <summary>
            Creates a widget by type
            </summary>
    </member>
    <member name="M:Editor.DockManager.OnCreateDock(System.String,System.String)">
      <summary>
            Called from the native class when restoring a layout to ask to make a widget.
            </summary>
    </member>
    <member name="P:Editor.DockManager.State">
      <summary>
            A JSON string representing the entire state of the dock manager, i.e. position of all the docks, etc.
            </summary>
    </member>
    <member name="M:Editor.DockManager.Clear">
      <summary>
            Clear the known widgets, reset manager to an empty state.
            </summary>
    </member>
    <member name="F:Editor.DockManager.DockProperty.DisallowUserDocking">
      <summary>
            Disables all drag/docking ability by the user
            </summary>
    </member>
    <member name="F:Editor.DockManager.DockProperty.HideCloseButton">
      <summary>
            Hides the close button on the tab for this tool window
            </summary>
    </member>
    <member name="F:Editor.DockManager.DockProperty.DisableDraggableTab">
      <summary>
            Disable the user being able to drag this tab in the tab bar, to rearrange
            </summary>
    </member>
    <member name="F:Editor.DockManager.DockProperty.HideOnClose">
      <summary>
            When the tool window is closed, hide it instead of removing it
            </summary>
    </member>
    <member name="F:Editor.DockManager.DockProperty.DisallowFloatWindow">
      <summary>
            Don't allow this tool window to be floated
            </summary>
    </member>
    <member name="F:Editor.DockManager.DockProperty.AlwaysDisplayFullTabs">
      <summary>
            When displaying this tool window in tabs, always display the tabs even if there's only one
            </summary>
    </member>
    <member name="T:Editor.DockWindow">
      <summary>
            A window that is built from docking windows
            </summary>
    </member>
    <member name="P:Editor.DockWindow.DockManager">
      <summary>
            The dock manager for this window, that is automatically created.
            </summary>
    </member>
    <member name="M:Editor.DockWindow.RestoreDefaultDockLayout">
      <summary>
            Override to apply a default layout to your window. This is called automatically from
            RestoreFromStateCookie if there is no cookie set.
            </summary>
    </member>
    <member name="M:Editor.DockWindow.CreateDynamicViewMenu(Editor.Menu)">
      <summary>
            Create a viewmenu dynamically, with common options
            </summary>
    </member>
    <member name="T:Editor.DragData">
      <summary>
            Contains drag and drop data for tool widgets. See <see cref="T:Editor.Widget.DragEvent" />.
            </summary>
    </member>
    <member name="P:Editor.DragData.Assets">
      <summary>
            Interprets <see cref="P:Editor.DragData.Text" /> as a list of asset paths or cloud asset URLs,
            getting a list of helper objects to access each asset. Generated and cached
            internally on first access after <see cref="P:Editor.DragData.Text" /> changes.
            </summary>
    </member>
    <member name="P:Editor.DragData.Object">
      <summary>
            An object that can be used to pass drag and drop data
            </summary>
    </member>
    <member name="P:Editor.DragData.Text">
      <summary>
            Text data of the drag and drop event.
            </summary>
    </member>
    <member name="P:Editor.DragData.Html">
      <summary>
            HTML data of the drag and drop event, if any.
            </summary>
    </member>
    <member name="P:Editor.DragData.Url">
      <summary>
            URL data of the drag and drop event, if any.
            </summary>
    </member>
    <member name="P:Editor.DragData.HasFileOrFolder">
      <summary>
            Whether the drag data has at least 1 file or folder.
            </summary>
    </member>
    <member name="P:Editor.DragData.FileOrFolder">
      <summary>
            The first file or folder in the drag data.
            </summary>
    </member>
    <member name="P:Editor.DragData.Files">
      <summary>
            All files and folders in the drag data.
            </summary>
    </member>
    <member name="M:Editor.DragData.OfType``1">
      <summary>
            Helper for finding instances of type <typeparamref name="T" /> in <see cref="P:Editor.DragData.Object" />.
            Will find matches if <see cref="P:Editor.DragData.Object" /> is of type <typeparamref name="T" />, is
            an <see cref="T:System.Collections.IEnumerable" /> with <typeparamref name="T" /> items, or a <see cref="T:Sandbox.SerializedObject" />
            with <typeparamref name="T" /> targets.
            </summary>
    </member>
    <member name="M:Editor.DragData.OfType(System.Type)">
      <summary>
            Helper for finding instances of type <paramref name="type" /> in <see cref="P:Editor.DragData.Object" />.
            Will find matches if <see cref="P:Editor.DragData.Object" /> is of type <paramref name="type" />, is
            an <see cref="T:System.Collections.IEnumerable" /> with <paramref name="type" /> items, or a <see cref="T:Sandbox.SerializedObject" />
            with <paramref name="type" /> targets.
            </summary>
    </member>
    <member name="T:Editor.DragAssetData">
      <summary>
            Represents an asset being dragged into an editor window. Assets will either
            be sourced from a package (see <see cref="P:Editor.DragAssetData.PackageIdent" />) or a local path (see <see cref="P:Editor.DragAssetData.AssetPath" />).
            Instances of this type are accessed through <see cref="P:Editor.DragData.Assets" />.
            </summary>
    </member>
    <member name="P:Editor.DragAssetData.PackageIdent">
      <summary>
            For package assets, the identifier of the source package. Will always be of the form <c>org.package[#version]</c>.
            </summary>
    </member>
    <member name="P:Editor.DragAssetData.AssetPath">
      <summary>
            For local assets, the path to the asset. Equivalent to <see cref="P:Editor.Asset.Path" />.
            </summary>
    </member>
    <member name="P:Editor.DragAssetData.DownloadProgress">
      <summary>
            For cloud assets, a value between <c>0.0</c> and <c>1.0</c> representing download progress.
            Download will only start after the first call to <see cref="M:Editor.DragAssetData.GetAssetAsync" />.
            </summary>
    </member>
    <member name="P:Editor.DragAssetData.IsInstalled">
      <summary>
            True when the asset is ready for use locally.
            For cloud assets, download will only start after the first call to <see cref="M:Editor.DragAssetData.GetAssetAsync" />.
            </summary>
    </member>
    <member name="M:Editor.DragAssetData.GetPackageAsync">
      <summary>
            For package assets, completes when the source package information is available.
            </summary>
    </member>
    <member name="M:Editor.DragAssetData.GetAssetAsync">
      <summary>
            Completes when the asset is ready to use. For cloud assets, the first call to this
            will start downloading and installing the source package. This is safe to call
            multiple times, the same task will be returned.
            </summary>
    </member>
    <member name="T:Editor.DropAction">
      <summary>
            Used to tell the user what kind of action will happen during a drag and drop event on mouse release.
            In Windows, these actions will also display text near cursor to let the user know what will happen if they release their mouse button.
            </summary>
    </member>
    <member name="F:Editor.DropAction.Copy">
      <summary>
            The data will be copied.
            </summary>
    </member>
    <member name="F:Editor.DropAction.Move">
      <summary>
            The data will be moved.
            </summary>
    </member>
    <member name="F:Editor.DropAction.Link">
      <summary>
            The data will be linked.
            </summary>
    </member>
    <member name="F:Editor.DropAction.Ignore">
      <summary>
            Ignore this drop action.
            </summary>
    </member>
    <member name="T:Editor.CursorShape">
      <summary>
            TODO: Make this match whatever we do in game
            </summary>
    </member>
    <member name="F:Editor.CursorShape.None">
      <summary>
            No cursor override.
            </summary>
    </member>
    <member name="T:Editor.ShortcutContext">
      <summary>
            Scope of the shortcut. Requires focus at this level for the shortcut to be active.
            Defaults to <see cref="F:Editor.ShortcutContext.WindowShortcut" />.
            </summary>
    </member>
    <member name="F:Editor.ShortcutContext.WidgetShortcut">
      <summary>
            Shortcut is only active when the parent widget is focused.
            </summary>
    </member>
    <member name="F:Editor.ShortcutContext.WindowShortcut">
      <summary>
            Shortcut is only active when the window of the parent widget is focused.
            </summary>
    </member>
    <member name="F:Editor.ShortcutContext.ApplicationShortcut">
      <summary>
            Shortcut is only active when one of the application windows is focused.
            </summary>
    </member>
    <member name="F:Editor.ShortcutContext.WidgetWithChildrenShortcut">
      <summary>
            Shortcut is only active when the parent widget, or a child of the parent widget, is focused.
            </summary>
    </member>
    <member name="F:Editor.SizeConstraint.SetDefaultConstraint">
      <summary>
            The main widget enforces minimum size
            </summary>
    </member>
    <member name="F:Editor.SizeConstraint.SetNoConstraint">
      <summary>
            The widget size ignores minimum and maximum size
            </summary>
    </member>
    <member name="F:Editor.SizeConstraint.SetMinimumSize">
      <summary>
            The main widget is set to minimum size and cannot be smaller
            </summary>
    </member>
    <member name="F:Editor.SizeConstraint.SetFixedSize">
      <summary>
            The main widget is fixed to the layout's size and won't resize at all
            </summary>
    </member>
    <member name="F:Editor.SizeConstraint.SetMaximumSize">
      <summary>
            The main widget is set to maximum size and cannot be smaller
            </summary>
    </member>
    <member name="F:Editor.SizeConstraint.SetMinAndMaxSize">
      <summary>
            Size between minimum and maximum size
            </summary>
    </member>
    <member name="F:Editor.SizeMode.CanGrow">
      <summary>
            Can grow beyond its size hint if necessary
            </summary>
    </member>
    <member name="F:Editor.SizeMode.Expand">
      <summary>
            Should get as much space as possible.
            </summary>
    </member>
    <member name="F:Editor.SizeMode.CanShrink">
      <summary>
            can shrink below its size hint if necessary.
            </summary>
    </member>
    <member name="F:Editor.SizeMode.Ignore">
      <summary>
            Widget size is ignored, will get as much space as possible.
            </summary>
    </member>
    <member name="F:Editor.SizeMode.Default">
      <summary>
            Default size mode - CanGrow and CanShrink
            </summary>
    </member>
    <member name="F:Editor.SizeMode.Flexible">
      <summary>
            Ignores the size hint - just expand as large as possible
            </summary>
    </member>
    <member name="T:Editor.MouseEvent">
      <summary>
            Information about a <see cref="T:Editor.Widget" />s mouse event.
            </summary>
    </member>
    <member name="P:Editor.MouseEvent.LeftMouseButton">
      <summary>
            Whether the event was triggered by the left mouse button.
            </summary>
    </member>
    <member name="P:Editor.MouseEvent.RightMouseButton">
      <summary>
            Whether the event was triggered by the left mouse button.
            </summary>
    </member>
    <member name="P:Editor.MouseEvent.MiddleMouseButton">
      <summary>
            Whether the event was triggered by the left mouse button.
            </summary>
    </member>
    <member name="P:Editor.MouseEvent.ButtonState">
      <summary>
            The current mouse button state.
            </summary>
    </member>
    <member name="P:Editor.MouseEvent.Button">
      <summary>
            The mouse button that triggered the event.
            </summary>
    </member>
    <member name="P:Editor.MouseEvent.LocalPosition">
      <summary>
            Position of the mouse cursor relative to the widgets top left corner.
            </summary>
    </member>
    <member name="P:Editor.MouseEvent.WindowPosition">
      <summary>
            Position of the mouse cursor relative to the top left corner of the window the widget belongs to.
            </summary>
    </member>
    <member name="P:Editor.MouseEvent.ScreenPosition">
      <summary>
            Absolute position of the mouse cursor on the screen.
            </summary>
    </member>
    <member name="P:Editor.MouseEvent.KeyboardModifiers">
      <summary>
            The keyboard modifier keys that were held down at the moment the event triggered.
            </summary>
    </member>
    <member name="P:Editor.MouseEvent.HasShift">
      <summary>
            Whether <c>Shift</c> key was being held down at the time of the event.
            </summary>
    </member>
    <member name="P:Editor.MouseEvent.HasCtrl">
      <summary>
            Whether <c>Control</c> key was being held down at the time of the event.
            </summary>
    </member>
    <member name="P:Editor.MouseEvent.HasAlt">
      <summary>
            Whether <c>Alt</c> key was being held down at the time of the event.
            </summary>
    </member>
    <member name="P:Editor.MouseEvent.Accepted">
      <summary>
            Whether this event should be propagated to parent widgets (<see langword="false" />) or not (<see langword="true" />).
            </summary>
    </member>
    <member name="P:Editor.MouseEvent.IsDoubleClick">
      <summary>
            Whether this mouse event was a double click.
            </summary>
    </member>
    <member name="T:Editor.KeyEvent">
      <summary>
            Information about a <see cref="T:Editor.Widget" />s keyboard event.
            </summary>
    </member>
    <member name="P:Editor.KeyEvent.Key">
      <summary>
            The key that triggered this event.
            </summary>
    </member>
    <member name="P:Editor.KeyEvent.Text">
      <summary>
            Text the <see cref="P:Editor.KeyEvent.Key" /> would type in a text field.
            </summary>
    </member>
    <member name="P:Editor.KeyEvent.Name">
      <summary>
            The name of the key that triggered this event.
            </summary>
    </member>
    <member name="P:Editor.KeyEvent.NativeKeyCode">
      <summary>
            OS specific key code that triggered this event.
            </summary>
    </member>
    <member name="P:Editor.KeyEvent.NativeScanCode">
      <summary>
            The native scan code.
            </summary>
    </member>
    <member name="P:Editor.KeyEvent.KeyboardModifiers">
      <inheritdoc cref="P:Editor.MouseEvent.KeyboardModifiers" />
    </member>
    <member name="P:Editor.KeyEvent.HasShift">
      <inheritdoc cref="P:Editor.MouseEvent.HasShift" />
    </member>
    <member name="P:Editor.KeyEvent.HasCtrl">
      <inheritdoc cref="P:Editor.MouseEvent.HasCtrl" />
    </member>
    <member name="P:Editor.KeyEvent.HasAlt">
      <inheritdoc cref="P:Editor.MouseEvent.HasAlt" />
    </member>
    <member name="P:Editor.KeyEvent.Accepted">
      <inheritdoc cref="P:Editor.MouseEvent.Accepted" />
    </member>
    <member name="T:Editor.ContextMenuEvent">
      <summary>
            Information about a <see cref="T:Editor.Widget" />s context menu event.
            </summary>
    </member>
    <member name="P:Editor.ContextMenuEvent.LocalPosition">
      <inheritdoc cref="P:Editor.MouseEvent.LocalPosition" />
    </member>
    <member name="P:Editor.ContextMenuEvent.ScreenPosition">
      <inheritdoc cref="P:Editor.MouseEvent.ScreenPosition" />
    </member>
    <member name="P:Editor.ContextMenuEvent.Accepted">
      <inheritdoc cref="P:Editor.MouseEvent.Accepted" />
    </member>
    <member name="T:Editor.GraphicsMouseEvent">
      <summary>
            Information about a <see cref="T:Editor.GraphicsItem" />s mouse click event.
            </summary>
    </member>
    <member name="P:Editor.GraphicsMouseEvent.LeftMouseButton">
      <inheritdoc cref="P:Editor.MouseEvent.LeftMouseButton" />
    </member>
    <member name="P:Editor.GraphicsMouseEvent.RightMouseButton">
      <inheritdoc cref="P:Editor.MouseEvent.RightMouseButton" />
    </member>
    <member name="P:Editor.GraphicsMouseEvent.MiddleMouseButton">
      <inheritdoc cref="P:Editor.MouseEvent.MiddleMouseButton" />
    </member>
    <member name="P:Editor.GraphicsMouseEvent.Buttons">
      <inheritdoc cref="P:Editor.MouseEvent.ButtonState" />
    </member>
    <member name="P:Editor.GraphicsMouseEvent.Button">
      <inheritdoc cref="P:Editor.MouseEvent.Button" />
    </member>
    <member name="P:Editor.GraphicsMouseEvent.LocalPosition">
      <inheritdoc cref="P:Editor.MouseEvent.LocalPosition" />
    </member>
    <member name="P:Editor.GraphicsMouseEvent.ScenePosition">
      <summary>
            Position of the mouse cursor within the <see cref="T:Editor.GraphicsScene" />.
            </summary>
    </member>
    <member name="P:Editor.GraphicsMouseEvent.ScreenPosition">
      <inheritdoc cref="P:Editor.MouseEvent.ScreenPosition" />
    </member>
    <member name="P:Editor.GraphicsMouseEvent.KeyboardModifiers">
      <inheritdoc cref="P:Editor.MouseEvent.KeyboardModifiers" />
    </member>
    <member name="P:Editor.GraphicsMouseEvent.HasShift">
      <inheritdoc cref="P:Editor.MouseEvent.HasShift" />
    </member>
    <member name="P:Editor.GraphicsMouseEvent.HasCtrl">
      <inheritdoc cref="P:Editor.MouseEvent.HasCtrl" />
    </member>
    <member name="P:Editor.GraphicsMouseEvent.HasAlt">
      <inheritdoc cref="P:Editor.MouseEvent.HasAlt" />
    </member>
    <member name="P:Editor.GraphicsMouseEvent.Accepted">
      <inheritdoc cref="P:Editor.MouseEvent.Accepted" />
    </member>
    <member name="T:Editor.GraphicsHoverEvent">
      <summary>
            Information about a <see cref="T:Editor.GraphicsItem" />s mouse hover event.
            </summary>
    </member>
    <member name="P:Editor.GraphicsHoverEvent.LocalPosition">
      <inheritdoc cref="P:Editor.MouseEvent.LocalPosition" />
    </member>
    <member name="P:Editor.GraphicsHoverEvent.ScenePosition">
      <inheritdoc cref="P:Editor.GraphicsMouseEvent.ScenePosition" />
    </member>
    <member name="P:Editor.GraphicsHoverEvent.ScreenPosition">
      <inheritdoc cref="P:Editor.MouseEvent.ScreenPosition" />
    </member>
    <member name="P:Editor.GraphicsHoverEvent.Accepted">
      <inheritdoc cref="P:Editor.MouseEvent.Accepted" />
    </member>
    <member name="T:Editor.WheelEvent">
      <summary>
            Information about a mouse wheel scroll event of a <see cref="T:Editor.Widget" />.
            </summary>
    </member>
    <member name="P:Editor.WheelEvent.Accepted">
      <inheritdoc cref="P:Editor.MouseEvent.Accepted" />
    </member>
    <member name="P:Editor.WheelEvent.KeyboardModifiers">
      <inheritdoc cref="P:Editor.MouseEvent.KeyboardModifiers" />
    </member>
    <member name="P:Editor.WheelEvent.HasShift">
      <inheritdoc cref="P:Editor.MouseEvent.HasShift" />
    </member>
    <member name="P:Editor.WheelEvent.HasCtrl">
      <inheritdoc cref="P:Editor.MouseEvent.HasCtrl" />
    </member>
    <member name="P:Editor.WheelEvent.HasAlt">
      <inheritdoc cref="P:Editor.MouseEvent.HasAlt" />
    </member>
    <member name="T:Editor.Frame">
      <summary>
            Like a widget - but is drawn
            </summary>
    </member>
    <member name="F:Editor.ScrollbarMode.Auto">
      <summary>
            Only show the scrollbar when necessary.
            </summary>
    </member>
    <member name="F:Editor.ScrollbarMode.Off">
      <summary>
            Never show the scrollbar.
            </summary>
    </member>
    <member name="F:Editor.ScrollbarMode.On">
      <summary>
            Always show the scrollbar.
            </summary>
    </member>
    <member name="P:Editor.GraphicsView.SelectionRect">
      <summary>
            All items inside this rect will be selected
            </summary>
    </member>
    <member name="P:Editor.GraphicsView.Center">
      <summary>
            Where in the scene is the view currently centered.
            </summary>
    </member>
    <member name="P:Editor.GraphicsView.DragType">
      <summary>
            What happens when the user drags the mouse. You generally want to toggle this in
            OnMouseDown to switch what happens with different mouse buttons.
            </summary>
    </member>
    <member name="P:Editor.GraphicsItem.Focusable">
      <summary>
            Gets keyboard input
            </summary>
    </member>
    <member name="P:Editor.GraphicsItem.BoundingRect">
      <summary>
            The outer bounds of the item as a rectangle; all painting must be restricted to inside an item's bounding rect.
            </summary>
    </member>
    <member name="P:Editor.GraphicsItem.HandlePosition">
      <summary>
            0,0 means top left, 1,1 means bottom right
            </summary>
    </member>
    <member name="M:Editor.GraphicsItem.PrepareGeometryChange">
      <summary>
            Usually called before resizing items so they paint properly.
            </summary>
    </member>
    <member name="M:Editor.GraphicsItem.OnMoved">
      <summary>
            Item has been moved by the user dragging it
            </summary>
    </member>
    <member name="M:Editor.GraphicsItem.OnKeyPress(Editor.KeyEvent)">
      <summary>
            A key has been pressed.
            </summary>
    </member>
    <member name="M:Editor.GraphicsItem.OnKeyRelease(Editor.KeyEvent)">
      <summary>
            A key has been released.
            </summary>
    </member>
    <member name="M:Editor.Paint.DrawArc(Vector2,Vector2,System.Single,System.Single)">
      <summary>
            Draws an arc (line). Angles are clockwise, 0 is north.
            </summary>
      <param name="center">The center of the circle</param>
      <param name="radius">The radius of the circle</param>
      <param name="angle">The center of the arc, in degrees</param>
      <param name="angleSize">The size of the arc, in degrees</param>
    </member>
    <member name="M:Editor.Paint.DrawPie(Vector2,Vector2,System.Single,System.Single)">
      <summary>
            Draws a pie. Angles are clockwise, 0 is north.
            </summary>
      <param name="center">The center of the circle</param>
      <param name="radius">The radius of the circle</param>
      <param name="angle">The center of the pie, in degrees</param>
      <param name="angleSize">The size of the pie, in degrees</param>
    </member>
    <member name="M:Editor.Paint.SetFont(Sandbox.UI.Styles@)">
      <summary>
            Set the pen and font style from a style
            </summary>
    </member>
    <member name="M:Editor.Paint.Rect(Sandbox.UI.Styles@,Sandbox.Rect@)">
      <summary>
            Draw a rectangle using the background of a style
            </summary>
    </member>
    <member name="T:Editor.Pixmap">
      <summary>
            A pixel map, or just a simple image.
            </summary>
    </member>
    <member name="M:Editor.Pixmap.#ctor(System.Int32,System.Int32)">
      <summary>
             Create a new empty pixel map. It can then be drawn to via the <see cref="T:Editor.Paint" /> class, like so:
             <code>
             var myPixMap = new Pixmap( 16, 16 );
            
             Paint.Target( myPixMap );
              Paint.Antialiasing = true;
              Paint.ClearPen();
              Paint.SetBrush( Color.Red );
              Paint.DrawRect( new Rect( 0, myPixMap.Size ), 2 );
             Paint.Target( null );
             </code></summary>
    </member>
    <member name="M:Editor.Pixmap.#ctor(Vector2)">
      <inheritdoc cref="M:Editor.Pixmap.#ctor(System.Int32,System.Int32)" />
    </member>
    <member name="P:Editor.Pixmap.Width">
      <summary>
            Width of the pixel map.
            </summary>
    </member>
    <member name="P:Editor.Pixmap.Height">
      <summary>
            Height of the pixel map.
            </summary>
    </member>
    <member name="P:Editor.Pixmap.HasAlpha">
      <summary>
            Whether this pixel map supports the alpha channel.
            </summary>
    </member>
    <member name="P:Editor.Pixmap.Size">
      <summary>
            THe size of this pixel map.
            </summary>
    </member>
    <member name="M:Editor.Pixmap.FromFile(System.String)">
      <summary>
            Load an image from a file on disk, specifically from "core/tools/images".
            </summary>
    </member>
    <member name="M:Editor.Pixmap.FromTexture(Sandbox.Texture,System.Boolean)">
      <summary>
            Create a pixmap from a texture.
            </summary>
    </member>
    <member name="M:Editor.Pixmap.Clear(Color)">
      <summary>
            Fill the pixel map with given color.
            </summary>
    </member>
    <member name="M:Editor.Pixmap.Scroll(System.Int32,System.Int32,Sandbox.Rect)">
      <summary>
            Duplicate a sub-rectangle of the image at re-draw it at given coordinates.
            </summary>
      <param name="x">Position to re-draw the duplicated image at on the X axis, from the left edge.</param>
      <param name="y">Position to re-draw the duplicated image at on the Y axis, from the top edge.</param>
      <param name="r">The area on the image to duplicate.</param>
    </member>
    <member name="M:Editor.Pixmap.Scroll(System.Int32,System.Int32)">
      <summary>
            Duplicate the entire image and re-draw it at given coordinates.
            </summary>
      <param name="x">Position to re-draw the duplicated image at on the X axis, from the left edge.</param>
      <param name="y">Position to re-draw the duplicated image at on the Y axis, from the top edge.</param>
    </member>
    <member name="M:Editor.Pixmap.Resize(Vector2)">
      <summary>
            Returns a new pixel map that contains resized version of this image with given dimensions.
            Will try to preserve aspect ratio.
            </summary>
    </member>
    <member name="M:Editor.Pixmap.Resize(System.Int32,System.Int32)">
      <inheritdoc cref="M:Editor.Pixmap.Resize(Vector2)" />
    </member>
    <member name="M:Editor.Pixmap.UpdateFromPixels(System.ReadOnlySpan{System.Byte},System.Int32,System.Int32,Sandbox.ImageFormat)">
      <summary>
            Writes raw pixels to the pixel map.
            </summary>
      <param name="data">The raw image data in given <paramref name="format" />.</param>
      <param name="width">Width of the image in the raw data.</param>
      <param name="height">Height of the image in the raw data.</param>
      <param name="format">The format the <paramref name="data" /> is in.</param>
      <returns>Whether the process was successful or not.</returns>
      <exception cref="T:System.Exception">Thrown when given an unsupported <paramref name="format" />.</exception>
    </member>
    <member name="M:Editor.Pixmap.UpdateFromPixels(System.ReadOnlySpan{System.Byte},Vector2,Sandbox.ImageFormat)">
      <summary>
            Writes raw pixels to the pixel map. Only BGRA8888 is currently supported.
            </summary>
      <param name="data">The raw image data in given <paramref name="format" />.</param>
      <param name="size">Size of the image in the raw data.</param>
      <param name="format">The format the <paramref name="data" /> is in.</param>
      <returns>Whether the process was successful or not.</returns>
      <exception cref="T:System.Exception">Thrown when given an unsupported <paramref name="format" />.</exception>
    </member>
    <member name="M:Editor.Pixmap.GetPng">
      <summary>
            Returns the raw bytes of a PNG file that contains this pixel maps image.
            Internally writes and deletes a file, so be careful using it often.
            </summary>
    </member>
    <member name="M:Editor.Pixmap.SavePng(System.String)">
      <summary>
            Save the pixel map as a PNG file at given location.
            </summary>
      <param name="filename">A full, valid absolute target path. Will not create directories on its own.</param>
      <returns>Whether the file was created or not.</returns>
    </member>
    <member name="M:Editor.Pixmap.SaveJpg(System.String,System.Int32)">
      <summary>
            Save the pixel map as a JPEG file at given location.
            </summary>
      <param name="filename">A full, valid absolute target path. Will not create directories on its own.</param>
      <param name="quality">JPEG quality, 0 to 100.</param>
      <returns>Whether the file was created or not.</returns>
    </member>
    <member name="M:Editor.Pixmap.GetJpeg(System.Int32)">
      <summary>
            Returns the raw bytes of a JPEG file that contains this pixel maps image.
            Internally writes and deletes a file, so be careful using it often.
            </summary>
      <param name="quality">JPEG quality, 0 to 100.</param>
    </member>
    <member name="M:Editor.Pixmap.GetBmp(System.Int32)">
      <summary>
            Returns the raw bytes of a BMP file that contains this pixel maps image.
            Internally writes and deletes a file, so be careful using it often.
            </summary>
    </member>
    <member name="T:Editor.Label">
      <summary>
            A simple text label.
            </summary>
    </member>
    <member name="P:Editor.Label.Text">
      <summary>
            The text of this label.
            </summary>
    </member>
    <member name="P:Editor.Label.OpenExternalLinks">
      <summary>
            If true, clicking a html link on this label will open the website.
            This is true by default.
            </summary>
    </member>
    <member name="P:Editor.Layout.Spacing">
      <summary>
            The amount of space between items
            </summary>
    </member>
    <member name="P:Editor.Layout.SizeConstraint">
      <summary>
            How the layout should resize the owning widget
            </summary>
    </member>
    <member name="P:Editor.Layout.Enabled">
      <summary>
            An enabled layout adjusts dynamically to changes; a disabled layout acts as if it did not exist.
            </summary>
    </member>
    <member name="P:Editor.Layout.Alignment">
      <summary>
            An enabled layout adjusts dynamically to changes; a disabled layout acts as if it did not exist.
            </summary>
    </member>
    <member name="P:Editor.Layout.OuterRect">
      <summary>
            The rect of this layout including margins
            </summary>
    </member>
    <member name="P:Editor.Layout.InnerRect">
      <summary>
            The rect of this layout excluding margins
            </summary>
    </member>
    <member name="P:Editor.Layout.Margin">
      <summary>
            The amount of space to leave free around the outside of the layout
            </summary>
    </member>
    <member name="M:Editor.Layout.Clear(System.Boolean)">
      <summary>
            Remove all widgets from this layout, without deleting them outright.
            </summary>
      <param name="deleteWidgets">Also delete all the widgets.</param>
    </member>
    <member name="M:Editor.Layout.AddSpacingCell(System.Single)">
      <summary>
            Add a spacing item
            </summary>
    </member>
    <member name="M:Editor.Layout.AddStretchCell(System.Int32)">
      <summary>
            Add a stretch item
            </summary>
    </member>
    <member name="M:Editor.Layout.AddSeparator(System.Boolean)">
      <summary>
            Adds a 1 pixel line
            </summary>
    </member>
    <member name="M:Editor.Layout.AddSeparator(System.Single,Color)">
      <summary>
            Adds a line
            </summary>
    </member>
    <member name="T:Editor.BoxLayout">
      <summary>
            A widget layout. You can think of it as an invisible box of rows or columns, each one containing a widget, useful for automatic positioning and scaling.
            </summary>
    </member>
    <member name="M:Editor.BoxLayout.AddSpacingCell(System.Single)">
      <summary>
            Add a spacing item
            </summary>
    </member>
    <member name="M:Editor.BoxLayout.AddStretchCell(System.Int32)">
      <summary>
            Add a stretch item
            </summary>
    </member>
    <member name="T:Editor.GridLayout">
      <summary>
            A widget layout. You can think of it as an invisible box of rows or columns, each one containing a widget, useful for automatic positioning and scaling.
            </summary>
    </member>
    <member name="T:Editor.LineEdit">
      <summary>
            A single line text entry. See <see cref="T:Editor.TextEdit" /> for multi line version.
            </summary>
    </member>
    <member name="E:Editor.LineEdit.TextChanged">
      <inheritdoc cref="M:Editor.LineEdit.OnTextChanged(System.String)" />
    </member>
    <member name="E:Editor.LineEdit.TextEdited">
      <inheritdoc cref="M:Editor.LineEdit.OnTextEdited(System.String)" />
    </member>
    <member name="E:Editor.LineEdit.ReturnPressed">
      <inheritdoc cref="M:Editor.LineEdit.OnTextEdited(System.String)" />
    </member>
    <member name="E:Editor.LineEdit.EditingFinished">
      <inheritdoc cref="M:Editor.LineEdit.OnEditingFinished" />
    </member>
    <member name="E:Editor.LineEdit.EditingStarted">
      <summary>
            The text entry received keyboard focus.
            </summary>
    </member>
    <member name="P:Editor.LineEdit.ForwardNavigationEvents">
      <summary>
            Forward up, down and enter keys to this control. This is useful if you have a
            search box that you want to also allow to navigate a list of items.
            </summary>
    </member>
    <member name="P:Editor.LineEdit.Value">
      <summary>
            Alias of <see cref="P:Editor.LineEdit.Text" />, except disallows setting text when <see cref="P:Editor.Widget.IsFocused" /> is <see langword="true" />.
            </summary>
    </member>
    <member name="P:Editor.LineEdit.Text">
      <summary>
            The text of this text entry.
            </summary>
    </member>
    <member name="P:Editor.LineEdit.PlaceholderText">
      <summary>
            The placeholder text, it will be displayed only when the text entry is empty.
            Typically used to as a short description of the expected input, or as an example input.
            </summary>
    </member>
    <member name="P:Editor.LineEdit.MaxLength">
      <summary>
            User entered text can never be longer than this many characters (not bytes).
            </summary>
    </member>
    <member name="P:Editor.LineEdit.HasSelectedText">
      <summary>
            Whether the user has any text selected within this text entry.
            </summary>
    </member>
    <member name="P:Editor.LineEdit.SelectionStart">
      <summary>
            Character at which the text selection begins, or -1 if there is no selection.
            </summary>
    </member>
    <member name="P:Editor.LineEdit.SelectionEnd">
      <summary>
            Character at which the text selection ends, or -1 if there is no selection.
            </summary>
    </member>
    <member name="P:Editor.LineEdit.ClearButtonEnabled">
      <summary>
            Show a button to clear the text input when it is not empty.
            </summary>
    </member>
    <member name="P:Editor.LineEdit.SelectedText">
      <summary>
            The selected text, if any.
            </summary>
    </member>
    <member name="P:Editor.LineEdit.CursorPosition">
      <summary>
            Position of the text cursor, at which newly typed letters will be inserted.
            </summary>
    </member>
    <member name="M:Editor.LineEdit.Clear">
      <summary>
            Clear the text.
            </summary>
    </member>
    <member name="M:Editor.LineEdit.SelectAll">
      <summary>
            Select all of the text.
            </summary>
    </member>
    <member name="M:Editor.LineEdit.Deselect">
      <summary>
            De-select all of the text.
            </summary>
    </member>
    <member name="M:Editor.LineEdit.OnTextChanged(System.String)">
      <summary>
            Called when the input text changes.
            </summary>
    </member>
    <member name="M:Editor.LineEdit.OnTextEdited(System.String)">
      <summary>
            Called when the text was edited.
            </summary>
    </member>
    <member name="M:Editor.LineEdit.OnReturnPressed">
      <summary>
            Called when the user presses the return (Enter) key.
            </summary>
    </member>
    <member name="M:Editor.LineEdit.OnEditingFinished">
      <summary>
            The text entry lost keyboard focus.
            </summary>
    </member>
    <member name="P:Editor.LineEdit.AutoCompleteVisible">
      <summary>
            Whether the <see cref="P:Editor.LineEdit.AutoComplete">auto complete</see><see cref="T:Editor.Menu" /> is visible or not.
            </summary>
    </member>
    <member name="M:Editor.LineEdit.FocusNext">
      <summary>
            If we have our menus open, let use tab/shift tab to navigate instead of switching to next control
            </summary>
    </member>
    <member name="M:Editor.LineEdit.FocusPrevious">
      <summary>
            If we have our menus open, let use tab/shift tab to navigate instead of switching to next control
            </summary>
    </member>
    <member name="P:Editor.LineEdit.HistoryVisible">
      <summary>
            True if history menu is visible
            </summary>
    </member>
    <member name="P:Editor.LineEdit.MaxHistoryItems">
      <summary>
            if set &gt; 1 we will support history items (which you need to add using AddHistory)
            </summary>
    </member>
    <member name="T:Editor.LinkableSplitter">
      <summary>
            Splitter that can be linked to move alongside others
            </summary>
    </member>
    <member name="M:Editor.Menu.GetSplitPath(System.String)">
      <summary>
            Splits a path as a list of <c>/</c>-delimited elements, each with the form <c>"[#]name[:icon][@order]"</c>.
            </summary>
      <param name="path">Path to split.</param>
    </member>
    <member name="M:Editor.Menu.GetSplitPath(Sandbox.Internal.ITitleProvider)">
      <summary>
            Combines the <see cref="P:Sandbox.Internal.ICategoryProvider.Value" /> (if exists) and <see cref="P:Sandbox.Internal.ITitleProvider.Value" />, then splits it with <see cref="M:Editor.Menu.GetSplitPath(System.String)" />.
            </summary>
    </member>
    <member name="M:Editor.Menu.AddOptions``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.Action{``0},System.Boolean,System.Boolean,System.String)">
      <summary>
            Adds a bunch of options, creating sub-menus based on their paths.
            </summary>
      <param name="items">Items to create options for.</param>
      <param name="getPath">Gets the path of an item as a list of <c>/</c>-delimited elements, each with the form <c>"[#]name[:icon][@order]"</c>.</param>
      <param name="action">Action to call on a clicked element.</param>
      <param name="flat">If true, flatten each path after sorting.</param>
      <param name="reduce">If true, collapse sub-menus with single items.</param>
      <param name="defaultSubMenuIcon">Use this icon for any sub-menus without an icon specified.</param>
    </member>
    <member name="M:Editor.Menu.AddOptions``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Boolean,System.Boolean,System.String)">
      <summary>
            Adds a bunch of options, creating sub-menus based on their paths.
            </summary>
      <param name="items">Items to create options for.</param>
      <param name="action">Action to call on a clicked element.</param>
      <param name="flat">If true, flatten each path after sorting.</param>
      <param name="reduce">If true, collapse sub-menus with single items.</param>
      <param name="defaultSubMenuIcon">Use this icon for any sub-menus without an icon specified.</param>
    </member>
    <member name="M:Editor.Menu.AddOptions``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Editor.Menu.PathElement[]},System.Action{``0},System.Boolean,System.Boolean,System.String)">
      <summary>
            Adds a bunch of options, creating sub-menus based on their paths.
            </summary>
      <param name="items">Items to create options for.</param>
      <param name="getPath">Gets the path of an item.</param>
      <param name="action">Action to call on a clicked element.</param>
      <param name="flat">If true, flatten each path after sorting.</param>
      <param name="reduce">If true, collapse sub-menus with single items.</param>
      <param name="defaultSubMenuIcon">Use this icon for any sub-menus without an icon specified.</param>
    </member>
    <member name="P:Editor.Menu.ToolTipsVisible">
      <summary>
        <para>
            This property holds whether tooltips of menu actions should be visible.
            </para>
        <para>
            This property specifies whether action menu entries show their tooltip.
            </para>
        <para>
            By default, this property is <c>false</c>.
            </para>
      </summary>
    </member>
    <member name="M:Editor.Menu.AddOption(System.String[],System.String,System.Action,System.String)">
      <summary>
            Like AddOption, except will automatically create the menu path from the array of names
            </summary>
    </member>
    <member name="M:Editor.Menu.AddOption(System.ReadOnlySpan{Editor.Menu.PathElement},System.Action,System.String)">
      <summary>
            Like AddOption, except will automatically create the menu path from the array of names
            </summary>
    </member>
    <member name="M:Editor.Menu.AddWidget``1(``0)">
      <summary>
            Add a widget as an action to the menu.<br />
            Some widgets such as <see cref="T:Editor.Widget" /> and <see cref="T:Editor.LineEdit" /> require <see cref="M:Editor.Widget.OnMouseReleased(Editor.MouseEvent)" />
            to set <see cref="P:Editor.MouseEvent.Accepted" /> to <see langword="true" /> to prevent the menu from closing.
            </summary>
    </member>
    <member name="M:Editor.Menu.RemoveOptions">
      <summary>
            Remove all options
            </summary>
    </member>
    <member name="M:Editor.Menu.RemoveMenus">
      <summary>
            Remove all menus
            </summary>
    </member>
    <member name="M:Editor.Menu.RemoveWidgets">
      <summary>
            Remove all widgets
            </summary>
    </member>
    <member name="M:Editor.Menu.OpenAtCursor(System.Boolean)">
      <summary>
            Open this menu at the mouse cursor position
            </summary>
    </member>
    <member name="T:Editor.ContextMenu">
      <summary>
            Identical to Menu except DeleteOnClose defaults to true
            </summary>
    </member>
    <member name="T:Editor.NativeRenderingWidget">
      <summary>
            Sets up the widget to render
            </summary>
    </member>
    <member name="P:Editor.NativeRenderingWidget.Camera">
      <summary>
            The camera to render from
            </summary>
    </member>
    <member name="P:Editor.NativeRenderingWidget.Scene">
      <summary>
            The active scene that we're rendering
            </summary>
    </member>
    <member name="P:Editor.NativeRenderingWidget.CursorRay">
      <summary>
            Return a ray for the current cursor position
            </summary>
    </member>
    <member name="M:Editor.NativeRenderingWidget.GetRay(Vector2)">
      <summary>
            Given a local widget position, return a Ray
            </summary>
    </member>
    <member name="F:Editor.Option.Triggered">
      <inheritdoc cref="M:Editor.Option.OnTriggered" />
    </member>
    <member name="F:Editor.Option.Toggled">
      <inheritdoc cref="M:Editor.Option.OnToggled(System.Boolean)" />
    </member>
    <member name="F:Editor.Option.FetchCheckedState">
      <summary>
            A method to get the checked state. Called periodically to update the status
            </summary>
    </member>
    <member name="P:Editor.Option.Text">
      <summary>
            Text for this option.
            </summary>
    </member>
    <member name="P:Editor.Option.IconText">
      <summary>
            Text to display if <see cref="P:Editor.Option.Text" /> is empty.
            </summary>
    </member>
    <member name="P:Editor.Option.Checkable">
      <summary>
            Whether this option is a toggle option. <see cref="P:Editor.Option.Checked" />.
            </summary>
    </member>
    <member name="P:Editor.Option.Checked">
      <summary>
            Whether this option is toggled/checked. <see cref="P:Editor.Option.Checkable" />.
            </summary>
    </member>
    <member name="P:Editor.Option.ToolTip">
      <inheritdoc cref="P:Editor.Widget.ToolTip" />
    </member>
    <member name="P:Editor.Option.StatusTip">
      <inheritdoc cref="P:Editor.Widget.StatusTip" />
    </member>
    <member name="P:Editor.Option.Enabled">
      <summary>
            Whether this option can be clicked. Will also be visually different.
            </summary>
    </member>
    <member name="P:Editor.Option.Icon">
      <summary>
            The icon for this option.
            </summary>
    </member>
    <member name="M:Editor.Option.OnTriggered">
      <summary>
            Called when this option was clicked..
            </summary>
    </member>
    <member name="M:Editor.Option.OnToggled(System.Boolean)">
      <summary>
            Called when this option was toggled.
            </summary>
    </member>
    <member name="M:Editor.Option.SetIcon(Editor.Pixmap)">
      <summary>
            Sets an icon for the option via a raw image.
            </summary>
    </member>
    <member name="T:Editor.SceneRenderingWidget">
      <summary>
            Render a scene to a native widget. This replaces NativeRenderingWidget. 
            </summary>
    </member>
    <member name="P:Editor.SceneRenderingWidget.Scene">
      <summary>
            The active scene that we're rendering
            </summary>
    </member>
    <member name="P:Editor.SceneRenderingWidget.Camera">
      <summary>
            The camera to render from. We will fallback to Scene.Camera if this is null
            </summary>
    </member>
    <member name="P:Editor.SceneRenderingWidget.CursorRay">
      <summary>
            Return a ray for the current cursor position
            </summary>
    </member>
    <member name="M:Editor.SceneRenderingWidget.GetRay(Vector2)">
      <summary>
            Given a local widget position, return a Ray
            </summary>
    </member>
    <member name="T:Editor.ScrollArea">
      <summary>
            A widget that can scroll its <see cref="P:Editor.ScrollArea.Canvas" />.
            </summary>
    </member>
    <member name="P:Editor.ScrollArea.Canvas">
      <summary>
            The content widget to scroll.
            </summary>
    </member>
    <member name="T:Editor.Splitter">
      <summary>
            Split frame, allows dragging to resize panels
            </summary>
    </member>
    <member name="T:Editor.TextEdit">
      <summary>
            A multi-line text entry. See <see cref="T:Editor.LineEdit" /> for a single line version.
            </summary>
    </member>
    <member name="F:Editor.TextEdit.TextChanged">
      <inheritdoc cref="M:Editor.TextEdit.OnTextChanged(System.String)" />
    </member>
    <member name="M:Editor.TextEdit.OnTextChanged(System.String)">
      <summary>
            Called when text changed.
            </summary>
      <param name="value" />
    </member>
    <member name="T:Editor.TrayIcon">
      <summary>
            Like a widget - but is drawn
            </summary>
    </member>
    <member name="T:Editor.Widget">
      <summary>
            A generic widget.
            </summary>
    </member>
    <member name="M:Editor.Widget.SetContext(System.String,System.Object)">
      <summary>
            Set a context value on this widget. This context will be available to its children via FindContext.
            </summary>
    </member>
    <member name="M:Editor.Widget.ClearContext(System.String)">
      <summary>
            Remove a context on this widget. This will NOT remove contexts set from parent objects.
            </summary>
      <param name="key" />
    </member>
    <member name="M:Editor.Widget.GetContext``1(System.String,``0)">
      <summary>
            Find a context on this widget. If not found, look at the parent. If not found, look at the parent.
            This is useful for passing information down to child widgets without any effort.
            </summary>
    </member>
    <member name="M:Editor.Widget.#ctor(System.Boolean)">
      <summary>
            This is here for parent widgets to call into, that want to skip the CreateWidget shit.
            </summary>
    </member>
    <member name="M:Editor.Widget.#ctor(Editor.Widget,System.Boolean)">
      <summary>
            The default widget constructor
            </summary>
      <param name="parent">The parent to attach this to. This can be null while you're sorting stuff out, before you add it to a layout or something - but generally a null parent is something a window has.</param>
      <param name="isDarkWindow">If true we'll run a function on startup to force this to be a darkmode window. Basically pass true if this is going to be a window and we'll all be friends.</param>
    </member>
    <member name="P:Editor.Widget.Enabled">
      <summary>
            Makes the widget not interactable. This is also usually be reflected visually by the widget.
            The widget will not process any keyboard or mouse inputs. Applies retroactively to all children.
            </summary>
    </member>
    <member name="P:Editor.Widget.ReadOnly">
      <summary>
            Makes the widget read only. I.e. You can copy text of a text entry, but can't edit it.
            Applies retroactively to all children.
            </summary>
    </member>
    <member name="P:Editor.Widget.Parent">
      <summary>
            Parent widget. If non null, position of this widget will be relative to the parent widget. Certain events will also propagate to the parent widget if unhandled.
            </summary>
    </member>
    <member name="M:Editor.Widget.GetAncestor``1">
      <summary>
            Find the closest ancestor widget of type
            </summary>
    </member>
    <member name="M:Editor.Widget.GetDescendants``1">
      <summary>
            Get all descendants of type T
            </summary>
    </member>
    <member name="M:Editor.Widget.IsDescendantOf(Editor.Widget)">
      <summary>
            Returns whether or not the specified Widget is a descendent of this Widget.
            </summary>
    </member>
    <member name="M:Editor.Widget.IsAncestorOf(Editor.Widget)">
      <summary>
            Returns whether or not the specified Widget is an ancestor of this Widget.
            </summary>
    </member>
    <member name="P:Editor.Widget.Size">
      <summary>
            Size of this widget.
            </summary>
    </member>
    <member name="P:Editor.Widget.LocalRect">
      <summary>
            This panel's rect at 0,0
            </summary>
    </member>
    <member name="P:Editor.Widget.ScreenRect">
      <summary>
            This panel's rect in screen coordinates
            </summary>
    </member>
    <member name="P:Editor.Widget.Width">
      <summary>
            Utility to interact with a widget's width - use Size where possible
            </summary>
    </member>
    <member name="P:Editor.Widget.Height">
      <summary>
            Utility to interact with a widget's width - use Size where possible
            </summary>
    </member>
    <member name="P:Editor.Widget.MinimumSize">
      <summary>
            Sets <see cref="P:Editor.Widget.MinimumWidth" /> and <see cref="P:Editor.Widget.MinimumHeight" /> simultaneously.
            </summary>
    </member>
    <member name="P:Editor.Widget.MinimumWidth">
      <summary>
            This widgets width should never be smaller than the given value.
            </summary>
    </member>
    <member name="P:Editor.Widget.MinimumHeight">
      <summary>
            This widgets height should never be smaller than the given value.
            </summary>
    </member>
    <member name="P:Editor.Widget.FixedHeight">
      <summary>
            Sets the fixed height for this widget
            </summary>
    </member>
    <member name="P:Editor.Widget.FixedWidth">
      <summary>
            Sets the fixed width for this widget
            </summary>
    </member>
    <member name="P:Editor.Widget.MaximumWidth">
      <summary>
            This widgets width should never be larger than the given value.
            </summary>
    </member>
    <member name="P:Editor.Widget.MaximumHeight">
      <summary>
            This widgets height should never be larger than the given value.
            </summary>
    </member>
    <member name="P:Editor.Widget.MaximumSize">
      <summary>
            Sets <see cref="P:Editor.Widget.MaximumWidth" /> and <see cref="P:Editor.Widget.MaximumHeight" /> simultaneously.
            </summary>
    </member>
    <member name="P:Editor.Widget.Position">
      <summary>
            Position of this widget, relative to its parent if it has one.
            </summary>
    </member>
    <member name="P:Editor.Widget.Visible">
      <summary>
            Whether this widget is visible or not, in the tree. This will return false if a parent is hidden. You 
            might want to set Hidden if you're looking to check local visible status on a widget.
            </summary>
    </member>
    <member name="P:Editor.Widget.Hidden">
      <summary>
            Whether this widget is hidden. This differs from Visible because this will return the state for
            this particular widget, where as Visible returns false if a parent is hidden etc.
            </summary>
    </member>
    <member name="P:Editor.Widget.Name">
      <summary>
            Name of the widget, usually for debugging purposes.
            </summary>
    </member>
    <member name="P:Editor.Widget.AcceptDrops">
      <summary>
            Accept drag and dropping shit on us
            </summary>
    </member>
    <member name="P:Editor.Widget.DeleteOnClose">
      <summary>
            Delete this widget when close is pressed
            </summary>
    </member>
    <member name="P:Editor.Widget.DpiScale">
      <summary>
            The scale this widget is using (multiplying Size by this value gives the actual native size)
            </summary>
    </member>
    <member name="M:Editor.Widget.Blur">
      <summary>
            Clear keyboard focus from this widget.
            </summary>
    </member>
    <member name="P:Editor.Widget.IsFocused">
      <summary>
            Whether this widget has keyboard focus.
            </summary>
    </member>
    <member name="P:Editor.Widget.FocusMode">
      <summary>
            Sets the focus mode for this widget. This determines both how it will get focus and whether it will receive keyboard input.
            </summary>
    </member>
    <member name="M:Editor.Widget.SetStyles(System.String)">
      <summary>
            Directly set CSS style sheet(s) for this widget. Same format as a .css file.
            </summary>
      <param name="sheet" />
    </member>
    <member name="M:Editor.Widget.SetStylesheetFile(System.String)">
      <summary>
            Set a file to load CSS for this widget from.
            </summary>
    </member>
    <member name="P:Editor.Widget.Children">
      <summary>
            Child widgets of this widget.
            </summary>
    </member>
    <member name="M:Editor.Widget.DestroyChildren">
      <summary>
            Destroys all child widgets of this widget.
            </summary>
    </member>
    <member name="P:Editor.Widget.Cursor">
      <summary>
            Cursor override for this widget.
            </summary>
    </member>
    <member name="P:Editor.Widget.PixmapCursor">
      <summary>
            Custom cursor override for this widget.
            Will override <see cref="P:Editor.Widget.Cursor" /> with <see cref="F:Editor.CursorShape.CustomCursor" />.
            </summary>
    </member>
    <member name="M:Editor.Widget.Update">
      <summary>
            Tell this widget that shit changed and it needs to redraw
            </summary>
    </member>
    <member name="M:Editor.Widget.Repaint">
      <summary>
            Repaint immediately
            </summary>
    </member>
    <member name="P:Editor.Widget.ScreenPosition">
      <summary>
            Position of the widget relative to the monitor's top left corner.
            </summary>
    </member>
    <member name="M:Editor.Widget.ToScreen(Vector2)">
      <summary>
            Transform coordinates relative to the panel's top left corner, to coordinates relative to monitors's top left corner.
            </summary>
      <param name="p">Position on the panel, relative it its top left corner.</param>
      <returns>The same position relative to the monitors top left corner.</returns>
    </member>
    <member name="M:Editor.Widget.FromScreen(Vector2)">
      <summary>
            Transform coordinates relative to the monitors's top left corner, to coordinates relative to panel's top left corner.
            </summary>
      <param name="p">Position relative to the monitors top left corner.</param>
      <returns>The same position on the panel, relative it its top left corner.</returns>
    </member>
    <member name="M:Editor.Widget.SaveGeometry">
      <summary>
            Serialize position and size of this widget to a string, which can then be passed to <see cref="M:Editor.Widget.RestoreGeometry(System.String)" />.
            </summary>
      <returns />
    </member>
    <member name="M:Editor.Widget.RestoreGeometry(System.String)">
      <summary>
            Restore position and size previously stored via <see cref="M:Editor.Widget.SaveGeometry" />.
            </summary>
      <param name="state" />
    </member>
    <member name="P:Editor.Widget.ToolTip">
      <summary>
            If set, this text will be displayed after a certain delay of hovering this widget with the mouse cursor.
            </summary>
    </member>
    <member name="P:Editor.Widget.StatusTip">
      <summary>
            If set, hovering over this widget will set the text of a <see cref="T:Editor.StatusBar" /> of the window the widget belongs to.
            </summary>
    </member>
    <member name="M:Editor.Widget.SignalValuesChanged">
      <summary>
            When a value on this widget changed due to user input (ie, checking a box, editing a form)
            this is called, which sends a signal up the parent widgets.
            </summary>
    </member>
    <member name="M:Editor.Widget.AdjustSize">
      <summary>
            Adjusts the size of the widget to fit its contents.
            </summary>
    </member>
    <member name="P:Editor.Widget.ScreenGeometry">
      <summary>
            Returns the geometry of the screen this widget is currently on.
            </summary>
    </member>
    <member name="M:Editor.Widget.ConstrainToScreen">
      <summary>
            Constrain this widget to the screen it's currently on.
            </summary>
    </member>
    <member name="M:Editor.Widget.ConstrainTo(Sandbox.Rect)">
      <summary>
            Reposition this widget to ensure it is within the given rectangle.
            </summary>
      <param name="parentRect">Rectangle to constraint to, relative to the parent widget.</param>
    </member>
    <member name="M:Editor.Widget.Show">
      <summary>
            Make this widget visible.
            </summary>
    </member>
    <member name="M:Editor.Widget.Hide">
      <summary>
            Make this widget not visible.
            </summary>
    </member>
    <member name="M:Editor.Widget.Close">
      <summary>
            If a window - will close
            </summary>
    </member>
    <member name="M:Editor.Widget.SetModal(System.Boolean,System.Boolean)">
      <summary>
            Set this window to be modal. This means it will appear on top of everything and block input to everything else.
            </summary>
    </member>
    <member name="M:Editor.Widget.IsModal">
      <summary>
            Returns true if this is a modal window. This means it will appear on top of everything and block input to everything else.
            </summary>
    </member>
    <member name="M:Editor.Widget.DisableWindowActivation">
      <summary>
            Calling this will set the WS_EX_NOACTIVATE flag on the window internally, which will stop
            it taking focus away from other windows.
            </summary>
    </member>
    <member name="M:Editor.Widget.SetContentHash(System.Int32,System.Single)">
      <summary>
            Call every frame/tick to redraw this Widget on content change
            </summary>
    </member>
    <member name="M:Editor.Widget.SetContentHash(System.Func{System.Int32},System.Single)">
      <summary>
            Call every frame/tick to redraw this Widget on content change
            </summary>
    </member>
    <member name="P:Editor.Widget.UpdatesEnabled">
      <summary>
            If true, Update will call 
            </summary>
    </member>
    <member name="M:Editor.Widget.AlignToParent(Sandbox.TextFlag,Vector2)">
      <summary>
            Align this widget to its parents edge, with an offset.
            </summary>
    </member>
    <member name="M:Editor.Widget.UpdateGeometry">
      <summary>
            Tell everything that the geometry of this has changed
            </summary>
    </member>
    <member name="M:Editor.Widget.GetWindow">
      <summary>
            Get the top level window widget
            </summary>
    </member>
    <member name="P:Editor.Widget.DebugModeEnabled">
      <summary>
            Enable debug mode on this widget.
            </summary>
    </member>
    <member name="P:Editor.Widget.ProvidesDebugMode">
      <summary>
            If true then this widget has a debug mode that can be activated
            </summary>
    </member>
    <member name="P:Editor.Widget.IsPressed">
      <summary>
            Whether this widget is currently being pressed down or not.
            </summary>
    </member>
    <member name="M:Editor.Widget.OnWheel(Editor.WheelEvent)">
      <summary>
            Mouse wheel was scrolled while the mouse cursor was over this widget.
            </summary>
    </member>
    <member name="F:Editor.Widget.MouseRelease">
      <inheritdoc cref="M:Editor.Widget.OnMouseReleased(Editor.MouseEvent)" />
    </member>
    <member name="M:Editor.Widget.OnMouseReleased(Editor.MouseEvent)">
      <summary>
            Called when mouse is released over this widget.
            </summary>
    </member>
    <member name="F:Editor.Widget.MouseClick">
      <inheritdoc cref="M:Editor.Widget.OnMouseClick(Editor.MouseEvent)" />
    </member>
    <member name="M:Editor.Widget.OnMouseClick(Editor.MouseEvent)">
      <summary>
            Called when this widget is left clicked (on mouse release).
            </summary>
    </member>
    <member name="F:Editor.Widget.MouseRightClick">
      <inheritdoc cref="M:Editor.Widget.OnMouseRightClick(Editor.MouseEvent)" />
    </member>
    <member name="M:Editor.Widget.OnMouseRightClick(Editor.MouseEvent)">
      <summary>
            Called when this widget is right clicked (on mouse release).
            </summary>
    </member>
    <member name="F:Editor.Widget.MouseLeftPress">
      <summary>
            Called when this widget is left clicked (on mouse press).
            </summary>
    </member>
    <member name="F:Editor.Widget.MouseRightPress">
      <summary>
            Called when this widget is right clicked (on mouse press).
            </summary>
    </member>
    <member name="F:Editor.Widget.MouseMiddlePress">
      <summary>
            Called when this widget is clicked with the mouse wheel (on mouse press).
            </summary>
    </member>
    <member name="M:Editor.Widget.OnMousePress(Editor.MouseEvent)">
      <summary>
            Called when mouse is pressed over this widget.
            </summary>
    </member>
    <member name="P:Editor.Widget.IsDraggable">
      <summary>
            Whether this widget can be drag and dropped onto other widgets.
            </summary>
    </member>
    <member name="F:Editor.Widget.MouseMove">
      <inheritdoc cref="M:Editor.Widget.OnMouseMove(Editor.MouseEvent)" />
    </member>
    <member name="M:Editor.Widget.OnMouseMove(Editor.MouseEvent)">
      <summary>
            Called when the mouse cursor is moved while being over this widget.
            </summary>
    </member>
    <member name="M:Editor.Widget.OnMouseEnter">
      <summary>
            Mouse cursor entered the bounds of this widget.
            </summary>
    </member>
    <member name="M:Editor.Widget.OnMouseLeave">
      <summary>
            Mouse cursor exited the bounds of this widget.
            </summary>
    </member>
    <member name="M:Editor.Widget.OnContextMenu(Editor.ContextMenuEvent)">
      <summary>
            Called after <see cref="M:Editor.Widget.OnMouseRightClick(Editor.MouseEvent)" />, for the purposes of opening a context menu.
            </summary>
    </member>
    <member name="M:Editor.Widget.OnDoubleClick(Editor.MouseEvent)">
      <summary>
            Called when the widget was double clicked with any mouse button.
            </summary>
      <param name="e" />
    </member>
    <member name="M:Editor.Widget.OnKeyPress(Editor.KeyEvent)">
      <summary>
            A key has been pressed. Your widget needs keyboard focus for this to be called - see FocusMode.
            </summary>
    </member>
    <member name="M:Editor.Widget.OnKeyRelease(Editor.KeyEvent)">
      <summary>
            A key has been released.
            </summary>
    </member>
    <member name="M:Editor.Widget.OnShortcutPressed(Editor.KeyEvent)">
      <summary>
            A shortcut has been activated. This is called on the focused control so they can override it.
            </summary>
    </member>
    <member name="M:Editor.Widget.OnFocus(Editor.FocusChangeReason)">
      <summary>
            Called when the widget gains keyboard focus.
            </summary>
    </member>
    <member name="M:Editor.Widget.OnBlur(Editor.FocusChangeReason)">
      <summary>
            Called when the widget loses keyboard focus.
            </summary>
    </member>
    <member name="M:Editor.Widget.OnResize">
      <summary>
            Called when the widgets' size was changed.
            </summary>
    </member>
    <member name="E:Editor.Widget.Moved">
      <summary>
            Called when the widget is moved to a new position relative to it's parent.
            </summary>
    </member>
    <member name="M:Editor.Widget.OnMoved">
      <summary>
            Called when the widget was moved to a new position relative to it's parent.
            </summary>
    </member>
    <member name="M:Editor.Widget.InternalPaintEvent(QPainter,System.Int32)">
      <summary>
            Called from Widget paint event. If e is null then we're drawing manually
            which usually means directx is expected to draw a frame.
            </summary>
    </member>
    <member name="F:Editor.Widget.OnPaintOverride">
      <summary>
             Override the widget's paint process.
            
             Return <see langword="true" /> to prevent the default paint action, which is to call <see cref="M:Editor.Widget.OnPaint" />.
             </summary>
    </member>
    <member name="M:Editor.Widget.OnPaint">
      <summary>
            Override to custom paint your widget, for example using <see cref="T:Editor.Paint" />. Can be overwritten by <see cref="F:Editor.Widget.OnPaintOverride" />.
            </summary>
    </member>
    <member name="M:Editor.Widget.OnClose">
      <summary>
            Called when a window is about to be closed.
            </summary>
    </member>
    <member name="M:Editor.Widget.OnClosed">
      <summary>
            Called when a window is closed.
            </summary>
    </member>
    <member name="E:Editor.Widget.VisibilityChanged">
      <summary>
            Called when the visibility of this widget changes.
            </summary>
    </member>
    <member name="M:Editor.Widget.OnVisibilityChanged(System.Boolean)">
      <summary>
            Called when the visibility of this widget changes.
            </summary>
    </member>
    <member name="M:Editor.Widget.FocusNext">
      <summary>
            Called when Tab is pressed to find the next widget to focus.
            Return true to prevent focusing.
            </summary>
    </member>
    <member name="M:Editor.Widget.FocusPrevious">
      <summary>
            Called when Shift + Tab is pressed to find the next widget to focus.
            Return true to prevent focusing.
            </summary>
    </member>
    <member name="M:Editor.Widget.DoLayout">
      <summary>
            Called to make sure all child panels are in correct positions and have correct sizes.
            This is typically called when the size of this widget changes, but there are other cases as well.
            </summary>
    </member>
    <member name="M:Editor.Widget.MinimumSizeHint">
      <summary>
            Return the minimum size this widget wants to be
            </summary>
    </member>
    <member name="M:Editor.Widget.SizeHint">
      <summary>
            Should return the size this widget really wants to be if it can its way. The default
            is that you don't care - and just to return whatever the base value is.
            </summary>
    </member>
    <member name="P:Editor.Widget.IsBeingDroppedOn">
      <summary>
            Whether something is being dragged over this widget.
            </summary>
    </member>
    <member name="T:Editor.Widget.DragEvent">
      <summary>
            Information about a widget drag and drop event.
            </summary>
    </member>
    <member name="P:Editor.Widget.DragEvent.LocalPosition">
      <summary>
            Cursor position, local to this widget.
            </summary>
    </member>
    <member name="P:Editor.Widget.DragEvent.Data">
      <summary>
            The drag data.
            </summary>
    </member>
    <member name="P:Editor.Widget.DragEvent.KeyboardModifiers">
      <summary>
            The keyboard modifier keys that were held down at the moment the event triggered.
            </summary>
    </member>
    <member name="P:Editor.Widget.DragEvent.HasShift">
      <summary>
            Whether <c>Shift</c> key was being held down at the time of the event.
            </summary>
    </member>
    <member name="P:Editor.Widget.DragEvent.HasCtrl">
      <summary>
            Whether <c>Control</c> key was being held down at the time of the event.
            </summary>
    </member>
    <member name="P:Editor.Widget.DragEvent.HasAlt">
      <summary>
            Whether <c>Alt</c> key was being held down at the time of the event.
            </summary>
    </member>
    <member name="P:Editor.Widget.DragEvent.Action">
      <summary>
            Set this to what action will be (or was) performed.
            </summary>
    </member>
    <member name="M:Editor.Widget.OnDragStart">
      <summary>
            Called when dragging. <see cref="P:Editor.Widget.IsDraggable" /> should be true.
            </summary>
    </member>
    <member name="M:Editor.Widget.OnDragLeave">
      <summary>
            Cursor with drag and drop data left the bounds of this widget.
            <para>Requires <see cref="P:Editor.Widget.AcceptDrops" /> to function.</para></summary>
    </member>
    <member name="M:Editor.Widget.OnDragHover(Editor.Widget.DragEvent)">
      <summary>
            Cursor with drag and drop data moved on this widget.
            <para>Requires <see cref="P:Editor.Widget.AcceptDrops" /> to function.</para></summary>
      <param name="ev">The drag event info.</param>
    </member>
    <member name="M:Editor.Widget.OnDragDrop(Editor.Widget.DragEvent)">
      <summary>
            Something was dragged and dropped on this widget. Apply the data here, if its valid.
            <para>Requires <see cref="P:Editor.Widget.AcceptDrops" /> to function.</para></summary>
      <param name="ev">The drag event info.</param>
    </member>
    <member name="P:Editor.Widget.Layout">
      <summary>
            The widget's internal layout, if any
            </summary>
    </member>
    <member name="M:Editor.Widget.Raise">
      <summary>
            Raises this widget to the top of the parent widget's stack.
            After this call the widget will be visually in front of any overlapping sibling widgets.
            </summary>
    </member>
    <member name="M:Editor.Widget.Lower">
      <summary>
            Lowers the widget to the bottom of the parent widget's stack.
            After this call the widget will be visually behind (and therefore obscured by) any overlapping sibling widgets.
            </summary>
    </member>
    <member name="F:Editor.FocusMode.None">
      <summary>
            Do not accept focus.
            </summary>
    </member>
    <member name="F:Editor.FocusMode.Tab">
      <summary>
            Accept focus by tabbing.
            </summary>
    </member>
    <member name="F:Editor.FocusMode.Click">
      <summary>
            Accept focus by being clicked on.
            </summary>
    </member>
    <member name="F:Editor.FocusMode.TabOrClick">
      <summary>
            Accept focus by clicking or tabbing.
            </summary>
    </member>
    <member name="F:Editor.FocusMode.TabOrClickOrWheel">
      <summary>
            Accept focus when using the mouse wheel too.
            </summary>
    </member>
    <member name="T:Editor.SuspendUpdates">
      <summary>
            Suspends updates in the widget for this using scope.
            </summary>
    </member>
    <member name="T:Editor.FocusChangeReason">
      <summary>
            Describes why a <see cref="T:Editor.Widget" />s' keyboard focus has changed via <see cref="M:Editor.Widget.OnFocus(Editor.FocusChangeReason)" /> and <see cref="M:Editor.Widget.OnBlur(Editor.FocusChangeReason)" /> callbacks.
            </summary>
    </member>
    <member name="P:Editor.Window.StateCookie">
      <summary>
            A unique identifier for this window, to store the window state across sessions using the <see cref="P:Sandbox.Internal.GlobalGameNamespace.Cookie">Cookie</see> library.
            </summary>
    </member>
    <member name="M:Editor.Window.RestoreFromStateCookie">
      <summary>
            Called whenever the window should restore its state via the <see cref="P:Sandbox.Internal.GlobalToolsNamespace.EditorCookie">EditorCookie</see> library,
            that was previously saved in <see cref="M:Editor.Window.SaveToStateCookie" />.<br />
            You should use <see cref="P:Editor.Window.StateCookie" /> in the cookie name.
            </summary>
    </member>
    <member name="M:Editor.Window.SaveToStateCookie">
      <summary>
            Called whenever the window should save its state via the <see cref="P:Sandbox.Internal.GlobalToolsNamespace.EditorCookie">EditorCookie</see> library,
            to be later restored in <see cref="M:Editor.Window.RestoreFromStateCookie" />. This is useful to carry data across game sessions.<br />
            You should use <see cref="P:Editor.Window.StateCookie" /> in the cookie name.
            </summary>
    </member>
    <member name="P:Editor.Window.StartCentered">
      <summary>
            Initialises the window at the centre of the screen (or main editor window if one is present) by default.
            </summary>
    </member>
    <member name="M:Editor.Window.Clear">
      <summary>
            TODO this was a test, get rid of it
            </summary>
    </member>
    <member name="M:Editor.Window.Center">
      <summary>
            Position the window at the centre of the screen, or main editor window if one is present.
            </summary>
    </member>
    <member name="T:Editor.WindowControlIcon">
      <summary>
            These apply to both Segoe Fluent Icons and Segoe MDL2 Assets
            </summary>
    </member>
    <member name="M:Editor.EditorScene.OpenScene(Sandbox.SceneFile)">
      <summary>
            Opens the given scene file for editing, if it's not already open.
            </summary>
    </member>
    <member name="M:Editor.EditorScene.OpenPrefab(Sandbox.PrefabFile)">
      <summary>
            Opens the given prefab file for editing, if it's not already open.
            </summary>
    </member>
    <member name="M:Editor.EditorScene.TogglePlay">
      <summary>
            Toggles play mode.
            </summary>
    </member>
    <member name="M:Editor.EditorScene.OnPlayStore">
      <summary>
            Store stuff before playing
            </summary>
    </member>
    <member name="M:Editor.EditorScene.OnPlayRestore">
      <summary>
            Restore stuff before playing
            </summary>
    </member>
    <member name="M:Editor.EditorScene.SceneEditorTick">
      <summary>
            Called once a frame to keep the game camera in sync with the main camera in the editor scene
            </summary>
    </member>
    <member name="M:Editor.EditorScene.LoadFromScene(Sandbox.SceneFile)">
      <summary>
            This is called when the user wants to open a new scene
            </summary>
    </member>
    <member name="M:Editor.EditorScene.LoadFromPrefab(Sandbox.PrefabFile)">
      <summary>
            This is called when the user wants to open a new scene
            </summary>
    </member>
    <member name="M:Editor.EditorScene.UpdatePrefabInstances(Sandbox.PrefabFile)">
      <summary>
            Update any/all instances of a prefab in any open sessions
            </summary>
    </member>
    <member name="M:Editor.SceneEditor.HasComponentInClipboard">
      <summary>
            Is there a <see cref="T:Sandbox.Component" /> type in the clipboard?
            </summary>
    </member>
    <member name="T:Editor.GameEditorSession">
      <summary>
            Like SceneEditorSession except this is the session for the running game. It
            has a scene editor tab, but we create via this class to differenciate it, because
            there are differences, like it can't be saved/loaded etc.
            </summary>
    </member>
    <member name="M:Editor.GameEditorSession.CloseAll">
      <summary>
            Close any active game editor sessions
            </summary>
    </member>
    <member name="T:Editor.PrefabEditorSession">
      <summary>
            Holds a current open scene and its edit state
            </summary>
    </member>
    <member name="T:Editor.SceneEditorSession">
      <summary>
            Holds a current open scene and its edit state
            </summary>
    </member>
    <member name="P:Editor.SceneEditorSession.IsGameSession">
      <summary>
            Returns true if this session is the running game
            </summary>
    </member>
    <member name="P:Editor.SceneEditorSession.IsPrefabSession">
      <summary>
            Returns true if this session is editing a prefab
            </summary>
    </member>
    <member name="M:Editor.SceneEditorSession.CreateSceneDock">
      <summary>
            Create the tabbed dock widget that holds the scene view
            </summary>
    </member>
    <member name="M:Editor.SceneEditorSession.MakeActive(System.Boolean)">
      <summary>
            Makes this scene active and brings it to the front
            </summary>
    </member>
    <member name="M:Editor.SceneEditorSession.BringToFront">
      <summary>
            Bring this scene tab to the front
            </summary>
    </member>
    <member name="M:Editor.SceneEditorSession.Scope">
      <summary>
            Pushes the active editor scene to the current scope
            </summary>
    </member>
    <member name="M:Editor.SceneEditorSession.FrameTo(BBox@)">
      <summary>
            Zoom the scene to view this bbox
            </summary>
    </member>
    <member name="M:Editor.SceneEditorSession.Resolve(Sandbox.Scene)">
      <summary>
            Resolve a scene to an editor session
            </summary>
    </member>
    <member name="M:Editor.SceneEditorSession.Resolve(Sandbox.SceneFile)">
      <summary>
            Resolve a scene file to an editor session.
            </summary>
    </member>
    <member name="M:Editor.SceneEditorSession.Resolve(Sandbox.PrefabFile)">
      <summary>
            Resolve a prefab file to an editor session.
            </summary>
    </member>
    <member name="M:Editor.SceneEditorSession.Resolve(Facepunch.ActionGraphs.ISourceLocation)">
      <summary>
            Resolve an action graph source location to an editor session.
            </summary>
    </member>
    <member name="M:Editor.SceneEditorSession.GetParentSession">
      <summary>
            If this is a GameSession then this will return its parent editor session.
            </summary>
    </member>
    <member name="F:Editor.SceneEditorSession.previousSavedSelection">
      <summary>
            when changing the selection, we save it as the previous, so that undo has a frame of reference
            </summary>
    </member>
    <member name="M:Editor.SceneEditorSession.SerializeSelection">
      <summary>
            Serlialize the current selection to a json string. The aim here is to make something we can transfer back to objects.
            </summary>
    </member>
    <member name="M:Editor.SceneEditorSession.DeserializeSelection(System.String)">
      <summary>
            Take a json string created by SerializeSelection and turn it into a selection
            </summary>
    </member>
    <member name="M:Editor.SceneEditorSession.FullUndoSnapshot(System.String)">
      <summary>
            Take a full scene snapshot for the undo system. This is usually a last resort, if you can't do anything more incremental.
            </summary>
    </member>
    <member name="M:Editor.SceneEditorSession.PushUndoSelection">
      <summary>
            Push the current selection into the undo system
            </summary>
    </member>
    <member name="T:Editor.StartupLoadProject">
      <summary>
            Called once on editor startup to load the -project
            </summary>
    </member>
    <member name="M:Editor.StartupLoadProject.Run">
      <summary>
            Load the startup project for the first time
            </summary>
    </member>
    <member name="M:Editor.StartupLoadProject.OpenProject(System.String,System.Action{System.String,System.Single},System.Threading.CancellationToken)">
      <summary>
            Opens the project for the editor, this should only be called once from the -project command line.
            </summary>
    </member>
    <member name="M:Editor.StartupLoadProject.DownloadCloudAssets">
      <summary>
            For each asset in our current asset system, download all cloud resources required 
            </summary>
    </member>
    <member name="T:Editor.ToolRender">
      <summary>
            Renders basic stuff for tool views
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.TranslateString(System.String,System.String)">
      <summary>
            Translate input into language
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.LoadBitmap(System.String)">
      <summary>
            Load a float bitmap. This is usually a png, tga, exr, psd
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.CreateModelFromMeshFile(Editor.Asset,System.String)">
      <summary>
            Create a vmdl file from a mesh. Will return non null if the asset was created successfully
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.CreateModelFromPolygonMeshes(Sandbox.PolygonMesh[],System.String)">
      <summary>
            Create a vmdl file from polygon meshes. Will return non null if the asset was created successfully
            </summary>
    </member>
    <member name="E:Editor.EditorUtility.OnInspect">
      <summary>
            Called when InspectorObject changes
            </summary>
    </member>
    <member name="P:Editor.EditorUtility.InspectorObject">
      <summary>
            Set the object to be inspected by the inspector.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.GetRootPanels">
      <summary>
            Get all the root panels.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.OpenFolder(System.String)">
      <summary>
            Open a folder (or url)
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.OpenFile(System.String)">
      <summary>
            Open a folder (or url)
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.OpenFileFolder(System.String)">
      <summary>
            Open given file's folder in OS file explorer and select given file.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.CopyFileToDirectory(System.String,System.String,System.Boolean)">
      <summary>
            Copies a file to a directory
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.MoveAssetToDirectory(Editor.Asset,System.String,System.Boolean)">
      <summary>
            Moves an asset's source and compiled files to a directory (if they exist)
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.RenameAsset(Editor.Asset,System.String)">
      <summary>
            Moves a file to the same directory but gives it a new name 
            </summary>
      <param name="asset" />
      <param name="newName" />
    </member>
    <member name="M:Editor.EditorUtility.CopyAssetToDirectory(Editor.Asset,System.String,System.Boolean)">
      <summary>
            Copies an asset's source and compiled files to a directory (if they exist)
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.RedrawActiveWindow">
      <summary>
            People are lazy and will be calling this all the time if we let them. Lets keep it hidden for as long as possible
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.StopAssetSound">
      <summary>
            Stop a sound playing from an asset preview
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.PlayAssetSound(Editor.Asset)">
      <summary>
            Plays an asset sound in 2d space
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.PlayAssetSound(Sandbox.SoundEvent)">
      <summary>
            Plays an asset sound in 2d space
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.PlayAssetSound(Sandbox.SoundFile)">
      <summary>
            Plays an asset sound in 2d space
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.PlaySound(System.String,System.Single)">
      <summary>
            Plays a sound event
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.PlayRawSound(System.String)">
      <summary>
            Plays a sound via the OS, which is the way you play a sound if you
            want it to be heard when the game is tabbed away
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.GetSceneCameras">
      <summary>
            Return all known SceneCameras. This list might have cameras that are no longer active
            but haven't been garbage collected yet.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.ClearPackageCache">
      <summary>
            Delete the cached package info. This will cause any future requests to get fresh information
            from the backend. This is useful if you just updated something and want to see the changes.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.CreateWebSurface">
      <summary>
            Create an unlimited web surface
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.GetSerializedObject(System.Object)">
      <summary>
            Get a serialized object for this object. Because you're in the editor, this is an
            unrestricted object, we aren't whitelisting or using TypeLibrary.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.CreateVideoWriter(System.String,Sandbox.VideoWriter.Config)">
      <summary>
            Create a video writer
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.DisableTextureStreaming">
      <summary>
            Force textures to load fully when loading a model etc..
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.Quit">
      <summary>
            Quit the whole engine
            </summary>
    </member>
    <member name="P:Editor.EditorUtility.IsVulkan">
      <summary>
            Used for shadergraph
            </summary>
    </member>
    <member name="P:Editor.EditorUtility.IsRecordingVideo">
      <summary>
            True if we're currently recording a video (using the video command, or F6)
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.DisplayDialog(System.String,System.String,System.String,System.String,Editor.Widget)">
      <summary>
            Display a modal dialog message. This is a blocking call.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.DisplayDialog(System.String,System.String,System.String,System.String,System.Action,System.String,Editor.Widget)">
      <summary>
            Display a modal dialog message. This is a blocking call.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.OpenControlSheet(Sandbox.SerializedObject,Editor.Widget)">
      <summary>
            Show a popup control sheet for this. You should set parent to the control from this this sheet is created.
            If you do that properly, when that control is deleted, this popup will get deleted too. If you set it to null
            then the control sheet will stay open until it's closed.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.GetSearchPaths">
      <summary>
            Gets every search path seperated by ;
            </summary>
    </member>
    <member name="P:Editor.EditorUtility.RenderSettings">
      <summary>
            Access to the client's render settings
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.KeyValues3ToJson(System.String)">
      <summary>
            Some assets are kv3, we want to convert them to json
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.RestartEditor">
      <summary>
            Restarts the editor with the same project.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.RestartEditorPrompt(System.String,System.String)">
      <summary>
            Open a dialog prompt asking the user to restart the editor.
            </summary>
      <param name="message" />
      <param name="title" />
    </member>
    <member name="M:Editor.EditorUtility.IsCodeFolder(System.String)">
      <summary>
            Checks if a given folder is a code folder, e.g. [project root]/Code
            </summary>
      <param name="fullPath" />
      <returns />
    </member>
    <member name="M:Editor.EditorUtility.IsCodeFile(System.String)">
      <summary>
            Checks if a given file is a code file
            </summary>
      <param name="fullPath" />
      <returns />
    </member>
    <member name="M:Editor.EditorUtility.GetSourceLocation(Sandbox.Scene)">
      <summary>
            Gets the source location for the given scene, used by action graph stack traces,
            and so the action graph editor knows which asset to save when editing a graph.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.FindProjectByDirectory(System.String)">
      <summary>
            Tries to find a project based on a given directory.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.CompileShader(System.String,Sandbox.Engine.Shaders.ShaderCompileOptions,System.Threading.CancellationToken)">
      <summary>
            Compile a fucking shader. Takes a .shader file and compiles it.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.CreateTypeLibrary(Sandbox.CompilerOutput[])">
      <summary>
            Create a TypeLibrary from a collection of assemblies
            </summary>
      <param name="assemblies" />
      <returns />
    </member>
    <member name="M:Editor.EditorUtility.SaveFileDialog(System.String,System.String,System.String)">
      <summary>
            Open a file save dialog. Returns null on cancel, else the absolute path of the target file.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.OpenFileDialog(System.String,System.String,System.String)">
      <summary>
            Open a file open dialog. Returns null on cancel, else the absolute path of the target file.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.Mounting.Get(System.String)">
      <summary>
            Get the mount
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.Mounting.InitMountsFromConfig(Sandbox.Project)">
      <summary>
            Look at the current project's config and mount any mounts.
            Complain if a mount is missing.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.Mounting.SetMounted(System.String,System.Boolean)">
      <summary>
            Set a mount state. This state will be saved in the project, and your game will require it if you publish it.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.Mounting.Refresh(System.String)">
      <summary>
            Flush this source to force a refresh. Unmount and re-mount, updating and getting a list of all the new files.
            This is used during development to force an update of the files, so you don't have to restart the editor.
            </summary>
    </member>
    <member name="P:Editor.EditorUtility.Network.Active">
      <summary>
            True if the network system is active
            </summary>
    </member>
    <member name="P:Editor.EditorUtility.Network.Hosting">
      <summary>
            True if the network system is active and we're the host
            </summary>
    </member>
    <member name="P:Editor.EditorUtility.Network.Client">
      <summary>
            True if the network system is active and we're the host
            </summary>
    </member>
    <member name="P:Editor.EditorUtility.Network.HostPrivacy">
      <summary>
            Determines who can join a lobby hosted from the editor. Should only be set
            before creating a lobby. Persists between lobbies.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.Network.Disconnect">
      <summary>
            Disconnect from the current network session
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.Network.Connect(System.String)">
      <summary>
            Connenct to a network address
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.Network.StartHosting">
      <summary>
            Start a server
            </summary>
    </member>
    <member name="P:Editor.EditorUtility.Network.Channels">
      <summary>
            Return all of the channels on this connection. 
            If you're the host, it should return all client connections.
            If you're the client, it should return empty - unless you're in a p2p session (lobby).
            Returns empty if you're not connected
            </summary>
    </member>
    <member name="P:Editor.EditorUtility.Network.Sockets">
      <summary>
            Return all of the sockets on this connection. 
            If you're the host, it should return all active sockets.
            If you're the client, it should return empty - unless you're in a p2p session (lobby).
            Returns empty if you're not connected
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.Prefabs.GetTargets(Sandbox.GameObject,Sandbox.PrefabVariable)">
      <summary>
            Get a SerializedProperty representing variable targets. Will return null if there are no targets
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.Prefabs.CreateAsset(Sandbox.GameObject)">
      <summary>
            Create a prefab out of any GameObject
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.Prefabs.GetTemplates">
      <summary>
            Fetches all prefab templates to show in Create GameObject menus
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.Projects.Compile(Sandbox.Project,System.Action{System.String})">
      <summary>
            Compiled a project ready to be published. Will return the compiled result and any CodeArchives
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.Projects.ResolveCompiler(System.Reflection.Assembly)">
      <summary>
            Resolve a compiler from an assembly, using the assembly name
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.Projects.SortLibrariesForCompilation(System.Collections.Generic.IEnumerable{Sandbox.Project},System.Action{System.String})">
      <summary>
            Finds the compilation order for any of the given libraries containing code,
            based on which libraries reference others.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.Projects.DisplayLoadingErrorDialog(System.String,System.String)">
      <summary>
            Display a modal dialog message. This is a blocking call.
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.Projects.WaitForCompiles">
      <summary>
            Wait for the local compiles to be finished
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.Projects.GenerateSolution">
      <summary>
            Regenerates the project's solution
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.LoadProjectSettings``1(System.String)">
      <summary>
            Load a project settings file
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.SaveProjectSettings``1(``0,System.String)">
      <summary>
            Save a project settings file
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.VoiceRecording.Start(System.Int32,System.Int32)">
      <summary>
            Start recording data from microphone
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.VoiceRecording.Stop">
      <summary>
            Stop recording data from microphone
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.VoiceRecording.Flush">
      <summary>
            Flush any recorded data so we don't have it kept in memory
            </summary>
    </member>
    <member name="M:Editor.EditorUtility.VoiceRecording.Save(System.String)">
      <summary>
            Grab any recorded voice data and save it as a WAV file
            </summary>
    </member>
    <member name="M:Editor.Animate.Add(System.Object,System.Single,System.Single,System.Single,System.Action{System.Single},System.String)">
      <summary>
            Add a float animation for this object
            </summary>
    </member>
    <member name="M:Editor.Animate.CancelAll(System.Object,System.Boolean)">
      <summary>
            Cancel all of this object's active animations
            </summary>
    </member>
    <member name="M:Editor.Animate.IsActive(System.Object)">
      <summary>
            Returns true if this object has any active animations
            </summary>
    </member>
    <member name="M:Editor.CloudAsset.IsInstalled(System.String)">
      <summary>
            Checks if a package is installed on disk, including checking the version if it's present in the ident.
            </summary>
      <param name="ident" />
      <returns />
    </member>
    <member name="M:Editor.CloudAsset.InstallSingle(System.String)">
      <summary>
            Install a cloud asset by ident
            </summary>
    </member>
    <member name="M:Editor.CloudAsset.Install(System.String,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Install multiple packages, skipping what's already installed. Does progress window.
            </summary>
    </member>
    <member name="M:Editor.CloudAsset.Install(System.Collections.Generic.IEnumerable{System.String},System.Action{Sandbox.Package},System.Threading.CancellationToken)">
      <summary>
            Install multiple packages, skipping what's already installed.
            </summary>
    </member>
    <member name="M:Editor.CloudAsset.GetAssetReferences(System.Boolean)">
      <summary>
            Gets all cloud packages referenced from assets
            </summary>
    </member>
    <member name="T:Editor.IPopupEditor`1">
      <summary>
            An popup editor capable of editing type T. This is created when EditorUtility.OpenControlSheet is called, 
            which is generally and most commonly done via the GenericControlWidget, which is a ControlWidget used
            to view and edit generic classes.
            </summary>
    </member>
    <member name="F:Editor.ExportConfig.CodePackages">
      <summary>
            Assemblies can reference asset packages. This is a list
            of packages that the compiled code references.
            </summary>
    </member>
    <member name="P:Editor.ExportConfig.AssemblyFiles">
      <summary>
            If the compile process created any assemblies
            </summary>
    </member>
    <member name="P:Editor.ExportConfig.TargetDir">
      <summary>
            Where are we putting the exported build?
            </summary>
    </member>
    <member name="P:Editor.ExportConfig.ExecutableName">
      <summary>
            The target .exe name for this export
            </summary>
    </member>
    <member name="P:Editor.ExportConfig.TargetIcon">
      <summary>
            The icon for the target .exe
            </summary>
    </member>
    <member name="P:Editor.ExportConfig.StartupImage">
      <summary>
            The splash screen to use
            </summary>
    </member>
    <member name="P:Editor.ExportConfig.AppId">
      <summary>
            The Steam AppID for the target .exe
            </summary>
    </member>
    <member name="P:Editor.ExportConfig.BuildDate">
      <summary>
            Game's build date
            </summary>
    </member>
    <member name="M:Editor.FileAssociations.Create">
      <summary>
            Creates/updates file associations between .sbproj files and the editor
            </summary>
    </member>
    <member name="T:Editor.HistoryList`1">
      <summary>
            A helper class to store a list of strings, which can then be navigated around, saved, restored
            </summary>
    </member>
    <member name="P:Editor.HistoryList`1.MaxItems">
      <summary>
            The maximum history length
            </summary>
    </member>
    <member name="P:Editor.HistoryList`1.Debug">
      <summary>
            Print debug information on navigation
            </summary>
    </member>
    <member name="F:Editor.HistoryList`1.OnNavigate">
      <summary>
            Called when navigations successfully happened.
            </summary>
    </member>
    <member name="M:Editor.HistoryList`1.Add(`0)">
      <summary>
            Navigate to the previous item in the list, removes any items after the current position.
            </summary>
    </member>
    <member name="M:Editor.HistoryList`1.Navigate(System.Int32)">
      <summary>
            Navigate to delta positions from the current position. For example, -1 is backwards.
            Returns false if nothing changed.
            </summary>
    </member>
    <member name="P:Editor.ProjectPublisher.PackageManifest.CodePackageReferences">
      <summary>
            List of packages that the code references
            </summary>
    </member>
    <member name="M:Editor.ProjectPublisher.PackageManifest.CollectInputDependencies(Editor.Asset)">
      <summary>
            Collect and add input dependencies to the manifest.
            These are files that were involved in compile but don't cause a recompile - usually only present for child resources (ie. the tga that a vtex_c came from)
            </summary>
      <param name="asset" />
      <returns />
    </member>
    <member name="F:Editor.ProjectPublisher.PackageManifest.DissallowedExtensions">
      <summary>
            This really exists only to dissallow dangerous extensions like .exe etc.
            So feel free to add anything non dangerous to this list.
            </summary>
    </member>
    <member name="M:Editor.ProjectPublisher.PackageManifest.GrabWildcardReferences(System.String)">
      <summary>
            Test our wildcards and make sure to pull in any assets that the assets that
            we're whitelisting are referencing. If they're not already included in the wildcard
            then we'll add them by full relative path to the end of the list.
            </summary>
    </member>
    <member name="M:Editor.ProjectPublisher.PackageManifest.AddCodePackageReference(System.String)">
      <summary>
            We're referencing this asset package, so add it as an EditorReference and
            include its asset.
            </summary>
    </member>
    <member name="T:Editor.ProjectPublisher.ProjectFile">
      <summary>
            A single file in the project revision manifest
            </summary>
    </member>
    <member name="M:Editor.ProjectPublisher.GetGameSettings(Sandbox.CompilerOutput[])">
      <summary>
            Fetch a list of game settings to be added to the project's metadata
            </summary>
      <param name="assemblies" />
      <returns />
    </member>
    <member name="M:Editor.ProjectPublisher.GenerateAssetManifest(Editor.IProgress,System.Threading.CancellationToken)">
      <summary>
            Build a list of files to upload for this version. Return false if errors that would prevent the upload.
            </summary>
    </member>
    <member name="M:Editor.ProjectPublisher.GenerateSourceManifest(Editor.IProgress,System.Threading.CancellationToken)">
      <summary>
            Build a list of files to upload for this version. Return false if errors that would prevent the upload.
            </summary>
    </member>
    <member name="M:Editor.ProjectPublisher.Publish(Editor.IProgress,System.Threading.CancellationToken)">
      <summary>
            Publish a new revision
            </summary>
    </member>
    <member name="M:Editor.ProjectPublisher.PrePublish(System.Threading.CancellationToken)">
      <summary>
            Check the intended manifest, ask the backend which files need to be uploaded.
            </summary>
    </member>
    <member name="M:Editor.ProjectPublisher.AddFile(System.Byte[],System.String)">
      <summary>
            Manually add a file to the manifest
            </summary>
    </member>
    <member name="M:Editor.ProjectPublisher.AddFile(System.String,System.String)">
      <summary>
            Manually add a file to the manifest
            </summary>
    </member>
    <member name="M:Editor.ProjectPublisher.AddCodePackageReference(System.String)">
      <summary>
            If the code is referencing a package - we can add it to the manifest using this.
            </summary>
    </member>
    <member name="P:Editor.ProjectPublisher.Files">
      <summary>
            Get access to the files within the manifest
            </summary>
    </member>
    <member name="M:Editor.ProjectPublisher.SetChangeDetails(System.String,System.String)">
      <summary>
            Allows to set information on the revision - for future reference
            </summary>
    </member>
    <member name="M:Editor.ProjectPublisher.CanPublishFile(Editor.Asset)">
      <summary>
            Return true if we're not opposed to publishing this asset
            </summary>
    </member>
    <member name="M:Editor.StandaloneExporter.GetCodeResources(System.String)">
      <summary>
            Fetch all code-defined core resources
            </summary>
    </member>
    <member name="M:Editor.StandaloneExporter.GenerateAssetManifest(Editor.IProgress,System.Threading.CancellationToken)">
      <summary>
            Build a list of files to upload for this version. Return false if errors that would prevent the upload.
            </summary>
    </member>
    <member name="M:Editor.StandaloneExporter.AddFile(System.Byte[],System.String)">
      <summary>
            Manually add a file to the manifest
            </summary>
    </member>
    <member name="M:Editor.StandaloneExporter.AddFile(System.String,System.String)">
      <summary>
            Manually add a file to the manifest
            </summary>
    </member>
    <member name="M:Editor.StandaloneExporter.AddCodePackageReference(System.String)">
      <summary>
            If the code is referencing a package - we can add it to the manifest using this.
            </summary>
    </member>
    <member name="T:Editor.PrefabVariableProperty">
      <summary>
            Used to wrap a regular prefab property with a variable
            </summary>
    </member>
    <member name="P:Editor.BaseItemWidget.ItemClicked">
      <summary>
            Called when an item is selected.
            </summary>
    </member>
    <member name="P:Editor.BaseItemWidget.ItemSelected">
      <summary>
            Called when an item is selected.
            </summary>
    </member>
    <member name="P:Editor.BaseItemWidget.ItemDeselected">
      <summary>
            Called when an item is no longer selected.
            </summary>
    </member>
    <member name="P:Editor.BaseItemWidget.ItemHoverEnter">
      <summary>
            Called when an item is hovered by the user's cursor.
            </summary>
    </member>
    <member name="P:Editor.BaseItemWidget.ItemHoverLeave">
      <summary>
            Called when an item is no longer hovered by the user's cursor.
            </summary>
    </member>
    <member name="P:Editor.BaseItemWidget.ItemContextMenu">
      <summary>
            Called when an item is right clicked.
            </summary>
    </member>
    <member name="P:Editor.BaseItemWidget.ItemActivated">
      <summary>
            Called when an item is double left clicked.
            </summary>
    </member>
    <member name="P:Editor.BaseItemWidget.ItemPaint">
      <summary>
            Used to overwrite an item's style
            </summary>
    </member>
    <member name="P:Editor.BaseItemWidget.ItemDrag">
      <summary>
            Called to see whether or not we can drag a specific item.
            </summary>
    </member>
    <member name="P:Editor.BaseItemWidget.SelectionOverride">
      <summary>
            Can override an item's selection here.
            </summary>
    </member>
    <member name="P:Editor.BaseItemWidget.BodyContextMenu">
      <summary>
            Called when right clicking on the item's parent.
            </summary>
    </member>
    <member name="P:Editor.BaseItemWidget.ItemsPreSelectionChange">
      <summary>
            Calle before selection is changed
            </summary>
    </member>
    <member name="P:Editor.BaseItemWidget.ItemsSelected">
      <summary>
            Multiple items have been selected
            </summary>
    </member>
    <member name="P:Editor.BaseItemWidget.ToggleSelect">
      <summary>
            If set, selecting an item will not deselect all already selected items, clicking a selected item will deselect it.
            </summary>
    </member>
    <member name="P:Editor.BaseItemWidget.CanvasRect">
      <summary>
            The inner of LocalRect with Margin
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.SetItems(System.Collections.Generic.IEnumerable{System.Object})">
      <summary>
            Set the items in the list.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.AddItems(System.Collections.Generic.IEnumerable{System.Object})">
      <summary>
            Add multiple items.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.AddItem``1(``0)">
      <summary>
            Add given item to this widget.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.RemoveItem(System.Object)">
      <summary>
            Remove given item from this widget.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.Clear">
      <summary>
            Remove all items.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.GetItemAt(Vector2)">
      <summary>
            Get the virtual item at this local position.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.OnHoverChanged(System.Object,System.Object)">
      <summary>
            Hover has changed, neither of these objects are guaranteed to be non null.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.GetTooltip(System.Object)">
      <summary>
            Called to retrieve a tooltip for given item.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.OnItemPressed(Editor.VirtualWidget,Editor.MouseEvent)">
      <summary>
            Allows over-riding mouse press on an item, without click or selection.
            Return true to allow default behavior.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.OnItemContextMenu(Editor.VirtualWidget,Editor.MouseEvent)">
      <summary>
            The item has been right clicked
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.FindVirtualWidget(System.Object)">
      <summary>
            Given an object, try to find the virtual widget. This can of course return null if the item isn't visible
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.OnItemDrag(Editor.BaseItemWidget.ItemDragEvent)">
      <summary>
            Called when a dragged item is being hovered over this widget.
            This is the place to make drag and drop previews.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.OnDragHoverItem(Editor.Widget.DragEvent,Editor.VirtualWidget)">
      <summary>
            Called when a dragged item is being hovered over this widget.
            This is the place to make drag and drop previews.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.OnDropOnItem(Editor.Widget.DragEvent,Editor.VirtualWidget)">
      <summary>
            Called when an item is drag and dropped onto this widget.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.OnDragItem(Editor.VirtualWidget)">
      <summary>
            Called when we start to drag an item.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.OnKeyPressOnItem(Editor.KeyEvent,System.Object)">
      <summary>
            A key has been pressed on this selected item.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.ItemIndex(System.Object)">
      <summary>
            Returns the index of given item.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.GetAtIndex(System.Int32)">
      <summary>
            Returns the item at given index, or null.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.ScrollTo(System.Object)">
      <summary>
            Ensure that given item is in view, scrolling to it if necessary.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.ScrollTo(System.Single,System.Single)">
      <summary>
            Ensure that given position is in view, scrolling to it if necessary.
            </summary>
      <param name="targetPosition">Target vertical position to make sure is in view.</param>
      <param name="height">Height of a potential item/element we want to make sure is in view.</param>
    </member>
    <member name="M:Editor.BaseItemWidget.Rebuild">
      <summary>
            Rebuild the panel layout.
            </summary>
    </member>
    <member name="P:Editor.BaseItemWidget.MultiSelect">
      <summary>
            Whether to allow selecting multiple items at once.
            </summary>
    </member>
    <member name="P:Editor.BaseItemWidget.SelectedItems">
      <summary>
            Selected items.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.ResolveObject(System.Object)">
      <summary>
            For derived classes where the object is wrapped in another class (i.e. TreeView)
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.IsSelected(System.Object)">
      <summary>
            Return true if this item is selected.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.SelectItem(System.Object,System.Boolean,System.Boolean)">
      <summary>
            Select given item.
            </summary>
      <param name="obj">Item to select.</param>
      <param name="add">Whether to add the item to selection, or replace current selection.</param>
      <param name="skipEvents">Do not invoke <see cref="P:Editor.BaseItemWidget.ItemSelected" /> and <see cref="P:Editor.BaseItemWidget.ItemDeselected" />.</param>
    </member>
    <member name="M:Editor.BaseItemWidget.SetSelected(System.Object,System.Boolean,System.Boolean)">
      <summary>
            Set the selection state of an item.
            </summary>
      <param name="obj">Item to set selection state of.</param>
      <param name="state">Whether the item should be selected or not.</param>
      <param name="skipEvents">Do not invoke <see cref="P:Editor.BaseItemWidget.ItemSelected" /> and <see cref="P:Editor.BaseItemWidget.ItemDeselected" />.</param>
    </member>
    <member name="M:Editor.BaseItemWidget.SelectMove(System.Int32)">
      <summary>
            Move the selection pointer by this many positions.
            </summary>
    </member>
    <member name="M:Editor.BaseItemWidget.SelectTo(System.Object)">
      <summary>
            Select everything between the current selection pointer and this one.
            </summary>
    </member>
    <member name="F:Editor.BaseItemWidget.ItemDragEvent.IsDrop">
      <summary>
            If true, this is a drop - not just a hover
            </summary>
    </member>
    <member name="P:Editor.BaseWindow.StartCentered">
      <summary>
            Position the window at the centre of the screen (or main editor window if one is present) by default.
            </summary>
    </member>
    <member name="T:Editor.Dialog">
      <summary>
            A wrapper to more easily create dialog windows.
            </summary>
    </member>
    <member name="P:Editor.Dialog.Window">
      <summary>
            The created parent window for this dialog.
            </summary>
    </member>
    <member name="M:Editor.Dialog.AskStringFolder(System.Action{System.String},System.String,System.String,System.String,System.String)">
      <summary>
            Ask for a string which is intended to be a new folder name.. which means it shouldn't have / or " or : etc.
            </summary>
    </member>
    <member name="M:Editor.Dialog.AskStringFile(System.Action{System.String},System.String,System.String,System.String,System.String)">
      <summary>
            Ask for a string which is intended to be a new file name.. which means it shouldn't have / or " or : etc.
            </summary>
    </member>
    <member name="M:Editor.Dialog.AskString(System.Action{System.String},System.String,System.String,System.String,System.String,System.String)">
      <summary>
            Ask for a string
            </summary>
    </member>
    <member name="M:Editor.Dialog.AskConfirm(System.Action,System.String,System.String,System.String,System.String)">
      <summary>
            Ask for a confirmation
            </summary>
    </member>
    <member name="M:Editor.Dialog.AskConfirm(System.Action,System.Action,System.String,System.String,System.String,System.String)">
      <summary>
            Ask for a confirmation
            </summary>
    </member>
    <member name="T:Editor.Dialog.TextDialog">
      <summary>
            A wrapper to more easily create dialog windows
            </summary>
    </member>
    <member name="M:Editor.Dialog.TextDialog.Validate">
      <summary>
            Called when text changes to revalidate the input, disable Okay button, etc.
            </summary>
    </member>
    <member name="M:Editor.Dialog.TextDialog.Okay">
      <summary>
            Called when the user presses the Okay button
            </summary>
    </member>
    <member name="M:Editor.Dialog.TextDialog.Cancel">
      <summary>
            Called when the user presses the Cancel button
            </summary>
    </member>
    <member name="M:Editor.Dialog.TextDialog.Finish">
      <summary>
            Called when the user presses Enter in the text field
            </summary>
    </member>
    <member name="T:Editor.FolderEdit">
      <summary>
            An editable text box with a button to browse for an arbitrary folder using OS file browser dialog.
            </summary>
    </member>
    <member name="F:Editor.FolderEdit.FolderSelected">
      <summary>
            Path to the user selected folder.
            </summary>
    </member>
    <member name="P:Editor.FolderEdit.DialogTitle">
      <summary>
            Title override for the "browse folder" dialog.
            </summary>
    </member>
    <member name="M:Editor.FolderEdit.Browse">
      <summary>
            Open a "browse folder" dialog.
            </summary>
    </member>
    <member name="P:Editor.IconButton.IsToggle">
      <summary>
            If true we will toggle IsActive automatically
            </summary>
    </member>
    <member name="P:Editor.IconButton.IsActive">
      <summary>
            If IsToggle is true, this is toggled on press
            </summary>
    </member>
    <member name="P:Editor.ListView.ItemScrollEnter">
      <summary>
            Called when an item is scrolled into view.
            </summary>
    </member>
    <member name="P:Editor.ListView.ItemScrollExit">
      <summary>
            Called when an item is scrolled out of view.
            </summary>
    </member>
    <member name="M:Editor.ListView.Rebuild">
      <summary>
            Rebuild the scrollbars and layout for the visible items
            </summary>
    </member>
    <member name="M:Editor.ListView.LayoutScrollbar">
      <summary>
            Work out how big the scrollbars need to be and layout the current PVS
            </summary>
    </member>
    <member name="T:Editor.PopupWidget">
      <summary>
            A popup widget that automatically deletes itself once it stops being visible
            </summary>
    </member>
    <member name="M:Editor.PopupWidget.OpenBelowCursor(System.Single,System.Single)">
      <summary>
            Open the window this many pixels below the cursor.
            </summary>
    </member>
    <member name="M:Editor.VirtualWidget.PaintBackground(Color,System.Single)">
      <summary>
            Generically paint a background for this item
            </summary>
    </member>
    <member name="M:Editor.VirtualWidget.GetForegroundColor">
      <summary />
    </member>
    <member name="F:AssetLocation_t.Game">
      <summary>
            Compiled files
            </summary>
    </member>
    <member name="F:AssetLocation_t.Content">
      <summary>
            Source files
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.GetAssets(Sandbox.Project)">
      <summary>
            Get all assets in this project
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.SetFavouriteAsync(Sandbox.Package,System.Boolean)">
      <summary>
            Mark this package as a favourite
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.SetVoteAsync(Sandbox.Package,System.Boolean)">
      <summary>
            Add your vote for this package
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.UploadFile(Sandbox.Package,System.String,System.String,Sandbox.Utility.DataProgress.Callback,System.Threading.CancellationToken)">
      <summary>
            Mark this package as a favourite
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.UploadFile(Sandbox.Package,System.Byte[],System.String,Sandbox.Utility.DataProgress.Callback,System.Threading.CancellationToken)">
      <summary>
            Upload a file used by this package
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.UploadVideo(Editor.Asset,System.Byte[],System.Boolean,System.Boolean,System.String,Sandbox.Utility.DataProgress.Callback,System.Threading.CancellationToken)">
      <summary>
            Upload a video for this package
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.UpdateValue(Sandbox.Package,System.String,System.String,System.Threading.CancellationToken)">
      <summary>
            Update a value on this package
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.RenderToPixmap(Sandbox.SceneCamera,Editor.Pixmap,System.Boolean)">
      <summary>
            Render this camera to the target widget. Once you do this the target widget becomes "externally painted", so you
            won't be able to paint on it anymore with Qt's Paint stuff. 
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.RenderToPixmap(Sandbox.CameraComponent,Editor.Pixmap,System.Boolean)">
      <summary>
            Render this camera to the target widget. Once you do this the target widget becomes "externally painted", so you
            won't be able to paint on it anymore with Qt's Paint stuff. 
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.RenderToPixmap(Sandbox.Scene,Editor.Pixmap,System.Boolean)">
      <summary>
            Render this camera to the target widget. Once you do this the target widget becomes "externally painted", so you
            won't be able to paint on it anymore with Qt's Paint stuff. 
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.RenderToVideo(Sandbox.SceneCamera,Sandbox.VideoWriter,System.Nullable{System.TimeSpan})">
      <summary>
            Render this camera to the target widget. Once you do this the target widget becomes "externally painted", so you
            won't be able to paint on it anymore with Qt's Paint stuff. 
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.RenderToVideoAsync(Sandbox.SceneCamera,Sandbox.VideoWriter,System.Nullable{System.TimeSpan})">
      <summary>
            Render this camera to the target widget. Once you do this the target widget becomes "externally painted", so you
            won't be able to paint on it anymore with Qt's Paint stuff. 
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.GetSerialized(System.Object)">
      <summary>
            Shortcut for EditorTypeLibrary.GetSerializedObject( x )
            </summary>
    </member>
    <member name="T:Sandbox.SandboxToolExtensions.PropertyPath">
      <summary>
            Describes the path to a <see cref="T:Sandbox.SerializedProperty" /> from either a <see cref="T:Sandbox.GameObject" />
            or <see cref="T:Sandbox.Component" />.
            </summary>
    </member>
    <member name="P:Sandbox.SandboxToolExtensions.PropertyPath.Properties">
      <summary>
            Full path to reach the original property, starting from a property on a <see cref="T:Sandbox.GameObject" /> or
            <see cref="T:Sandbox.Component" />.
            </summary>
    </member>
    <member name="P:Sandbox.SandboxToolExtensions.PropertyPath.FullName">
      <summary>
            Names of each property in <see cref="P:Sandbox.SandboxToolExtensions.PropertyPath.Properties" />, separated by <c>'.'</c>s.
            </summary>
    </member>
    <member name="P:Sandbox.SandboxToolExtensions.PropertyPath.Targets">
      <summary>
        <see cref="T:Sandbox.GameObject" />(s) or <see cref="T:Sandbox.Component" />(s) that contain the original property.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.PropertyPath.ToString">
      <summary>
            Returns <see cref="P:Sandbox.SandboxToolExtensions.PropertyPath.FullName" />.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.FindPathInScene(Sandbox.SerializedProperty)">
      <summary>
            Tries to find the path from a <see cref="T:Sandbox.GameObject" /> or <see cref="T:Sandbox.Component" /> to this property.
            Returns <see langword="null" /> if not found.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.GetContainingGameObject(Sandbox.SerializedProperty)">
      <summary>
            Tries to find the <see cref="T:Sandbox.GameObject" /> that contains the given property.
            Returns <see langword="null" /> if not found.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.ConstructTitle(Sandbox.SelectionSystem)">
      <summary>
            Create a feasible title from the current selection
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.AddTarget(Sandbox.PrefabVariable,Sandbox.SerializedProperty)">
      <summary>
            Add a target to the variable
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.HasTarget(Sandbox.PrefabVariable,Sandbox.SerializedProperty)">
      <summary>
            Has this varible got this target?
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.FromConsoleVariable(Sandbox.Bind.Builder,System.String)">
      <summary>
            Bind the Left hand side to the value of the given console variable.
            </summary>
    </member>
    <member name="M:Sandbox.SandboxToolExtensions.FromConsoleVariableInt(Sandbox.Bind.Builder,System.String)">
      <summary>
            Bind the Left hand side to the value of the given console variable as an integer.
            </summary>
    </member>
    <member name="T:Sandbox.Global">
      <summary>
            Utility info for tools usage.
            </summary>
    </member>
    <member name="P:Sandbox.Global.InGame">
      <summary>
            Is the local client in game or not.
            </summary>
    </member>
    <member name="P:Sandbox.Global.MapName">
      <summary>
            Name of the map the local client is on.
            </summary>
    </member>
    <member name="P:Sandbox.Global.GameIdent">
      <summary>
            Identity of the gamemode the local client is currently playing.
            </summary>
    </member>
    <member name="P:Sandbox.Global.BackendTitle">
      <summary>
            Front facing identity for the backend
            </summary>
    </member>
    <member name="P:Sandbox.Global.BackendUrl">
      <summary>
            Url for the backend
            </summary>
    </member>
    <member name="P:Sandbox.Global.IsApiConnected">
      <summary>
            Are we connected to the API? (If not, offline mode. Requires Steam Servers to be online to connect..)
            </summary>
    </member>
    <member name="T:Sandbox.Internal.MapEntitySerializedObject">
      <summary>
            An implementation of TypeLibrary which uses TypeLibrary to fill out properties
            </summary>E
        </member>
    <member name="T:Sandbox.Internal.ReflectionSerializedObject">
      <summary>
            An implementation of SerializedObject which uses reflection to fill out properties. This is only accessible from 
            tools by default. We (probably) shouldn't trust the client with such things, as they can access 
            </summary>
    </member>
    <member name="M:Sandbox.Internal.TypeSerializedProperty.GetAttributes">
      <inheritdoc />
    </member>
    <member name="M:Sandbox.SceneExtensions.CreateContextMenu(Sandbox.Scene,Editor.Widget)">
      <summary>
            We should make this globally reachanle at some point. Should be able to draw icons using bitmaps etc too.
            </summary>
    </member>
    <member name="M:Sandbox.SceneExtensions.CopyToClipboard(Sandbox.Component)">
      <summary>
            Copy the target <see cref="T:Sandbox.Component" /> to the clipboard.
            </summary>
      <param name="component" />
    </member>
    <member name="M:Sandbox.SceneExtensions.PasteValues(Sandbox.Component)">
      <summary>
            Paste component values from clipboard to the target <see cref="T:Sandbox.Component" />.
            </summary>
      <param name="target" />
    </member>
    <member name="M:Sandbox.SceneExtensions.ShouldShowInHierarchy(Sandbox.GameObject)">
      <summary>
            Return true if this object should be shown in the GameObject list
            </summary>
    </member>
    <member name="M:Sandbox.SceneExtensions.PasteComponent(Sandbox.GameObject)">
      <summary>
            Paste a <see cref="T:Sandbox.Component" /> as a new component on the target <see cref="T:Sandbox.GameObject" />.
            </summary>
      <param name="target" />
    </member>
    <member name="T:Sandbox.SceneReferenceHelper">
      <summary>
            Editor helpers for scene.ref nodes.
            </summary>
    </member>
    <member name="M:Sandbox.ToolsDll.OnRender">
      <summary>
            Called from <see cref="M:Sandbox.EngineLoop.OnClientOutput" />,
            this method exists because we can't access the scene editor session from GameMenuDll to render cameras in the game viewport FROM the editor scene
            and we probably don't want to either
            </summary>
    </member>
    <member name="M:Sandbox.ToolsDll.OnPresent">
      <summary>
            Present what is rendered to the screen, outside of a BeginRenderingViews/EndRenderingViews block
            </summary>
    </member>
    <member name="M:Sandbox.ToolsDll.Initialize">
      <summary>
            Bootstrapping has finished. Close the splash screen and show the editor.
            </summary>
    </member>
    <member name="M:Sandbox.ToolsDll.LoadProject">
      <summary>
            Load the startup project for the first time
            </summary>
    </member>
    <member name="M:Sandbox.ToolsDll.RegisterHandle(System.IntPtr,System.UInt32)">
      <summary>
            Registers exclusive Sandbox.Tools <see cref="T:Sandbox.IHandle" /> types
            </summary>
    </member>
    <member name="M:Sandbox.ToolsDll.OwnsAssembly(System.Reflection.Assembly)">
      <summary>
            Return true if this assembly is a part of this context
            </summary>
    </member>
    <member name="P:Sandbox.ToolsDll.IsGameViewVisible">
      <summary>
            Return true if the GameFrame is visible
            </summary>
    </member>
    <member name="M:Sandbox.ToolsDll.ResolvePackageAsset(System.String)">
      <summary>
            Called from the code generator, the job of this function is:
            1. Make sure the package is downloaded and installed
            2. Return the relative path to the primary asset
            </summary>
    </member>
    <member name="T:Sandbox.Helpers.UndoSystem">
      <summary>
            A system that aims to wrap the main reusable functionality of an undo system
            </summary>
    </member>
    <member name="P:Sandbox.Helpers.UndoSystem.Entry.Image">
            [Obsolete]?
        </member>
    <member name="F:Sandbox.Helpers.UndoSystem.OnUndo">
      <summary>
            Called when an undo is run
            </summary>
    </member>
    <member name="F:Sandbox.Helpers.UndoSystem.OnRedo">
      <summary>
            Called when a redo is run
            </summary>
    </member>
    <member name="P:Sandbox.Helpers.UndoSystem.Back">
      <summary>
            Backwards stack
            </summary>
    </member>
    <member name="P:Sandbox.Helpers.UndoSystem.Forward">
      <summary>
            Forwards stack, gets cleared when a new undo is added
            </summary>
    </member>
    <member name="M:Sandbox.Helpers.UndoSystem.Undo">
      <summary>
            Instigate an undo. Return true if we found a successful undo
            </summary>
    </member>
    <member name="M:Sandbox.Helpers.UndoSystem.Redo">
      <summary>
            Instigate a redo, returns true if we found a successful undo
            </summary>
    </member>
    <member name="M:Sandbox.Helpers.UndoSystem.Insert(System.String,System.Action,System.Action)">
      <summary>
            Insert a new undo entry
            </summary>
    </member>
    <member name="M:Sandbox.Helpers.UndoSystem.SetSnapshotFunction(System.Func{System.Action})">
      <summary>
            Provide a function that returns an action to call on undo/redo.
            This generally is a function that saves and restores the entire state
            of a project.
            </summary>
    </member>
    <member name="F:Sandbox.Helpers.UndoSystem.next">
      <code>
              func getsnapshot()
              {
            		var state = currentstate();
            
            		return () =&gt; restorestate( state );
              }
            
              startup()
              {
                 -- give a function that creates undo functions
                 UndoSystem.SetSnapshotter( getsnapshot )
            
                 -- store current snapshot in `next`
                 UndoSystem.Initialize();
              }
            
              mainloop()
              {
                 deleteobject();
            
                 -- store 'next' snapshot as "object deleted" undo
                 -- take a new snapshot and store it in next
                 UndoSystem.Snapshot( "object deleted" );
              }
             </code>
    </member>
    <member name="M:Sandbox.Helpers.UndoSystem.Snapshot(System.String)">
      <summary>
            Should be called after you make a change to your project. The snapshot system
            is good for self contained projects that can be serialized and deserialized quickly.
            </summary>
    </member>
    <member name="M:Sandbox.Helpers.UndoSystem.Initialize">
      <summary>
            Clear the history and take an initial snapshot.
            You should call this right after a load, or a new project.
            </summary>
    </member>
    <member name="T:Sandbox.WorkshopUtils">
      <summary>
            Utils for uploading assets to Steam. This is wholely for clothing right now.
            </summary>
    </member>
    <member name="M:Sandbox.WorkshopUtils.IsAllowed(Editor.Asset)">
      <summary>
            Is this allowed to be uploaded?
            </summary>
      <param name="asset" />
      <returns />
    </member>
    <member name="M:Sandbox.WorkshopUtils.CreateTemporaryFilesInternal(Editor.Asset,Steamworks.Data.PublishedFileId)">
      <summary>
            Creates some temporary files for the workshop addon so we can track them
            </summary>
      <param name="asset" />
      <param name="itemId" />
    </member>
    <member name="M:Sandbox.WorkshopUtils.CreateTemporaryFiles(Editor.Asset,Steamworks.Data.PublishedFileId)">
      <inheritdoc cref="M:Sandbox.WorkshopUtils.CreateTemporaryFilesInternal(Editor.Asset,Steamworks.Data.PublishedFileId)" />
    </member>
    <member name="M:Sandbox.WorkshopUtils.DestroyTemporaryFiles(Editor.Asset)">
      <summary>
            Destroys temporary files made for the workshop addon
            </summary>
      <param name="asset" />
    </member>
    <member name="M:Sandbox.WorkshopUtils.NeedsLegalAgreement">
      <summary>
            Do we need to fill out the legal agreement in Steam?
            </summary>
      <returns />
    </member>
    <member name="M:Sandbox.WorkshopUtils.UploadAsset(Editor.Asset)">
      <summary>
            Uploads an asset to the steam workshop and embeds the published id in the asset's metadata
            </summary>
      <param name="asset" />
      <returns />
    </member>
    <member name="M:Managed.SourceAnimgraph.Exports.Editor_Animgraph_CreateModelPicker(System.IntPtr)">
      <summary>
            Editor.Animgraph.CreateModelPicker( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceAssetSytem.Exports.Editor_AssetSystem_PreInitialize">
      <summary>
            Editor.AssetSystem.PreInitialize( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceAssetSytem.Exports.Editor_AssetSystem_AssetAdded(System.IntPtr)">
      <summary>
            Editor.AssetSystem.AssetAdded( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceAssetSytem.Exports.Editor_AssetSystem_AssetRemoved(System.UInt32)">
      <summary>
            Editor.AssetSystem.AssetRemoved( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceAssetSytem.Exports.Editor_AssetSystem_AssetChanged(System.UInt32)">
      <summary>
            Editor.AssetSystem.AssetChanged( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceAssetSytem.Exports.Editor_AssetSystem_UpdateAssetAutoTags(System.UInt32)">
      <summary>
            Editor.AssetSystem.UpdateAssetAutoTags( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceAssetSytem.Exports.Editor_AssetSystem_RecordAssetOpen(System.UInt32)">
      <summary>
            Editor.AssetSystem.RecordAssetOpen( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceAssetSytem.Exports.Editor_AssetSystem_AssetScanComplete">
      <summary>
            Editor.AssetSystem.AssetScanComplete( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceAssetSytem.Exports.Editor_AssetSystem_RegisterAssetType(System.Int32,System.IntPtr)">
      <summary>
            Editor.AssetSystem.RegisterAssetType( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceAssetSytem.Exports.Editor_AssetSystem_InitializeCompilerForFilename(System.IntPtr,System.IntPtr)">
      <summary>
            Editor.AssetSystem.InitializeCompilerForFilename( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceAssetSytem.Exports.Editor_AssetSystem_TryManagedCompile(System.IntPtr)">
      <summary>
            Editor.AssetSystem.TryManagedCompile( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceAssetSytem.Exports.Editor_AssetSystem_OnSoundReload(System.IntPtr)">
      <summary>
            Editor.AssetSystem.OnSoundReload( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceAssetSytem.Exports.Editor_AssetSystem_OnSoundReloaded(System.IntPtr)">
      <summary>
            Editor.AssetSystem.OnSoundReloaded( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceAssetSytem.Exports.Editor_AssetSystem_OnDemandRecompile(System.UInt32,System.IntPtr)">
      <summary>
            Editor.AssetSystem.OnDemandRecompile( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceAssetSytem.Exports.Editor_AssetSystem_OpenPicker(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr,System.Int32,System.IntPtr)">
      <summary>
            Editor.AssetSystem.OpenPicker( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceAssetSytem.Exports.Editor_AssetSystem_PopulateAssetMenu(System.IntPtr,System.IntPtr)">
      <summary>
            Editor.AssetSystem.PopulateAssetMenu( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_BlockToolGlue_BuildGeometry(System.Int32,System.IntPtr)">
      <summary>
            Editor.MapEditor.BlockToolGlue.BuildGeometry( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_BlockToolGlue_BuildUI(System.IntPtr)">
      <summary>
            Editor.MapEditor.BlockToolGlue.BuildUI( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_BlockToolGlue_SetInProgress(System.Int32)">
      <summary>
            Editor.MapEditor.BlockToolGlue.SetInProgress( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_BlockToolGlue_SetOverrideEntity(System.IntPtr)">
      <summary>
            Editor.MapEditor.BlockToolGlue.SetOverrideEntity( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_EntityToolGlue_Create(System.IntPtr)">
      <summary>
            Editor.MapEditor.EntityToolGlue.Create( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_Hammer_Init(System.IntPtr)">
      <summary>
            Editor.MapEditor.Hammer.Init( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_Hammer_RunFrame">
      <summary>
            Editor.MapEditor.Hammer.RunFrame( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_Hammer_Shutdown">
      <summary>
            Editor.MapEditor.Hammer.Shutdown( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_Hammer_UpdateActiveMaterial(System.IntPtr)">
      <summary>
            Editor.MapEditor.Hammer.UpdateActiveMaterial( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_Hammer_RenderMapViewHUD(System.Int32,System.IntPtr)">
      <summary>
            Editor.MapEditor.Hammer.RenderMapViewHUD( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_Hammer_PreSaveMap(System.Int32)">
      <summary>
            Editor.MapEditor.Hammer.PreSaveMap( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_Hammer_PostLoadMap(System.Int32)">
      <summary>
            Editor.MapEditor.Hammer.PostLoadMap( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_Hammer_MapAssetSaved(System.Int32,System.Int32)">
      <summary>
            Editor.MapEditor.Hammer.MapAssetSaved( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_Hammer_OnMapViewOpenContextMenu(System.Int32,System.IntPtr)">
      <summary>
            Editor.MapEditor.Hammer.OnMapViewOpenContextMenu( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_Hammer_OnCreateGameObjectMenu">
      <summary>
            Editor.MapEditor.Hammer.OnCreateGameObjectMenu( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HammerEvents_OnMapNodeDescriptionChanged(System.Int32)">
      <summary>
            Editor.MapEditor.HammerEvents.OnMapNodeDescriptionChanged( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HammerEvents_OnObjectAddedToDocument(System.Int32,System.Int32)">
      <summary>
            Editor.MapEditor.HammerEvents.OnObjectAddedToDocument( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HammerEvents_OnObjectRemovedFromDocument(System.Int32,System.Int32)">
      <summary>
            Editor.MapEditor.HammerEvents.OnObjectRemovedFromDocument( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HammerEvents_OnMeshesTiedToGameObject(System.Int32)">
      <summary>
            Editor.MapEditor.HammerEvents.OnMeshesTiedToGameObject( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HammerMainWindow_WindowInit(System.UInt32)">
      <summary>
            Editor.MapEditor.HammerMainWindow.WindowInit( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HammerMainWindow_AddNativeDock(System.UInt32,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int64,System.Int64,System.Single)">
      <summary>
            Editor.MapEditor.HammerMainWindow.AddNativeDock( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HammerMainWindow_CreateDynamicViewMenu(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MapEditor.HammerMainWindow.CreateDynamicViewMenu( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HammerMainWindow_ToggleAssetBrowser(System.UInt32)">
      <summary>
            Editor.MapEditor.HammerMainWindow.ToggleAssetBrowser( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HammerMainWindow_ToggleFullscreenLayout(System.UInt32,System.Int32)">
      <summary>
            Editor.MapEditor.HammerMainWindow.ToggleFullscreenLayout( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HammerMainWindow_InitHammerMainWindow(System.IntPtr)">
      <summary>
            Editor.MapEditor.HammerMainWindow.InitHammerMainWindow( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HmmrMngdnspctr_Create(System.IntPtr)">
      <summary>
            Editor.MapEditor.HammerManagedInspector.Create( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HmmrMngdnspctr_Inspect(System.UInt32,System.Int32)">
      <summary>
            Editor.MapEditor.HammerManagedInspector.Inspect( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HmmrMngdnspctr_GetWidget(System.UInt32)">
      <summary>
            Editor.MapEditor.HammerManagedInspector.GetWidget( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HammerSession_Create(System.IntPtr,System.IntPtr)">
      <summary>
            Editor.MapEditor.HammerSession.Create( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HammerSession_Destroyed(System.UInt32)">
      <summary>
            Editor.MapEditor.HammerSession.Destroyed( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HammerSession_LaunchMapInEngine(System.UInt32)">
      <summary>
            Editor.MapEditor.HammerSession.LaunchMapInEngine( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HammerSession_OnPreCompileFinished(System.UInt32)">
      <summary>
            Editor.MapEditor.HammerSession.OnPreCompileFinished( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HammerSession_OnPostCompileFinished(System.UInt32)">
      <summary>
            Editor.MapEditor.HammerSession.OnPostCompileFinished( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_HammerSession_OnPaste(System.UInt32)">
      <summary>
            Editor.MapEditor.HammerSession.OnPaste( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_IEntityTool_CreateUI(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MapEditor.IEntityTool.CreateUI( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_IEntityTool_GetCurrentEntityClassName(System.UInt32)">
      <summary>
            Editor.MapEditor.IEntityTool.GetCurrentEntityClassName( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_IPathTool_CreateUI(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MapEditor.IPathTool.CreateUI( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_IPathTool_GetCurrentEntityClassName(System.UInt32)">
      <summary>
            Editor.MapEditor.IPathTool.GetCurrentEntityClassName( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_IPathTool_GetRadiusOffset(System.UInt32)">
      <summary>
            Editor.MapEditor.IPathTool.GetRadiusOffset( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_IPathTool_IsRadiusOffsetEnabled(System.UInt32)">
      <summary>
            Editor.MapEditor.IPathTool.IsRadiusOffsetEnabled( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MapNodeCallbacks_OnAddToWorld(System.Int32,System.Int32)">
      <summary>
            Editor.MapEditor.MapNodeCallbacks.OnAddToWorld( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MapNodeCallbacks_OnRemoveFromWorld(System.Int32,System.Int32)">
      <summary>
            Editor.MapEditor.MapNodeCallbacks.OnRemoveFromWorld( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MapNodeCallbacks_PreSaveToFile(System.Int32)">
      <summary>
            Editor.MapEditor.MapNodeCallbacks.PreSaveToFile( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MapNodeCallbacks_PostLoadFromFile(System.Int32)">
      <summary>
            Editor.MapEditor.MapNodeCallbacks.PostLoadFromFile( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MapNodeCallbacks_PostLoadDocument(System.Int32)">
      <summary>
            Editor.MapEditor.MapNodeCallbacks.PostLoadDocument( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MapNodeCallbacks_OnCopyFrom(System.Int32,System.Int32,System.Int32)">
      <summary>
            Editor.MapEditor.MapNodeCallbacks.OnCopyFrom( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MapNodeCallbacks_OnParentChanged(System.Int32,System.Int32)">
      <summary>
            Editor.MapEditor.MapNodeCallbacks.OnParentChanged( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MapNodeCallbacks_OnTransformChanged(System.Int32,Vector3,Angles,Vector3)">
      <summary>
            Editor.MapEditor.MapNodeCallbacks.OnTransformChanged( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MapNodeCallbacks_OnSetEnabled(System.Int32,System.Int32)">
      <summary>
            Editor.MapEditor.MapNodeCallbacks.OnSetEnabled( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MapNodeCallbacks_GetMimeData(System.Int32,System.IntPtr)">
      <summary>
            Editor.MapEditor.MapNodeCallbacks.GetMimeData( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MapNodeCallbacks_GetGameObjectName(System.Int32)">
      <summary>
            Editor.MapEditor.MapNodeCallbacks.GetGameObjectName( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MapNodeCallbacks_GetWorldResourceReferencesAndDependencies(System.Int32,System.IntPtr)">
      <summary>
            Editor.MapEditor.MapNodeCallbacks.GetWorldResourceReferencesAndDependencies( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MpVwDrpTrgt_OnDragEnter(System.IntPtr,System.Int32)">
      <summary>
            Editor.MapEditor.MapViewDropTarget.OnDragEnter( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MpVwDrpTrgt_OnDragMove(System.IntPtr,System.Int32)">
      <summary>
            Editor.MapEditor.MapViewDropTarget.OnDragMove( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MpVwDrpTrgt_OnDrop(System.IntPtr,System.Int32)">
      <summary>
            Editor.MapEditor.MapViewDropTarget.OnDrop( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MpVwDrpTrgt_OnDragLeave(System.Int32)">
      <summary>
            Editor.MapEditor.MapViewDropTarget.OnDragLeave( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MpVwDrpTrgt_GetDragAndDropActive">
      <summary>
            Editor.MapEditor.MapViewDropTarget.GetDragAndDropActive( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MapViewRender_OnPreRender(System.Int32,System.IntPtr)">
      <summary>
            Editor.MapEditor.MapViewRender.OnPreRender( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_MapViewRender_TraceManagedGizmos(System.Int32,Vector2,System.IntPtr)">
      <summary>
            Editor.MapEditor.MapViewRender.TraceManagedGizmos( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_PathToolGlue_Create">
      <summary>
            Editor.MapEditor.PathToolGlue.Create( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceHammer.Exports.dtrMpdtr_Selection_OnSelectionChanged">
      <summary>
            Editor.MapEditor.Selection.OnSelectionChanged( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceModelDoc.Exports.dtrMdldtr_ModelDoc_Init(System.IntPtr)">
      <summary>
            Editor.ModelEditor.ModelDoc.Init( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceModelDoc.Exports.dtrMdldtr_ModelDoc_OnToolsMenu(System.IntPtr)">
      <summary>
            Editor.ModelEditor.ModelDoc.OnToolsMenu( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_AssetThumbnail_GetAssetThumb(System.UInt32)">
      <summary>
            Editor.AssetThumbnail.GetAssetThumb( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_AssetThumbnail_RefreshThumbnail(System.UInt32)">
      <summary>
            Editor.AssetThumbnail.RefreshThumbnail( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalOnScrollChanged(System.UInt32)">
      <summary>
            Editor.BaseScrollWidget.InternalOnScrollChanged( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalOnEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.BaseScrollWidget.InternalOnEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalMousePressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalMousePressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalMouseEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalMouseEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalMouseLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalMouseLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalMouseReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalMouseReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalMouseMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalMouseMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalMouseDoubleClickEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalMouseDoubleClickEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalWheelEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalWheelEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalContextMenuEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalContextMenuEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalKeyPressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalKeyPressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalKeyReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalKeyReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalFocusInEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.BaseScrollWidget.InternalFocusInEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalFocusOutEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.BaseScrollWidget.InternalFocusOutEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalOnResizeEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalOnResizeEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalOnMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalOnMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalPaintEvent(System.UInt32,System.IntPtr,System.Int32)">
      <summary>
            Editor.BaseScrollWidget.InternalPaintEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalFocusNextPrevChild(System.UInt32,System.Int32)">
      <summary>
            Editor.BaseScrollWidget.InternalFocusNextPrevChild( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalDragEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalDragEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalDragMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalDragMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalDragLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalDragLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalDropEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalDropEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalCloseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalCloseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.BaseScrollWidget.InternalSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalMinimumSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.BaseScrollWidget.InternalMinimumSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_BaseScrollWidget_InternalShortcutOverrideEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.BaseScrollWidget.InternalShortcutOverrideEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalOnPressed(System.UInt32)">
      <summary>
            Editor.Button.InternalOnPressed( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalOnReleased(System.UInt32)">
      <summary>
            Editor.Button.InternalOnReleased( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalOnClicked(System.UInt32)">
      <summary>
            Editor.Button.InternalOnClicked( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalOnToggled(System.UInt32)">
      <summary>
            Editor.Button.InternalOnToggled( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalOnEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Button.InternalOnEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalMousePressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalMousePressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalMouseEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalMouseEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalMouseLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalMouseLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalMouseReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalMouseReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalMouseMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalMouseMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalMouseDoubleClickEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalMouseDoubleClickEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalWheelEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalWheelEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalContextMenuEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalContextMenuEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalKeyPressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalKeyPressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalKeyReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalKeyReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalFocusInEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Button.InternalFocusInEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalFocusOutEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Button.InternalFocusOutEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalOnResizeEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalOnResizeEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalOnMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalOnMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalPaintEvent(System.UInt32,System.IntPtr,System.Int32)">
      <summary>
            Editor.Button.InternalPaintEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalFocusNextPrevChild(System.UInt32,System.Int32)">
      <summary>
            Editor.Button.InternalFocusNextPrevChild( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalDragEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalDragEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalDragMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalDragMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalDragLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalDragLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalDropEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalDropEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalCloseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalCloseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.Button.InternalSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalMinimumSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.Button.InternalMinimumSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Button_InternalShortcutOverrideEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Button.InternalShortcutOverrideEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalOnPressed(System.UInt32)">
      <summary>
            Editor.Checkbox.InternalOnPressed( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalOnReleased(System.UInt32)">
      <summary>
            Editor.Checkbox.InternalOnReleased( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalOnClicked(System.UInt32)">
      <summary>
            Editor.Checkbox.InternalOnClicked( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalOnToggled(System.UInt32)">
      <summary>
            Editor.Checkbox.InternalOnToggled( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalOnStateChanged(System.UInt32)">
      <summary>
            Editor.Checkbox.InternalOnStateChanged( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalOnEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Checkbox.InternalOnEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalMousePressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalMousePressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalMouseEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalMouseEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalMouseLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalMouseLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalMouseReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalMouseReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalMouseMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalMouseMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalMouseDoubleClickEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalMouseDoubleClickEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalWheelEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalWheelEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalContextMenuEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalContextMenuEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalKeyPressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalKeyPressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalKeyReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalKeyReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalFocusInEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Checkbox.InternalFocusInEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalFocusOutEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Checkbox.InternalFocusOutEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalOnResizeEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalOnResizeEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalOnMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalOnMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalPaintEvent(System.UInt32,System.IntPtr,System.Int32)">
      <summary>
            Editor.Checkbox.InternalPaintEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalFocusNextPrevChild(System.UInt32,System.Int32)">
      <summary>
            Editor.Checkbox.InternalFocusNextPrevChild( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalDragEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalDragEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalDragMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalDragMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalDragLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalDragLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalDropEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalDropEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalCloseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalCloseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.Checkbox.InternalSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalMinimumSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.Checkbox.InternalMinimumSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Checkbox_InternalShortcutOverrideEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Checkbox.InternalShortcutOverrideEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalTextChanged(System.UInt32)">
      <summary>
            Editor.ComboBox.InternalTextChanged( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalIndexChanged(System.UInt32)">
      <summary>
            Editor.ComboBox.InternalIndexChanged( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalOnEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.ComboBox.InternalOnEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalMousePressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalMousePressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalMouseEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalMouseEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalMouseLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalMouseLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalMouseReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalMouseReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalMouseMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalMouseMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalMouseDoubleClickEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalMouseDoubleClickEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalWheelEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalWheelEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalContextMenuEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalContextMenuEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalKeyPressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalKeyPressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalKeyReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalKeyReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalFocusInEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.ComboBox.InternalFocusInEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalFocusOutEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.ComboBox.InternalFocusOutEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalOnResizeEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalOnResizeEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalOnMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalOnMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalPaintEvent(System.UInt32,System.IntPtr,System.Int32)">
      <summary>
            Editor.ComboBox.InternalPaintEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalFocusNextPrevChild(System.UInt32,System.Int32)">
      <summary>
            Editor.ComboBox.InternalFocusNextPrevChild( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalDragEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalDragEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalDragMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalDragMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalDragLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalDragLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalDropEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalDropEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalCloseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalCloseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.ComboBox.InternalSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalMinimumSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.ComboBox.InternalMinimumSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ComboBox_InternalShortcutOverrideEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ComboBox.InternalShortcutOverrideEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_CompileStatus_CompileProgress(System.IntPtr)">
      <summary>
            Editor.CompileStatus.CompileProgress( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_CompileStatus_StartCompile(System.Int32,System.IntPtr)">
      <summary>
            Editor.CompileStatus.StartCompile( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_CompileStatus_EndCompile(System.Int32)">
      <summary>
            Editor.CompileStatus.EndCompile( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_DockManager_OnCreateDock(System.UInt32,System.IntPtr,System.IntPtr)">
      <summary>
            Editor.DockManager.OnCreateDock( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_DockManager_OnRightClickTab(System.UInt32,System.IntPtr)">
      <summary>
            Editor.DockManager.OnRightClickTab( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalOnEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Frame.InternalOnEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalMousePressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalMousePressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalMouseEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalMouseEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalMouseLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalMouseLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalMouseReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalMouseReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalMouseMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalMouseMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalMouseDoubleClickEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalMouseDoubleClickEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalWheelEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalWheelEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalContextMenuEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalContextMenuEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalKeyPressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalKeyPressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalKeyReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalKeyReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalFocusInEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Frame.InternalFocusInEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalFocusOutEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Frame.InternalFocusOutEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalOnResizeEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalOnResizeEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalOnMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalOnMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalPaintEvent(System.UInt32,System.IntPtr,System.Int32)">
      <summary>
            Editor.Frame.InternalPaintEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalFocusNextPrevChild(System.UInt32,System.Int32)">
      <summary>
            Editor.Frame.InternalFocusNextPrevChild( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalDragEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalDragEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalDragMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalDragMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalDragLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalDragLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalDropEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalDropEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalCloseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalCloseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.Frame.InternalSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalMinimumSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.Frame.InternalMinimumSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Frame_InternalShortcutOverrideEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Frame.InternalShortcutOverrideEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GameData_Initialize(System.IntPtr)">
      <summary>
            Editor.GameData.Initialize( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsItem_InternalPaint(System.UInt32,System.IntPtr,System.Int32)">
      <summary>
            Editor.GraphicsItem.InternalPaint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsItem_InternalGetPaintRect(System.UInt32)">
      <summary>
            Editor.GraphicsItem.InternalGetPaintRect( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsItem_InternalGetBoundingRect(System.UInt32)">
      <summary>
            Editor.GraphicsItem.InternalGetBoundingRect( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsItem_InternalMousePressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsItem.InternalMousePressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsItem_InternalMouseReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsItem.InternalMouseReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsItem_InternalMouseMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsItem.InternalMouseMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsItem_InternalHoverEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsItem.InternalHoverEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsItem_InternalHoverMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsItem.InternalHoverMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsItem_InternalHoverLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsItem.InternalHoverLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsItem_InternalKeyPressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsItem.InternalKeyPressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsItem_InternalKeyReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsItem.InternalKeyReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsItem_InternalItemChange(System.UInt32,System.Int32)">
      <summary>
            Editor.GraphicsItem.InternalItemChange( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsItem_Contains(System.UInt32,Vector3)">
      <summary>
            Editor.GraphicsItem.Contains( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalOnEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.GraphicsView.InternalOnEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalMousePressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalMousePressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalMouseEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalMouseEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalMouseLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalMouseLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalMouseReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalMouseReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalMouseMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalMouseMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalMouseDoubleClickEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalMouseDoubleClickEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalWheelEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalWheelEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalContextMenuEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalContextMenuEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalKeyPressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalKeyPressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalKeyReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalKeyReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalFocusInEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.GraphicsView.InternalFocusInEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalFocusOutEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.GraphicsView.InternalFocusOutEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalOnResizeEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalOnResizeEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalOnMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalOnMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalPaintEvent(System.UInt32,System.IntPtr,System.Int32)">
      <summary>
            Editor.GraphicsView.InternalPaintEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalFocusNextPrevChild(System.UInt32,System.Int32)">
      <summary>
            Editor.GraphicsView.InternalFocusNextPrevChild( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalDragEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalDragEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalDragMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalDragMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalDragLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalDragLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalDropEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalDropEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalCloseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalCloseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.GraphicsView.InternalSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalMinimumSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.GraphicsView.InternalMinimumSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsView_InternalShortcutOverrideEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.GraphicsView.InternalShortcutOverrideEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_GraphicsWidget_Poop(System.UInt32)">
      <summary>
            Editor.GraphicsWidget.Poop( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalOnEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Label.InternalOnEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalMousePressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalMousePressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalMouseEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalMouseEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalMouseLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalMouseLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalMouseReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalMouseReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalMouseMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalMouseMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalMouseDoubleClickEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalMouseDoubleClickEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalWheelEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalWheelEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalContextMenuEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalContextMenuEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalKeyPressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalKeyPressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalKeyReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalKeyReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalFocusInEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Label.InternalFocusInEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalFocusOutEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Label.InternalFocusOutEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalOnResizeEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalOnResizeEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalOnMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalOnMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalPaintEvent(System.UInt32,System.IntPtr,System.Int32)">
      <summary>
            Editor.Label.InternalPaintEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalFocusNextPrevChild(System.UInt32,System.Int32)">
      <summary>
            Editor.Label.InternalFocusNextPrevChild( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalDragEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalDragEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalDragMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalDragMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalDragLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalDragLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalDropEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalDropEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalCloseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalCloseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.Label.InternalSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalMinimumSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.Label.InternalMinimumSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Label_InternalShortcutOverrideEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Label.InternalShortcutOverrideEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalTextChanged(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalTextChanged( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalTextEdited(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalTextEdited( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalReturnPressed(System.UInt32)">
      <summary>
            Editor.LineEdit.InternalReturnPressed( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalEditingFinished(System.UInt32)">
      <summary>
            Editor.LineEdit.InternalEditingFinished( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalOnEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.LineEdit.InternalOnEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalMousePressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalMousePressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalMouseEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalMouseEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalMouseLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalMouseLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalMouseReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalMouseReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalMouseMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalMouseMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalMouseDoubleClickEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalMouseDoubleClickEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalWheelEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalWheelEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalContextMenuEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalContextMenuEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalKeyPressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalKeyPressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalKeyReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalKeyReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalFocusInEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.LineEdit.InternalFocusInEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalFocusOutEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.LineEdit.InternalFocusOutEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalOnResizeEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalOnResizeEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalOnMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalOnMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalPaintEvent(System.UInt32,System.IntPtr,System.Int32)">
      <summary>
            Editor.LineEdit.InternalPaintEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalFocusNextPrevChild(System.UInt32,System.Int32)">
      <summary>
            Editor.LineEdit.InternalFocusNextPrevChild( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalDragEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalDragEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalDragMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalDragMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalDragLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalDragLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalDropEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalDropEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalCloseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalCloseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.LineEdit.InternalSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalMinimumSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.LineEdit.InternalMinimumSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_LineEdit_InternalShortcutOverrideEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.LineEdit.InternalShortcutOverrideEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ManagedTools_InitQt">
      <summary>
            Editor.ManagedTools.InitQt( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ManagedTools_StartSplashScreen">
      <summary>
            Editor.ManagedTools.StartSplashScreen( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ManagedTools_InitStart">
      <summary>
            Editor.ManagedTools.InitStart( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ManagedTools_InitFinish">
      <summary>
            Editor.ManagedTools.InitFinish( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ManagedTools_RunFrame">
      <summary>
            Editor.ManagedTools.RunFrame( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ManagedTools_Shutdown">
      <summary>
            Editor.ManagedTools.Shutdown( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ManagedTools_NativeHook(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
      <summary>
            Editor.ManagedTools.NativeHook( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ManagedTools_GlobalMousePressed(System.Int32)">
      <summary>
            Editor.ManagedTools.GlobalMousePressed( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ManagedTools_GlobalMouseReleased(System.Int32)">
      <summary>
            Editor.ManagedTools.GlobalMouseReleased( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ManagedTools_GlobalMouseWheel(System.Int32,System.Int32)">
      <summary>
            Editor.ManagedTools.GlobalMouseWheel( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ManagedTools_GlobalKeyPressed(System.Int32,System.IntPtr)">
      <summary>
            Editor.ManagedTools.GlobalKeyPressed( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ManagedTools_GlobalShortcutPressed">
      <summary>
            Editor.ManagedTools.GlobalShortcutPressed( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ManagedTools_OnToolCommand(System.IntPtr)">
      <summary>
            Editor.ManagedTools.OnToolCommand( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ManagedTools_UpdateSplash(System.IntPtr,System.Int32)">
      <summary>
            Editor.ManagedTools.UpdateSplash( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ManagedTools_OnQtHeartbeat">
      <summary>
            Editor.ManagedTools.OnQtHeartbeat( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalOnEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.MenuBar.InternalOnEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalMousePressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalMousePressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalMouseEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalMouseEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalMouseLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalMouseLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalMouseReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalMouseReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalMouseMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalMouseMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalMouseDoubleClickEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalMouseDoubleClickEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalWheelEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalWheelEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalContextMenuEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalContextMenuEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalKeyPressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalKeyPressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalKeyReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalKeyReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalFocusInEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.MenuBar.InternalFocusInEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalFocusOutEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.MenuBar.InternalFocusOutEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalOnResizeEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalOnResizeEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalOnMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalOnMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalPaintEvent(System.UInt32,System.IntPtr,System.Int32)">
      <summary>
            Editor.MenuBar.InternalPaintEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalFocusNextPrevChild(System.UInt32,System.Int32)">
      <summary>
            Editor.MenuBar.InternalFocusNextPrevChild( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalDragEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalDragEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalDragMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalDragMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalDragLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalDragLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalDropEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalDropEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalCloseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalCloseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.MenuBar.InternalSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalMinimumSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.MenuBar.InternalMinimumSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_MenuBar_InternalShortcutOverrideEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.MenuBar.InternalShortcutOverrideEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Option_InternalTriggered(System.UInt32)">
      <summary>
            Editor.Option.InternalTriggered( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Option_InternalToggled(System.UInt32,System.Int32)">
      <summary>
            Editor.Option.InternalToggled( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalOnEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.StatusBar.InternalOnEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalMousePressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalMousePressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalMouseEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalMouseEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalMouseLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalMouseLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalMouseReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalMouseReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalMouseMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalMouseMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalMouseDoubleClickEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalMouseDoubleClickEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalWheelEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalWheelEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalContextMenuEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalContextMenuEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalKeyPressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalKeyPressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalKeyReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalKeyReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalFocusInEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.StatusBar.InternalFocusInEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalFocusOutEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.StatusBar.InternalFocusOutEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalOnResizeEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalOnResizeEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalOnMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalOnMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalPaintEvent(System.UInt32,System.IntPtr,System.Int32)">
      <summary>
            Editor.StatusBar.InternalPaintEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalFocusNextPrevChild(System.UInt32,System.Int32)">
      <summary>
            Editor.StatusBar.InternalFocusNextPrevChild( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalDragEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalDragEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalDragMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalDragMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalDragLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalDragLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalDropEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalDropEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalCloseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalCloseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.StatusBar.InternalSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalMinimumSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.StatusBar.InternalMinimumSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_StatusBar_InternalShortcutOverrideEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.StatusBar.InternalShortcutOverrideEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalTextChanged(System.UInt32)">
      <summary>
            Editor.TextEdit.InternalTextChanged( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalOnEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.TextEdit.InternalOnEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalMousePressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalMousePressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalMouseEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalMouseEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalMouseLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalMouseLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalMouseReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalMouseReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalMouseMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalMouseMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalMouseDoubleClickEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalMouseDoubleClickEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalWheelEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalWheelEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalContextMenuEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalContextMenuEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalKeyPressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalKeyPressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalKeyReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalKeyReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalFocusInEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.TextEdit.InternalFocusInEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalFocusOutEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.TextEdit.InternalFocusOutEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalOnResizeEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalOnResizeEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalOnMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalOnMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalPaintEvent(System.UInt32,System.IntPtr,System.Int32)">
      <summary>
            Editor.TextEdit.InternalPaintEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalFocusNextPrevChild(System.UInt32,System.Int32)">
      <summary>
            Editor.TextEdit.InternalFocusNextPrevChild( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalDragEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalDragEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalDragMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalDragMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalDragLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalDragLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalDropEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalDropEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalCloseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalCloseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.TextEdit.InternalSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalMinimumSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.TextEdit.InternalMinimumSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TextEdit_InternalShortcutOverrideEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.TextEdit.InternalShortcutOverrideEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalOnEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.ToolBar.InternalOnEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalMousePressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalMousePressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalMouseEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalMouseEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalMouseLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalMouseLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalMouseReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalMouseReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalMouseMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalMouseMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalMouseDoubleClickEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalMouseDoubleClickEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalWheelEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalWheelEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalContextMenuEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalContextMenuEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalKeyPressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalKeyPressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalKeyReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalKeyReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalFocusInEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.ToolBar.InternalFocusInEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalFocusOutEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.ToolBar.InternalFocusOutEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalOnResizeEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalOnResizeEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalOnMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalOnMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalPaintEvent(System.UInt32,System.IntPtr,System.Int32)">
      <summary>
            Editor.ToolBar.InternalPaintEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalFocusNextPrevChild(System.UInt32,System.Int32)">
      <summary>
            Editor.ToolBar.InternalFocusNextPrevChild( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalDragEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalDragEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalDragMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalDragMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalDragLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalDragLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalDropEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalDropEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalCloseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalCloseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.ToolBar.InternalSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalMinimumSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.ToolBar.InternalMinimumSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_ToolBar_InternalShortcutOverrideEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.ToolBar.InternalShortcutOverrideEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TrayIcon_InternalActivated(System.UInt32)">
      <summary>
            Editor.TrayIcon.InternalActivated( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_TrayIcon_InternalMessageClicked(System.UInt32)">
      <summary>
            Editor.TrayIcon.InternalMessageClicked( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalOnEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Widget.InternalOnEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalMousePressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalMousePressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalMouseEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalMouseEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalMouseLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalMouseLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalMouseReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalMouseReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalMouseMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalMouseMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalMouseDoubleClickEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalMouseDoubleClickEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalWheelEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalWheelEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalContextMenuEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalContextMenuEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalKeyPressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalKeyPressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalKeyReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalKeyReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalFocusInEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Widget.InternalFocusInEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalFocusOutEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Widget.InternalFocusOutEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalOnResizeEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalOnResizeEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalOnMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalOnMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalPaintEvent(System.UInt32,System.IntPtr,System.Int32)">
      <summary>
            Editor.Widget.InternalPaintEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalFocusNextPrevChild(System.UInt32,System.Int32)">
      <summary>
            Editor.Widget.InternalFocusNextPrevChild( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalDragEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalDragEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalDragMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalDragMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalDragLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalDragLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalDropEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalDropEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalCloseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalCloseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.Widget.InternalSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalMinimumSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.Widget.InternalMinimumSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Widget_InternalShortcutOverrideEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Widget.InternalShortcutOverrideEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InitFramelessWindow(System.IntPtr)">
      <summary>
            Editor.Window.InitFramelessWindow( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalOnEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Window.InternalOnEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalMousePressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalMousePressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalMouseEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalMouseEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalMouseLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalMouseLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalMouseReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalMouseReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalMouseMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalMouseMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalMouseDoubleClickEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalMouseDoubleClickEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalWheelEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalWheelEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalContextMenuEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalContextMenuEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalKeyPressEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalKeyPressEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalKeyReleaseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalKeyReleaseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalFocusInEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Window.InternalFocusInEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalFocusOutEvent(System.UInt32,System.Int64)">
      <summary>
            Editor.Window.InternalFocusOutEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalOnResizeEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalOnResizeEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalOnMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalOnMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalPaintEvent(System.UInt32,System.IntPtr,System.Int32)">
      <summary>
            Editor.Window.InternalPaintEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalFocusNextPrevChild(System.UInt32,System.Int32)">
      <summary>
            Editor.Window.InternalFocusNextPrevChild( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalDragEnterEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalDragEnterEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalDragMoveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalDragMoveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalDragLeaveEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalDragLeaveEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalDropEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalDropEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalCloseEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalCloseEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.Window.InternalSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalMinimumSizeHint(System.UInt32,System.Int32,System.Int32)">
      <summary>
            Editor.Window.InternalMinimumSizeHint( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Editor_Window_InternalShortcutOverrideEvent(System.UInt32,System.IntPtr)">
      <summary>
            Editor.Window.InternalShortcutOverrideEvent( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Sandbox_Graphics_OnLayer(System.Int32,ManagedRenderSetup_t)">
      <summary>
            Sandbox.Graphics.OnLayer( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.SandboxPhysics_PhysicsEngine_OnPhysicsJointBreak(System.Int32)">
      <summary>
            Sandbox.Physics.PhysicsEngine.OnPhysicsJointBreak( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.SandboxPhysics_PhysicsEngine_OnActive(System.Int32,Transform,Vector3,Vector3)">
      <summary>
            Sandbox.Physics.PhysicsEngine.OnActive( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.SandboxPhysics_PhysicsEngine_DebugDrawLine(Vector3,Vector3,Color32)">
      <summary>
            Sandbox.Physics.PhysicsEngine.DebugDrawLine( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Sandbox_RealTime_Update(System.Single)">
      <summary>
            Sandbox.RealTime.Update( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.SndbxRndrng_RenderPipeline_AddLayersToView(System.IntPtr,NativeEngine.RenderViewport,System.IntPtr,System.IntPtr,System.Int64,System.IntPtr,NativeEngine.RenderViewport)">
      <summary>
            Sandbox.Rendering.RenderPipeline.AddLayersToView( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.SndbxRndrng_RenderPipeline_OnStage(System.Int64,System.IntPtr,NativeEngine.RenderViewport)">
      <summary>
            Sandbox.Rendering.RenderPipeline.OnStage( ... )
            </summary>
    </member>
    <member name="M:Managed.SourceTools.Exports.Sandbox_RenderTarget_Flush">
      <summary>
            Sandbox.RenderTarget.Flush( ... )
            </summary>
    </member>
    <member name="T:NativeHammer.TraceFlags">
      <summary>
            Matches TraceFlags_t
            </summary>
    </member>
  </members>
</MergedRoot>